
filters:     file format elf32-littleriscv
filters
architecture: riscv, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000200

Program Header:
    LOAD off    0x00001000 vaddr 0x00000000 paddr 0x00000000 align 2**12
         filesz 0x0000022c memsz 0x0000022c flags r-x
    LOAD off    0x00002000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x0000ed4c memsz 0x0000edb8 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000c558  00010000  00010000  00002000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       000006f0  0001c558  0001c558  0000e558  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init_array   00000008  0001cc48  0001cc48  0000ec48  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .fini_array   00000004  0001cc50  0001cc50  0000ec50  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .eh_frame     00001454  0001cc54  0001cc54  0000ec54  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .jcr          00000004  0001e0a8  0001e0a8  000100a8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000c20  0001e0b0  0001e0b0  000100b0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  7 .sdata        0000007c  0001ecd0  0001ecd0  00010cd0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  8 .sbss         0000001c  0001ed50  0001ed50  00010d4c  2**2
                  ALLOC
  9 .bss          0000004c  0001ed6c  0001ed6c  00010d4c  2**2
                  ALLOC
 10 .startup      0000022c  00000000  00000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .comment      00000011  00000000  00000000  00010d4c  2**0
                  CONTENTS, READONLY
 12 .debug_info   000189a6  00000000  00000000  00010d5d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00005417  00000000  00000000  00029703  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00000590  00000000  00000000  0002eb1a  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00011481  00000000  00000000  0002f0aa  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00002b15  00000000  00000000  0004052b  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    000118a3  00000000  00000000  00043040  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00000b50  00000000  00000000  000548e3  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
0001c558 l    d  .rodata	00000000 .rodata
0001cc48 l    d  .init_array	00000000 .init_array
0001cc50 l    d  .fini_array	00000000 .fini_array
0001cc54 l    d  .eh_frame	00000000 .eh_frame
0001e0a8 l    d  .jcr	00000000 .jcr
0001e0b0 l    d  .data	00000000 .data
0001ecd0 l    d  .sdata	00000000 .sdata
0001ed50 l    d  .sbss	00000000 .sbss
0001ed6c l    d  .bss	00000000 .bss
00000000 l    d  .startup	00000000 .startup
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 crtstuff.c
0001cc54 l     O .eh_frame	00000000 __EH_FRAME_BEGIN__
0001e0a8 l     O .jcr	00000000 __JCR_LIST__
0001004c l     F .text	00000000 deregister_tm_clones
00010078 l     F .text	00000000 register_tm_clones
000100b0 l     F .text	00000000 __do_global_dtors_aux
0001ed6c l     O .bss	00000001 completed.3082
0001cc50 l     O .fini_array	00000000 __do_global_dtors_aux_fini_array_entry
000100f4 l     F .text	00000000 frame_dummy
0001ed70 l     O .bss	00000018 object.3087
0001cc48 l     O .init_array	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 syscalls.c
0001ed88 l     O .bss	00000004 heap_end.1982
00000000 l    df *ABS*	00000000 htif.c
000106e4 l     F .text	00000068 htif_tohost
0001074c l     F .text	00000044 htif_fromhost
00000000 l    df *ABS*	00000000 riscv_counters.c
00000000 l    df *ABS*	00000000 ns16550.c
0001ecd8 l     O .sdata	00000004 pio
000108d4 l     F .text	000000b0 ns16550_init
00000000 l    df *ABS*	00000000 filters.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
00014014 l     F .text	000000bc __sbprintf
0001c8e4 l     O .rodata	00000010 blanks.4190
0001c8f4 l     O .rodata	00000010 zeroes.4191
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 dtoa.c
0001431c l     F .text	000001e8 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
00015d28 l     F .text	00000008 __fp_unlock
00015d3c l     F .text	0000018c __sinit.part.1
00015ecc l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
0001e410 l     O .data	00000440 impure_data
00000000 l    df *ABS*	00000000 locale.c
0001e850 l     O .data	00000020 lc_ctype_charset
0001e870 l     O .data	00000020 lc_message_charset
0001e890 l     O .data	00000038 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 mprec.c
0001c908 l     O .rodata	0000000c p05.2565
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 vfprintf.c
00018fac l     F .text	000000e8 __sprint_r.part.0
0001a0d4 l     F .text	000000bc __sbprintf
0001cb94 l     O .rodata	00000010 blanks.4133
0001cba4 l     O .rodata	00000010 zeroes.4134
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 dp-bit.c
0001a880 l     F .text	00000350 _fpadd_parts
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
0001b96c l     F .text	000001c8 _fpadd_parts
00000000 l    df *ABS*	00000000 crtstuff.c
0001e0a4 l     O .eh_frame	00000000 __FRAME_END__
0001e0a8 l     O .jcr	00000000 __JCR_END__
00000000 l    df *ABS*	00000000 
0001cc54 l       .fini_array	00000000 __fini_array_end
0001cc50 l       .fini_array	00000000 __fini_array_start
0001cc50 l       .init_array	00000000 __init_array_end
0001cc48 l       .init_array	00000000 __preinit_array_end
0001cc48 l       .init_array	00000000 __init_array_start
0001cc48 l       .init_array	00000000 __preinit_array_start
000185c8 g     F .text	00000078 _mprec_log10
000186a8 g     F .text	00000084 __any_on
0001c9e0 g     O .rodata	00000028 __mprec_tinytens
00012188 g     F .text	000000b0 _puts_r
0001b4d0 g     F .text	00000048 .hidden __cmpdf2
0001b5e0 g     F .text	00000004 .hidden __eqdf2
00011560 g     F .text	000004d0 .hidden __divdi3
0001e140 g     O .data	00000090 input_data_g
00012138 g     F .text	00000050 printf
0001e0b0 g       .data	00000000 _fdata
0001a6b8 g     F .text	00000094 _wcrtomb_r
00018e24 g     F .text	00000068 __sseek
0001605c g     F .text	00000010 __sinit
0001a548 g     F .text	00000160 __swbuf_r
00016a80 g     F .text	00000078 _setlocale_r
00015ed4 g     F .text	00000070 __sfmoreglue
00017724 g     F .text	00000004 __malloc_unlock
0001bfa8 g     F .text	0000012c .hidden __divsf3
00017524 g     F .text	00000120 memmove
0001604c g     F .text	00000010 _cleanup
00017728 g     F .text	000000a4 _Balloc
0001c428 g     F .text	0000008c .hidden __fixsfsi
0001b578 g     F .text	00000004 .hidden __gtdf2
00010838 g     F .text	00000034 read_cycle
00010464 g     F .text	00000024 times
0001edb4 g     O .bss	00000004 errno
0001b874 g     F .text	00000030 .hidden __make_dp
00018da4 g     F .text	00000008 __seofread
0001cc48 g       .rodata	00000000 _etext
0001c4ec g     F .text	0000002c .hidden __make_fp
0001f4d0 g       *ABS*	00000000 _gp
0001bdb0 g     F .text	00000054 .hidden __subsf3
00010178 g     F .text	00000034 execve
00010208 g     F .text	00000020 getpid
00011fd4 g     F .text	00000120 memcpy
0001ecd0 g     O .sdata	00000000 .hidden __TMC_END__
00015d30 g     F .text	0000000c _cleanup_r
0001b634 g     F .text	000000c0 .hidden __floatsidf
0001b5d8 g     F .text	00000004 .hidden __ltdf2
00012238 g     F .text	0000000c puts
00018cb4 g     F .text	00000074 __fpclassifyd
0001851c g     F .text	000000ac __ratio
00010a78 g     F .text	00000080 multiply
00010984 g     F .text	00000034 ns16550_rxready
00000000  w      *UND*	00000000 malloc
000120f4 g     F .text	00000044 _printf_r
00010228 g     F .text	00000024 isatty
0001c918 g     O .rodata	000000c8 __mprec_tens
00010644 g     F .text	000000a0 sleep
00016af8 g     F .text	0000000c __locale_charset
0001c244 g     F .text	00000050 .hidden __lesf2
0001ed6c g       .bss	00000000 _bss_start
0001ed68 g     O .sbss	00000004 __malloc_top_pad
000109f8 g     F .text	0000004c ns16550_txchar
0001ecd0 g     O .sdata	00000000 .hidden __dso_handle
0001ece4 g     O .sdata	00000004 __mb_cur_max
00016b20 g     F .text	0000000c _localeconv_r
00010790 g     F .text	00000040 htif_putc
00017b30 g     F .text	00000034 __i2b
00016478 g     F .text	00000498 __sfvwrite_r
0001ae14 g     F .text	00000120 .hidden __unpack_d
0001a248 g     F .text	000000f0 _fclose_r
00015d08 g     F .text	00000020 fflush
0001ed64 g     O .sbss	00000004 __malloc_max_sbrked_mem
0001e2f0 g     O .data	00000090 verify_data_g
0001c518 g     F .text	00000040 .hidden __extendsfdf2
0001af34 g     F .text	00000050 .hidden __adddf3
0001c29c g     F .text	00000004 .hidden __nesf2
000182a8 g     F .text	00000130 __b2d
000102ac g     F .text	0000002c lseek
0001ecdc g     O .sdata	00000004 _global_impure_ptr
0001872c g     F .text	00000588 _realloc_r
00011f34 g     F .text	000000a0 __libc_init_array
0001a4a4 g     F .text	00000028 _fputwc_r
0001ca08 g     O .rodata	00000028 __mprec_bigtens
00017900 g     F .text	00000104 __s2b
0001b6f4 g     F .text	00000088 .hidden __floatunsidf
00017fdc g     F .text	00000060 __mcmp
0001607c g     F .text	00000010 __fp_lock_all
0001086c g     F .text	00000034 read_time
00010048 g       .text	00000000 _init
00011ed4 g     F .text	00000060 __libc_fini_array
0001bc90 g     F .text	000000d8 .hidden __unpack_f
00017a04 g     F .text	0000007c __hi0bits
0001b77c g     F .text	000000bc .hidden __fixdfsi
000104e0 g     F .text	0000006c write
0001c240 g     F .text	00000004 .hidden __gtsf2
0001ecd4 g     O .sdata	00000004 environ
000101d4 g     F .text	00000034 fstat
0001024c g     F .text	00000030 kill
0001b57c g     F .text	00000058 .hidden __ledf2
00017d54 g     F .text	00000138 __pow5mult
0001ed5c g     O .sbss	00000004 __nlocale_changed
00010d10 g     F .text	000005d0 sharpen
00000000  w      *UND*	00000000 __deregister_frame_info
0001e260 g     O .data	00000090 verify_data_r
0001bb34 g     F .text	0000015c .hidden __pack_f
00010bb4 g     F .text	0000015c remove_red
00000000  w      *UND*	00000000 _ITM_registerTMCloneTable
0001b8fc g     F .text	00000070 .hidden __clzsi2
000112e0 g     F .text	00000134 verify
0001606c g     F .text	00000000 __sfp_lock_acquire
00017450 g     F .text	000000d4 memchr
0001619c g     F .text	000002dc _free_r
000104b4 g     F .text	0000002c wait
00016b04 g     F .text	00000008 __locale_mb_cur_max
0001ed58 g     O .sbss	00000004 __mlocale_changed
00010000 g       .text	00000000 _ftext
0001ece8 g     O .sdata	00000004 __malloc_sbrk_base
00010000 g       .text	00000000 _start
00017e8c g     F .text	00000150 __lshift
00010304 g     F .text	000000bc read
0001c2ec g     F .text	000000a4 .hidden __floatsisf
00014228 g     F .text	000000f4 __register_exitproc
000108a0 g     F .text	00000034 read_instret
00017b64 g     F .text	000001f0 __multiply
0001ed8c g     O .bss	00000028 __malloc_current_mallinfo
00010488 g     F .text	0000002c unlink
0001c2a0 g     F .text	00000004 .hidden __eqsf2
000183d8 g     F .text	00000144 __d2b
0001b3e8 g     F .text	000000e8 .hidden __fpcmp_parts_d
0001b838 g     F .text	0000003c .hidden __negdf2
000101ac g     F .text	00000028 fork
000140d4 g     F .text	00000154 __swsetup_r
0001b244 g     F .text	000001a4 .hidden __divdf3
0001c4b4 g     F .text	00000038 .hidden __negsf2
00015f44 g     F .text	00000108 __sfp
00018640 g     F .text	00000068 __copybits
0001e8c8 g     O .data	00000408 __malloc_av_
00016078 g     F .text	00000004 __sinit_lock_release
0001afe0 g     F .text	00000264 .hidden __muldf3
00018d28 g     F .text	0000007c __sread
0001ed50 g     O .sbss	00000004 __env
0001cbd0 g     O .rodata	00000010 .hidden __thenan_sf
00017720 g     F .text	00000004 __malloc_lock
00000000  w      *UND*	00000000 _ITM_deregisterTMCloneTable
000103c0 g     F .text	00000070 sbrk
00015cac g     F .text	0000005c _fflush_r
0001a194 g     F .text	000000b4 _calloc_r
0001c1a8 g     F .text	00000040 .hidden __cmpsf2
0001054c g     F .text	000000f8 gettimeofday
0001e380 g     O .data	00000090 verify_data_b
00017644 g       .text	00000000 memset
00011414 g     F .text	0000014c main
0001ed60 g     O .sbss	00000004 __malloc_max_total_mem
0001a6a8 g     F .text	00000010 __swbuf
0001c298 g     F .text	00000004 .hidden __ltsf2
00018e90 g     F .text	00000008 __sclose
0001a338 g     F .text	0000000c fclose
0001b8a4 g     F .text	00000058 .hidden __truncdfsf2
00014504 g     F .text	00001518 _dtoa_r
00016cd8 g     F .text	00000778 _malloc_r
0001a7f4 g     F .text	00000030 __ascii_wctomb
0001e1d0 g     O .data	00000090 input_data_b
00010af8 g     F .text	000000bc divide
00016910 g     F .text	000000b0 _fwalk
0001cbb8 g     O .rodata	00000018 .hidden __thenan_df
0001609c g     F .text	00000100 _malloc_trim_r
0001be04 g     F .text	000001a4 .hidden __mulsf3
00018e98 g       .text	00000000 strcmp
0001a0c0 g     F .text	00000014 vfiprintf
0001b5dc g     F .text	00000004 .hidden __nedf2
00010048 g       .text	00000000 _fini
0001c680 g     O .rodata	00000100 .hidden __clz_tab
0001ed54 g     O .sbss	00000004 _PathLocale
00011ec0 g     F .text	00000014 atexit
0001c1e8 g     F .text	00000058 .hidden __gesf2
00016b2c g     F .text	00000010 setlocale
0001ece0 g     O .sdata	00000004 _impure_ptr
0001e0b0 g     O .data	00000090 input_data_r
00015a1c g     F .text	00000290 __sflush_r
00016b18 g     F .text	00000008 __locale_cjk_lang
0001822c g     F .text	0000007c __ulp
0001608c g     F .text	00000010 __fp_unlock_all
00016b3c g     F .text	00000008 localeconv
00010430 g     F .text	00000034 stat
00000200 g       .startup	00000000 _reset
0001ecd0 g       .data	00000000 _edata
0001edb8 g       .bss	00000000 _end
0001c2a4 g     F .text	00000044 .hidden __unordsf2
0001a344 g     F .text	00000160 __fputwc
00018dac g     F .text	00000078 __swrite
0001ecec g     O .sdata	00000004 __malloc_trim_threshold
0001027c g     F .text	00000030 link
00016b0c g     F .text	0000000c __locale_msgcharset
00010140 g     F .text	00000014 exit
000190ac g     F .text	00001014 _vfiprintf_r
000107d0 g     F .text	00000068 htif_getc
000169c0 g     F .text	000000c0 _fwalk_reent
0001c390 g     F .text	00000098 .hidden __floatunsisf
0001803c g     F .text	000001f0 __mdiff
00016070 g     F .text	00000004 __sfp_lock_release
0001b5e4 g     F .text	0000004c .hidden __unorddf2
00011a30 g     F .text	00000490 .hidden __moddi3
0001c0d4 g     F .text	000000d4 .hidden __fpcmp_parts_f
00016b48 g     F .text	00000190 __smakebuf_r
00012244 g     F .text	00000090 strlen
000102d8 g     F .text	0000002c open
0001b518 g     F .text	00000060 .hidden __gedf2
0001ecf0 g     O .sdata	00000004 __wctomb
00019094 g     F .text	00000018 __sprint_r
00010a44 g     F .text	00000034 ns16550_flush
000109b8 g     F .text	00000040 ns16550_rxchar
0001a824 g     F .text	0000005c _wctomb_r
00000000  w      *UND*	00000000 _Jv_RegisterClasses
0001af84 g     F .text	0000005c .hidden __subdf3
000122d4 g     F .text	00001d2c _vfprintf_r
00017a80 g     F .text	000000b0 __lo0bits
0001ed50 g       .sbss	00000000 _fbss
00000000  w      *UND*	00000000 __register_frame_info
0001a74c g     F .text	000000a8 wcrtomb
00010154 g     F .text	00000024 close
0001bd68 g     F .text	00000048 .hidden __addsf3
0001abd0 g     F .text	00000244 .hidden __pack_d
00014000 g     F .text	00000014 vfprintf
0001a4cc g     F .text	00000078 fputwc
00016074 g     F .text	00000004 __sinit_lock_acquire
000177f0 g     F .text	00000110 __multadd
000177cc g     F .text	00000024 _Bfree



Disassembly of section .text:

00010000 <_ftext>:
   10000:	0000f197          	auipc	gp,0xf
   10004:	4d018193          	addi	gp,gp,1232 # 1f4d0 <_gp>
   10008:	0000f297          	auipc	t0,0xf
   1000c:	d4828293          	addi	t0,t0,-696 # 1ed50 <__env>
   10010:	0000f317          	auipc	t1,0xf
   10014:	da830313          	addi	t1,t1,-600 # 1edb8 <_end>
   10018:	0002a023          	sw	zero,0(t0)
   1001c:	00428293          	addi	t0,t0,4
   10020:	fe62ece3          	bltu	t0,t1,10018 <_ftext+0x18>
   10024:	00002517          	auipc	a0,0x2
   10028:	eb050513          	addi	a0,a0,-336 # 11ed4 <__libc_fini_array>
   1002c:	695010ef          	jal	11ec0 <atexit>
   10030:	705010ef          	jal	11f34 <__libc_init_array>
   10034:	00012503          	lw	a0,0(sp)
   10038:	00410593          	addi	a1,sp,4
   1003c:	00000613          	li	a2,0
   10040:	3d4010ef          	jal	11414 <main>
   10044:	0fc0006f          	j	10140 <exit>

00010048 <_fini>:
   10048:	00008067          	ret

0001004c <deregister_tm_clones>:
   1004c:	80018713          	addi	a4,gp,-2048 # 1ecd0 <_edata>
   10050:	80318793          	addi	a5,gp,-2045 # 1ecd3 <_edata+0x3>
   10054:	40e787b3          	sub	a5,a5,a4
   10058:	00600713          	li	a4,6
   1005c:	00f77c63          	bleu	a5,a4,10074 <deregister_tm_clones+0x28>
   10060:	00000293          	li	t0,0
   10064:	00028863          	beqz	t0,10074 <deregister_tm_clones+0x28>
   10068:	80018513          	addi	a0,gp,-2048 # 1ecd0 <_edata>
   1006c:	00028313          	mv	t1,t0
   10070:	00030067          	jr	t1
   10074:	00008067          	ret

00010078 <register_tm_clones>:
   10078:	80018593          	addi	a1,gp,-2048 # 1ecd0 <_edata>
   1007c:	80018793          	addi	a5,gp,-2048 # 1ecd0 <_edata>
   10080:	40b787b3          	sub	a5,a5,a1
   10084:	4027d793          	srai	a5,a5,0x2
   10088:	01f7d593          	srli	a1,a5,0x1f
   1008c:	00f585b3          	add	a1,a1,a5
   10090:	4015d593          	srai	a1,a1,0x1
   10094:	00058c63          	beqz	a1,100ac <register_tm_clones+0x34>
   10098:	00000293          	li	t0,0
   1009c:	00028863          	beqz	t0,100ac <register_tm_clones+0x34>
   100a0:	80018513          	addi	a0,gp,-2048 # 1ecd0 <_edata>
   100a4:	00028313          	mv	t1,t0
   100a8:	00030067          	jr	t1
   100ac:	00008067          	ret

000100b0 <__do_global_dtors_aux>:
   100b0:	ff010113          	addi	sp,sp,-16
   100b4:	00812423          	sw	s0,8(sp)
   100b8:	89c1c783          	lbu	a5,-1892(gp) # 1ed6c <_bss_start>
   100bc:	00112623          	sw	ra,12(sp)
   100c0:	02079263          	bnez	a5,100e4 <__do_global_dtors_aux+0x34>
   100c4:	f89ff0ef          	jal	1004c <deregister_tm_clones>
   100c8:	00000793          	li	a5,0
   100cc:	00078863          	beqz	a5,100dc <__do_global_dtors_aux+0x2c>
   100d0:	0001d537          	lui	a0,0x1d
   100d4:	c5450513          	addi	a0,a0,-940 # 1cc54 <__fini_array_end>
   100d8:	f29ef0ef          	jal	0 <_reset-0x200>
   100dc:	00100793          	li	a5,1
   100e0:	88f18e23          	sb	a5,-1892(gp) # 1ed6c <_bss_start>
   100e4:	00c12083          	lw	ra,12(sp)
   100e8:	00812403          	lw	s0,8(sp)
   100ec:	01010113          	addi	sp,sp,16
   100f0:	00008067          	ret

000100f4 <frame_dummy>:
   100f4:	ff010113          	addi	sp,sp,-16
   100f8:	00000793          	li	a5,0
   100fc:	00112623          	sw	ra,12(sp)
   10100:	00078a63          	beqz	a5,10114 <frame_dummy+0x20>
   10104:	0001d537          	lui	a0,0x1d
   10108:	8a018593          	addi	a1,gp,-1888 # 1ed70 <object.3087>
   1010c:	c5450513          	addi	a0,a0,-940 # 1cc54 <__fini_array_end>
   10110:	ef1ef0ef          	jal	0 <_reset-0x200>
   10114:	0001e537          	lui	a0,0x1e
   10118:	0a850513          	addi	a0,a0,168 # 1e0a8 <__JCR_END__>
   1011c:	00052783          	lw	a5,0(a0)
   10120:	00079863          	bnez	a5,10130 <frame_dummy+0x3c>
   10124:	00c12083          	lw	ra,12(sp)
   10128:	01010113          	addi	sp,sp,16
   1012c:	f4dff06f          	j	10078 <register_tm_clones>
   10130:	00000793          	li	a5,0
   10134:	fe0788e3          	beqz	a5,10124 <frame_dummy+0x30>
   10138:	000780e7          	jalr	a5
   1013c:	fe9ff06f          	j	10124 <frame_dummy+0x30>

00010140 <exit>:
register char * stack_ptr asm ("sp");

#undef errno
int errno;

void exit (int status) {
   10140:	fe010113          	addi	sp,sp,-32
   10144:	00812e23          	sw	s0,28(sp)
   10148:	02010413          	addi	s0,sp,32
   1014c:	fea42623          	sw	a0,-20(s0)
  while (1)
    ;
   10150:	0000006f          	j	10150 <exit+0x10>

00010154 <close>:
}

int close(int file) {
   10154:	fe010113          	addi	sp,sp,-32
   10158:	00812e23          	sw	s0,28(sp)
   1015c:	02010413          	addi	s0,sp,32
   10160:	fea42623          	sw	a0,-20(s0)
  return -1;
   10164:	fff00793          	li	a5,-1
}
   10168:	00078513          	mv	a0,a5
   1016c:	01c12403          	lw	s0,28(sp)
   10170:	02010113          	addi	sp,sp,32
   10174:	00008067          	ret

00010178 <execve>:

char *__env[1] = { 0 };
char **environ = __env;

int execve(char *name, char **argv, char **env) {
   10178:	fe010113          	addi	sp,sp,-32
   1017c:	00812e23          	sw	s0,28(sp)
   10180:	02010413          	addi	s0,sp,32
   10184:	fea42623          	sw	a0,-20(s0)
   10188:	feb42423          	sw	a1,-24(s0)
   1018c:	fec42223          	sw	a2,-28(s0)
  errno = ENOMEM;
   10190:	00c00713          	li	a4,12
   10194:	8ee1a223          	sw	a4,-1820(gp) # 1edb4 <errno>
  return -1;
   10198:	fff00793          	li	a5,-1
}
   1019c:	00078513          	mv	a0,a5
   101a0:	01c12403          	lw	s0,28(sp)
   101a4:	02010113          	addi	sp,sp,32
   101a8:	00008067          	ret

000101ac <fork>:

int fork(void) {
   101ac:	ff010113          	addi	sp,sp,-16
   101b0:	00812623          	sw	s0,12(sp)
   101b4:	01010413          	addi	s0,sp,16
  errno = EAGAIN;
   101b8:	00b00713          	li	a4,11
   101bc:	8ee1a223          	sw	a4,-1820(gp) # 1edb4 <errno>
  return -1;
   101c0:	fff00793          	li	a5,-1
}
   101c4:	00078513          	mv	a0,a5
   101c8:	00c12403          	lw	s0,12(sp)
   101cc:	01010113          	addi	sp,sp,16
   101d0:	00008067          	ret

000101d4 <fstat>:

int fstat(int file, struct stat *st) {
   101d4:	fe010113          	addi	sp,sp,-32
   101d8:	00812e23          	sw	s0,28(sp)
   101dc:	02010413          	addi	s0,sp,32
   101e0:	fea42623          	sw	a0,-20(s0)
   101e4:	feb42423          	sw	a1,-24(s0)
  st->st_mode = S_IFCHR;
   101e8:	fe842783          	lw	a5,-24(s0)
   101ec:	00002737          	lui	a4,0x2
   101f0:	00e7a823          	sw	a4,16(a5)
  return 0;
   101f4:	00000793          	li	a5,0
}
   101f8:	00078513          	mv	a0,a5
   101fc:	01c12403          	lw	s0,28(sp)
   10200:	02010113          	addi	sp,sp,32
   10204:	00008067          	ret

00010208 <getpid>:

int getpid(void) {
   10208:	ff010113          	addi	sp,sp,-16
   1020c:	00812623          	sw	s0,12(sp)
   10210:	01010413          	addi	s0,sp,16
  return 1;
   10214:	00100793          	li	a5,1
}
   10218:	00078513          	mv	a0,a5
   1021c:	00c12403          	lw	s0,12(sp)
   10220:	01010113          	addi	sp,sp,16
   10224:	00008067          	ret

00010228 <isatty>:

int isatty(int file) {
   10228:	fe010113          	addi	sp,sp,-32
   1022c:	00812e23          	sw	s0,28(sp)
   10230:	02010413          	addi	s0,sp,32
   10234:	fea42623          	sw	a0,-20(s0)
  return 1;
   10238:	00100793          	li	a5,1
}
   1023c:	00078513          	mv	a0,a5
   10240:	01c12403          	lw	s0,28(sp)
   10244:	02010113          	addi	sp,sp,32
   10248:	00008067          	ret

0001024c <kill>:

int kill(int pid, int sig) {
   1024c:	fe010113          	addi	sp,sp,-32
   10250:	00812e23          	sw	s0,28(sp)
   10254:	02010413          	addi	s0,sp,32
   10258:	fea42623          	sw	a0,-20(s0)
   1025c:	feb42423          	sw	a1,-24(s0)
  errno = EINVAL;
   10260:	01600713          	li	a4,22
   10264:	8ee1a223          	sw	a4,-1820(gp) # 1edb4 <errno>
  return -1;
   10268:	fff00793          	li	a5,-1
}
   1026c:	00078513          	mv	a0,a5
   10270:	01c12403          	lw	s0,28(sp)
   10274:	02010113          	addi	sp,sp,32
   10278:	00008067          	ret

0001027c <link>:

int link(char *old, char *new) {
   1027c:	fe010113          	addi	sp,sp,-32
   10280:	00812e23          	sw	s0,28(sp)
   10284:	02010413          	addi	s0,sp,32
   10288:	fea42623          	sw	a0,-20(s0)
   1028c:	feb42423          	sw	a1,-24(s0)
  errno = EMLINK;
   10290:	01f00713          	li	a4,31
   10294:	8ee1a223          	sw	a4,-1820(gp) # 1edb4 <errno>
  return -1;
   10298:	fff00793          	li	a5,-1
}
   1029c:	00078513          	mv	a0,a5
   102a0:	01c12403          	lw	s0,28(sp)
   102a4:	02010113          	addi	sp,sp,32
   102a8:	00008067          	ret

000102ac <lseek>:

int lseek(int file, int ptr, int dir) {
   102ac:	fe010113          	addi	sp,sp,-32
   102b0:	00812e23          	sw	s0,28(sp)
   102b4:	02010413          	addi	s0,sp,32
   102b8:	fea42623          	sw	a0,-20(s0)
   102bc:	feb42423          	sw	a1,-24(s0)
   102c0:	fec42223          	sw	a2,-28(s0)
  return 0;
   102c4:	00000793          	li	a5,0
}
   102c8:	00078513          	mv	a0,a5
   102cc:	01c12403          	lw	s0,28(sp)
   102d0:	02010113          	addi	sp,sp,32
   102d4:	00008067          	ret

000102d8 <open>:

int open(const char *name, int flags, int mode) {
   102d8:	fe010113          	addi	sp,sp,-32
   102dc:	00812e23          	sw	s0,28(sp)
   102e0:	02010413          	addi	s0,sp,32
   102e4:	fea42623          	sw	a0,-20(s0)
   102e8:	feb42423          	sw	a1,-24(s0)
   102ec:	fec42223          	sw	a2,-28(s0)
  return -1;
   102f0:	fff00793          	li	a5,-1
}
   102f4:	00078513          	mv	a0,a5
   102f8:	01c12403          	lw	s0,28(sp)
   102fc:	02010113          	addi	sp,sp,32
   10300:	00008067          	ret

00010304 <read>:

int read(int file, char *ptr, int len) {
   10304:	fd010113          	addi	sp,sp,-48
   10308:	02112623          	sw	ra,44(sp)
   1030c:	02812423          	sw	s0,40(sp)
   10310:	02912223          	sw	s1,36(sp)
   10314:	03010413          	addi	s0,sp,48
   10318:	fca42e23          	sw	a0,-36(s0)
   1031c:	fcb42c23          	sw	a1,-40(s0)
   10320:	fcc42a23          	sw	a2,-44(s0)
  int todo;
  if(len == 0)
   10324:	fd442783          	lw	a5,-44(s0)
   10328:	00079663          	bnez	a5,10334 <read+0x30>
    return 0;
   1032c:	00000793          	li	a5,0
   10330:	0780006f          	j	103a8 <read+0xa4>
    // note: this is always blocking
    *ptr++ = htif_getc();
  }
#endif
#ifdef CONSOLE_UART
  *ptr++ = ns16550_rxchar();
   10334:	fd842483          	lw	s1,-40(s0)
   10338:	00148793          	addi	a5,s1,1
   1033c:	fcf42c23          	sw	a5,-40(s0)
   10340:	678000ef          	jal	109b8 <ns16550_rxchar>
   10344:	00050793          	mv	a5,a0
   10348:	0ff7f793          	andi	a5,a5,255
   1034c:	00f48023          	sb	a5,0(s1)
  for(todo = 1; todo < len; todo++) {
   10350:	00100793          	li	a5,1
   10354:	fef42623          	sw	a5,-20(s0)
   10358:	0380006f          	j	10390 <read+0x8c>
    if (!ns16550_rxready())
   1035c:	628000ef          	jal	10984 <ns16550_rxready>
   10360:	00050793          	mv	a5,a0
   10364:	02078e63          	beqz	a5,103a0 <read+0x9c>
      break;
    *ptr++ = ns16550_rxchar();
   10368:	fd842483          	lw	s1,-40(s0)
   1036c:	00148793          	addi	a5,s1,1
   10370:	fcf42c23          	sw	a5,-40(s0)
   10374:	644000ef          	jal	109b8 <ns16550_rxchar>
   10378:	00050793          	mv	a5,a0
   1037c:	0ff7f793          	andi	a5,a5,255
   10380:	00f48023          	sb	a5,0(s1)
    *ptr++ = htif_getc();
  }
#endif
#ifdef CONSOLE_UART
  *ptr++ = ns16550_rxchar();
  for(todo = 1; todo < len; todo++) {
   10384:	fec42783          	lw	a5,-20(s0)
   10388:	00178793          	addi	a5,a5,1
   1038c:	fef42623          	sw	a5,-20(s0)
   10390:	fec42703          	lw	a4,-20(s0)
   10394:	fd442783          	lw	a5,-44(s0)
   10398:	fcf742e3          	blt	a4,a5,1035c <read+0x58>
   1039c:	0080006f          	j	103a4 <read+0xa0>
    if (!ns16550_rxready())
      break;
   103a0:	00000013          	nop
    *ptr++ = ns16550_rxchar();
  }
#endif
  return todo;
   103a4:	fec42783          	lw	a5,-20(s0)
}
   103a8:	00078513          	mv	a0,a5
   103ac:	02c12083          	lw	ra,44(sp)
   103b0:	02812403          	lw	s0,40(sp)
   103b4:	02412483          	lw	s1,36(sp)
   103b8:	03010113          	addi	sp,sp,48
   103bc:	00008067          	ret

000103c0 <sbrk>:

caddr_t sbrk(int incr) {
   103c0:	fd010113          	addi	sp,sp,-48
   103c4:	02812623          	sw	s0,44(sp)
   103c8:	03010413          	addi	s0,sp,48
   103cc:	fca42e23          	sw	a0,-36(s0)
  extern char _end;		/* Defined by the linker */
  static char *heap_end;
  char *prev_heap_end;

  if (heap_end == 0) {
   103d0:	8b81a783          	lw	a5,-1864(gp) # 1ed88 <heap_end.1982>
   103d4:	00079663          	bnez	a5,103e0 <sbrk+0x20>
    heap_end = &_end;
   103d8:	8e818713          	addi	a4,gp,-1816 # 1edb8 <_end>
   103dc:	8ae1ac23          	sw	a4,-1864(gp) # 1ed88 <heap_end.1982>
  }
  prev_heap_end = heap_end;
   103e0:	8b81a783          	lw	a5,-1864(gp) # 1ed88 <heap_end.1982>
   103e4:	fef42623          	sw	a5,-20(s0)
  if (heap_end + incr > stack_ptr) {
   103e8:	8b81a703          	lw	a4,-1864(gp) # 1ed88 <heap_end.1982>
   103ec:	fdc42783          	lw	a5,-36(s0)
   103f0:	00f707b3          	add	a5,a4,a5
   103f4:	00010713          	mv	a4,sp
   103f8:	00f77a63          	bleu	a5,a4,1040c <sbrk+0x4c>
    errno = ENOMEM;
   103fc:	00c00713          	li	a4,12
   10400:	8ee1a223          	sw	a4,-1820(gp) # 1edb4 <errno>
    return (caddr_t) -1;
   10404:	fff00793          	li	a5,-1
   10408:	0180006f          	j	10420 <sbrk+0x60>
  }

  heap_end += incr;
   1040c:	8b81a703          	lw	a4,-1864(gp) # 1ed88 <heap_end.1982>
   10410:	fdc42783          	lw	a5,-36(s0)
   10414:	00f70733          	add	a4,a4,a5
   10418:	8ae1ac23          	sw	a4,-1864(gp) # 1ed88 <heap_end.1982>
  return (caddr_t) prev_heap_end;
   1041c:	fec42783          	lw	a5,-20(s0)
}
   10420:	00078513          	mv	a0,a5
   10424:	02c12403          	lw	s0,44(sp)
   10428:	03010113          	addi	sp,sp,48
   1042c:	00008067          	ret

00010430 <stat>:

int stat(const char *file, struct stat *st) {
   10430:	fe010113          	addi	sp,sp,-32
   10434:	00812e23          	sw	s0,28(sp)
   10438:	02010413          	addi	s0,sp,32
   1043c:	fea42623          	sw	a0,-20(s0)
   10440:	feb42423          	sw	a1,-24(s0)
  st->st_mode = S_IFCHR;
   10444:	fe842783          	lw	a5,-24(s0)
   10448:	00002737          	lui	a4,0x2
   1044c:	00e7a823          	sw	a4,16(a5)
  return 0;
   10450:	00000793          	li	a5,0
}
   10454:	00078513          	mv	a0,a5
   10458:	01c12403          	lw	s0,28(sp)
   1045c:	02010113          	addi	sp,sp,32
   10460:	00008067          	ret

00010464 <times>:

clock_t times(struct tms *buf) {
   10464:	fe010113          	addi	sp,sp,-32
   10468:	00812e23          	sw	s0,28(sp)
   1046c:	02010413          	addi	s0,sp,32
   10470:	fea42623          	sw	a0,-20(s0)
  return -1;
   10474:	fff00793          	li	a5,-1
}
   10478:	00078513          	mv	a0,a5
   1047c:	01c12403          	lw	s0,28(sp)
   10480:	02010113          	addi	sp,sp,32
   10484:	00008067          	ret

00010488 <unlink>:

int unlink(char *name) {
   10488:	fe010113          	addi	sp,sp,-32
   1048c:	00812e23          	sw	s0,28(sp)
   10490:	02010413          	addi	s0,sp,32
   10494:	fea42623          	sw	a0,-20(s0)
  errno = ENOENT;
   10498:	00200713          	li	a4,2
   1049c:	8ee1a223          	sw	a4,-1820(gp) # 1edb4 <errno>
  return -1;
   104a0:	fff00793          	li	a5,-1
}
   104a4:	00078513          	mv	a0,a5
   104a8:	01c12403          	lw	s0,28(sp)
   104ac:	02010113          	addi	sp,sp,32
   104b0:	00008067          	ret

000104b4 <wait>:

int wait(int *status) {
   104b4:	fe010113          	addi	sp,sp,-32
   104b8:	00812e23          	sw	s0,28(sp)
   104bc:	02010413          	addi	s0,sp,32
   104c0:	fea42623          	sw	a0,-20(s0)
  errno = ECHILD;
   104c4:	00a00713          	li	a4,10
   104c8:	8ee1a223          	sw	a4,-1820(gp) # 1edb4 <errno>
  return -1;
   104cc:	fff00793          	li	a5,-1
}
   104d0:	00078513          	mv	a0,a5
   104d4:	01c12403          	lw	s0,28(sp)
   104d8:	02010113          	addi	sp,sp,32
   104dc:	00008067          	ret

000104e0 <write>:

int write(int file, char *ptr, int len) {
   104e0:	fd010113          	addi	sp,sp,-48
   104e4:	02112623          	sw	ra,44(sp)
   104e8:	02812423          	sw	s0,40(sp)
   104ec:	03010413          	addi	s0,sp,48
   104f0:	fca42e23          	sw	a0,-36(s0)
   104f4:	fcb42c23          	sw	a1,-40(s0)
   104f8:	fcc42a23          	sw	a2,-44(s0)
  for (todo = 0; todo < len; todo++) {
    htif_putc (*ptr++);
  }
#endif
#ifdef CONSOLE_UART
  for (todo = 0; todo < len; todo++) {
   104fc:	fe042623          	sw	zero,-20(s0)
   10500:	0280006f          	j	10528 <write+0x48>
    ns16550_txchar (*ptr++);
   10504:	fd842783          	lw	a5,-40(s0)
   10508:	00178713          	addi	a4,a5,1
   1050c:	fce42c23          	sw	a4,-40(s0)
   10510:	0007c783          	lbu	a5,0(a5)
   10514:	00078513          	mv	a0,a5
   10518:	4e0000ef          	jal	109f8 <ns16550_txchar>
  for (todo = 0; todo < len; todo++) {
    htif_putc (*ptr++);
  }
#endif
#ifdef CONSOLE_UART
  for (todo = 0; todo < len; todo++) {
   1051c:	fec42783          	lw	a5,-20(s0)
   10520:	00178793          	addi	a5,a5,1
   10524:	fef42623          	sw	a5,-20(s0)
   10528:	fec42703          	lw	a4,-20(s0)
   1052c:	fd442783          	lw	a5,-44(s0)
   10530:	fcf74ae3          	blt	a4,a5,10504 <write+0x24>
    ns16550_txchar (*ptr++);
  }
#endif
  return len;
   10534:	fd442783          	lw	a5,-44(s0)
}
   10538:	00078513          	mv	a0,a5
   1053c:	02c12083          	lw	ra,44(sp)
   10540:	02812403          	lw	s0,40(sp)
   10544:	03010113          	addi	sp,sp,48
   10548:	00008067          	ret

0001054c <gettimeofday>:

#define CLOCK_PERIOD  (10000000)

int gettimeofday(struct timeval *ptimeval, void *ptimezone)
{
   1054c:	fd010113          	addi	sp,sp,-48
   10550:	02112623          	sw	ra,44(sp)
   10554:	02812423          	sw	s0,40(sp)
   10558:	03010413          	addi	s0,sp,48
   1055c:	fca42e23          	sw	a0,-36(s0)
   10560:	fcb42c23          	sw	a1,-40(s0)
    if (ptimeval)
   10564:	fdc42583          	lw	a1,-36(s0)
   10568:	0c058263          	beqz	a1,1062c <gettimeofday+0xe0>
#ifdef __riscv64
	asm ("rdtime %0" : "=r" (tv));
#else
	unsigned int tvh;
	unsigned int tvl;
	asm ("rdtime %0;"
   1056c:	c0102573          	rdtime	a0
   10570:	c81025f3          	rdtimeh	a1
   10574:	fea42623          	sw	a0,-20(s0)
   10578:	feb42423          	sw	a1,-24(s0)
	    "rdtimeh %1 " : "=r" (tvl), "=r" (tvh));
	tv = ((long long)tvh) << 32 | tvl;
   1057c:	fe842583          	lw	a1,-24(s0)
   10580:	00058813          	mv	a6,a1
   10584:	00000893          	li	a7,0
   10588:	00081793          	slli	a5,a6,0x0
   1058c:	00000713          	li	a4,0
   10590:	fec42583          	lw	a1,-20(s0)
   10594:	00058613          	mv	a2,a1
   10598:	00000693          	li	a3,0
   1059c:	00c765b3          	or	a1,a4,a2
   105a0:	feb42023          	sw	a1,-32(s0)
   105a4:	00d7e7b3          	or	a5,a5,a3
   105a8:	fef42223          	sw	a5,-28(s0)
#endif
	ptimeval->tv_sec = tv / CLOCK_PERIOD;
   105ac:	fe042703          	lw	a4,-32(s0)
   105b0:	fe442783          	lw	a5,-28(s0)
   105b4:	00989637          	lui	a2,0x989
   105b8:	68060613          	addi	a2,a2,1664 # 989680 <_gp+0x96a1b0>
   105bc:	00000693          	li	a3,0
   105c0:	00070513          	mv	a0,a4
   105c4:	00078593          	mv	a1,a5
   105c8:	799000ef          	jal	11560 <__divdi3>
   105cc:	00050713          	mv	a4,a0
   105d0:	00058793          	mv	a5,a1
   105d4:	fdc42683          	lw	a3,-36(s0)
   105d8:	00e6a023          	sw	a4,0(a3)
   105dc:	00f6a223          	sw	a5,4(a3)
	ptimeval->tv_usec = tv % CLOCK_PERIOD / (CLOCK_PERIOD / 1000000);
   105e0:	fe042703          	lw	a4,-32(s0)
   105e4:	fe442783          	lw	a5,-28(s0)
   105e8:	00989637          	lui	a2,0x989
   105ec:	68060613          	addi	a2,a2,1664 # 989680 <_gp+0x96a1b0>
   105f0:	00000693          	li	a3,0
   105f4:	00070513          	mv	a0,a4
   105f8:	00078593          	mv	a1,a5
   105fc:	434010ef          	jal	11a30 <__moddi3>
   10600:	00050713          	mv	a4,a0
   10604:	00058793          	mv	a5,a1
   10608:	00a00613          	li	a2,10
   1060c:	00000693          	li	a3,0
   10610:	00070513          	mv	a0,a4
   10614:	00078593          	mv	a1,a5
   10618:	749000ef          	jal	11560 <__divdi3>
   1061c:	00050713          	mv	a4,a0
   10620:	00058793          	mv	a5,a1
   10624:	fdc42783          	lw	a5,-36(s0)
   10628:	00e7a423          	sw	a4,8(a5)
    }

    return 0;
   1062c:	00000793          	li	a5,0
}
   10630:	00078513          	mv	a0,a5
   10634:	02c12083          	lw	ra,44(sp)
   10638:	02812403          	lw	s0,40(sp)
   1063c:	03010113          	addi	sp,sp,48
   10640:	00008067          	ret

00010644 <sleep>:

unsigned int sleep(unsigned int seconds)
{
   10644:	fd010113          	addi	sp,sp,-48
   10648:	02112623          	sw	ra,44(sp)
   1064c:	02812423          	sw	s0,40(sp)
   10650:	03212223          	sw	s2,36(sp)
   10654:	03312023          	sw	s3,32(sp)
   10658:	03010413          	addi	s0,sp,48
   1065c:	fca42e23          	sw	a0,-36(s0)
    struct timeval tv;
    gettimeofday(&tv, NULL);
   10660:	fe040793          	addi	a5,s0,-32
   10664:	00000593          	li	a1,0
   10668:	00078513          	mv	a0,a5
   1066c:	ee1ff0ef          	jal	1054c <gettimeofday>
    seconds += tv.tv_sec;
   10670:	fe042703          	lw	a4,-32(s0)
   10674:	fe442783          	lw	a5,-28(s0)
   10678:	fdc42783          	lw	a5,-36(s0)
   1067c:	00e787b3          	add	a5,a5,a4
   10680:	fcf42e23          	sw	a5,-36(s0)

    while (tv.tv_sec < seconds)
   10684:	0140006f          	j	10698 <sleep+0x54>
	gettimeofday(&tv, NULL);
   10688:	fe040793          	addi	a5,s0,-32
   1068c:	00000593          	li	a1,0
   10690:	00078513          	mv	a0,a5
   10694:	eb9ff0ef          	jal	1054c <gettimeofday>
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    seconds += tv.tv_sec;

    while (tv.tv_sec < seconds)
   10698:	fe042703          	lw	a4,-32(s0)
   1069c:	fe442783          	lw	a5,-28(s0)
   106a0:	fdc42683          	lw	a3,-36(s0)
   106a4:	00068913          	mv	s2,a3
   106a8:	00000993          	li	s3,0
   106ac:	00078693          	mv	a3,a5
   106b0:	fd36ece3          	bltu	a3,s3,10688 <sleep+0x44>
   106b4:	00078693          	mv	a3,a5
   106b8:	00d99663          	bne	s3,a3,106c4 <sleep+0x80>
   106bc:	00070793          	mv	a5,a4
   106c0:	fd27e4e3          	bltu	a5,s2,10688 <sleep+0x44>
	gettimeofday(&tv, NULL);

    return 0;
   106c4:	00000793          	li	a5,0
}
   106c8:	00078513          	mv	a0,a5
   106cc:	02c12083          	lw	ra,44(sp)
   106d0:	02812403          	lw	s0,40(sp)
   106d4:	02412903          	lw	s2,36(sp)
   106d8:	02012983          	lw	s3,32(sp)
   106dc:	03010113          	addi	sp,sp,48
   106e0:	00008067          	ret

000106e4 <htif_tohost>:
#define HTIF_CMD_WRITE      (0x01UL)
#define HTIF_CMD_IDENTITY   (0xFFUL)

static inline void htif_tohost(unsigned long dev,
	unsigned long cmd, unsigned long data)
{
   106e4:	fd010113          	addi	sp,sp,-48
   106e8:	02812623          	sw	s0,44(sp)
   106ec:	03010413          	addi	s0,sp,48
   106f0:	fca42e23          	sw	a0,-36(s0)
   106f4:	fcb42c23          	sw	a1,-40(s0)
   106f8:	fcc42a23          	sw	a2,-44(s0)
	unsigned long packet;
	packet = (dev << HTIF_DEV_SHIFT) | (cmd << HTIF_CMD_SHIFT) | data;
   106fc:	fdc42783          	lw	a5,-36(s0)
   10700:	01879713          	slli	a4,a5,0x18
   10704:	fd842783          	lw	a5,-40(s0)
   10708:	01079793          	slli	a5,a5,0x10
   1070c:	00f76733          	or	a4,a4,a5
   10710:	fd442783          	lw	a5,-44(s0)
   10714:	00f767b3          	or	a5,a4,a5
   10718:	fef42623          	sw	a5,-20(s0)
	while (csr_swap(mtohost, packet) != 0);
   1071c:	00000013          	nop
   10720:	fec42783          	lw	a5,-20(s0)
   10724:	fef42423          	sw	a5,-24(s0)
   10728:	fe842783          	lw	a5,-24(s0)
   1072c:	780797f3          	csrrw	a5,mtohost,a5
   10730:	fef42423          	sw	a5,-24(s0)
   10734:	fe842783          	lw	a5,-24(s0)
   10738:	fe0794e3          	bnez	a5,10720 <htif_tohost+0x3c>
}
   1073c:	00000013          	nop
   10740:	02c12403          	lw	s0,44(sp)
   10744:	03010113          	addi	sp,sp,48
   10748:	00008067          	ret

0001074c <htif_fromhost>:

static inline unsigned long htif_fromhost(void)
{
   1074c:	fe010113          	addi	sp,sp,-32
   10750:	00812e23          	sw	s0,28(sp)
   10754:	02010413          	addi	s0,sp,32
	unsigned long data;
	while ((data = csr_swap(mfromhost, 0)) == 0);
   10758:	00000013          	nop
   1075c:	fe042623          	sw	zero,-20(s0)
   10760:	fec42783          	lw	a5,-20(s0)
   10764:	781797f3          	csrrw	a5,mfromhost,a5
   10768:	fef42623          	sw	a5,-20(s0)
   1076c:	fec42783          	lw	a5,-20(s0)
   10770:	fef42423          	sw	a5,-24(s0)
   10774:	fe842783          	lw	a5,-24(s0)
   10778:	fe0782e3          	beqz	a5,1075c <htif_fromhost+0x10>
	return data;
   1077c:	fe842783          	lw	a5,-24(s0)
}
   10780:	00078513          	mv	a0,a5
   10784:	01c12403          	lw	s0,28(sp)
   10788:	02010113          	addi	sp,sp,32
   1078c:	00008067          	ret

00010790 <htif_putc>:

#define HTIF_DEV_CONSOLE        (1U)

void htif_putc(char c)
{
   10790:	fe010113          	addi	sp,sp,-32
   10794:	00112e23          	sw	ra,28(sp)
   10798:	00812c23          	sw	s0,24(sp)
   1079c:	02010413          	addi	s0,sp,32
   107a0:	00050793          	mv	a5,a0
   107a4:	fef407a3          	sb	a5,-17(s0)
    htif_tohost(HTIF_DEV_CONSOLE, HTIF_CMD_WRITE, c);
   107a8:	fef44783          	lbu	a5,-17(s0)
   107ac:	00078613          	mv	a2,a5
   107b0:	00100593          	li	a1,1
   107b4:	00100513          	li	a0,1
   107b8:	f2dff0ef          	jal	106e4 <htif_tohost>
}
   107bc:	00000013          	nop
   107c0:	01c12083          	lw	ra,28(sp)
   107c4:	01812403          	lw	s0,24(sp)
   107c8:	02010113          	addi	sp,sp,32
   107cc:	00008067          	ret

000107d0 <htif_getc>:

char htif_getc(void)
{
   107d0:	fe010113          	addi	sp,sp,-32
   107d4:	00112e23          	sw	ra,28(sp)
   107d8:	00812c23          	sw	s0,24(sp)
   107dc:	02010413          	addi	s0,sp,32
    htif_tohost(HTIF_DEV_CONSOLE, HTIF_CMD_READ, 0);
   107e0:	00000613          	li	a2,0
   107e4:	00000593          	li	a1,0
   107e8:	00100513          	li	a0,1
   107ec:	ef9ff0ef          	jal	106e4 <htif_tohost>

    // poll interrupt
    unsigned long mip = csr_read(mip);
   107f0:	344027f3          	csrr	a5,mip
   107f4:	00078093          	mv	ra,a5
   107f8:	00008793          	mv	a5,ra
   107fc:	fef42623          	sw	a5,-20(s0)
    while (!(mip & 0x40000000))
   10800:	00000013          	nop
   10804:	fec42703          	lw	a4,-20(s0)
   10808:	400007b7          	lui	a5,0x40000
   1080c:	00f777b3          	and	a5,a4,a5
   10810:	fe078ae3          	beqz	a5,10804 <htif_getc+0x34>
	;  // nothing

    unsigned long data = htif_fromhost();
   10814:	f39ff0ef          	jal	1074c <htif_fromhost>
   10818:	fea42423          	sw	a0,-24(s0)
    return data;
   1081c:	fe842783          	lw	a5,-24(s0)
   10820:	0ff7f793          	andi	a5,a5,255
}
   10824:	00078513          	mv	a0,a5
   10828:	01c12083          	lw	ra,28(sp)
   1082c:	01812403          	lw	s0,24(sp)
   10830:	02010113          	addi	sp,sp,32
   10834:	00008067          	ret

00010838 <read_cycle>:
// The following are interfaces to inline RISC-V assembly instructions
//     RDCYCLE, RDTIME, RDINSTRET
// For all of them, the result is left in v0 (= x2) per calling convention

uint64_t  read_cycle (void)
{
   10838:	fe010113          	addi	sp,sp,-32
   1083c:	00812e23          	sw	s0,28(sp)
   10840:	02010413          	addi	s0,sp,32
    uint64_t result;

    asm volatile ("RDCYCLE %0" : "=r" (result));
   10844:	c0002773          	rdcycle	a4
   10848:	fee42423          	sw	a4,-24(s0)
   1084c:	fef42623          	sw	a5,-20(s0)
    return result;
   10850:	fe842703          	lw	a4,-24(s0)
   10854:	fec42783          	lw	a5,-20(s0)
}
   10858:	00070513          	mv	a0,a4
   1085c:	00078593          	mv	a1,a5
   10860:	01c12403          	lw	s0,28(sp)
   10864:	02010113          	addi	sp,sp,32
   10868:	00008067          	ret

0001086c <read_time>:

uint64_t  read_time (void)
{
   1086c:	fe010113          	addi	sp,sp,-32
   10870:	00812e23          	sw	s0,28(sp)
   10874:	02010413          	addi	s0,sp,32
    uint64_t result;

    asm volatile ("RDTIME %0" : "=r" (result));
   10878:	c0102773          	rdtime	a4
   1087c:	fee42423          	sw	a4,-24(s0)
   10880:	fef42623          	sw	a5,-20(s0)
    return result;
   10884:	fe842703          	lw	a4,-24(s0)
   10888:	fec42783          	lw	a5,-20(s0)
}
   1088c:	00070513          	mv	a0,a4
   10890:	00078593          	mv	a1,a5
   10894:	01c12403          	lw	s0,28(sp)
   10898:	02010113          	addi	sp,sp,32
   1089c:	00008067          	ret

000108a0 <read_instret>:

uint64_t  read_instret (void)
{
   108a0:	fe010113          	addi	sp,sp,-32
   108a4:	00812e23          	sw	s0,28(sp)
   108a8:	02010413          	addi	s0,sp,32
    uint64_t result;

    asm volatile ("RDINSTRET %0" : "=r" (result));
   108ac:	c0202773          	rdinstret	a4
   108b0:	fee42423          	sw	a4,-24(s0)
   108b4:	fef42623          	sw	a5,-20(s0)
    return result;
   108b8:	fe842703          	lw	a4,-24(s0)
   108bc:	fec42783          	lw	a5,-20(s0)
}
   108c0:	00070513          	mv	a0,a4
   108c4:	00078593          	mv	a1,a5
   108c8:	01c12403          	lw	s0,28(sp)
   108cc:	02010113          	addi	sp,sp,32
   108d0:	00008067          	ret

000108d4 <ns16550_init>:
static struct ns16550_pio * pio = (void*)NS16550_BASE;

#ifdef CONSOLE_UART
__attribute__ ((constructor))
static int ns16550_init(void)
{
   108d4:	fe010113          	addi	sp,sp,-32
   108d8:	00812e23          	sw	s0,28(sp)
   108dc:	02010413          	addi	s0,sp,32
  uint32_t divisor;

  pio->ier = 0;
   108e0:	8081a783          	lw	a5,-2040(gp) # 1ecd8 <pio>
   108e4:	00078223          	sb	zero,4(a5) # 40000004 <_gp+0x3ffe0b34>

  divisor = NS16550_CLOCK_RATE / (16 * DEFAULT_BAUDRATE);
   108e8:	01a00793          	li	a5,26
   108ec:	fef42623          	sw	a5,-20(s0)
  pio->lcr |= LCR_DLAB;
   108f0:	8081a783          	lw	a5,-2040(gp) # 1ecd8 <pio>
   108f4:	8081a703          	lw	a4,-2040(gp) # 1ecd8 <pio>
   108f8:	00c74703          	lbu	a4,12(a4) # 200c <_reset+0x1e0c>
   108fc:	0ff77713          	andi	a4,a4,255
   10900:	f8076713          	ori	a4,a4,-128
   10904:	0ff77713          	andi	a4,a4,255
   10908:	00e78623          	sb	a4,12(a5)
  pio->dll = divisor & 0xff;
   1090c:	8081a783          	lw	a5,-2040(gp) # 1ecd8 <pio>
   10910:	fec42703          	lw	a4,-20(s0)
   10914:	0ff77713          	andi	a4,a4,255
   10918:	00e78023          	sb	a4,0(a5)
  pio->dlm = (divisor >> 8) & 0xff;
   1091c:	8081a783          	lw	a5,-2040(gp) # 1ecd8 <pio>
   10920:	fec42703          	lw	a4,-20(s0)
   10924:	00875713          	srli	a4,a4,0x8
   10928:	0ff77713          	andi	a4,a4,255
   1092c:	00e78223          	sb	a4,4(a5)
  pio->lcr &= ~LCR_DLAB;
   10930:	8081a783          	lw	a5,-2040(gp) # 1ecd8 <pio>
   10934:	8081a703          	lw	a4,-2040(gp) # 1ecd8 <pio>
   10938:	00c74703          	lbu	a4,12(a4)
   1093c:	0ff77713          	andi	a4,a4,255
   10940:	07f77713          	andi	a4,a4,127
   10944:	0ff77713          	andi	a4,a4,255
   10948:	00e78623          	sb	a4,12(a5)

  pio->lcr = LCR_WLS8;
   1094c:	8081a783          	lw	a5,-2040(gp) # 1ecd8 <pio>
   10950:	00300713          	li	a4,3
   10954:	00e78623          	sb	a4,12(a5)
  pio->fcr = FCR_FE;
   10958:	8081a783          	lw	a5,-2040(gp) # 1ecd8 <pio>
   1095c:	00100713          	li	a4,1
   10960:	00e78423          	sb	a4,8(a5)
  pio->mcr = MCR_RTS;
   10964:	8081a783          	lw	a5,-2040(gp) # 1ecd8 <pio>
   10968:	00200713          	li	a4,2
   1096c:	00e78823          	sb	a4,16(a5)

  return 0;
   10970:	00000793          	li	a5,0
}
   10974:	00078513          	mv	a0,a5
   10978:	01c12403          	lw	s0,28(sp)
   1097c:	02010113          	addi	sp,sp,32
   10980:	00008067          	ret

00010984 <ns16550_rxready>:
#endif


int ns16550_rxready(void)
{
   10984:	ff010113          	addi	sp,sp,-16
   10988:	00812623          	sw	s0,12(sp)
   1098c:	01010413          	addi	s0,sp,16
  return (pio->lsr & LSR_DR) != 0;
   10990:	8081a783          	lw	a5,-2040(gp) # 1ecd8 <pio>
   10994:	0147c783          	lbu	a5,20(a5)
   10998:	0ff7f793          	andi	a5,a5,255
   1099c:	0017f793          	andi	a5,a5,1
   109a0:	00f037b3          	snez	a5,a5
   109a4:	0ff7f793          	andi	a5,a5,255
}
   109a8:	00078513          	mv	a0,a5
   109ac:	00c12403          	lw	s0,12(sp)
   109b0:	01010113          	addi	sp,sp,16
   109b4:	00008067          	ret

000109b8 <ns16550_rxchar>:


int ns16550_rxchar(void)
{
   109b8:	ff010113          	addi	sp,sp,-16
   109bc:	00812623          	sw	s0,12(sp)
   109c0:	01010413          	addi	s0,sp,16
  while ((pio->lsr & LSR_DR) == 0)
   109c4:	00000013          	nop
   109c8:	8081a783          	lw	a5,-2040(gp) # 1ecd8 <pio>
   109cc:	0147c783          	lbu	a5,20(a5)
   109d0:	0ff7f793          	andi	a5,a5,255
   109d4:	0017f793          	andi	a5,a5,1
   109d8:	fe0788e3          	beqz	a5,109c8 <ns16550_rxchar+0x10>
    ;  // nothing

  return pio->rbr;
   109dc:	8081a783          	lw	a5,-2040(gp) # 1ecd8 <pio>
   109e0:	0007c783          	lbu	a5,0(a5)
   109e4:	0ff7f793          	andi	a5,a5,255
}
   109e8:	00078513          	mv	a0,a5
   109ec:	00c12403          	lw	s0,12(sp)
   109f0:	01010113          	addi	sp,sp,16
   109f4:	00008067          	ret

000109f8 <ns16550_txchar>:


int ns16550_txchar(int c)
{
   109f8:	fe010113          	addi	sp,sp,-32
   109fc:	00812e23          	sw	s0,28(sp)
   10a00:	02010413          	addi	s0,sp,32
   10a04:	fea42623          	sw	a0,-20(s0)
  while ((pio->lsr & LSR_THRE) == 0)
   10a08:	00000013          	nop
   10a0c:	8081a783          	lw	a5,-2040(gp) # 1ecd8 <pio>
   10a10:	0147c783          	lbu	a5,20(a5)
   10a14:	0ff7f793          	andi	a5,a5,255
   10a18:	0207f793          	andi	a5,a5,32
   10a1c:	fe0788e3          	beqz	a5,10a0c <ns16550_txchar+0x14>
    ;  // nothing

  pio->thr = c;
   10a20:	8081a783          	lw	a5,-2040(gp) # 1ecd8 <pio>
   10a24:	fec42703          	lw	a4,-20(s0)
   10a28:	0ff77713          	andi	a4,a4,255
   10a2c:	00e78023          	sb	a4,0(a5)

  return c;
   10a30:	fec42783          	lw	a5,-20(s0)
}
   10a34:	00078513          	mv	a0,a5
   10a38:	01c12403          	lw	s0,28(sp)
   10a3c:	02010113          	addi	sp,sp,32
   10a40:	00008067          	ret

00010a44 <ns16550_flush>:


void ns16550_flush(void)
{
   10a44:	ff010113          	addi	sp,sp,-16
   10a48:	00812623          	sw	s0,12(sp)
   10a4c:	01010413          	addi	s0,sp,16
  while ((pio->lsr & LSR_TEMT) == 0)
   10a50:	00000013          	nop
   10a54:	8081a783          	lw	a5,-2040(gp) # 1ecd8 <pio>
   10a58:	0147c783          	lbu	a5,20(a5)
   10a5c:	0ff7f793          	andi	a5,a5,255
   10a60:	0407f793          	andi	a5,a5,64
   10a64:	fe0788e3          	beqz	a5,10a54 <ns16550_flush+0x10>
    ;  // nothing
}
   10a68:	00000013          	nop
   10a6c:	00c12403          	lw	s0,12(sp)
   10a70:	01010113          	addi	sp,sp,16
   10a74:	00008067          	ret

00010a78 <multiply>:
// in the same .c file.


// multiply function
int multiply( int x, int y )
{
   10a78:	fd010113          	addi	sp,sp,-48
   10a7c:	02812623          	sw	s0,44(sp)
   10a80:	03010413          	addi	s0,sp,48
   10a84:	fca42e23          	sw	a0,-36(s0)
   10a88:	fcb42c23          	sw	a1,-40(s0)

 int i;
 int result = 0;
   10a8c:	fe042423          	sw	zero,-24(s0)

 for (i = 0; i < 32; i++)
   10a90:	fe042623          	sw	zero,-20(s0)
   10a94:	0440006f          	j	10ad8 <multiply+0x60>
 {
   if ((x & 0x1) == 1)
   10a98:	fdc42783          	lw	a5,-36(s0)
   10a9c:	0017f793          	andi	a5,a5,1
   10aa0:	00078a63          	beqz	a5,10ab4 <multiply+0x3c>
     result = result + y;
   10aa4:	fe842703          	lw	a4,-24(s0)
   10aa8:	fd842783          	lw	a5,-40(s0)
   10aac:	00f707b3          	add	a5,a4,a5
   10ab0:	fef42423          	sw	a5,-24(s0)

   x = x >> 1;
   10ab4:	fdc42783          	lw	a5,-36(s0)
   10ab8:	4017d793          	srai	a5,a5,0x1
   10abc:	fcf42e23          	sw	a5,-36(s0)
   y = y << 1;
   10ac0:	fd842783          	lw	a5,-40(s0)
   10ac4:	00179793          	slli	a5,a5,0x1
   10ac8:	fcf42c23          	sw	a5,-40(s0)
{

 int i;
 int result = 0;

 for (i = 0; i < 32; i++)
   10acc:	fec42783          	lw	a5,-20(s0)
   10ad0:	00178793          	addi	a5,a5,1
   10ad4:	fef42623          	sw	a5,-20(s0)
   10ad8:	fec42703          	lw	a4,-20(s0)
   10adc:	01f00793          	li	a5,31
   10ae0:	fae7dce3          	ble	a4,a5,10a98 <multiply+0x20>

   x = x >> 1;
   y = y << 1;
 }

 return result;
   10ae4:	fe842783          	lw	a5,-24(s0)

}
   10ae8:	00078513          	mv	a0,a5
   10aec:	02c12403          	lw	s0,44(sp)
   10af0:	03010113          	addi	sp,sp,48
   10af4:	00008067          	ret

00010af8 <divide>:


// divide function
int divide( int x, int y )
{
   10af8:	fd010113          	addi	sp,sp,-48
   10afc:	02812623          	sw	s0,44(sp)
   10b00:	03010413          	addi	s0,sp,48
   10b04:	fca42e23          	sw	a0,-36(s0)
   10b08:	fcb42c23          	sw	a1,-40(s0)
 int i, y2 = y, tmp = 1;
   10b0c:	fd842783          	lw	a5,-40(s0)
   10b10:	fef42623          	sw	a5,-20(s0)
   10b14:	00100793          	li	a5,1
   10b18:	fef42423          	sw	a5,-24(s0)
 int result = 1;
   10b1c:	00100793          	li	a5,1
   10b20:	fef42223          	sw	a5,-28(s0)

 while (x > y2)
   10b24:	01c0006f          	j	10b40 <divide+0x48>
 {
   y2 = y2 << 1;
   10b28:	fec42783          	lw	a5,-20(s0)
   10b2c:	00179793          	slli	a5,a5,0x1
   10b30:	fef42623          	sw	a5,-20(s0)
   tmp = tmp << 1;
   10b34:	fe842783          	lw	a5,-24(s0)
   10b38:	00179793          	slli	a5,a5,0x1
   10b3c:	fef42423          	sw	a5,-24(s0)
int divide( int x, int y )
{
 int i, y2 = y, tmp = 1;
 int result = 1;

 while (x > y2)
   10b40:	fdc42703          	lw	a4,-36(s0)
   10b44:	fec42783          	lw	a5,-20(s0)
   10b48:	fee7c0e3          	blt	a5,a4,10b28 <divide+0x30>
 {
   y2 = y2 << 1;
   tmp = tmp << 1;
 }

 while (x > y)
   10b4c:	0480006f          	j	10b94 <divide+0x9c>
 {
   if (x > y2)
   10b50:	fdc42703          	lw	a4,-36(s0)
   10b54:	fec42783          	lw	a5,-20(s0)
   10b58:	02e7d263          	ble	a4,a5,10b7c <divide+0x84>
   {
     x = x - y2;
   10b5c:	fdc42703          	lw	a4,-36(s0)
   10b60:	fec42783          	lw	a5,-20(s0)
   10b64:	40f707b3          	sub	a5,a4,a5
   10b68:	fcf42e23          	sw	a5,-36(s0)
     result = result + tmp;
   10b6c:	fe442703          	lw	a4,-28(s0)
   10b70:	fe842783          	lw	a5,-24(s0)
   10b74:	00f707b3          	add	a5,a4,a5
   10b78:	fef42223          	sw	a5,-28(s0)
   }
   tmp = tmp >> 1;
   10b7c:	fe842783          	lw	a5,-24(s0)
   10b80:	4017d793          	srai	a5,a5,0x1
   10b84:	fef42423          	sw	a5,-24(s0)
   y2 = y2 >> 1;
   10b88:	fec42783          	lw	a5,-20(s0)
   10b8c:	4017d793          	srai	a5,a5,0x1
   10b90:	fef42623          	sw	a5,-20(s0)
 {
   y2 = y2 << 1;
   tmp = tmp << 1;
 }

 while (x > y)
   10b94:	fdc42703          	lw	a4,-36(s0)
   10b98:	fd842783          	lw	a5,-40(s0)
   10b9c:	fae7cae3          	blt	a5,a4,10b50 <divide+0x58>
   }
   tmp = tmp >> 1;
   y2 = y2 >> 1;
 }

 return result;
   10ba0:	fe442783          	lw	a5,-28(s0)

}
   10ba4:	00078513          	mv	a0,a5
   10ba8:	02c12403          	lw	s0,44(sp)
   10bac:	03010113          	addi	sp,sp,48
   10bb0:	00008067          	ret

00010bb4 <remove_red>:

void remove_red(int pmap_r[DATA_SIZE][DATA_SIZE], int pmap_g[DATA_SIZE][DATA_SIZE], int pmap_b[DATA_SIZE][DATA_SIZE],
                int res_r[DATA_SIZE][DATA_SIZE], int res_g[DATA_SIZE][DATA_SIZE], int res_b[DATA_SIZE][DATA_SIZE])
{
   10bb4:	fc010113          	addi	sp,sp,-64
   10bb8:	02112e23          	sw	ra,60(sp)
   10bbc:	02812c23          	sw	s0,56(sp)
   10bc0:	04010413          	addi	s0,sp,64
   10bc4:	fca42e23          	sw	a0,-36(s0)
   10bc8:	fcb42c23          	sw	a1,-40(s0)
   10bcc:	fcc42a23          	sw	a2,-44(s0)
   10bd0:	fcd42823          	sw	a3,-48(s0)
   10bd4:	fce42623          	sw	a4,-52(s0)
   10bd8:	fcf42423          	sw	a5,-56(s0)
  int i, j;
  printf("called remove_red\n");
   10bdc:	0001c7b7          	lui	a5,0x1c
   10be0:	55878513          	addi	a0,a5,1368 # 1c558 <__extendsfdf2+0x40>
   10be4:	654010ef          	jal	12238 <puts>
  for (i = 0; i < DATA_SIZE; i++)
   10be8:	fe042623          	sw	zero,-20(s0)
   10bec:	0f80006f          	j	10ce4 <remove_red+0x130>
  {
    for (j = 0; j < DATA_SIZE; j++)
   10bf0:	fe042423          	sw	zero,-24(s0)
   10bf4:	0d80006f          	j	10ccc <remove_red+0x118>
    {
      res_r[i][j] = 0;
   10bf8:	fec42783          	lw	a5,-20(s0)
   10bfc:	00379793          	slli	a5,a5,0x3
   10c00:	00279713          	slli	a4,a5,0x2
   10c04:	40f707b3          	sub	a5,a4,a5
   10c08:	fd042703          	lw	a4,-48(s0)
   10c0c:	00f70733          	add	a4,a4,a5
   10c10:	fe842783          	lw	a5,-24(s0)
   10c14:	00279793          	slli	a5,a5,0x2
   10c18:	00f707b3          	add	a5,a4,a5
   10c1c:	0007a023          	sw	zero,0(a5)
      res_g[i][j] = pmap_g[i][j];
   10c20:	fec42783          	lw	a5,-20(s0)
   10c24:	00379793          	slli	a5,a5,0x3
   10c28:	00279713          	slli	a4,a5,0x2
   10c2c:	40f707b3          	sub	a5,a4,a5
   10c30:	fcc42703          	lw	a4,-52(s0)
   10c34:	00f706b3          	add	a3,a4,a5
   10c38:	fec42783          	lw	a5,-20(s0)
   10c3c:	00379793          	slli	a5,a5,0x3
   10c40:	00279713          	slli	a4,a5,0x2
   10c44:	40f707b3          	sub	a5,a4,a5
   10c48:	fd842703          	lw	a4,-40(s0)
   10c4c:	00f70733          	add	a4,a4,a5
   10c50:	fe842783          	lw	a5,-24(s0)
   10c54:	00279793          	slli	a5,a5,0x2
   10c58:	00f707b3          	add	a5,a4,a5
   10c5c:	0007a703          	lw	a4,0(a5)
   10c60:	fe842783          	lw	a5,-24(s0)
   10c64:	00279793          	slli	a5,a5,0x2
   10c68:	00f687b3          	add	a5,a3,a5
   10c6c:	00e7a023          	sw	a4,0(a5)
      res_b[i][j] = pmap_b[i][j];
   10c70:	fec42783          	lw	a5,-20(s0)
   10c74:	00379793          	slli	a5,a5,0x3
   10c78:	00279713          	slli	a4,a5,0x2
   10c7c:	40f707b3          	sub	a5,a4,a5
   10c80:	fc842703          	lw	a4,-56(s0)
   10c84:	00f706b3          	add	a3,a4,a5
   10c88:	fec42783          	lw	a5,-20(s0)
   10c8c:	00379793          	slli	a5,a5,0x3
   10c90:	00279713          	slli	a4,a5,0x2
   10c94:	40f707b3          	sub	a5,a4,a5
   10c98:	fd442703          	lw	a4,-44(s0)
   10c9c:	00f70733          	add	a4,a4,a5
   10ca0:	fe842783          	lw	a5,-24(s0)
   10ca4:	00279793          	slli	a5,a5,0x2
   10ca8:	00f707b3          	add	a5,a4,a5
   10cac:	0007a703          	lw	a4,0(a5)
   10cb0:	fe842783          	lw	a5,-24(s0)
   10cb4:	00279793          	slli	a5,a5,0x2
   10cb8:	00f687b3          	add	a5,a3,a5
   10cbc:	00e7a023          	sw	a4,0(a5)
{
  int i, j;
  printf("called remove_red\n");
  for (i = 0; i < DATA_SIZE; i++)
  {
    for (j = 0; j < DATA_SIZE; j++)
   10cc0:	fe842783          	lw	a5,-24(s0)
   10cc4:	00178793          	addi	a5,a5,1
   10cc8:	fef42423          	sw	a5,-24(s0)
   10ccc:	fe842703          	lw	a4,-24(s0)
   10cd0:	00500793          	li	a5,5
   10cd4:	f2e7d2e3          	ble	a4,a5,10bf8 <remove_red+0x44>
void remove_red(int pmap_r[DATA_SIZE][DATA_SIZE], int pmap_g[DATA_SIZE][DATA_SIZE], int pmap_b[DATA_SIZE][DATA_SIZE],
                int res_r[DATA_SIZE][DATA_SIZE], int res_g[DATA_SIZE][DATA_SIZE], int res_b[DATA_SIZE][DATA_SIZE])
{
  int i, j;
  printf("called remove_red\n");
  for (i = 0; i < DATA_SIZE; i++)
   10cd8:	fec42783          	lw	a5,-20(s0)
   10cdc:	00178793          	addi	a5,a5,1
   10ce0:	fef42623          	sw	a5,-20(s0)
   10ce4:	fec42703          	lw	a4,-20(s0)
   10ce8:	00500793          	li	a5,5
   10cec:	f0e7d2e3          	ble	a4,a5,10bf0 <remove_red+0x3c>
      res_g[i][j] = pmap_g[i][j];
      res_b[i][j] = pmap_b[i][j];
    }
  }

  printf("exiting remove_red\n");
   10cf0:	0001c7b7          	lui	a5,0x1c
   10cf4:	56c78513          	addi	a0,a5,1388 # 1c56c <__extendsfdf2+0x54>
   10cf8:	540010ef          	jal	12238 <puts>
}
   10cfc:	00000013          	nop
   10d00:	03c12083          	lw	ra,60(sp)
   10d04:	03812403          	lw	s0,56(sp)
   10d08:	04010113          	addi	sp,sp,64
   10d0c:	00008067          	ret

00010d10 <sharpen>:

void sharpen(int pmap_r[DATA_SIZE][DATA_SIZE], int pmap_g[DATA_SIZE][DATA_SIZE], int pmap_b[DATA_SIZE][DATA_SIZE],
             int res_r[DATA_SIZE][DATA_SIZE], int res_g[DATA_SIZE][DATA_SIZE], int res_b[DATA_SIZE][DATA_SIZE])
{
   10d10:	f8010113          	addi	sp,sp,-128
   10d14:	06112e23          	sw	ra,124(sp)
   10d18:	06812c23          	sw	s0,120(sp)
   10d1c:	08010413          	addi	s0,sp,128
   10d20:	f8a42e23          	sw	a0,-100(s0)
   10d24:	f8b42c23          	sw	a1,-104(s0)
   10d28:	f8c42a23          	sw	a2,-108(s0)
   10d2c:	f8d42823          	sw	a3,-112(s0)
   10d30:	f8e42623          	sw	a4,-116(s0)
   10d34:	f8f42423          	sw	a5,-120(s0)
  int i, j, k, l, x, y;

  int sharpen_filter[3][3]={{0,-1,0},{-1,5,-1},{0,-1,0}};
   10d38:	0001c7b7          	lui	a5,0x1c
   10d3c:	fa840713          	addi	a4,s0,-88
   10d40:	5a078793          	addi	a5,a5,1440 # 1c5a0 <__extendsfdf2+0x88>
   10d44:	02400693          	li	a3,36
   10d48:	00068613          	mv	a2,a3
   10d4c:	00078593          	mv	a1,a5
   10d50:	00070513          	mv	a0,a4
   10d54:	280010ef          	jal	11fd4 <memcpy>

  int sum_r = 0;
   10d58:	fc042e23          	sw	zero,-36(s0)
  int sum_g = 0;
   10d5c:	fc042c23          	sw	zero,-40(s0)
  int sum_b = 0;
   10d60:	fc042a23          	sw	zero,-44(s0)

  printf("called sharpen\n");
   10d64:	0001c7b7          	lui	a5,0x1c
   10d68:	58078513          	addi	a0,a5,1408 # 1c580 <__extendsfdf2+0x68>
   10d6c:	4cc010ef          	jal	12238 <puts>

  for (i = 0; i < DATA_SIZE; i++)
   10d70:	fe042623          	sw	zero,-20(s0)
   10d74:	2680006f          	j	10fdc <sharpen+0x2cc>
  {
    res_r[0][i] = pmap_r[0][i];
   10d78:	f9c42703          	lw	a4,-100(s0)
   10d7c:	fec42783          	lw	a5,-20(s0)
   10d80:	00279793          	slli	a5,a5,0x2
   10d84:	00f707b3          	add	a5,a4,a5
   10d88:	0007a703          	lw	a4,0(a5)
   10d8c:	f9042683          	lw	a3,-112(s0)
   10d90:	fec42783          	lw	a5,-20(s0)
   10d94:	00279793          	slli	a5,a5,0x2
   10d98:	00f687b3          	add	a5,a3,a5
   10d9c:	00e7a023          	sw	a4,0(a5)
    res_g[0][i] = pmap_g[0][i];
   10da0:	f9842703          	lw	a4,-104(s0)
   10da4:	fec42783          	lw	a5,-20(s0)
   10da8:	00279793          	slli	a5,a5,0x2
   10dac:	00f707b3          	add	a5,a4,a5
   10db0:	0007a703          	lw	a4,0(a5)
   10db4:	f8c42683          	lw	a3,-116(s0)
   10db8:	fec42783          	lw	a5,-20(s0)
   10dbc:	00279793          	slli	a5,a5,0x2
   10dc0:	00f687b3          	add	a5,a3,a5
   10dc4:	00e7a023          	sw	a4,0(a5)
    res_b[0][i] = pmap_b[0][i];
   10dc8:	f9442703          	lw	a4,-108(s0)
   10dcc:	fec42783          	lw	a5,-20(s0)
   10dd0:	00279793          	slli	a5,a5,0x2
   10dd4:	00f707b3          	add	a5,a4,a5
   10dd8:	0007a703          	lw	a4,0(a5)
   10ddc:	f8842683          	lw	a3,-120(s0)
   10de0:	fec42783          	lw	a5,-20(s0)
   10de4:	00279793          	slli	a5,a5,0x2
   10de8:	00f687b3          	add	a5,a3,a5
   10dec:	00e7a023          	sw	a4,0(a5)
    res_r[DATA_SIZE-1][i] = pmap_r[DATA_SIZE-1][i];
   10df0:	f9042783          	lw	a5,-112(s0)
   10df4:	07878693          	addi	a3,a5,120
   10df8:	f9c42783          	lw	a5,-100(s0)
   10dfc:	07878713          	addi	a4,a5,120
   10e00:	fec42783          	lw	a5,-20(s0)
   10e04:	00279793          	slli	a5,a5,0x2
   10e08:	00f707b3          	add	a5,a4,a5
   10e0c:	0007a703          	lw	a4,0(a5)
   10e10:	fec42783          	lw	a5,-20(s0)
   10e14:	00279793          	slli	a5,a5,0x2
   10e18:	00f687b3          	add	a5,a3,a5
   10e1c:	00e7a023          	sw	a4,0(a5)
    res_g[DATA_SIZE-1][i] = pmap_g[DATA_SIZE-1][i];
   10e20:	f8c42783          	lw	a5,-116(s0)
   10e24:	07878693          	addi	a3,a5,120
   10e28:	f9842783          	lw	a5,-104(s0)
   10e2c:	07878713          	addi	a4,a5,120
   10e30:	fec42783          	lw	a5,-20(s0)
   10e34:	00279793          	slli	a5,a5,0x2
   10e38:	00f707b3          	add	a5,a4,a5
   10e3c:	0007a703          	lw	a4,0(a5)
   10e40:	fec42783          	lw	a5,-20(s0)
   10e44:	00279793          	slli	a5,a5,0x2
   10e48:	00f687b3          	add	a5,a3,a5
   10e4c:	00e7a023          	sw	a4,0(a5)
    res_b[DATA_SIZE-1][i] = pmap_b[DATA_SIZE-1][i];
   10e50:	f8842783          	lw	a5,-120(s0)
   10e54:	07878693          	addi	a3,a5,120
   10e58:	f9442783          	lw	a5,-108(s0)
   10e5c:	07878713          	addi	a4,a5,120
   10e60:	fec42783          	lw	a5,-20(s0)
   10e64:	00279793          	slli	a5,a5,0x2
   10e68:	00f707b3          	add	a5,a4,a5
   10e6c:	0007a703          	lw	a4,0(a5)
   10e70:	fec42783          	lw	a5,-20(s0)
   10e74:	00279793          	slli	a5,a5,0x2
   10e78:	00f687b3          	add	a5,a3,a5
   10e7c:	00e7a023          	sw	a4,0(a5)

    res_r[i][0] = pmap_r[i][0];
   10e80:	fec42783          	lw	a5,-20(s0)
   10e84:	00379793          	slli	a5,a5,0x3
   10e88:	00279713          	slli	a4,a5,0x2
   10e8c:	40f707b3          	sub	a5,a4,a5
   10e90:	f9042703          	lw	a4,-112(s0)
   10e94:	00f70733          	add	a4,a4,a5
   10e98:	fec42783          	lw	a5,-20(s0)
   10e9c:	00379793          	slli	a5,a5,0x3
   10ea0:	00279693          	slli	a3,a5,0x2
   10ea4:	40f687b3          	sub	a5,a3,a5
   10ea8:	f9c42683          	lw	a3,-100(s0)
   10eac:	00f687b3          	add	a5,a3,a5
   10eb0:	0007a783          	lw	a5,0(a5)
   10eb4:	00f72023          	sw	a5,0(a4)
    res_g[i][0] = pmap_g[i][0];
   10eb8:	fec42783          	lw	a5,-20(s0)
   10ebc:	00379793          	slli	a5,a5,0x3
   10ec0:	00279713          	slli	a4,a5,0x2
   10ec4:	40f707b3          	sub	a5,a4,a5
   10ec8:	f8c42703          	lw	a4,-116(s0)
   10ecc:	00f70733          	add	a4,a4,a5
   10ed0:	fec42783          	lw	a5,-20(s0)
   10ed4:	00379793          	slli	a5,a5,0x3
   10ed8:	00279693          	slli	a3,a5,0x2
   10edc:	40f687b3          	sub	a5,a3,a5
   10ee0:	f9842683          	lw	a3,-104(s0)
   10ee4:	00f687b3          	add	a5,a3,a5
   10ee8:	0007a783          	lw	a5,0(a5)
   10eec:	00f72023          	sw	a5,0(a4)
    res_b[i][0] = pmap_b[i][0];
   10ef0:	fec42783          	lw	a5,-20(s0)
   10ef4:	00379793          	slli	a5,a5,0x3
   10ef8:	00279713          	slli	a4,a5,0x2
   10efc:	40f707b3          	sub	a5,a4,a5
   10f00:	f8842703          	lw	a4,-120(s0)
   10f04:	00f70733          	add	a4,a4,a5
   10f08:	fec42783          	lw	a5,-20(s0)
   10f0c:	00379793          	slli	a5,a5,0x3
   10f10:	00279693          	slli	a3,a5,0x2
   10f14:	40f687b3          	sub	a5,a3,a5
   10f18:	f9442683          	lw	a3,-108(s0)
   10f1c:	00f687b3          	add	a5,a3,a5
   10f20:	0007a783          	lw	a5,0(a5)
   10f24:	00f72023          	sw	a5,0(a4)
    res_r[i][DATA_SIZE-1] = pmap_r[i][DATA_SIZE-1];
   10f28:	fec42783          	lw	a5,-20(s0)
   10f2c:	00379793          	slli	a5,a5,0x3
   10f30:	00279713          	slli	a4,a5,0x2
   10f34:	40f707b3          	sub	a5,a4,a5
   10f38:	f9042703          	lw	a4,-112(s0)
   10f3c:	00f70733          	add	a4,a4,a5
   10f40:	fec42783          	lw	a5,-20(s0)
   10f44:	00379793          	slli	a5,a5,0x3
   10f48:	00279693          	slli	a3,a5,0x2
   10f4c:	40f687b3          	sub	a5,a3,a5
   10f50:	f9c42683          	lw	a3,-100(s0)
   10f54:	00f687b3          	add	a5,a3,a5
   10f58:	0147a783          	lw	a5,20(a5)
   10f5c:	00f72a23          	sw	a5,20(a4)
    res_g[i][DATA_SIZE-1] = pmap_g[i][DATA_SIZE-1];
   10f60:	fec42783          	lw	a5,-20(s0)
   10f64:	00379793          	slli	a5,a5,0x3
   10f68:	00279713          	slli	a4,a5,0x2
   10f6c:	40f707b3          	sub	a5,a4,a5
   10f70:	f8c42703          	lw	a4,-116(s0)
   10f74:	00f70733          	add	a4,a4,a5
   10f78:	fec42783          	lw	a5,-20(s0)
   10f7c:	00379793          	slli	a5,a5,0x3
   10f80:	00279693          	slli	a3,a5,0x2
   10f84:	40f687b3          	sub	a5,a3,a5
   10f88:	f9842683          	lw	a3,-104(s0)
   10f8c:	00f687b3          	add	a5,a3,a5
   10f90:	0147a783          	lw	a5,20(a5)
   10f94:	00f72a23          	sw	a5,20(a4)
    res_b[i][DATA_SIZE-1] = pmap_b[i][DATA_SIZE-1];
   10f98:	fec42783          	lw	a5,-20(s0)
   10f9c:	00379793          	slli	a5,a5,0x3
   10fa0:	00279713          	slli	a4,a5,0x2
   10fa4:	40f707b3          	sub	a5,a4,a5
   10fa8:	f8842703          	lw	a4,-120(s0)
   10fac:	00f70733          	add	a4,a4,a5
   10fb0:	fec42783          	lw	a5,-20(s0)
   10fb4:	00379793          	slli	a5,a5,0x3
   10fb8:	00279693          	slli	a3,a5,0x2
   10fbc:	40f687b3          	sub	a5,a3,a5
   10fc0:	f9442683          	lw	a3,-108(s0)
   10fc4:	00f687b3          	add	a5,a3,a5
   10fc8:	0147a783          	lw	a5,20(a5)
   10fcc:	00f72a23          	sw	a5,20(a4)
  int sum_g = 0;
  int sum_b = 0;

  printf("called sharpen\n");

  for (i = 0; i < DATA_SIZE; i++)
   10fd0:	fec42783          	lw	a5,-20(s0)
   10fd4:	00178793          	addi	a5,a5,1
   10fd8:	fef42623          	sw	a5,-20(s0)
   10fdc:	fec42703          	lw	a4,-20(s0)
   10fe0:	00500793          	li	a5,5
   10fe4:	d8e7dae3          	ble	a4,a5,10d78 <sharpen+0x68>
    res_g[i][DATA_SIZE-1] = pmap_g[i][DATA_SIZE-1];
    res_b[i][DATA_SIZE-1] = pmap_b[i][DATA_SIZE-1];

  }

  for (i = 1; i < DATA_SIZE-1; i++)
   10fe8:	00100793          	li	a5,1
   10fec:	fef42623          	sw	a5,-20(s0)
   10ff0:	2c40006f          	j	112b4 <sharpen+0x5a4>
  {
    for (j = 1; j < DATA_SIZE-1; j++)
   10ff4:	00100793          	li	a5,1
   10ff8:	fef42423          	sw	a5,-24(s0)
   10ffc:	2a00006f          	j	1129c <sharpen+0x58c>
    {
      sum_r = 0;
   11000:	fc042e23          	sw	zero,-36(s0)
      sum_g = 0;
   11004:	fc042c23          	sw	zero,-40(s0)
      sum_b = 0;
   11008:	fc042a23          	sw	zero,-44(s0)

      for (k = 0; k < 3; k++)
   1100c:	fe042223          	sw	zero,-28(s0)
   11010:	19c0006f          	j	111ac <sharpen+0x49c>
      {
	for (l = 0; l < 3; l++)
   11014:	fe042023          	sw	zero,-32(s0)
   11018:	17c0006f          	j	11194 <sharpen+0x484>
	{
	  x = i + k - 1;
   1101c:	fec42703          	lw	a4,-20(s0)
   11020:	fe442783          	lw	a5,-28(s0)
   11024:	00f707b3          	add	a5,a4,a5
   11028:	fff78793          	addi	a5,a5,-1
   1102c:	fcf42823          	sw	a5,-48(s0)
	  y = j + l - 1;
   11030:	fe842703          	lw	a4,-24(s0)
   11034:	fe042783          	lw	a5,-32(s0)
   11038:	00f707b3          	add	a5,a4,a5
   1103c:	fff78793          	addi	a5,a5,-1
   11040:	fcf42623          	sw	a5,-52(s0)
          sum_r = sum_r + multiply(pmap_r[x][y], sharpen_filter[k][l]);
   11044:	fd042783          	lw	a5,-48(s0)
   11048:	00379793          	slli	a5,a5,0x3
   1104c:	00279713          	slli	a4,a5,0x2
   11050:	40f707b3          	sub	a5,a4,a5
   11054:	f9c42703          	lw	a4,-100(s0)
   11058:	00f70733          	add	a4,a4,a5
   1105c:	fcc42783          	lw	a5,-52(s0)
   11060:	00279793          	slli	a5,a5,0x2
   11064:	00f707b3          	add	a5,a4,a5
   11068:	0007a683          	lw	a3,0(a5)
   1106c:	fe442703          	lw	a4,-28(s0)
   11070:	00070793          	mv	a5,a4
   11074:	00179793          	slli	a5,a5,0x1
   11078:	00e787b3          	add	a5,a5,a4
   1107c:	fe042703          	lw	a4,-32(s0)
   11080:	00e787b3          	add	a5,a5,a4
   11084:	00279793          	slli	a5,a5,0x2
   11088:	ff040713          	addi	a4,s0,-16
   1108c:	00f707b3          	add	a5,a4,a5
   11090:	fb87a783          	lw	a5,-72(a5)
   11094:	00078593          	mv	a1,a5
   11098:	00068513          	mv	a0,a3
   1109c:	9ddff0ef          	jal	10a78 <multiply>
   110a0:	00050713          	mv	a4,a0
   110a4:	fdc42783          	lw	a5,-36(s0)
   110a8:	00e787b3          	add	a5,a5,a4
   110ac:	fcf42e23          	sw	a5,-36(s0)
          sum_g = sum_g + multiply(pmap_g[x][y], sharpen_filter[k][l]);
   110b0:	fd042783          	lw	a5,-48(s0)
   110b4:	00379793          	slli	a5,a5,0x3
   110b8:	00279713          	slli	a4,a5,0x2
   110bc:	40f707b3          	sub	a5,a4,a5
   110c0:	f9842703          	lw	a4,-104(s0)
   110c4:	00f70733          	add	a4,a4,a5
   110c8:	fcc42783          	lw	a5,-52(s0)
   110cc:	00279793          	slli	a5,a5,0x2
   110d0:	00f707b3          	add	a5,a4,a5
   110d4:	0007a683          	lw	a3,0(a5)
   110d8:	fe442703          	lw	a4,-28(s0)
   110dc:	00070793          	mv	a5,a4
   110e0:	00179793          	slli	a5,a5,0x1
   110e4:	00e787b3          	add	a5,a5,a4
   110e8:	fe042703          	lw	a4,-32(s0)
   110ec:	00e787b3          	add	a5,a5,a4
   110f0:	00279793          	slli	a5,a5,0x2
   110f4:	ff040713          	addi	a4,s0,-16
   110f8:	00f707b3          	add	a5,a4,a5
   110fc:	fb87a783          	lw	a5,-72(a5)
   11100:	00078593          	mv	a1,a5
   11104:	00068513          	mv	a0,a3
   11108:	971ff0ef          	jal	10a78 <multiply>
   1110c:	00050713          	mv	a4,a0
   11110:	fd842783          	lw	a5,-40(s0)
   11114:	00e787b3          	add	a5,a5,a4
   11118:	fcf42c23          	sw	a5,-40(s0)
          sum_b = sum_b + multiply(pmap_b[x][y], sharpen_filter[k][l]);
   1111c:	fd042783          	lw	a5,-48(s0)
   11120:	00379793          	slli	a5,a5,0x3
   11124:	00279713          	slli	a4,a5,0x2
   11128:	40f707b3          	sub	a5,a4,a5
   1112c:	f9442703          	lw	a4,-108(s0)
   11130:	00f70733          	add	a4,a4,a5
   11134:	fcc42783          	lw	a5,-52(s0)
   11138:	00279793          	slli	a5,a5,0x2
   1113c:	00f707b3          	add	a5,a4,a5
   11140:	0007a683          	lw	a3,0(a5)
   11144:	fe442703          	lw	a4,-28(s0)
   11148:	00070793          	mv	a5,a4
   1114c:	00179793          	slli	a5,a5,0x1
   11150:	00e787b3          	add	a5,a5,a4
   11154:	fe042703          	lw	a4,-32(s0)
   11158:	00e787b3          	add	a5,a5,a4
   1115c:	00279793          	slli	a5,a5,0x2
   11160:	ff040713          	addi	a4,s0,-16
   11164:	00f707b3          	add	a5,a4,a5
   11168:	fb87a783          	lw	a5,-72(a5)
   1116c:	00078593          	mv	a1,a5
   11170:	00068513          	mv	a0,a3
   11174:	905ff0ef          	jal	10a78 <multiply>
   11178:	00050713          	mv	a4,a0
   1117c:	fd442783          	lw	a5,-44(s0)
   11180:	00e787b3          	add	a5,a5,a4
   11184:	fcf42a23          	sw	a5,-44(s0)
      sum_g = 0;
      sum_b = 0;

      for (k = 0; k < 3; k++)
      {
	for (l = 0; l < 3; l++)
   11188:	fe042783          	lw	a5,-32(s0)
   1118c:	00178793          	addi	a5,a5,1
   11190:	fef42023          	sw	a5,-32(s0)
   11194:	fe042703          	lw	a4,-32(s0)
   11198:	00200793          	li	a5,2
   1119c:	e8e7d0e3          	ble	a4,a5,1101c <sharpen+0x30c>
    {
      sum_r = 0;
      sum_g = 0;
      sum_b = 0;

      for (k = 0; k < 3; k++)
   111a0:	fe442783          	lw	a5,-28(s0)
   111a4:	00178793          	addi	a5,a5,1
   111a8:	fef42223          	sw	a5,-28(s0)
   111ac:	fe442703          	lw	a4,-28(s0)
   111b0:	00200793          	li	a5,2
   111b4:	e6e7d0e3          	ble	a4,a5,11014 <sharpen+0x304>
          sum_g = sum_g + multiply(pmap_g[x][y], sharpen_filter[k][l]);
          sum_b = sum_b + multiply(pmap_b[x][y], sharpen_filter[k][l]);
	}
      }

      res_r[i][j] = (sum_r > 255)? 255 : (sum_r >= 0)? sum_r : 0;
   111b8:	fec42783          	lw	a5,-20(s0)
   111bc:	00379793          	slli	a5,a5,0x3
   111c0:	00279713          	slli	a4,a5,0x2
   111c4:	40f707b3          	sub	a5,a4,a5
   111c8:	f9042703          	lw	a4,-112(s0)
   111cc:	00f706b3          	add	a3,a4,a5
   111d0:	fdc42703          	lw	a4,-36(s0)
   111d4:	0ff00793          	li	a5,255
   111d8:	00e7ca63          	blt	a5,a4,111ec <sharpen+0x4dc>
   111dc:	fdc42783          	lw	a5,-36(s0)
   111e0:	0007d863          	bgez	a5,111f0 <sharpen+0x4e0>
   111e4:	00000793          	li	a5,0
   111e8:	0080006f          	j	111f0 <sharpen+0x4e0>
   111ec:	0ff00793          	li	a5,255
   111f0:	fe842703          	lw	a4,-24(s0)
   111f4:	00271713          	slli	a4,a4,0x2
   111f8:	00e68733          	add	a4,a3,a4
   111fc:	00f72023          	sw	a5,0(a4)
      res_g[i][j] = (sum_g > 255)? 255 : (sum_g >= 0)? sum_g : 0;
   11200:	fec42783          	lw	a5,-20(s0)
   11204:	00379793          	slli	a5,a5,0x3
   11208:	00279713          	slli	a4,a5,0x2
   1120c:	40f707b3          	sub	a5,a4,a5
   11210:	f8c42703          	lw	a4,-116(s0)
   11214:	00f706b3          	add	a3,a4,a5
   11218:	fd842703          	lw	a4,-40(s0)
   1121c:	0ff00793          	li	a5,255
   11220:	00e7ca63          	blt	a5,a4,11234 <sharpen+0x524>
   11224:	fd842783          	lw	a5,-40(s0)
   11228:	0007d863          	bgez	a5,11238 <sharpen+0x528>
   1122c:	00000793          	li	a5,0
   11230:	0080006f          	j	11238 <sharpen+0x528>
   11234:	0ff00793          	li	a5,255
   11238:	fe842703          	lw	a4,-24(s0)
   1123c:	00271713          	slli	a4,a4,0x2
   11240:	00e68733          	add	a4,a3,a4
   11244:	00f72023          	sw	a5,0(a4)
      res_b[i][j] = (sum_b > 255)? 255 : (sum_b >= 0)? sum_b : 0;
   11248:	fec42783          	lw	a5,-20(s0)
   1124c:	00379793          	slli	a5,a5,0x3
   11250:	00279713          	slli	a4,a5,0x2
   11254:	40f707b3          	sub	a5,a4,a5
   11258:	f8842703          	lw	a4,-120(s0)
   1125c:	00f706b3          	add	a3,a4,a5
   11260:	fd442703          	lw	a4,-44(s0)
   11264:	0ff00793          	li	a5,255
   11268:	00e7ca63          	blt	a5,a4,1127c <sharpen+0x56c>
   1126c:	fd442783          	lw	a5,-44(s0)
   11270:	0007d863          	bgez	a5,11280 <sharpen+0x570>
   11274:	00000793          	li	a5,0
   11278:	0080006f          	j	11280 <sharpen+0x570>
   1127c:	0ff00793          	li	a5,255
   11280:	fe842703          	lw	a4,-24(s0)
   11284:	00271713          	slli	a4,a4,0x2
   11288:	00e68733          	add	a4,a3,a4
   1128c:	00f72023          	sw	a5,0(a4)

  }

  for (i = 1; i < DATA_SIZE-1; i++)
  {
    for (j = 1; j < DATA_SIZE-1; j++)
   11290:	fe842783          	lw	a5,-24(s0)
   11294:	00178793          	addi	a5,a5,1
   11298:	fef42423          	sw	a5,-24(s0)
   1129c:	fe842703          	lw	a4,-24(s0)
   112a0:	00400793          	li	a5,4
   112a4:	d4e7dee3          	ble	a4,a5,11000 <sharpen+0x2f0>
    res_g[i][DATA_SIZE-1] = pmap_g[i][DATA_SIZE-1];
    res_b[i][DATA_SIZE-1] = pmap_b[i][DATA_SIZE-1];

  }

  for (i = 1; i < DATA_SIZE-1; i++)
   112a8:	fec42783          	lw	a5,-20(s0)
   112ac:	00178793          	addi	a5,a5,1
   112b0:	fef42623          	sw	a5,-20(s0)
   112b4:	fec42703          	lw	a4,-20(s0)
   112b8:	00400793          	li	a5,4
   112bc:	d2e7dce3          	ble	a4,a5,10ff4 <sharpen+0x2e4>
      res_g[i][j] = (sum_g > 255)? 255 : (sum_g >= 0)? sum_g : 0;
      res_b[i][j] = (sum_b > 255)? 255 : (sum_b >= 0)? sum_b : 0;

    }
  }
  printf("exiting sharpen\n");
   112c0:	0001c7b7          	lui	a5,0x1c
   112c4:	59078513          	addi	a0,a5,1424 # 1c590 <__extendsfdf2+0x78>
   112c8:	771000ef          	jal	12238 <puts>
}
   112cc:	00000013          	nop
   112d0:	07c12083          	lw	ra,124(sp)
   112d4:	07812403          	lw	s0,120(sp)
   112d8:	08010113          	addi	sp,sp,128
   112dc:	00008067          	ret

000112e0 <verify>:

//--------------------------------------------------------------------------
// Helper functions

int verify(int test[DATA_SIZE][DATA_SIZE], int correct[DATA_SIZE][DATA_SIZE])
{
   112e0:	fd010113          	addi	sp,sp,-48
   112e4:	02112623          	sw	ra,44(sp)
   112e8:	02812423          	sw	s0,40(sp)
   112ec:	03010413          	addi	s0,sp,48
   112f0:	fca42e23          	sw	a0,-36(s0)
   112f4:	fcb42c23          	sw	a1,-40(s0)
  int i, j;
  for ( i = 0; i < DATA_SIZE; i++ ) {
   112f8:	fe042623          	sw	zero,-20(s0)
   112fc:	0f40006f          	j	113f0 <verify+0x110>
    for ( j = 0; j < DATA_SIZE; j++ ) {
   11300:	fe042423          	sw	zero,-24(s0)
   11304:	0d40006f          	j	113d8 <verify+0xf8>
      if ( test[i][j] != correct[i][j] ) {
   11308:	fec42783          	lw	a5,-20(s0)
   1130c:	00379793          	slli	a5,a5,0x3
   11310:	00279713          	slli	a4,a5,0x2
   11314:	40f707b3          	sub	a5,a4,a5
   11318:	fdc42703          	lw	a4,-36(s0)
   1131c:	00f70733          	add	a4,a4,a5
   11320:	fe842783          	lw	a5,-24(s0)
   11324:	00279793          	slli	a5,a5,0x2
   11328:	00f707b3          	add	a5,a4,a5
   1132c:	0007a703          	lw	a4,0(a5)
   11330:	fec42783          	lw	a5,-20(s0)
   11334:	00379793          	slli	a5,a5,0x3
   11338:	00279693          	slli	a3,a5,0x2
   1133c:	40f687b3          	sub	a5,a3,a5
   11340:	fd842683          	lw	a3,-40(s0)
   11344:	00f686b3          	add	a3,a3,a5
   11348:	fe842783          	lw	a5,-24(s0)
   1134c:	00279793          	slli	a5,a5,0x2
   11350:	00f687b3          	add	a5,a3,a5
   11354:	0007a783          	lw	a5,0(a5)
   11358:	06f70a63          	beq	a4,a5,113cc <verify+0xec>
	  printf ("Verify err: i %1d j %0d test[i][j] %d correct[i][j] %d\n",
		  i, j, test[i][j], correct[i][j]);
   1135c:	fec42783          	lw	a5,-20(s0)
   11360:	00379793          	slli	a5,a5,0x3
   11364:	00279713          	slli	a4,a5,0x2
   11368:	40f707b3          	sub	a5,a4,a5
   1136c:	fdc42703          	lw	a4,-36(s0)
   11370:	00f70733          	add	a4,a4,a5
{
  int i, j;
  for ( i = 0; i < DATA_SIZE; i++ ) {
    for ( j = 0; j < DATA_SIZE; j++ ) {
      if ( test[i][j] != correct[i][j] ) {
	  printf ("Verify err: i %1d j %0d test[i][j] %d correct[i][j] %d\n",
   11374:	fe842783          	lw	a5,-24(s0)
   11378:	00279793          	slli	a5,a5,0x2
   1137c:	00f707b3          	add	a5,a4,a5
   11380:	0007a683          	lw	a3,0(a5)
		  i, j, test[i][j], correct[i][j]);
   11384:	fec42783          	lw	a5,-20(s0)
   11388:	00379793          	slli	a5,a5,0x3
   1138c:	00279713          	slli	a4,a5,0x2
   11390:	40f707b3          	sub	a5,a4,a5
   11394:	fd842703          	lw	a4,-40(s0)
   11398:	00f70733          	add	a4,a4,a5
{
  int i, j;
  for ( i = 0; i < DATA_SIZE; i++ ) {
    for ( j = 0; j < DATA_SIZE; j++ ) {
      if ( test[i][j] != correct[i][j] ) {
	  printf ("Verify err: i %1d j %0d test[i][j] %d correct[i][j] %d\n",
   1139c:	fe842783          	lw	a5,-24(s0)
   113a0:	00279793          	slli	a5,a5,0x2
   113a4:	00f707b3          	add	a5,a4,a5
   113a8:	0007a783          	lw	a5,0(a5)
   113ac:	00078713          	mv	a4,a5
   113b0:	fe842603          	lw	a2,-24(s0)
   113b4:	fec42583          	lw	a1,-20(s0)
   113b8:	0001c7b7          	lui	a5,0x1c
   113bc:	5c478513          	addi	a0,a5,1476 # 1c5c4 <__extendsfdf2+0xac>
   113c0:	579000ef          	jal	12138 <printf>
		  i, j, test[i][j], correct[i][j]);
	  return 0;
   113c4:	00000793          	li	a5,0
   113c8:	0380006f          	j	11400 <verify+0x120>

int verify(int test[DATA_SIZE][DATA_SIZE], int correct[DATA_SIZE][DATA_SIZE])
{
  int i, j;
  for ( i = 0; i < DATA_SIZE; i++ ) {
    for ( j = 0; j < DATA_SIZE; j++ ) {
   113cc:	fe842783          	lw	a5,-24(s0)
   113d0:	00178793          	addi	a5,a5,1
   113d4:	fef42423          	sw	a5,-24(s0)
   113d8:	fe842703          	lw	a4,-24(s0)
   113dc:	00500793          	li	a5,5
   113e0:	f2e7d4e3          	ble	a4,a5,11308 <verify+0x28>
// Helper functions

int verify(int test[DATA_SIZE][DATA_SIZE], int correct[DATA_SIZE][DATA_SIZE])
{
  int i, j;
  for ( i = 0; i < DATA_SIZE; i++ ) {
   113e4:	fec42783          	lw	a5,-20(s0)
   113e8:	00178793          	addi	a5,a5,1
   113ec:	fef42623          	sw	a5,-20(s0)
   113f0:	fec42703          	lw	a4,-20(s0)
   113f4:	00500793          	li	a5,5
   113f8:	f0e7d4e3          	ble	a4,a5,11300 <verify+0x20>
		  i, j, test[i][j], correct[i][j]);
	  return 0;
      }
    }
  }
  return 1;
   113fc:	00100793          	li	a5,1
}
   11400:	00078513          	mv	a0,a5
   11404:	02c12083          	lw	ra,44(sp)
   11408:	02812403          	lw	s0,40(sp)
   1140c:	03010113          	addi	sp,sp,48
   11410:	00008067          	ret

00011414 <main>:

//--------------------------------------------------------------------------
// Main

int main( int argc, char* argv[] )
{
   11414:	e2010113          	addi	sp,sp,-480
   11418:	1c112e23          	sw	ra,476(sp)
   1141c:	1c812c23          	sw	s0,472(sp)
   11420:	1e010413          	addi	s0,sp,480
   11424:	e2a42623          	sw	a0,-468(s0)
   11428:	e2b42423          	sw	a1,-472(s0)
  int resr, resg, resb;
  int results_data_r[DATA_SIZE][DATA_SIZE];
  int results_data_g[DATA_SIZE][DATA_SIZE];
  int results_data_b[DATA_SIZE][DATA_SIZE];

  for (i = 0; i < DATA_SIZE; i++)
   1142c:	fe042623          	sw	zero,-20(s0)
   11430:	0380006f          	j	11468 <main+0x54>
  {
    sharpen( input_data_r, input_data_g, input_data_b,
   11434:	e3040793          	addi	a5,s0,-464
   11438:	ec040713          	addi	a4,s0,-320
   1143c:	f5040693          	addi	a3,s0,-176
   11440:	0001e637          	lui	a2,0x1e
   11444:	1d060613          	addi	a2,a2,464 # 1e1d0 <input_data_b>
   11448:	0001e5b7          	lui	a1,0x1e
   1144c:	14058593          	addi	a1,a1,320 # 1e140 <input_data_g>
   11450:	0001e537          	lui	a0,0x1e
   11454:	0b050513          	addi	a0,a0,176 # 1e0b0 <_fdata>
   11458:	8b9ff0ef          	jal	10d10 <sharpen>
  int resr, resg, resb;
  int results_data_r[DATA_SIZE][DATA_SIZE];
  int results_data_g[DATA_SIZE][DATA_SIZE];
  int results_data_b[DATA_SIZE][DATA_SIZE];

  for (i = 0; i < DATA_SIZE; i++)
   1145c:	fec42783          	lw	a5,-20(s0)
   11460:	00178793          	addi	a5,a5,1
   11464:	fef42623          	sw	a5,-20(s0)
   11468:	fec42703          	lw	a4,-20(s0)
   1146c:	00500793          	li	a5,5
   11470:	fce7d2e3          	ble	a4,a5,11434 <main+0x20>
                results_data_r, results_data_g, results_data_b);
  }

  // Check the results

  resr = verify(results_data_r, verify_data_r);
   11474:	f5040713          	addi	a4,s0,-176
   11478:	0001e7b7          	lui	a5,0x1e
   1147c:	26078593          	addi	a1,a5,608 # 1e260 <verify_data_r>
   11480:	00070513          	mv	a0,a4
   11484:	e5dff0ef          	jal	112e0 <verify>
   11488:	fea42423          	sw	a0,-24(s0)
  resg = verify(results_data_g, verify_data_g);
   1148c:	ec040713          	addi	a4,s0,-320
   11490:	0001e7b7          	lui	a5,0x1e
   11494:	2f078593          	addi	a1,a5,752 # 1e2f0 <verify_data_g>
   11498:	00070513          	mv	a0,a4
   1149c:	e45ff0ef          	jal	112e0 <verify>
   114a0:	fea42223          	sw	a0,-28(s0)
  resb = verify(results_data_b, verify_data_b);
   114a4:	e3040713          	addi	a4,s0,-464
   114a8:	0001e7b7          	lui	a5,0x1e
   114ac:	38078593          	addi	a1,a5,896 # 1e380 <verify_data_b>
   114b0:	00070513          	mv	a0,a4
   114b4:	e2dff0ef          	jal	112e0 <verify>
   114b8:	fea42023          	sw	a0,-32(s0)

  // Check the results

  if (resr)
   114bc:	fe842783          	lw	a5,-24(s0)
   114c0:	00078a63          	beqz	a5,114d4 <main+0xc0>
      printf ("Verify resr = ok\n");
   114c4:	0001c7b7          	lui	a5,0x1c
   114c8:	5fc78513          	addi	a0,a5,1532 # 1c5fc <__extendsfdf2+0xe4>
   114cc:	56d000ef          	jal	12238 <puts>
   114d0:	0100006f          	j	114e0 <main+0xcc>
  else
      printf ("Verify resr = not ok\n");
   114d4:	0001c7b7          	lui	a5,0x1c
   114d8:	61078513          	addi	a0,a5,1552 # 1c610 <__extendsfdf2+0xf8>
   114dc:	55d000ef          	jal	12238 <puts>
  if (resg)
   114e0:	fe442783          	lw	a5,-28(s0)
   114e4:	00078a63          	beqz	a5,114f8 <main+0xe4>
      printf ("Verify resg = ok\n");
   114e8:	0001c7b7          	lui	a5,0x1c
   114ec:	62878513          	addi	a0,a5,1576 # 1c628 <__extendsfdf2+0x110>
   114f0:	549000ef          	jal	12238 <puts>
   114f4:	0100006f          	j	11504 <main+0xf0>
  else
      printf ("Verify resg = not ok\n");
   114f8:	0001c7b7          	lui	a5,0x1c
   114fc:	63c78513          	addi	a0,a5,1596 # 1c63c <__extendsfdf2+0x124>
   11500:	539000ef          	jal	12238 <puts>
  if (resb)
   11504:	fe042783          	lw	a5,-32(s0)
   11508:	00078a63          	beqz	a5,1151c <main+0x108>
      printf ("Verify resb = ok\n");
   1150c:	0001c7b7          	lui	a5,0x1c
   11510:	65478513          	addi	a0,a5,1620 # 1c654 <__extendsfdf2+0x13c>
   11514:	525000ef          	jal	12238 <puts>
   11518:	0100006f          	j	11528 <main+0x114>
  else
      printf ("Verify resb = not ok\n");
   1151c:	0001c7b7          	lui	a5,0x1c
   11520:	66878513          	addi	a0,a5,1640 # 1c668 <__extendsfdf2+0x150>
   11524:	515000ef          	jal	12238 <puts>

  return (resr && resg && resb);
   11528:	fe842783          	lw	a5,-24(s0)
   1152c:	00078e63          	beqz	a5,11548 <main+0x134>
   11530:	fe442783          	lw	a5,-28(s0)
   11534:	00078a63          	beqz	a5,11548 <main+0x134>
   11538:	fe042783          	lw	a5,-32(s0)
   1153c:	00078663          	beqz	a5,11548 <main+0x134>
   11540:	00100793          	li	a5,1
   11544:	0080006f          	j	1154c <main+0x138>
   11548:	00000793          	li	a5,0
}
   1154c:	00078513          	mv	a0,a5
   11550:	1dc12083          	lw	ra,476(sp)
   11554:	1d812403          	lw	s0,472(sp)
   11558:	1e010113          	addi	sp,sp,480
   1155c:	00008067          	ret

00011560 <__divdi3>:
  Wtype c = 0;
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
   11560:	2605ce63          	bltz	a1,117dc <__divdi3+0x27c>
   11564:	00050313          	mv	t1,a0
   11568:	00058793          	mv	a5,a1

#ifdef L_divdi3
DWtype
__divdi3 (DWtype u, DWtype v)
{
  Wtype c = 0;
   1156c:	00000893          	li	a7,0
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
   11570:	2406ca63          	bltz	a3,117c4 <__divdi3+0x264>
  DWunion rr;
  UWtype d0, d1, n0, n1, n2;
  UWtype q0, q1;
  UWtype b, bm;

  d0 = dd.s.low;
   11574:	00060293          	mv	t0,a2
  d1 = dd.s.high;
  n0 = nn.s.low;
   11578:	00030393          	mv	t2,t1
  n1 = nn.s.high;
   1157c:	00078593          	mv	a1,a5
	}
    }

#else /* UDIV_NEEDS_NORMALIZATION */

  if (d1 == 0)
   11580:	0e069e63          	bnez	a3,1167c <__divdi3+0x11c>
    {
      if (d0 > n1)
   11584:	16c7f263          	bleu	a2,a5,116e8 <__divdi3+0x188>
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   11588:	00010737          	lui	a4,0x10
   1158c:	26e66c63          	bltu	a2,a4,11804 <__divdi3+0x2a4>
   11590:	01000737          	lui	a4,0x1000
   11594:	00e63733          	sltu	a4,a2,a4
   11598:	00174713          	xori	a4,a4,1
   1159c:	40e00733          	neg	a4,a4
   115a0:	00877713          	andi	a4,a4,8
   115a4:	01070713          	addi	a4,a4,16 # 1000010 <_gp+0xfe0b40>
   115a8:	0001c6b7          	lui	a3,0x1c
   115ac:	00e65533          	srl	a0,a2,a4
   115b0:	68068693          	addi	a3,a3,1664 # 1c680 <__clz_tab>
   115b4:	00d506b3          	add	a3,a0,a3
   115b8:	0006c683          	lbu	a3,0(a3)
   115bc:	00e68733          	add	a4,a3,a4
   115c0:	02000693          	li	a3,32
   115c4:	40e686b3          	sub	a3,a3,a4

	  if (bm != 0)
   115c8:	00068c63          	beqz	a3,115e0 <__divdi3+0x80>
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   115cc:	00d797b3          	sll	a5,a5,a3
   115d0:	00e35733          	srl	a4,t1,a4
	  if (bm != 0)
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
   115d4:	00d612b3          	sll	t0,a2,a3
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   115d8:	00f765b3          	or	a1,a4,a5
	      n0 = n0 << bm;
   115dc:	00d313b3          	sll	t2,t1,a3
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   115e0:	0102d613          	srli	a2,t0,0x10
   115e4:	02c5d533          	divu	a0,a1,a2
   115e8:	01029693          	slli	a3,t0,0x10
   115ec:	0106d693          	srli	a3,a3,0x10
   115f0:	0103d713          	srli	a4,t2,0x10
   115f4:	02c5f7b3          	remu	a5,a1,a2
   115f8:	02a68833          	mul	a6,a3,a0
   115fc:	01079793          	slli	a5,a5,0x10
   11600:	00f765b3          	or	a1,a4,a5
   11604:	0105fc63          	bleu	a6,a1,1161c <__divdi3+0xbc>
   11608:	005585b3          	add	a1,a1,t0
   1160c:	fff50793          	addi	a5,a0,-1
   11610:	0055e463          	bltu	a1,t0,11618 <__divdi3+0xb8>
   11614:	4105e263          	bltu	a1,a6,11a18 <__divdi3+0x4b8>
   11618:	00078513          	mv	a0,a5
   1161c:	410585b3          	sub	a1,a1,a6
   11620:	02c5d7b3          	divu	a5,a1,a2
   11624:	01039393          	slli	t2,t2,0x10
   11628:	0103d393          	srli	t2,t2,0x10
   1162c:	02c5f5b3          	remu	a1,a1,a2
   11630:	02f686b3          	mul	a3,a3,a5
   11634:	01059593          	slli	a1,a1,0x10
   11638:	00b3e5b3          	or	a1,t2,a1
   1163c:	00d5fe63          	bleu	a3,a1,11658 <__divdi3+0xf8>
   11640:	00b285b3          	add	a1,t0,a1
   11644:	fff78713          	addi	a4,a5,-1
   11648:	0055e663          	bltu	a1,t0,11654 <__divdi3+0xf4>
   1164c:	ffe78793          	addi	a5,a5,-2
   11650:	00d5e463          	bltu	a1,a3,11658 <__divdi3+0xf8>
   11654:	00070793          	mv	a5,a4
   11658:	01051513          	slli	a0,a0,0x10
   1165c:	00f56533          	or	a0,a0,a5
   11660:	00000593          	li	a1,0
  if (vv.s.high < 0)
    c = ~c,
    vv.ll = -vv.ll;

  w = __udivmoddi4 (uu.ll, vv.ll, (UDWtype *) 0);
  if (c)
   11664:	00088a63          	beqz	a7,11678 <__divdi3+0x118>
    w = -w;
   11668:	40a00533          	neg	a0,a0
   1166c:	00a037b3          	snez	a5,a0
   11670:	40b005b3          	neg	a1,a1
   11674:	40f585b3          	sub	a1,a1,a5

  return w;
}
   11678:	00008067          	ret
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
   1167c:	00d7f863          	bleu	a3,a5,1168c <__divdi3+0x12c>
   11680:	00000593          	li	a1,0
   11684:	00000513          	li	a0,0
   11688:	fddff06f          	j	11664 <__divdi3+0x104>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   1168c:	00010737          	lui	a4,0x10
   11690:	18e6e263          	bltu	a3,a4,11814 <__divdi3+0x2b4>
   11694:	01000737          	lui	a4,0x1000
   11698:	00e6b733          	sltu	a4,a3,a4
   1169c:	00174713          	xori	a4,a4,1
   116a0:	40e00733          	neg	a4,a4
   116a4:	00877713          	andi	a4,a4,8
   116a8:	01070713          	addi	a4,a4,16 # 1000010 <_gp+0xfe0b40>
   116ac:	0001c5b7          	lui	a1,0x1c
   116b0:	00e6d533          	srl	a0,a3,a4
   116b4:	68058593          	addi	a1,a1,1664 # 1c680 <__clz_tab>
   116b8:	00b505b3          	add	a1,a0,a1
   116bc:	0005c803          	lbu	a6,0(a1)
   116c0:	02000293          	li	t0,32
   116c4:	00e80833          	add	a6,a6,a4
   116c8:	410282b3          	sub	t0,t0,a6
	  if (bm == 0)
   116cc:	14029c63          	bnez	t0,11824 <__divdi3+0x2c4>

		 This special case is necessary, not an optimization.  */

	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
   116d0:	00000593          	li	a1,0
   116d4:	00100513          	li	a0,1
   116d8:	f8f6e6e3          	bltu	a3,a5,11664 <__divdi3+0x104>
   116dc:	00c33533          	sltu	a0,t1,a2
   116e0:	00154513          	xori	a0,a0,1
   116e4:	f81ff06f          	j	11664 <__divdi3+0x104>
	}
      else
	{
	  /* qq = NN / 0d */

	  if (d0 == 0)
   116e8:	00061663          	bnez	a2,116f4 <__divdi3+0x194>
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
   116ec:	00100293          	li	t0,1
   116f0:	02d2d2b3          	divu	t0,t0,a3

	  count_leading_zeros (bm, d0);
   116f4:	00010737          	lui	a4,0x10
   116f8:	0ee2ee63          	bltu	t0,a4,117f4 <__divdi3+0x294>
   116fc:	01000737          	lui	a4,0x1000
   11700:	00e2b733          	sltu	a4,t0,a4
   11704:	00174713          	xori	a4,a4,1
   11708:	40e00733          	neg	a4,a4
   1170c:	00877713          	andi	a4,a4,8
   11710:	01070713          	addi	a4,a4,16 # 1000010 <_gp+0xfe0b40>
   11714:	0001c6b7          	lui	a3,0x1c
   11718:	00e2d633          	srl	a2,t0,a4
   1171c:	68068693          	addi	a3,a3,1664 # 1c680 <__clz_tab>
   11720:	00d606b3          	add	a3,a2,a3
   11724:	0006c503          	lbu	a0,0(a3)
   11728:	02000e13          	li	t3,32
   1172c:	00e50533          	add	a0,a0,a4
   11730:	40ae0e33          	sub	t3,t3,a0

	  if (bm == 0)
   11734:	1e0e1663          	bnez	t3,11920 <__divdi3+0x3c0>
   11738:	01029813          	slli	a6,t0,0x10
		 leading quotient digit q1 = 1).

		 This special case is necessary, not an optimization.
		 (Shifts counts of W_TYPE_SIZE are undefined.)  */

	      n1 -= d0;
   1173c:	405786b3          	sub	a3,a5,t0
   11740:	0102d613          	srli	a2,t0,0x10
   11744:	01085813          	srli	a6,a6,0x10
   11748:	00100593          	li	a1,1
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   1174c:	0103d793          	srli	a5,t2,0x10
   11750:	02c6d533          	divu	a0,a3,a2
   11754:	02c6f6b3          	remu	a3,a3,a2
   11758:	03050733          	mul	a4,a0,a6
   1175c:	01069693          	slli	a3,a3,0x10
   11760:	00d7e7b3          	or	a5,a5,a3
   11764:	00e7fc63          	bleu	a4,a5,1177c <__divdi3+0x21c>
   11768:	005787b3          	add	a5,a5,t0
   1176c:	fff50693          	addi	a3,a0,-1
   11770:	0057e463          	bltu	a5,t0,11778 <__divdi3+0x218>
   11774:	2ae7e863          	bltu	a5,a4,11a24 <__divdi3+0x4c4>
   11778:	00068513          	mv	a0,a3
   1177c:	40e78733          	sub	a4,a5,a4
   11780:	02c757b3          	divu	a5,a4,a2
   11784:	01039393          	slli	t2,t2,0x10
   11788:	0103d393          	srli	t2,t2,0x10
   1178c:	02c77733          	remu	a4,a4,a2
   11790:	03078833          	mul	a6,a5,a6
   11794:	01071713          	slli	a4,a4,0x10
   11798:	00e3e733          	or	a4,t2,a4
   1179c:	01077e63          	bleu	a6,a4,117b8 <__divdi3+0x258>
   117a0:	00e28733          	add	a4,t0,a4
   117a4:	fff78693          	addi	a3,a5,-1
   117a8:	00576663          	bltu	a4,t0,117b4 <__divdi3+0x254>
   117ac:	ffe78793          	addi	a5,a5,-2
   117b0:	01076463          	bltu	a4,a6,117b8 <__divdi3+0x258>
   117b4:	00068793          	mv	a5,a3
   117b8:	01051513          	slli	a0,a0,0x10
   117bc:	00f56533          	or	a0,a0,a5
   117c0:	ea5ff06f          	j	11664 <__divdi3+0x104>
  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    c = ~c,
    vv.ll = -vv.ll;
   117c4:	40c00633          	neg	a2,a2
   117c8:	00c03733          	snez	a4,a2
   117cc:	40d006b3          	neg	a3,a3

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    c = ~c,
   117d0:	fff8c893          	not	a7,a7
    vv.ll = -vv.ll;
   117d4:	40e686b3          	sub	a3,a3,a4
   117d8:	d9dff06f          	j	11574 <__divdi3+0x14>
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
   117dc:	40a00333          	neg	t1,a0
   117e0:	00603733          	snez	a4,t1
   117e4:	40b007b3          	neg	a5,a1
   117e8:	40e787b3          	sub	a5,a5,a4
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
   117ec:	fff00893          	li	a7,-1
   117f0:	d81ff06f          	j	11570 <__divdi3+0x10>
	  /* qq = NN / 0d */

	  if (d0 == 0)
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */

	  count_leading_zeros (bm, d0);
   117f4:	0ff00713          	li	a4,255
   117f8:	00573733          	sltu	a4,a4,t0
   117fc:	00371713          	slli	a4,a4,0x3
   11800:	f15ff06f          	j	11714 <__divdi3+0x1b4>
    {
      if (d0 > n1)
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   11804:	0ff00713          	li	a4,255
   11808:	00c73733          	sltu	a4,a4,a2
   1180c:	00371713          	slli	a4,a4,0x3
   11810:	d99ff06f          	j	115a8 <__divdi3+0x48>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   11814:	0ff00713          	li	a4,255
   11818:	00d73733          	sltu	a4,a4,a3
   1181c:	00371713          	slli	a4,a4,0x3
   11820:	e8dff06f          	j	116ac <__divdi3+0x14c>
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
   11824:	01065733          	srl	a4,a2,a6
   11828:	005696b3          	sll	a3,a3,t0
   1182c:	00e6e6b3          	or	a3,a3,a4
	      d0 = d0 << bm;
	      n2 = n1 >> b;
   11830:	0107d5b3          	srl	a1,a5,a6
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11834:	0106de93          	srli	t4,a3,0x10
   11838:	03d5de33          	divu	t3,a1,t4
   1183c:	01069393          	slli	t2,a3,0x10
   11840:	0103d393          	srli	t2,t2,0x10
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   11844:	005797b3          	sll	a5,a5,t0
   11848:	01035833          	srl	a6,t1,a6
   1184c:	00f867b3          	or	a5,a6,a5
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11850:	0107d713          	srli	a4,a5,0x10
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
   11854:	00561633          	sll	a2,a2,t0
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11858:	03d5f5b3          	remu	a1,a1,t4
   1185c:	03c38533          	mul	a0,t2,t3
   11860:	01059593          	slli	a1,a1,0x10
   11864:	00b76733          	or	a4,a4,a1
   11868:	00a77e63          	bleu	a0,a4,11884 <__divdi3+0x324>
   1186c:	00d70733          	add	a4,a4,a3
   11870:	fffe0593          	addi	a1,t3,-1
   11874:	18d76e63          	bltu	a4,a3,11a10 <__divdi3+0x4b0>
   11878:	18a77c63          	bleu	a0,a4,11a10 <__divdi3+0x4b0>
   1187c:	ffee0e13          	addi	t3,t3,-2
   11880:	00d70733          	add	a4,a4,a3
   11884:	40a70733          	sub	a4,a4,a0
   11888:	03d75833          	divu	a6,a4,t4
   1188c:	01079793          	slli	a5,a5,0x10
   11890:	0107d793          	srli	a5,a5,0x10
   11894:	03d77733          	remu	a4,a4,t4
   11898:	030385b3          	mul	a1,t2,a6
   1189c:	01071713          	slli	a4,a4,0x10
   118a0:	00e7e7b3          	or	a5,a5,a4
   118a4:	00b7fe63          	bleu	a1,a5,118c0 <__divdi3+0x360>
   118a8:	00d787b3          	add	a5,a5,a3
   118ac:	fff80713          	addi	a4,a6,-1
   118b0:	14d7e863          	bltu	a5,a3,11a00 <__divdi3+0x4a0>
   118b4:	14b7f663          	bleu	a1,a5,11a00 <__divdi3+0x4a0>
   118b8:	ffe80813          	addi	a6,a6,-2
   118bc:	00d787b3          	add	a5,a5,a3
   118c0:	010e1e13          	slli	t3,t3,0x10
	      umul_ppmm (m1, m0, q0, d0);
   118c4:	000103b7          	lui	t2,0x10
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   118c8:	010e6533          	or	a0,t3,a6
	      umul_ppmm (m1, m0, q0, d0);
   118cc:	fff38713          	addi	a4,t2,-1 # ffff <_reset+0xfdff>
   118d0:	00e576b3          	and	a3,a0,a4
   118d4:	01055813          	srli	a6,a0,0x10
   118d8:	00e67733          	and	a4,a2,a4
   118dc:	01065613          	srli	a2,a2,0x10
   118e0:	02e68e33          	mul	t3,a3,a4
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   118e4:	40b787b3          	sub	a5,a5,a1
   118e8:	02c686b3          	mul	a3,a3,a2
	      umul_ppmm (m1, m0, q0, d0);
   118ec:	010e5593          	srli	a1,t3,0x10
   118f0:	02e80733          	mul	a4,a6,a4
   118f4:	00e686b3          	add	a3,a3,a4
   118f8:	00d586b3          	add	a3,a1,a3
   118fc:	02c80633          	mul	a2,a6,a2
   11900:	00e6f463          	bleu	a4,a3,11908 <__divdi3+0x3a8>
   11904:	00760633          	add	a2,a2,t2
   11908:	0106d813          	srli	a6,a3,0x10
   1190c:	00c80633          	add	a2,a6,a2

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   11910:	0cc7ee63          	bltu	a5,a2,119ec <__divdi3+0x48c>
   11914:	0ac78c63          	beq	a5,a2,119cc <__divdi3+0x46c>
		{
		  q0--;
   11918:	00000593          	li	a1,0
   1191c:	d49ff06f          	j	11664 <__divdi3+0x104>
	    {
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
   11920:	01c292b3          	sll	t0,t0,t3
	      n2 = n1 >> b;
   11924:	00a7d833          	srl	a6,a5,a0
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11928:	0102d713          	srli	a4,t0,0x10
   1192c:	02e85eb3          	divu	t4,a6,a4
   11930:	01029f13          	slli	t5,t0,0x10

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   11934:	01c796b3          	sll	a3,a5,t3
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11938:	010f5f13          	srli	t5,t5,0x10

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   1193c:	00a35533          	srl	a0,t1,a0
   11940:	00d56533          	or	a0,a0,a3
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11944:	01055613          	srli	a2,a0,0x10
	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;
   11948:	01c313b3          	sll	t2,t1,t3

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   1194c:	02e87833          	remu	a6,a6,a4
   11950:	03df06b3          	mul	a3,t5,t4
   11954:	01081813          	slli	a6,a6,0x10
   11958:	01066633          	or	a2,a2,a6
   1195c:	00d67e63          	bleu	a3,a2,11978 <__divdi3+0x418>
   11960:	00560633          	add	a2,a2,t0
   11964:	fffe8793          	addi	a5,t4,-1
   11968:	0a566063          	bltu	a2,t0,11a08 <__divdi3+0x4a8>
   1196c:	08d67e63          	bleu	a3,a2,11a08 <__divdi3+0x4a8>
   11970:	ffee8e93          	addi	t4,t4,-2
   11974:	00560633          	add	a2,a2,t0
   11978:	40d60633          	sub	a2,a2,a3
   1197c:	02e655b3          	divu	a1,a2,a4
   11980:	01051513          	slli	a0,a0,0x10
   11984:	01055513          	srli	a0,a0,0x10
   11988:	02e67633          	remu	a2,a2,a4
   1198c:	02bf07b3          	mul	a5,t5,a1
   11990:	01061613          	slli	a2,a2,0x10
   11994:	00c566b3          	or	a3,a0,a2
   11998:	00f6fe63          	bleu	a5,a3,119b4 <__divdi3+0x454>
   1199c:	005686b3          	add	a3,a3,t0
   119a0:	fff58613          	addi	a2,a1,-1
   119a4:	0456ea63          	bltu	a3,t0,119f8 <__divdi3+0x498>
   119a8:	04f6f863          	bleu	a5,a3,119f8 <__divdi3+0x498>
   119ac:	ffe58593          	addi	a1,a1,-2
   119b0:	005686b3          	add	a3,a3,t0
   119b4:	010e9e93          	slli	t4,t4,0x10
   119b8:	40f686b3          	sub	a3,a3,a5
   119bc:	00bee5b3          	or	a1,t4,a1
   119c0:	000f0813          	mv	a6,t5
   119c4:	00070613          	mv	a2,a4
   119c8:	d85ff06f          	j	1174c <__divdi3+0x1ec>
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   119cc:	000107b7          	lui	a5,0x10
   119d0:	fff78793          	addi	a5,a5,-1 # ffff <_reset+0xfdff>
   119d4:	00f6f6b3          	and	a3,a3,a5
   119d8:	01069693          	slli	a3,a3,0x10
   119dc:	00fe77b3          	and	a5,t3,a5
   119e0:	00531333          	sll	t1,t1,t0
   119e4:	00f687b3          	add	a5,a3,a5
   119e8:	f2f378e3          	bleu	a5,t1,11918 <__divdi3+0x3b8>
   119ec:	fff50513          	addi	a0,a0,-1
		{
		  q0--;
   119f0:	00000593          	li	a1,0
   119f4:	c71ff06f          	j	11664 <__divdi3+0x104>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   119f8:	00060593          	mv	a1,a2
   119fc:	fb9ff06f          	j	119b4 <__divdi3+0x454>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11a00:	00070813          	mv	a6,a4
   11a04:	ebdff06f          	j	118c0 <__divdi3+0x360>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11a08:	00078e93          	mv	t4,a5
   11a0c:	f6dff06f          	j	11978 <__divdi3+0x418>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11a10:	00058e13          	mv	t3,a1
   11a14:	e71ff06f          	j	11884 <__divdi3+0x324>
	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
	      n0 = n0 << bm;
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11a18:	ffe50513          	addi	a0,a0,-2
   11a1c:	005585b3          	add	a1,a1,t0
   11a20:	bfdff06f          	j	1161c <__divdi3+0xbc>
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11a24:	ffe50513          	addi	a0,a0,-2
   11a28:	005787b3          	add	a5,a5,t0
   11a2c:	d51ff06f          	j	1177c <__divdi3+0x21c>

00011a30 <__moddi3>:

#ifdef L_moddi3
DWtype
__moddi3 (DWtype u, DWtype v)
{
  Wtype c = 0;
   11a30:	00000813          	li	a6,0
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
   11a34:	1605c863          	bltz	a1,11ba4 <__moddi3+0x174>
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
   11a38:	1806c263          	bltz	a3,11bbc <__moddi3+0x18c>
  DWunion rr;
  UWtype d0, d1, n0, n1, n2;
  UWtype q0, q1;
  UWtype b, bm;

  d0 = dd.s.low;
   11a3c:	00060893          	mv	a7,a2
  d1 = dd.s.high;
  n0 = nn.s.low;
   11a40:	00050313          	mv	t1,a0
  n1 = nn.s.high;
   11a44:	00058393          	mv	t2,a1
	}
    }

#else /* UDIV_NEEDS_NORMALIZATION */

  if (d1 == 0)
   11a48:	0e069663          	bnez	a3,11b34 <__moddi3+0x104>
    {
      if (d0 > n1)
   11a4c:	18c5f263          	bleu	a2,a1,11bd0 <__moddi3+0x1a0>
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   11a50:	000107b7          	lui	a5,0x10
   11a54:	24f66063          	bltu	a2,a5,11c94 <__moddi3+0x264>
   11a58:	010002b7          	lui	t0,0x1000
   11a5c:	005632b3          	sltu	t0,a2,t0
   11a60:	0012c293          	xori	t0,t0,1
   11a64:	405002b3          	neg	t0,t0
   11a68:	0082f293          	andi	t0,t0,8
   11a6c:	01028293          	addi	t0,t0,16 # 1000010 <_gp+0xfe0b40>
   11a70:	0001c7b7          	lui	a5,0x1c
   11a74:	00565733          	srl	a4,a2,t0
   11a78:	68078793          	addi	a5,a5,1664 # 1c680 <__clz_tab>
   11a7c:	00f707b3          	add	a5,a4,a5
   11a80:	0007c783          	lbu	a5,0(a5)
   11a84:	005787b3          	add	a5,a5,t0
   11a88:	02000293          	li	t0,32
   11a8c:	40f282b3          	sub	t0,t0,a5

	  if (bm != 0)
   11a90:	00028c63          	beqz	t0,11aa8 <__moddi3+0x78>
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   11a94:	005595b3          	sll	a1,a1,t0
   11a98:	00f557b3          	srl	a5,a0,a5
	  if (bm != 0)
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
   11a9c:	005618b3          	sll	a7,a2,t0
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   11aa0:	00b7e3b3          	or	t2,a5,a1
	      n0 = n0 << bm;
   11aa4:	00551333          	sll	t1,a0,t0
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11aa8:	0108de13          	srli	t3,a7,0x10
   11aac:	03c3d633          	divu	a2,t2,t3
   11ab0:	01089693          	slli	a3,a7,0x10
   11ab4:	0106d693          	srli	a3,a3,0x10
   11ab8:	01035713          	srli	a4,t1,0x10
   11abc:	03c3f5b3          	remu	a1,t2,t3
   11ac0:	02c68633          	mul	a2,a3,a2
   11ac4:	01059593          	slli	a1,a1,0x10
   11ac8:	00b76733          	or	a4,a4,a1
   11acc:	00c77863          	bleu	a2,a4,11adc <__moddi3+0xac>
   11ad0:	01170733          	add	a4,a4,a7
   11ad4:	01176463          	bltu	a4,a7,11adc <__moddi3+0xac>
   11ad8:	3cc76863          	bltu	a4,a2,11ea8 <__moddi3+0x478>
   11adc:	40c70733          	sub	a4,a4,a2
   11ae0:	03c757b3          	divu	a5,a4,t3
   11ae4:	01031313          	slli	t1,t1,0x10
   11ae8:	01035313          	srli	t1,t1,0x10
   11aec:	03c77733          	remu	a4,a4,t3
   11af0:	02f68533          	mul	a0,a3,a5
   11af4:	01071713          	slli	a4,a4,0x10
   11af8:	00e367b3          	or	a5,t1,a4
   11afc:	00a7fa63          	bleu	a0,a5,11b10 <__moddi3+0xe0>
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11b00:	011787b3          	add	a5,a5,a7
   11b04:	0117e663          	bltu	a5,a7,11b10 <__moddi3+0xe0>
   11b08:	00a7f463          	bleu	a0,a5,11b10 <__moddi3+0xe0>
   11b0c:	011787b3          	add	a5,a5,a7
   11b10:	40a787b3          	sub	a5,a5,a0
	  /* Remainder in n0 >> bm.  */
	}

      if (rp != 0)
	{
	  rr.s.low = n0 >> bm;
   11b14:	0057d533          	srl	a0,a5,t0
	  rr.s.high = 0;
	  *rp = rr.ll;
   11b18:	00000593          	li	a1,0
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    vv.ll = -vv.ll;

  (void) __udivmoddi4 (uu.ll, vv.ll, (UDWtype*)&w);
  if (c)
   11b1c:	00080a63          	beqz	a6,11b30 <__moddi3+0x100>
    w = -w;
   11b20:	40a00533          	neg	a0,a0
   11b24:	00a037b3          	snez	a5,a0
   11b28:	40b005b3          	neg	a1,a1
   11b2c:	40f585b3          	sub	a1,a1,a5

  return w;
}
   11b30:	00008067          	ret
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
   11b34:	fed5e4e3          	bltu	a1,a3,11b1c <__moddi3+0xec>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   11b38:	000107b7          	lui	a5,0x10
   11b3c:	16f6e463          	bltu	a3,a5,11ca4 <__moddi3+0x274>
   11b40:	010008b7          	lui	a7,0x1000
   11b44:	0116b8b3          	sltu	a7,a3,a7
   11b48:	0018c893          	xori	a7,a7,1
   11b4c:	411008b3          	neg	a7,a7
   11b50:	0088f893          	andi	a7,a7,8
   11b54:	01088893          	addi	a7,a7,16 # 1000010 <_gp+0xfe0b40>
   11b58:	0001c7b7          	lui	a5,0x1c
   11b5c:	0116d733          	srl	a4,a3,a7
   11b60:	68078793          	addi	a5,a5,1664 # 1c680 <__clz_tab>
   11b64:	00f707b3          	add	a5,a4,a5
   11b68:	0007ce83          	lbu	t4,0(a5)
   11b6c:	02000e13          	li	t3,32
   11b70:	011e8eb3          	add	t4,t4,a7
   11b74:	41de0e33          	sub	t3,t3,t4
	  if (bm == 0)
   11b78:	1c0e1863          	bnez	t3,11d48 <__moddi3+0x318>

		 This special case is necessary, not an optimization.  */

	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
   11b7c:	00b6e663          	bltu	a3,a1,11b88 <__moddi3+0x158>
   11b80:	00050793          	mv	a5,a0
   11b84:	00c56a63          	bltu	a0,a2,11b98 <__moddi3+0x168>
		{
		  q0 = 1;
		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
   11b88:	40c507b3          	sub	a5,a0,a2
   11b8c:	40d585b3          	sub	a1,a1,a3
   11b90:	00f53533          	sltu	a0,a0,a5
   11b94:	40a583b3          	sub	t2,a1,a0

	      if (rp != 0)
		{
		  rr.s.low = n0;
		  rr.s.high = n1;
		  *rp = rr.ll;
   11b98:	00078513          	mv	a0,a5
   11b9c:	00038593          	mv	a1,t2
   11ba0:	f7dff06f          	j	11b1c <__moddi3+0xec>
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
   11ba4:	40a00533          	neg	a0,a0
   11ba8:	00a037b3          	snez	a5,a0
   11bac:	40b00733          	neg	a4,a1
   11bb0:	40f705b3          	sub	a1,a4,a5
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
   11bb4:	fff00813          	li	a6,-1
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
   11bb8:	e806d2e3          	bgez	a3,11a3c <__moddi3+0xc>
    vv.ll = -vv.ll;
   11bbc:	40c00633          	neg	a2,a2
   11bc0:	00c037b3          	snez	a5,a2
   11bc4:	40d006b3          	neg	a3,a3
   11bc8:	40f686b3          	sub	a3,a3,a5
   11bcc:	e71ff06f          	j	11a3c <__moddi3+0xc>
	}
      else
	{
	  /* qq = NN / 0d */

	  if (d0 == 0)
   11bd0:	00061663          	bnez	a2,11bdc <__moddi3+0x1ac>
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
   11bd4:	00100893          	li	a7,1
   11bd8:	02d8d8b3          	divu	a7,a7,a3

	  count_leading_zeros (bm, d0);
   11bdc:	000107b7          	lui	a5,0x10
   11be0:	0af8e263          	bltu	a7,a5,11c84 <__moddi3+0x254>
   11be4:	010007b7          	lui	a5,0x1000
   11be8:	00f8b7b3          	sltu	a5,a7,a5
   11bec:	0017c793          	xori	a5,a5,1
   11bf0:	40f007b3          	neg	a5,a5
   11bf4:	0087f793          	andi	a5,a5,8
   11bf8:	01078793          	addi	a5,a5,16 # 1000010 <_gp+0xfe0b40>
   11bfc:	0001c737          	lui	a4,0x1c
   11c00:	00f8d6b3          	srl	a3,a7,a5
   11c04:	68070713          	addi	a4,a4,1664 # 1c680 <__clz_tab>
   11c08:	00e68733          	add	a4,a3,a4
   11c0c:	00074703          	lbu	a4,0(a4)
   11c10:	02000293          	li	t0,32
   11c14:	00f707b3          	add	a5,a4,a5
   11c18:	40f282b3          	sub	t0,t0,a5

	  if (bm == 0)
   11c1c:	08029c63          	bnez	t0,11cb4 <__moddi3+0x284>
   11c20:	01089793          	slli	a5,a7,0x10
		 leading quotient digit q1 = 1).

		 This special case is necessary, not an optimization.
		 (Shifts counts of W_TYPE_SIZE are undefined.)  */

	      n1 -= d0;
   11c24:	411585b3          	sub	a1,a1,a7
   11c28:	0108d693          	srli	a3,a7,0x10
   11c2c:	0107d793          	srli	a5,a5,0x10
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11c30:	01035713          	srli	a4,t1,0x10
   11c34:	02d5d633          	divu	a2,a1,a3
   11c38:	02d5f5b3          	remu	a1,a1,a3
   11c3c:	02f60633          	mul	a2,a2,a5
   11c40:	01059593          	slli	a1,a1,0x10
   11c44:	00b76733          	or	a4,a4,a1
   11c48:	00c77a63          	bleu	a2,a4,11c5c <__moddi3+0x22c>
   11c4c:	01170733          	add	a4,a4,a7
   11c50:	01176663          	bltu	a4,a7,11c5c <__moddi3+0x22c>
   11c54:	00c77463          	bleu	a2,a4,11c5c <__moddi3+0x22c>
   11c58:	01170733          	add	a4,a4,a7
   11c5c:	40c70733          	sub	a4,a4,a2
   11c60:	02d75633          	divu	a2,a4,a3
   11c64:	01031313          	slli	t1,t1,0x10
   11c68:	01035313          	srli	t1,t1,0x10
   11c6c:	02d77733          	remu	a4,a4,a3
   11c70:	02f60533          	mul	a0,a2,a5
   11c74:	01071713          	slli	a4,a4,0x10
   11c78:	00e367b3          	or	a5,t1,a4
   11c7c:	e8a7fae3          	bleu	a0,a5,11b10 <__moddi3+0xe0>
   11c80:	e81ff06f          	j	11b00 <__moddi3+0xd0>
	  /* qq = NN / 0d */

	  if (d0 == 0)
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */

	  count_leading_zeros (bm, d0);
   11c84:	0ff00793          	li	a5,255
   11c88:	0117b7b3          	sltu	a5,a5,a7
   11c8c:	00379793          	slli	a5,a5,0x3
   11c90:	f6dff06f          	j	11bfc <__moddi3+0x1cc>
    {
      if (d0 > n1)
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   11c94:	0ff00293          	li	t0,255
   11c98:	00c2b2b3          	sltu	t0,t0,a2
   11c9c:	00329293          	slli	t0,t0,0x3
   11ca0:	dd1ff06f          	j	11a70 <__moddi3+0x40>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   11ca4:	0ff00893          	li	a7,255
   11ca8:	00d8b8b3          	sltu	a7,a7,a3
   11cac:	00389893          	slli	a7,a7,0x3
   11cb0:	ea9ff06f          	j	11b58 <__moddi3+0x128>
	    {
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
   11cb4:	005898b3          	sll	a7,a7,t0
	      n2 = n1 >> b;
   11cb8:	00f5de33          	srl	t3,a1,a5
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11cbc:	0108d713          	srli	a4,a7,0x10
   11cc0:	02ee5633          	divu	a2,t3,a4
   11cc4:	01089393          	slli	t2,a7,0x10

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   11cc8:	005595b3          	sll	a1,a1,t0
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11ccc:	0103d393          	srli	t2,t2,0x10

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   11cd0:	00f557b3          	srl	a5,a0,a5
   11cd4:	00b7e7b3          	or	a5,a5,a1
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11cd8:	0107d693          	srli	a3,a5,0x10
	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;
   11cdc:	00551333          	sll	t1,a0,t0

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11ce0:	02ee7e33          	remu	t3,t3,a4
   11ce4:	02c385b3          	mul	a1,t2,a2
   11ce8:	010e1e13          	slli	t3,t3,0x10
   11cec:	01c6e633          	or	a2,a3,t3
   11cf0:	00b67a63          	bleu	a1,a2,11d04 <__moddi3+0x2d4>
   11cf4:	01160633          	add	a2,a2,a7
   11cf8:	01166663          	bltu	a2,a7,11d04 <__moddi3+0x2d4>
   11cfc:	00b67463          	bleu	a1,a2,11d04 <__moddi3+0x2d4>
   11d00:	01160633          	add	a2,a2,a7
   11d04:	40b60633          	sub	a2,a2,a1
   11d08:	02e655b3          	divu	a1,a2,a4
   11d0c:	01079793          	slli	a5,a5,0x10
   11d10:	0107d793          	srli	a5,a5,0x10
   11d14:	02e67633          	remu	a2,a2,a4
   11d18:	02b385b3          	mul	a1,t2,a1
   11d1c:	01061613          	slli	a2,a2,0x10
   11d20:	00c7e6b3          	or	a3,a5,a2
   11d24:	00b6fa63          	bleu	a1,a3,11d38 <__moddi3+0x308>
   11d28:	011686b3          	add	a3,a3,a7
   11d2c:	0116e663          	bltu	a3,a7,11d38 <__moddi3+0x308>
   11d30:	00b6f463          	bleu	a1,a3,11d38 <__moddi3+0x308>
   11d34:	011686b3          	add	a3,a3,a7
   11d38:	40b685b3          	sub	a1,a3,a1
   11d3c:	00038793          	mv	a5,t2
   11d40:	00070693          	mv	a3,a4
   11d44:	eedff06f          	j	11c30 <__moddi3+0x200>
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
   11d48:	01c696b3          	sll	a3,a3,t3
   11d4c:	01d653b3          	srl	t2,a2,t4
   11d50:	0076e3b3          	or	t2,a3,t2
	      d0 = d0 << bm;
	      n2 = n1 >> b;
   11d54:	01d5d333          	srl	t1,a1,t4
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11d58:	0103d893          	srli	a7,t2,0x10
   11d5c:	031357b3          	divu	a5,t1,a7
   11d60:	01039713          	slli	a4,t2,0x10
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   11d64:	01c596b3          	sll	a3,a1,t3
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11d68:	01075713          	srli	a4,a4,0x10
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   11d6c:	01d555b3          	srl	a1,a0,t4
   11d70:	00d5e6b3          	or	a3,a1,a3
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11d74:	0106d293          	srli	t0,a3,0x10
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
   11d78:	01c61633          	sll	a2,a2,t3
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;
   11d7c:	01c51533          	sll	a0,a0,t3

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11d80:	03137333          	remu	t1,t1,a7
   11d84:	02f705b3          	mul	a1,a4,a5
   11d88:	01031313          	slli	t1,t1,0x10
   11d8c:	0062e2b3          	or	t0,t0,t1
   11d90:	00b2fe63          	bleu	a1,t0,11dac <__moddi3+0x37c>
   11d94:	007282b3          	add	t0,t0,t2
   11d98:	fff78313          	addi	t1,a5,-1
   11d9c:	1072e263          	bltu	t0,t2,11ea0 <__moddi3+0x470>
   11da0:	10b2f063          	bleu	a1,t0,11ea0 <__moddi3+0x470>
   11da4:	ffe78793          	addi	a5,a5,-2
   11da8:	007282b3          	add	t0,t0,t2
   11dac:	40b282b3          	sub	t0,t0,a1
   11db0:	0312d333          	divu	t1,t0,a7
   11db4:	01069693          	slli	a3,a3,0x10
   11db8:	0106d693          	srli	a3,a3,0x10
   11dbc:	0312f2b3          	remu	t0,t0,a7
   11dc0:	02670733          	mul	a4,a4,t1
   11dc4:	01029893          	slli	a7,t0,0x10
   11dc8:	0116e8b3          	or	a7,a3,a7
   11dcc:	00e8fe63          	bleu	a4,a7,11de8 <__moddi3+0x3b8>
   11dd0:	007888b3          	add	a7,a7,t2
   11dd4:	fff30693          	addi	a3,t1,-1
   11dd8:	0c78e063          	bltu	a7,t2,11e98 <__moddi3+0x468>
   11ddc:	0ae8fe63          	bleu	a4,a7,11e98 <__moddi3+0x468>
   11de0:	ffe30313          	addi	t1,t1,-2
   11de4:	007888b3          	add	a7,a7,t2
   11de8:	01079793          	slli	a5,a5,0x10
	      umul_ppmm (m1, m0, q0, d0);
   11dec:	00010fb7          	lui	t6,0x10
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11df0:	0067e333          	or	t1,a5,t1
	      umul_ppmm (m1, m0, q0, d0);
   11df4:	ffff8793          	addi	a5,t6,-1 # ffff <_reset+0xfdff>
   11df8:	00f376b3          	and	a3,t1,a5
   11dfc:	01065593          	srli	a1,a2,0x10
   11e00:	01035313          	srli	t1,t1,0x10
   11e04:	00f677b3          	and	a5,a2,a5
   11e08:	02f68f33          	mul	t5,a3,a5
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11e0c:	40e88733          	sub	a4,a7,a4
	      umul_ppmm (m1, m0, q0, d0);
   11e10:	02f307b3          	mul	a5,t1,a5
   11e14:	010f5293          	srli	t0,t5,0x10
   11e18:	02b686b3          	mul	a3,a3,a1
   11e1c:	00f686b3          	add	a3,a3,a5
   11e20:	00d288b3          	add	a7,t0,a3
   11e24:	02b30333          	mul	t1,t1,a1
   11e28:	00f8f463          	bleu	a5,a7,11e30 <__moddi3+0x400>
   11e2c:	01f30333          	add	t1,t1,t6
   11e30:	000106b7          	lui	a3,0x10
   11e34:	fff68793          	addi	a5,a3,-1 # ffff <_reset+0xfdff>
   11e38:	0108d693          	srli	a3,a7,0x10
   11e3c:	00f8f8b3          	and	a7,a7,a5
   11e40:	01089293          	slli	t0,a7,0x10
   11e44:	00668333          	add	t1,a3,t1
   11e48:	00ff78b3          	and	a7,t5,a5
   11e4c:	011288b3          	add	a7,t0,a7

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   11e50:	00676a63          	bltu	a4,t1,11e64 <__moddi3+0x434>
   11e54:	04670e63          	beq	a4,t1,11eb0 <__moddi3+0x480>
   11e58:	40670733          	sub	a4,a4,t1
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);
   11e5c:	00088793          	mv	a5,a7
   11e60:	0180006f          	j	11e78 <__moddi3+0x448>

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
		{
		  q0--;
		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
   11e64:	40c887b3          	sub	a5,a7,a2
   11e68:	40730333          	sub	t1,t1,t2
   11e6c:	00f8b8b3          	sltu	a7,a7,a5
   11e70:	411308b3          	sub	a7,t1,a7
   11e74:	41170733          	sub	a4,a4,a7
	      q1 = 0;

	      /* Remainder in (n1n0 - m1m0) >> bm.  */
	      if (rp != 0)
		{
		  sub_ddmmss (n1, n0, n1, n0, m1, m0);
   11e78:	40f507b3          	sub	a5,a0,a5
   11e7c:	00f53533          	sltu	a0,a0,a5
   11e80:	40a70733          	sub	a4,a4,a0
		  rr.s.low = (n1 << b) | (n0 >> bm);
   11e84:	01d71533          	sll	a0,a4,t4
   11e88:	01c7d7b3          	srl	a5,a5,t3
		  rr.s.high = n1 >> bm;
		  *rp = rr.ll;
   11e8c:	00f56533          	or	a0,a0,a5
   11e90:	01c755b3          	srl	a1,a4,t3
   11e94:	c89ff06f          	j	11b1c <__moddi3+0xec>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11e98:	00068313          	mv	t1,a3
   11e9c:	f4dff06f          	j	11de8 <__moddi3+0x3b8>
   11ea0:	00030793          	mv	a5,t1
   11ea4:	f09ff06f          	j	11dac <__moddi3+0x37c>
	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
	      n0 = n0 << bm;
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11ea8:	01170733          	add	a4,a4,a7
   11eac:	c31ff06f          	j	11adc <__moddi3+0xac>
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   11eb0:	fb156ae3          	bltu	a0,a7,11e64 <__moddi3+0x434>
   11eb4:	00088793          	mv	a5,a7
   11eb8:	00000713          	li	a4,0
   11ebc:	fbdff06f          	j	11e78 <__moddi3+0x448>

00011ec0 <atexit>:
int
_DEFUN (atexit,
	(fn),
	_VOID _EXFNPTR(fn, (_VOID)))
{
  return __register_exitproc (__et_atexit, fn, NULL, NULL);
   11ec0:	00050593          	mv	a1,a0
   11ec4:	00000693          	li	a3,0
   11ec8:	00000613          	li	a2,0
   11ecc:	00000513          	li	a0,0
   11ed0:	3580206f          	j	14228 <__register_exitproc>

00011ed4 <__libc_fini_array>:
extern void _fini (void);

/* Run all the cleanup routines.  */
void
__libc_fini_array (void)
{
   11ed4:	ff010113          	addi	sp,sp,-16
   11ed8:	00812423          	sw	s0,8(sp)
   11edc:	00912223          	sw	s1,4(sp)
  size_t count;
  size_t i;
  
  count = __fini_array_end - __fini_array_start;
   11ee0:	0001d437          	lui	s0,0x1d
   11ee4:	0001d4b7          	lui	s1,0x1d
   11ee8:	c5048493          	addi	s1,s1,-944 # 1cc50 <__init_array_end>
   11eec:	c5440413          	addi	s0,s0,-940 # 1cc54 <__fini_array_end>
   11ef0:	40940433          	sub	s0,s0,s1
   11ef4:	40245413          	srai	s0,s0,0x2
   11ef8:	00241793          	slli	a5,s0,0x2
   11efc:	ffc78793          	addi	a5,a5,-4
extern void _fini (void);

/* Run all the cleanup routines.  */
void
__libc_fini_array (void)
{
   11f00:	00112623          	sw	ra,12(sp)
   11f04:	009784b3          	add	s1,a5,s1
  size_t count;
  size_t i;
  
  count = __fini_array_end - __fini_array_start;
  for (i = count; i > 0; i--)
   11f08:	00040c63          	beqz	s0,11f20 <__libc_fini_array+0x4c>
    __fini_array_start[i-1] ();
   11f0c:	0004a783          	lw	a5,0(s1)
   11f10:	fff40413          	addi	s0,s0,-1
   11f14:	ffc48493          	addi	s1,s1,-4
   11f18:	000780e7          	jalr	a5
{
  size_t count;
  size_t i;
  
  count = __fini_array_end - __fini_array_start;
  for (i = count; i > 0; i--)
   11f1c:	fe0418e3          	bnez	s0,11f0c <__libc_fini_array+0x38>
    __fini_array_start[i-1] ();

  _fini ();
}
   11f20:	00c12083          	lw	ra,12(sp)
   11f24:	00812403          	lw	s0,8(sp)
   11f28:	00412483          	lw	s1,4(sp)
   11f2c:	01010113          	addi	sp,sp,16
  
  count = __fini_array_end - __fini_array_start;
  for (i = count; i > 0; i--)
    __fini_array_start[i-1] ();

  _fini ();
   11f30:	918fe06f          	j	10048 <_fini>

00011f34 <__libc_init_array>:
extern void _init (void);

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
   11f34:	ff010113          	addi	sp,sp,-16
   11f38:	00812423          	sw	s0,8(sp)
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
   11f3c:	0001d7b7          	lui	a5,0x1d
   11f40:	0001d437          	lui	s0,0x1d
extern void _init (void);

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
   11f44:	01212023          	sw	s2,0(sp)
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
   11f48:	c4878793          	addi	a5,a5,-952 # 1cc48 <_etext>
   11f4c:	c4840913          	addi	s2,s0,-952 # 1cc48 <_etext>
   11f50:	41278933          	sub	s2,a5,s2
   11f54:	40295913          	srai	s2,s2,0x2
extern void _init (void);

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
   11f58:	00912223          	sw	s1,4(sp)
   11f5c:	00112623          	sw	ra,12(sp)
   11f60:	c4840413          	addi	s0,s0,-952
   11f64:	00000493          	li	s1,0
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
   11f68:	00090c63          	beqz	s2,11f80 <__libc_init_array+0x4c>
    __preinit_array_start[i] ();
   11f6c:	00042783          	lw	a5,0(s0)
{
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
   11f70:	00148493          	addi	s1,s1,1
   11f74:	00440413          	addi	s0,s0,4
    __preinit_array_start[i] ();
   11f78:	000780e7          	jalr	a5
{
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
   11f7c:	fe9918e3          	bne	s2,s1,11f6c <__libc_init_array+0x38>
    __preinit_array_start[i] ();

  _init ();

  count = __init_array_end - __init_array_start;
   11f80:	0001d437          	lui	s0,0x1d

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
    __preinit_array_start[i] ();

  _init ();
   11f84:	8c4fe0ef          	jal	10048 <_fini>

  count = __init_array_end - __init_array_start;
   11f88:	0001d7b7          	lui	a5,0x1d
   11f8c:	c4840913          	addi	s2,s0,-952 # 1cc48 <_etext>
   11f90:	c5078793          	addi	a5,a5,-944 # 1cc50 <__init_array_end>
   11f94:	41278933          	sub	s2,a5,s2
   11f98:	40295913          	srai	s2,s2,0x2
   11f9c:	c4840413          	addi	s0,s0,-952
  for (i = 0; i < count; i++)
   11fa0:	00000493          	li	s1,0
   11fa4:	00090c63          	beqz	s2,11fbc <__libc_init_array+0x88>
    __init_array_start[i] ();
   11fa8:	00042783          	lw	a5,0(s0)
    __preinit_array_start[i] ();

  _init ();

  count = __init_array_end - __init_array_start;
  for (i = 0; i < count; i++)
   11fac:	00148493          	addi	s1,s1,1
   11fb0:	00440413          	addi	s0,s0,4
    __init_array_start[i] ();
   11fb4:	000780e7          	jalr	a5
    __preinit_array_start[i] ();

  _init ();

  count = __init_array_end - __init_array_start;
  for (i = 0; i < count; i++)
   11fb8:	fe9918e3          	bne	s2,s1,11fa8 <__libc_init_array+0x74>
    __init_array_start[i] ();
}
   11fbc:	00c12083          	lw	ra,12(sp)
   11fc0:	00812403          	lw	s0,8(sp)
   11fc4:	00412483          	lw	s1,4(sp)
   11fc8:	00012903          	lw	s2,0(sp)
   11fcc:	01010113          	addi	sp,sp,16
   11fd0:	00008067          	ret

00011fd4 <memcpy>:

  char* a = (char*)aa;
  const char* b = (const char*)bb;
  char* end = a+n;
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
   11fd4:	00a5c7b3          	xor	a5,a1,a0
   11fd8:	0037f793          	andi	a5,a5,3
    *(a-1) = tt; \
  }

  char* a = (char*)aa;
  const char* b = (const char*)bb;
  char* end = a+n;
   11fdc:	00c508b3          	add	a7,a0,a2
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
   11fe0:	0e079263          	bnez	a5,120c4 <memcpy+0xf0>
   11fe4:	00300793          	li	a5,3
   11fe8:	0ec7fe63          	bleu	a2,a5,120e4 <memcpy+0x110>
      while (a < end)
        BODY(a, b, char);
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
   11fec:	00357793          	andi	a5,a0,3
   11ff0:	04079a63          	bnez	a5,12044 <memcpy+0x70>
    while ((uintptr_t)a & msk)
      BODY(a, b, char);

  long* la = (long*)a;
  const long* lb = (const long*)b;
  long* lend = (long*)((uintptr_t)end & ~msk);
   11ff4:	ffc8f813          	andi	a6,a7,-4

  if (__builtin_expect(la < lend-8, 0))
   11ff8:	fe080793          	addi	a5,a6,-32
   11ffc:	00050713          	mv	a4,a0
   12000:	06f56663          	bltu	a0,a5,1206c <memcpy+0x98>
      *la++ = b7;
      *la++ = b8;
    }
  }

  while (la < lend)
   12004:	00058693          	mv	a3,a1
   12008:	00070793          	mv	a5,a4
   1200c:	03077863          	bleu	a6,a4,1203c <memcpy+0x68>
    BODY(la, lb, long);
   12010:	0006a603          	lw	a2,0(a3)
   12014:	00478793          	addi	a5,a5,4
   12018:	00468693          	addi	a3,a3,4
   1201c:	fec7ae23          	sw	a2,-4(a5)
      *la++ = b7;
      *la++ = b8;
    }
  }

  while (la < lend)
   12020:	ff07e8e3          	bltu	a5,a6,12010 <memcpy+0x3c>
   12024:	fff74793          	not	a5,a4
   12028:	01078833          	add	a6,a5,a6
   1202c:	ffc87813          	andi	a6,a6,-4
   12030:	00480813          	addi	a6,a6,4
   12034:	01070733          	add	a4,a4,a6
   12038:	010585b3          	add	a1,a1,a6
    BODY(la, lb, long);

  a = (char*)la;
  b = (const char*)lb;
  if (__builtin_expect(a < end, 0))
   1203c:	09176863          	bltu	a4,a7,120cc <memcpy+0xf8>
    goto small;
  return aa;
}
   12040:	00008067          	ret
   12044:	00050713          	mv	a4,a0
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
    while ((uintptr_t)a & msk)
      BODY(a, b, char);
   12048:	0005c683          	lbu	a3,0(a1)
   1204c:	00170713          	addi	a4,a4,1
        BODY(a, b, char);
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
    while ((uintptr_t)a & msk)
   12050:	00377793          	andi	a5,a4,3
      BODY(a, b, char);
   12054:	00158593          	addi	a1,a1,1
   12058:	fed70fa3          	sb	a3,-1(a4)
        BODY(a, b, char);
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
    while ((uintptr_t)a & msk)
   1205c:	fe0796e3          	bnez	a5,12048 <memcpy+0x74>
      BODY(a, b, char);

  long* la = (long*)a;
  const long* lb = (const long*)b;
  long* lend = (long*)((uintptr_t)end & ~msk);
   12060:	ffc8f813          	andi	a6,a7,-4

  if (__builtin_expect(la < lend-8, 0))
   12064:	fe080793          	addi	a5,a6,-32
   12068:	f8f77ee3          	bleu	a5,a4,12004 <memcpy+0x30>
  {
    while (la < lend-8)
    {
      long b0 = *lb++;
   1206c:	0005af83          	lw	t6,0(a1)
      long b1 = *lb++;
   12070:	0045af03          	lw	t5,4(a1)
      long b2 = *lb++;
   12074:	0085ae83          	lw	t4,8(a1)
      long b3 = *lb++;
   12078:	00c5ae03          	lw	t3,12(a1)
      long b4 = *lb++;
   1207c:	0105a383          	lw	t2,16(a1)
      long b5 = *lb++;
   12080:	0145a303          	lw	t1,20(a1)
      long b6 = *lb++;
   12084:	0185a283          	lw	t0,24(a1)
      long b7 = *lb++;
   12088:	01c5a603          	lw	a2,28(a1)
   1208c:	02458593          	addi	a1,a1,36
   12090:	02470713          	addi	a4,a4,36
      long b8 = *lb++;
   12094:	ffc5a683          	lw	a3,-4(a1)
      *la++ = b0;
   12098:	fdf72e23          	sw	t6,-36(a4)
      *la++ = b1;
   1209c:	ffe72023          	sw	t5,-32(a4)
      *la++ = b2;
   120a0:	ffd72223          	sw	t4,-28(a4)
      *la++ = b3;
   120a4:	ffc72423          	sw	t3,-24(a4)
      *la++ = b4;
   120a8:	fe772623          	sw	t2,-20(a4)
      *la++ = b5;
   120ac:	fe672823          	sw	t1,-16(a4)
      *la++ = b6;
   120b0:	fe572a23          	sw	t0,-12(a4)
      *la++ = b7;
   120b4:	fec72c23          	sw	a2,-8(a4)
      *la++ = b8;
   120b8:	fed72e23          	sw	a3,-4(a4)
  const long* lb = (const long*)b;
  long* lend = (long*)((uintptr_t)end & ~msk);

  if (__builtin_expect(la < lend-8, 0))
  {
    while (la < lend-8)
   120bc:	faf768e3          	bltu	a4,a5,1206c <memcpy+0x98>
   120c0:	f45ff06f          	j	12004 <memcpy+0x30>
  char* end = a+n;
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
  {
small:
    if (__builtin_expect(a < end, 1))
   120c4:	00050713          	mv	a4,a0
   120c8:	03157463          	bleu	a7,a0,120f0 <memcpy+0x11c>
      while (a < end)
        BODY(a, b, char);
   120cc:	0005c783          	lbu	a5,0(a1)
   120d0:	00170713          	addi	a4,a4,1
   120d4:	00158593          	addi	a1,a1,1
   120d8:	fef70fa3          	sb	a5,-1(a4)
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
  {
small:
    if (__builtin_expect(a < end, 1))
      while (a < end)
   120dc:	ff1768e3          	bltu	a4,a7,120cc <memcpy+0xf8>
   120e0:	00008067          	ret
   120e4:	00050713          	mv	a4,a0
  char* end = a+n;
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
  {
small:
    if (__builtin_expect(a < end, 1))
   120e8:	ff1562e3          	bltu	a0,a7,120cc <memcpy+0xf8>
   120ec:	f55ff06f          	j	12040 <memcpy+0x6c>
   120f0:	00008067          	ret

000120f4 <_printf_r>:

int
_DEFUN(_printf_r, (ptr, fmt),
       struct _reent *ptr _AND
       const char *__restrict fmt _DOTS)
{
   120f4:	fc010113          	addi	sp,sp,-64
   120f8:	02c12423          	sw	a2,40(sp)
   120fc:	02d12623          	sw	a3,44(sp)
   12100:	02f12a23          	sw	a5,52(sp)
   12104:	02e12823          	sw	a4,48(sp)
   12108:	03012c23          	sw	a6,56(sp)
   1210c:	03112e23          	sw	a7,60(sp)
  int ret;
  va_list ap;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   12110:	00058613          	mv	a2,a1
   12114:	00852583          	lw	a1,8(a0)
{
  int ret;
  va_list ap;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
   12118:	02810793          	addi	a5,sp,40
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   1211c:	00078693          	mv	a3,a5

int
_DEFUN(_printf_r, (ptr, fmt),
       struct _reent *ptr _AND
       const char *__restrict fmt _DOTS)
{
   12120:	00112e23          	sw	ra,28(sp)
  int ret;
  va_list ap;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
   12124:	00f12623          	sw	a5,12(sp)
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   12128:	1ac000ef          	jal	122d4 <_vfprintf_r>
  va_end (ap);
  return ret;
}
   1212c:	01c12083          	lw	ra,28(sp)
   12130:	04010113          	addi	sp,sp,64
   12134:	00008067          	ret

00012138 <printf>:
_DEFUN(printf, (fmt),
       const char *__restrict fmt _DOTS)
{
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;
   12138:	8101a283          	lw	t0,-2032(gp) # 1ece0 <_impure_ptr>
#ifndef _REENT_ONLY

int
_DEFUN(printf, (fmt),
       const char *__restrict fmt _DOTS)
{
   1213c:	fc010113          	addi	sp,sp,-64
   12140:	02c12423          	sw	a2,40(sp)
   12144:	02d12623          	sw	a3,44(sp)
   12148:	02f12a23          	sw	a5,52(sp)
   1214c:	02b12223          	sw	a1,36(sp)
   12150:	02e12823          	sw	a4,48(sp)
   12154:	03012c23          	sw	a6,56(sp)
   12158:	03112e23          	sw	a7,60(sp)
  va_list ap;
  struct _reent *ptr = _REENT;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   1215c:	0082a583          	lw	a1,8(t0)
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
   12160:	02410793          	addi	a5,sp,36
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   12164:	00050613          	mv	a2,a0
   12168:	00078693          	mv	a3,a5
   1216c:	00028513          	mv	a0,t0
#ifndef _REENT_ONLY

int
_DEFUN(printf, (fmt),
       const char *__restrict fmt _DOTS)
{
   12170:	00112e23          	sw	ra,28(sp)
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
   12174:	00f12623          	sw	a5,12(sp)
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   12178:	15c000ef          	jal	122d4 <_vfprintf_r>
  va_end (ap);
  return ret;
}
   1217c:	01c12083          	lw	ra,28(sp)
   12180:	04010113          	addi	sp,sp,64
   12184:	00008067          	ret

00012188 <_puts_r>:

int
_DEFUN(_puts_r, (ptr, s),
       struct _reent *ptr _AND
       _CONST char * s)
{
   12188:	fd010113          	addi	sp,sp,-48
   1218c:	02812423          	sw	s0,40(sp)
   12190:	00050413          	mv	s0,a0
#ifdef _FVWRITE_IN_STREAMIO
  int result;
  size_t c = strlen (s);
   12194:	00058513          	mv	a0,a1

int
_DEFUN(_puts_r, (ptr, s),
       struct _reent *ptr _AND
       _CONST char * s)
{
   12198:	02912223          	sw	s1,36(sp)
   1219c:	02112623          	sw	ra,44(sp)
   121a0:	00058493          	mv	s1,a1
#ifdef _FVWRITE_IN_STREAMIO
  int result;
  size_t c = strlen (s);
   121a4:	0a0000ef          	jal	12244 <strlen>
  uio.uio_resid = c + 1;
  uio.uio_iov = &iov[0];
  uio.uio_iovcnt = 2;

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
   121a8:	00842583          	lw	a1,8(s0)
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
  iov[0].iov_len = c;
  iov[1].iov_base = "\n";
   121ac:	0001d737          	lui	a4,0x1d
   121b0:	be070713          	addi	a4,a4,-1056 # 1cbe0 <__thenan_sf+0x10>
  uio.uio_iovcnt = 2;

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
   121b4:	00c59683          	lh	a3,12(a1)
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
  iov[0].iov_len = c;
  iov[1].iov_base = "\n";
   121b8:	00e12c23          	sw	a4,24(sp)
  iov[1].iov_len = 1;
   121bc:	00100713          	li	a4,1
   121c0:	00e12e23          	sw	a4,28(sp)
  uio.uio_resid = c + 1;
  uio.uio_iov = &iov[0];
   121c4:	01010713          	addi	a4,sp,16

  iov[0].iov_base = s;
  iov[0].iov_len = c;
  iov[1].iov_base = "\n";
  iov[1].iov_len = 1;
  uio.uio_resid = c + 1;
   121c8:	00150613          	addi	a2,a0,1
  uio.uio_iov = &iov[0];
   121cc:	00e12223          	sw	a4,4(sp)
  uio.uio_iovcnt = 2;

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
   121d0:	01269793          	slli	a5,a3,0x12
  iov[0].iov_len = c;
  iov[1].iov_base = "\n";
  iov[1].iov_len = 1;
  uio.uio_resid = c + 1;
  uio.uio_iov = &iov[0];
  uio.uio_iovcnt = 2;
   121d4:	00200713          	li	a4,2
  size_t c = strlen (s);
  struct __suio uio;
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
   121d8:	00912823          	sw	s1,16(sp)
  iov[0].iov_len = c;
   121dc:	00a12a23          	sw	a0,20(sp)
  iov[1].iov_base = "\n";
  iov[1].iov_len = 1;
  uio.uio_resid = c + 1;
   121e0:	00c12623          	sw	a2,12(sp)
  uio.uio_iov = &iov[0];
  uio.uio_iovcnt = 2;
   121e4:	00e12423          	sw	a4,8(sp)

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
   121e8:	0207c263          	bltz	a5,1220c <_puts_r+0x84>
  uio.uio_iov = &iov[0];
  uio.uio_iovcnt = 2;

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  _newlib_flockfile_start (fp);
   121ec:	0685a783          	lw	a5,104(a1)
  ORIENT (fp, -1);
   121f0:	ffffe737          	lui	a4,0xffffe
   121f4:	00002637          	lui	a2,0x2
   121f8:	fff70713          	addi	a4,a4,-1 # ffffdfff <_gp+0xfffdeb2f>
   121fc:	00c6e6b3          	or	a3,a3,a2
   12200:	00e7f733          	and	a4,a5,a4
   12204:	00d59623          	sh	a3,12(a1)
   12208:	06e5a423          	sw	a4,104(a1)
  result = (__sfvwrite_r (ptr, fp, &uio) ? EOF : '\n');
   1220c:	00410613          	addi	a2,sp,4
   12210:	00040513          	mv	a0,s0
   12214:	264040ef          	jal	16478 <__sfvwrite_r>

err:
  _newlib_flockfile_end (fp);
  return result;
#endif
}
   12218:	02c12083          	lw	ra,44(sp)

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
  result = (__sfvwrite_r (ptr, fp, &uio) ? EOF : '\n');
   1221c:	00a03533          	snez	a0,a0
   12220:	40a00533          	neg	a0,a0

err:
  _newlib_flockfile_end (fp);
  return result;
#endif
}
   12224:	00a56513          	ori	a0,a0,10
   12228:	02812403          	lw	s0,40(sp)
   1222c:	02412483          	lw	s1,36(sp)
   12230:	03010113          	addi	sp,sp,48
   12234:	00008067          	ret

00012238 <puts>:

int
_DEFUN(puts, (s),
       char _CONST * s)
{
  return _puts_r (_REENT, s);
   12238:	00050593          	mv	a1,a0
   1223c:	8101a503          	lw	a0,-2032(gp) # 1ece0 <_impure_ptr>
   12240:	f49ff06f          	j	12188 <_puts_r>

00012244 <strlen>:
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  while (*str++)
    ;
  return str - start - 1;
#else
  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
   12244:	00357793          	andi	a5,a0,3
   12248:	00050593          	mv	a1,a0
   1224c:	04079a63          	bnez	a5,122a0 <strlen+0x5c>
    if (!ch)
      return str - start - 1;
  } while ((uintptr_t)str & (sizeof(long)-1));

  unsigned long* ls = (unsigned long*)str;
  while (!__libc_detect_null(*ls++))
   12250:	7f7f86b7          	lui	a3,0x7f7f8
   12254:	f7f68693          	addi	a3,a3,-129 # 7f7f7f7f <_gp+0x7f7d8aaf>
   12258:	fff00613          	li	a2,-1
   1225c:	00450513          	addi	a0,a0,4
   12260:	ffc52783          	lw	a5,-4(a0)
   12264:	00d7f733          	and	a4,a5,a3
   12268:	00d70733          	add	a4,a4,a3
   1226c:	00d7e7b3          	or	a5,a5,a3
   12270:	00f767b3          	or	a5,a4,a5
   12274:	fec784e3          	beq	a5,a2,1225c <strlen+0x18>

  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
   12278:	ffc54703          	lbu	a4,-4(a0)
  while (!__libc_detect_null(*ls++))
    ;
  asm volatile ("" : "+r"(ls)); /* prevent "optimization" */

  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);
   1227c:	40b507b3          	sub	a5,a0,a1

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
   12280:	ffd54683          	lbu	a3,-3(a0)
   12284:	ffe54603          	lbu	a2,-2(a0)
  if (c0 == 0)            return ret + 0 - sl;
   12288:	02070e63          	beqz	a4,122c4 <strlen+0x80>
  if (c1 == 0)            return ret + 1 - sl;
   1228c:	02068863          	beqz	a3,122bc <strlen+0x78>
  if (c2 == 0)            return ret + 2 - sl;
  if (sl == 4 || c3 == 0) return ret + 3 - sl;
   12290:	fff78513          	addi	a0,a5,-1
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
  if (c1 == 0)            return ret + 1 - sl;
  if (c2 == 0)            return ret + 2 - sl;
   12294:	02060c63          	beqz	a2,122cc <strlen+0x88>
  if (c0 == 0)            return ret + 4 - sl;
  if (c1 == 0)            return ret + 5 - sl;
  if (c2 == 0)            return ret + 6 - sl;
                          return ret + 7 - sl;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   12298:	00008067          	ret
  {
    char ch = *str;
    str++;
    if (!ch)
      return str - start - 1;
  } while ((uintptr_t)str & (sizeof(long)-1));
   1229c:	fa070ae3          	beqz	a4,12250 <strlen+0xc>
    ;
  return str - start - 1;
#else
  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
  {
    char ch = *str;
   122a0:	00054783          	lbu	a5,0(a0)
    str++;
   122a4:	00150513          	addi	a0,a0,1
    if (!ch)
      return str - start - 1;
  } while ((uintptr_t)str & (sizeof(long)-1));
   122a8:	00357713          	andi	a4,a0,3
#else
  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
  {
    char ch = *str;
    str++;
    if (!ch)
   122ac:	fe0798e3          	bnez	a5,1229c <strlen+0x58>
      return str - start - 1;
   122b0:	40b50533          	sub	a0,a0,a1
   122b4:	fff50513          	addi	a0,a0,-1
   122b8:	00008067          	ret
  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
  if (c1 == 0)            return ret + 1 - sl;
   122bc:	ffd78513          	addi	a0,a5,-3
   122c0:	00008067          	ret

  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
   122c4:	ffc78513          	addi	a0,a5,-4
   122c8:	00008067          	ret
  if (c1 == 0)            return ret + 1 - sl;
  if (c2 == 0)            return ret + 2 - sl;
   122cc:	ffe78513          	addi	a0,a5,-2
  if (c0 == 0)            return ret + 4 - sl;
  if (c1 == 0)            return ret + 5 - sl;
  if (c2 == 0)            return ret + 6 - sl;
                          return ret + 7 - sl;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   122d0:	00008067          	ret

000122d4 <_vfprintf_r>:
_DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
       struct _reent *data _AND
       FILE * fp           _AND
       _CONST char *fmt0   _AND
       va_list ap)
{
   122d4:	ec010113          	addi	sp,sp,-320
   122d8:	12112e23          	sw	ra,316(sp)
   122dc:	12912a23          	sw	s1,308(sp)
   122e0:	13412423          	sw	s4,296(sp)
   122e4:	11812c23          	sw	s8,280(sp)
   122e8:	00058a13          	mv	s4,a1
   122ec:	00060493          	mv	s1,a2
   122f0:	02d12823          	sw	a3,48(sp)
   122f4:	12812c23          	sw	s0,312(sp)
   122f8:	13212823          	sw	s2,304(sp)
   122fc:	13312623          	sw	s3,300(sp)
   12300:	13512223          	sw	s5,292(sp)
   12304:	13612023          	sw	s6,288(sp)
   12308:	11712e23          	sw	s7,284(sp)
   1230c:	11912a23          	sw	s9,276(sp)
   12310:	11a12823          	sw	s10,272(sp)
   12314:	11b12623          	sw	s11,268(sp)
   12318:	00050c13          	mv	s8,a0
	char *thousands_sep = NULL;
	size_t thsnd_len = 0;
	const char *grouping = NULL;
#endif
#ifdef FLOATING_POINT
	char *decimal_point = _localeconv_r (data)->decimal_point;
   1231c:	005040ef          	jal	16b20 <_localeconv_r>
   12320:	00052503          	lw	a0,0(a0)
   12324:	04a12223          	sw	a0,68(sp)
	size_t decp_len = strlen (decimal_point);
   12328:	f1dff0ef          	jal	12244 <strlen>
   1232c:	04a12623          	sw	a0,76(sp)
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
   12330:	000c0663          	beqz	s8,1233c <_vfprintf_r+0x68>
   12334:	038c2783          	lw	a5,56(s8)
   12338:	2a078863          	beqz	a5,125e8 <_vfprintf_r+0x314>
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);
   1233c:	00ca1683          	lh	a3,12(s4)
   12340:	01069793          	slli	a5,a3,0x10
   12344:	0107d793          	srli	a5,a5,0x10
   12348:	01279613          	slli	a2,a5,0x12
   1234c:	02064663          	bltz	a2,12378 <_vfprintf_r+0xa4>
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
	_newlib_flockfile_start (fp);
   12350:	068a2603          	lw	a2,104(s4)

	ORIENT(fp, -1);
   12354:	000027b7          	lui	a5,0x2
   12358:	ffffe737          	lui	a4,0xffffe
   1235c:	00f6e7b3          	or	a5,a3,a5
   12360:	fff70713          	addi	a4,a4,-1 # ffffdfff <_gp+0xfffdeb2f>
   12364:	00e67733          	and	a4,a2,a4
   12368:	00fa1623          	sh	a5,12(s4)
   1236c:	01079793          	slli	a5,a5,0x10
   12370:	06ea2423          	sw	a4,104(s4)
   12374:	0107d793          	srli	a5,a5,0x10

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   12378:	0087f713          	andi	a4,a5,8
   1237c:	1a070263          	beqz	a4,12520 <_vfprintf_r+0x24c>
   12380:	010a2703          	lw	a4,16(s4)
   12384:	18070e63          	beqz	a4,12520 <_vfprintf_r+0x24c>
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   12388:	01a7f793          	andi	a5,a5,26
   1238c:	00a00713          	li	a4,10
   12390:	1ae78a63          	beq	a5,a4,12544 <_vfprintf_r+0x270>
   12394:	0001d7b7          	lui	a5,0x1d
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   12398:	0c010693          	addi	a3,sp,192
   1239c:	8e478b93          	addi	s7,a5,-1820 # 1c8e4 <blanks.4190>
   123a0:	0001d7b7          	lui	a5,0x1d
   123a4:	00d12e23          	sw	a3,28(sp)
   123a8:	08d12623          	sw	a3,140(sp)
	uio.uio_resid = 0;
   123ac:	08012a23          	sw	zero,148(sp)
	uio.uio_iovcnt = 0;
   123b0:	08012823          	sw	zero,144(sp)
	int expsize = 0;	/* character count for expstr */
	char expstr[MAXEXPLEN];	/* buffer for exponent string */
	int lead;		/* sig figs before decimal or group sep */
#endif /* FLOATING_POINT */
#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
	int ndig = 0;		/* actual number of digits returned by cvt */
   123b4:	04012023          	sw	zero,64(sp)
#endif
#ifdef FLOATING_POINT
	char *decimal_point = _localeconv_r (data)->decimal_point;
	size_t decp_len = strlen (decimal_point);
	char softsign;		/* temporary negative sign for floats */
	union { int i; _PRINTF_FLOAT_TYPE fp; } _double_ = {0};
   123b8:	04012823          	sw	zero,80(sp)
   123bc:	04012a23          	sw	zero,84(sp)
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   123c0:	00068293          	mv	t0,a3
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
   123c4:	04012c23          	sw	zero,88(sp)
	size_t decp_len = strlen (decimal_point);
	char softsign;		/* temporary negative sign for floats */
	union { int i; _PRINTF_FLOAT_TYPE fp; } _double_ = {0};
# define _fpvalue (_double_.fp)
	int expt;		/* integer value of exponent */
	int expsize = 0;	/* character count for expstr */
   123c8:	04012e23          	sw	zero,92(sp)
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
	uio.uio_resid = 0;
	uio.uio_iovcnt = 0;
#endif
	ret = 0;
   123cc:	02012a23          	sw	zero,52(sp)
   123d0:	8f478d13          	addi	s10,a5,-1804 # 1c8f4 <zeroes.4191>
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   123d4:	0004c783          	lbu	a5,0(s1)
   123d8:	6c078263          	beqz	a5,12a9c <_vfprintf_r+0x7c8>
   123dc:	02500713          	li	a4,37
   123e0:	00048413          	mv	s0,s1
   123e4:	00e79663          	bne	a5,a4,123f0 <_vfprintf_r+0x11c>
   123e8:	0540006f          	j	1243c <_vfprintf_r+0x168>
   123ec:	00e78863          	beq	a5,a4,123fc <_vfprintf_r+0x128>
                    fmt += 1;
   123f0:	00140413          	addi	s0,s0,1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   123f4:	00044783          	lbu	a5,0(s0)
   123f8:	fe079ae3          	bnez	a5,123ec <_vfprintf_r+0x118>
   123fc:	40940933          	sub	s2,s0,s1
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
   12400:	02090e63          	beqz	s2,1243c <_vfprintf_r+0x168>
			PRINT (cp, m);
   12404:	09412703          	lw	a4,148(sp)
   12408:	09012783          	lw	a5,144(sp)
   1240c:	0092a023          	sw	s1,0(t0)
   12410:	01270733          	add	a4,a4,s2
   12414:	00178793          	addi	a5,a5,1
   12418:	08e12a23          	sw	a4,148(sp)
   1241c:	00700713          	li	a4,7
   12420:	0122a223          	sw	s2,4(t0)
   12424:	08f12823          	sw	a5,144(sp)
   12428:	00828293          	addi	t0,t0,8
   1242c:	12f74c63          	blt	a4,a5,12564 <_vfprintf_r+0x290>
			ret += m;
   12430:	03412703          	lw	a4,52(sp)
   12434:	01270733          	add	a4,a4,s2
   12438:	02e12a23          	sw	a4,52(sp)
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
   1243c:	00044783          	lbu	a5,0(s0)
   12440:	14078063          	beqz	a5,12580 <_vfprintf_r+0x2ac>
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
   12444:	fff00793          	li	a5,-1
#else
                if (*fmt == '\0')
                    goto done;
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */
   12448:	00140493          	addi	s1,s0,1

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
   1244c:	060107a3          	sb	zero,111(sp)
   12450:	00000593          	li	a1,0
   12454:	00000513          	li	a0,0
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
   12458:	02f12423          	sw	a5,40(sp)
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
   1245c:	00000b13          	li	s6,0
                    goto done;
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
   12460:	00000913          	li	s2,0
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   12464:	05800693          	li	a3,88
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			} while (is_digit (ch));
   12468:	00900613          	li	a2,9
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
   1246c:	02a00813          	li	a6,42
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
   12470:	0004c983          	lbu	s3,0(s1)
   12474:	00148493          	addi	s1,s1,1
reswitch:	switch (ch) {
   12478:	fe098793          	addi	a5,s3,-32
   1247c:	1ef6e0e3          	bltu	a3,a5,12e5c <_vfprintf_r+0xb88>
   12480:	0001c737          	lui	a4,0x1c
   12484:	00279793          	slli	a5,a5,0x2
   12488:	78070713          	addi	a4,a4,1920 # 1c780 <__clz_tab+0x100>
   1248c:	00e787b3          	add	a5,a5,a4
   12490:	0007a783          	lw	a5,0(a5)
   12494:	00078067          	jr	a5
			} else
#endif
				flags |= LONGINT;
			goto rflag;
		case 'q': /* extension */
			flags |= QUADINT;
   12498:	01096913          	ori	s2,s2,16
			goto rflag;
   1249c:	fd5ff06f          	j	12470 <_vfprintf_r+0x19c>
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   124a0:	03012783          	lw	a5,48(sp)
   124a4:	0007ab03          	lw	s6,0(a5)
   124a8:	00478793          	addi	a5,a5,4
   124ac:	02f12823          	sw	a5,48(sp)
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
   124b0:	fc0b50e3          	bgez	s6,12470 <_vfprintf_r+0x19c>
				goto rflag;
			width = -width;
   124b4:	41600b33          	neg	s6,s6
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
   124b8:	00496913          	ori	s2,s2,4
			goto rflag;
   124bc:	fb5ff06f          	j	12470 <_vfprintf_r+0x19c>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   124c0:	03012683          	lw	a3,48(sp)
			base = HEX;
			xdigs = "0123456789abcdef";
			flags |= HEXPREFIX;
   124c4:	00296613          	ori	a2,s2,2

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   124c8:	060107a3          	sb	zero,111(sp)
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   124cc:	00468713          	addi	a4,a3,4
   124d0:	0006a783          	lw	a5,0(a3)
			base = HEX;
			xdigs = "0123456789abcdef";
			flags |= HEXPREFIX;
			ox[0] = '0';
   124d4:	03000693          	li	a3,48
   124d8:	06d10823          	sb	a3,112(sp)
			ox[1] = ch = 'x';
   124dc:	07800693          	li	a3,120
   124e0:	06d108a3          	sb	a3,113(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   124e4:	02812683          	lw	a3,40(sp)
   124e8:	1806cae3          	bltz	a3,12e7c <_vfprintf_r+0xba8>
   124ec:	f7f97913          	andi	s2,s2,-129
				flags &= ~ZEROPAD;
   124f0:	00296913          	ori	s2,s2,2
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   124f4:	02e12823          	sw	a4,48(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   124f8:	140796e3          	bnez	a5,12e44 <_vfprintf_r+0xb70>
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   124fc:	0001d7b7          	lui	a5,0x1d
   12500:	c0878793          	addi	a5,a5,-1016 # 1cc08 <__thenan_sf+0x38>
   12504:	04f12c23          	sw	a5,88(sp)
			flags |= HEXPREFIX;
			ox[0] = '0';
			ox[1] = ch = 'x';
   12508:	07800993          	li	s3,120
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   1250c:	02812783          	lw	a5,40(sp)
   12510:	00000613          	li	a2,0
   12514:	7e078063          	beqz	a5,12cf4 <_vfprintf_r+0xa20>
   12518:	00000793          	li	a5,0
   1251c:	7140006f          	j	12c30 <_vfprintf_r+0x95c>
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   12520:	000a0593          	mv	a1,s4
   12524:	000c0513          	mv	a0,s8
   12528:	3ad010ef          	jal	140d4 <__swsetup_r>
   1252c:	00050463          	beqz	a0,12534 <_vfprintf_r+0x260>
   12530:	3e00106f          	j	13910 <_vfprintf_r+0x163c>
   12534:	00ca5783          	lhu	a5,12(s4)
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   12538:	00a00713          	li	a4,10
   1253c:	01a7f793          	andi	a5,a5,26
   12540:	e4e79ae3          	bne	a5,a4,12394 <_vfprintf_r+0xc0>
   12544:	00ea1783          	lh	a5,14(s4)
   12548:	e407c6e3          	bltz	a5,12394 <_vfprintf_r+0xc0>
	    fp->_file >= 0) {
		_newlib_flockfile_exit (fp);
		return (__sbprintf (data, fp, fmt0, ap));
   1254c:	03012683          	lw	a3,48(sp)
   12550:	00048613          	mv	a2,s1
   12554:	000a0593          	mv	a1,s4
   12558:	000c0513          	mv	a0,s8
   1255c:	2b9010ef          	jal	14014 <__sbprintf>
   12560:	04c0006f          	j	125ac <_vfprintf_r+0x2d8>
#else
                while (*fmt != '\0' && *fmt != '%')
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
			PRINT (cp, m);
   12564:	08c10613          	addi	a2,sp,140
   12568:	000a0593          	mv	a1,s4
   1256c:	000c0513          	mv	a0,s8
   12570:	325060ef          	jal	19094 <__sprint_r>
   12574:	02051263          	bnez	a0,12598 <_vfprintf_r+0x2c4>
   12578:	0c010293          	addi	t0,sp,192
   1257c:	eb5ff06f          	j	12430 <_vfprintf_r+0x15c>
			_free_r (data, malloc_buf);
			malloc_buf = NULL;
		}
	}
done:
	FLUSH ();
   12580:	09412783          	lw	a5,148(sp)
   12584:	00078a63          	beqz	a5,12598 <_vfprintf_r+0x2c4>
   12588:	08c10613          	addi	a2,sp,140
   1258c:	000a0593          	mv	a1,s4
   12590:	000c0513          	mv	a0,s8
   12594:	301060ef          	jal	19094 <__sprint_r>
	if (malloc_buf != NULL)
		_free_r (data, malloc_buf);
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
   12598:	00ca5783          	lhu	a5,12(s4)
   1259c:	0407f793          	andi	a5,a5,64
   125a0:	00078463          	beqz	a5,125a8 <_vfprintf_r+0x2d4>
   125a4:	36c0106f          	j	13910 <_vfprintf_r+0x163c>
   125a8:	03412503          	lw	a0,52(sp)
	/* NOTREACHED */
}
   125ac:	13c12083          	lw	ra,316(sp)
   125b0:	13812403          	lw	s0,312(sp)
   125b4:	13412483          	lw	s1,308(sp)
   125b8:	13012903          	lw	s2,304(sp)
   125bc:	12c12983          	lw	s3,300(sp)
   125c0:	12812a03          	lw	s4,296(sp)
   125c4:	12412a83          	lw	s5,292(sp)
   125c8:	12012b03          	lw	s6,288(sp)
   125cc:	11c12b83          	lw	s7,284(sp)
   125d0:	11812c03          	lw	s8,280(sp)
   125d4:	11412c83          	lw	s9,276(sp)
   125d8:	11012d03          	lw	s10,272(sp)
   125dc:	10c12d83          	lw	s11,268(sp)
   125e0:	14010113          	addi	sp,sp,320
   125e4:	00008067          	ret
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
   125e8:	000c0513          	mv	a0,s8
   125ec:	271030ef          	jal	1605c <__sinit>
   125f0:	d4dff06f          	j	1233c <_vfprintf_r+0x68>
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   125f4:	00100593          	li	a1,1
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
			goto rflag;
		case '+':
			sign = '+';
   125f8:	02b00513          	li	a0,43
   125fc:	e75ff06f          	j	12470 <_vfprintf_r+0x19c>
   12600:	00058463          	beqz	a1,12608 <_vfprintf_r+0x334>
   12604:	1d50106f          	j	13fd8 <_vfprintf_r+0x1d04>
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   12608:	01097793          	andi	a5,s2,16
   1260c:	54078463          	beqz	a5,12b54 <_vfprintf_r+0x880>
   12610:	03012683          	lw	a3,48(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12614:	02812603          	lw	a2,40(sp)
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   12618:	0006a783          	lw	a5,0(a3)
   1261c:	00468713          	addi	a4,a3,4

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   12620:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12624:	54064863          	bltz	a2,12b74 <_vfprintf_r+0x8a0>
				flags &= ~ZEROPAD;
   12628:	f7f97913          	andi	s2,s2,-129
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   1262c:	02e12823          	sw	a4,48(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12630:	54079863          	bnez	a5,12b80 <_vfprintf_r+0x8ac>
   12634:	02812683          	lw	a3,40(sp)
   12638:	00000613          	li	a2,0
   1263c:	00000793          	li	a5,0
   12640:	00069463          	bnez	a3,12648 <_vfprintf_r+0x374>
   12644:	3c40106f          	j	13a08 <_vfprintf_r+0x1734>
   12648:	0c010413          	addi	s0,sp,192
				 * a variable; hence this switch.
				 */
				switch (base) {
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   1264c:	0077f713          	andi	a4,a5,7
   12650:	fff40413          	addi	s0,s0,-1
   12654:	03070713          	addi	a4,a4,48
						_uquad >>= 3;
   12658:	0037d793          	srli	a5,a5,0x3
				 * a variable; hence this switch.
				 */
				switch (base) {
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   1265c:	00e40023          	sb	a4,0(s0)
						_uquad >>= 3;
					} while (_uquad);
   12660:	fe0796e3          	bnez	a5,1264c <_vfprintf_r+0x378>
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
   12664:	00197793          	andi	a5,s2,1
   12668:	3e0780e3          	beqz	a5,13248 <_vfprintf_r+0xf74>
   1266c:	03000793          	li	a5,48
   12670:	48f70a63          	beq	a4,a5,12b04 <_vfprintf_r+0x830>
   12674:	01c12683          	lw	a3,28(sp)
						*--cp = '0';
   12678:	fff40713          	addi	a4,s0,-1
   1267c:	fef40fa3          	sb	a5,-1(s0)
   12680:	40e686b3          	sub	a3,a3,a4
   12684:	02d12623          	sw	a3,44(sp)
   12688:	00070413          	mv	s0,a4
   1268c:	5d40006f          	j	12c60 <_vfprintf_r+0x98c>
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
   12690:	0004c983          	lbu	s3,0(s1)
   12694:	00148493          	addi	s1,s1,1
   12698:	01099463          	bne	s3,a6,126a0 <_vfprintf_r+0x3cc>
   1269c:	0b90106f          	j	13f54 <_vfprintf_r+0x1c80>
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   126a0:	fd098893          	addi	a7,s3,-48
   126a4:	00000793          	li	a5,0
   126a8:	01167463          	bleu	a7,a2,126b0 <_vfprintf_r+0x3dc>
   126ac:	6300106f          	j	13cdc <_vfprintf_r+0x1a08>
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
   126b0:	00148493          	addi	s1,s1,1
   126b4:	fff4c983          	lbu	s3,-1(s1)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
				n = 10 * n + to_digit (ch);
   126b8:	00179713          	slli	a4,a5,0x1
   126bc:	00379793          	slli	a5,a5,0x3
   126c0:	00f707b3          	add	a5,a4,a5
   126c4:	011787b3          	add	a5,a5,a7
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   126c8:	fd098893          	addi	a7,s3,-48
   126cc:	ff1672e3          	bleu	a7,a2,126b0 <_vfprintf_r+0x3dc>
   126d0:	0007d463          	bgez	a5,126d8 <_vfprintf_r+0x404>
   126d4:	42c0106f          	j	13b00 <_vfprintf_r+0x182c>
   126d8:	02f12423          	sw	a5,40(sp)
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			}
			prec = n < 0 ? -1 : n;
			goto reswitch;
   126dc:	d9dff06f          	j	12478 <_vfprintf_r+0x1a4>
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
   126e0:	08096913          	ori	s2,s2,128
			goto rflag;
   126e4:	d8dff06f          	j	12470 <_vfprintf_r+0x19c>
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
   126e8:	d80514e3          	bnez	a0,12470 <_vfprintf_r+0x19c>
   126ec:	00100593          	li	a1,1
				sign = ' ';
   126f0:	02000513          	li	a0,32
   126f4:	d7dff06f          	j	12470 <_vfprintf_r+0x19c>
			goto rflag;
		case '#':
			flags |= ALT;
   126f8:	00196913          	ori	s2,s2,1
			goto rflag;
   126fc:	d75ff06f          	j	12470 <_vfprintf_r+0x19c>
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   12700:	03012703          	lw	a4,48(sp)
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
   12704:	060107a3          	sb	zero,111(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   12708:	00072403          	lw	s0,0(a4)
   1270c:	00470c93          	addi	s9,a4,4
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
   12710:	00041463          	bnez	s0,12718 <_vfprintf_r+0x444>
   12714:	4240106f          	j	13b38 <_vfprintf_r+0x1864>
				}
				cp[size] = '\0';
			}
			else
#endif /* _MB_CAPABLE */
			if (prec >= 0) {
   12718:	02812783          	lw	a5,40(sp)
   1271c:	0007d463          	bgez	a5,12724 <_vfprintf_r+0x450>
   12720:	3400106f          	j	13a60 <_vfprintf_r+0x178c>
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);
   12724:	00078613          	mv	a2,a5
   12728:	00000593          	li	a1,0
   1272c:	00040513          	mv	a0,s0
   12730:	00512a23          	sw	t0,20(sp)
   12734:	51d040ef          	jal	17450 <memchr>

				if (p != NULL)
   12738:	01412283          	lw	t0,20(sp)
   1273c:	00051463          	bnez	a0,12744 <_vfprintf_r+0x470>
   12740:	4c80106f          	j	13c08 <_vfprintf_r+0x1934>
					size = p - cp;
   12744:	40850533          	sub	a0,a0,s0
   12748:	02a12623          	sw	a0,44(sp)
   1274c:	00050a93          	mv	s5,a0
   12750:	00055463          	bgez	a0,12758 <_vfprintf_r+0x484>
   12754:	32c0106f          	j	13a80 <_vfprintf_r+0x17ac>
   12758:	06f14603          	lbu	a2,111(sp)
				else
					size = prec;
			} else
				size = strlen (cp);
   1275c:	03512023          	sw	s5,32(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   12760:	03912823          	sw	s9,48(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   12764:	02012423          	sw	zero,40(sp)
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   12768:	02012e23          	sw	zero,60(sp)
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
		if (sign)
   1276c:	00060863          	beqz	a2,1277c <_vfprintf_r+0x4a8>
			realsz++;
   12770:	02012783          	lw	a5,32(sp)
   12774:	00178793          	addi	a5,a5,1
   12778:	02f12023          	sw	a5,32(sp)
		if (flags & HEXPREFIX)
   1277c:	00297693          	andi	a3,s2,2
   12780:	02d12223          	sw	a3,36(sp)
   12784:	00068863          	beqz	a3,12794 <_vfprintf_r+0x4c0>
			realsz+= 2;
   12788:	02012703          	lw	a4,32(sp)
   1278c:	00270713          	addi	a4,a4,2
   12790:	02e12023          	sw	a4,32(sp)

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   12794:	08497793          	andi	a5,s2,132
   12798:	02f12c23          	sw	a5,56(sp)
   1279c:	70079e63          	bnez	a5,12eb8 <_vfprintf_r+0xbe4>
			PAD (width - realsz, blanks);
   127a0:	02012703          	lw	a4,32(sp)
   127a4:	40eb0db3          	sub	s11,s6,a4
   127a8:	71b05863          	blez	s11,12eb8 <_vfprintf_r+0xbe4>
   127ac:	01000813          	li	a6,16
   127b0:	09412783          	lw	a5,148(sp)
   127b4:	09012703          	lw	a4,144(sp)
   127b8:	05712423          	sw	s7,72(sp)
   127bc:	07b85063          	ble	s11,a6,1281c <_vfprintf_r+0x548>
   127c0:	00080c93          	mv	s9,a6
   127c4:	00700a93          	li	s5,7
   127c8:	00c0006f          	j	127d4 <_vfprintf_r+0x500>
   127cc:	ff0d8d93          	addi	s11,s11,-16
   127d0:	05bcd663          	ble	s11,s9,1281c <_vfprintf_r+0x548>
   127d4:	01078793          	addi	a5,a5,16
   127d8:	00170713          	addi	a4,a4,1
   127dc:	0172a023          	sw	s7,0(t0)
   127e0:	0192a223          	sw	s9,4(t0)
   127e4:	08f12a23          	sw	a5,148(sp)
   127e8:	08e12823          	sw	a4,144(sp)
   127ec:	00828293          	addi	t0,t0,8
   127f0:	fceadee3          	ble	a4,s5,127cc <_vfprintf_r+0x4f8>
   127f4:	08c10613          	addi	a2,sp,140
   127f8:	000a0593          	mv	a1,s4
   127fc:	000c0513          	mv	a0,s8
   12800:	095060ef          	jal	19094 <__sprint_r>
   12804:	d8051ae3          	bnez	a0,12598 <_vfprintf_r+0x2c4>
   12808:	ff0d8d93          	addi	s11,s11,-16
   1280c:	09412783          	lw	a5,148(sp)
   12810:	09012703          	lw	a4,144(sp)
   12814:	0c010293          	addi	t0,sp,192
   12818:	fbbccee3          	blt	s9,s11,127d4 <_vfprintf_r+0x500>
   1281c:	04812683          	lw	a3,72(sp)
   12820:	00fd87b3          	add	a5,s11,a5
   12824:	00170713          	addi	a4,a4,1
   12828:	00d2a023          	sw	a3,0(t0)
   1282c:	00700693          	li	a3,7
   12830:	01b2a223          	sw	s11,4(t0)
   12834:	08f12a23          	sw	a5,148(sp)
   12838:	08e12823          	sw	a4,144(sp)
   1283c:	2ee6c8e3          	blt	a3,a4,1332c <_vfprintf_r+0x1058>
   12840:	06f14603          	lbu	a2,111(sp)
   12844:	00828293          	addi	t0,t0,8

		/* prefix */
		if (sign)
   12848:	02060a63          	beqz	a2,1287c <_vfprintf_r+0x5a8>
			PRINT (&sign, 1);
   1284c:	09012703          	lw	a4,144(sp)
   12850:	06f10693          	addi	a3,sp,111
   12854:	00d2a023          	sw	a3,0(t0)
   12858:	00100693          	li	a3,1
   1285c:	00d2a223          	sw	a3,4(t0)
   12860:	00178793          	addi	a5,a5,1
   12864:	00170713          	addi	a4,a4,1
   12868:	00700693          	li	a3,7
   1286c:	08f12a23          	sw	a5,148(sp)
   12870:	08e12823          	sw	a4,144(sp)
   12874:	00828293          	addi	t0,t0,8
   12878:	18e6c0e3          	blt	a3,a4,131f8 <_vfprintf_r+0xf24>
		if (flags & HEXPREFIX)
   1287c:	02412703          	lw	a4,36(sp)
   12880:	02070a63          	beqz	a4,128b4 <_vfprintf_r+0x5e0>
			PRINT (ox, 2);
   12884:	09012703          	lw	a4,144(sp)
   12888:	07010693          	addi	a3,sp,112
   1288c:	00d2a023          	sw	a3,0(t0)
   12890:	00200693          	li	a3,2
   12894:	00d2a223          	sw	a3,4(t0)
   12898:	00278793          	addi	a5,a5,2
   1289c:	00170713          	addi	a4,a4,1
   128a0:	00700693          	li	a3,7
   128a4:	08f12a23          	sw	a5,148(sp)
   128a8:	08e12823          	sw	a4,144(sp)
   128ac:	00828293          	addi	t0,t0,8
   128b0:	16e6c4e3          	blt	a3,a4,13218 <_vfprintf_r+0xf44>

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   128b4:	03812683          	lw	a3,56(sp)
   128b8:	08000713          	li	a4,128
   128bc:	02e682e3          	beq	a3,a4,130e0 <_vfprintf_r+0xe0c>
			PAD (width - realsz, zeroes);

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   128c0:	02812703          	lw	a4,40(sp)
   128c4:	02c12683          	lw	a3,44(sp)
   128c8:	40d70cb3          	sub	s9,a4,a3
   128cc:	0b905863          	blez	s9,1297c <_vfprintf_r+0x6a8>
   128d0:	01000d93          	li	s11,16
   128d4:	09012703          	lw	a4,144(sp)
   128d8:	03a12223          	sw	s10,36(sp)
   128dc:	059dde63          	ble	s9,s11,12938 <_vfprintf_r+0x664>
   128e0:	00700a93          	li	s5,7
   128e4:	00c0006f          	j	128f0 <_vfprintf_r+0x61c>
   128e8:	ff0c8c93          	addi	s9,s9,-16
   128ec:	059dd663          	ble	s9,s11,12938 <_vfprintf_r+0x664>
   128f0:	01078793          	addi	a5,a5,16
   128f4:	00170713          	addi	a4,a4,1
   128f8:	01a2a023          	sw	s10,0(t0)
   128fc:	01b2a223          	sw	s11,4(t0)
   12900:	08f12a23          	sw	a5,148(sp)
   12904:	08e12823          	sw	a4,144(sp)
   12908:	00828293          	addi	t0,t0,8
   1290c:	fceadee3          	ble	a4,s5,128e8 <_vfprintf_r+0x614>
   12910:	08c10613          	addi	a2,sp,140
   12914:	000a0593          	mv	a1,s4
   12918:	000c0513          	mv	a0,s8
   1291c:	778060ef          	jal	19094 <__sprint_r>
   12920:	c6051ce3          	bnez	a0,12598 <_vfprintf_r+0x2c4>
   12924:	ff0c8c93          	addi	s9,s9,-16
   12928:	09412783          	lw	a5,148(sp)
   1292c:	09012703          	lw	a4,144(sp)
   12930:	0c010293          	addi	t0,sp,192
   12934:	fb9dcee3          	blt	s11,s9,128f0 <_vfprintf_r+0x61c>
   12938:	02412683          	lw	a3,36(sp)
   1293c:	019787b3          	add	a5,a5,s9
   12940:	00170713          	addi	a4,a4,1
   12944:	00d2a023          	sw	a3,0(t0)
   12948:	00700693          	li	a3,7
   1294c:	0192a223          	sw	s9,4(t0)
   12950:	08f12a23          	sw	a5,148(sp)
   12954:	08e12823          	sw	a4,144(sp)
   12958:	00828293          	addi	t0,t0,8
   1295c:	02e6d063          	ble	a4,a3,1297c <_vfprintf_r+0x6a8>
   12960:	08c10613          	addi	a2,sp,140
   12964:	000a0593          	mv	a1,s4
   12968:	000c0513          	mv	a0,s8
   1296c:	728060ef          	jal	19094 <__sprint_r>
   12970:	c20514e3          	bnez	a0,12598 <_vfprintf_r+0x2c4>
   12974:	09412783          	lw	a5,148(sp)
   12978:	0c010293          	addi	t0,sp,192

		/* the string or number proper */
#ifdef FLOATING_POINT
		if ((flags & FPT) == 0) {
   1297c:	10097713          	andi	a4,s2,256
   12980:	64071263          	bnez	a4,12fc4 <_vfprintf_r+0xcf0>
			PRINT (cp, size);
   12984:	02c12703          	lw	a4,44(sp)
   12988:	02c12683          	lw	a3,44(sp)
   1298c:	0082a023          	sw	s0,0(t0)
   12990:	00e787b3          	add	a5,a5,a4
   12994:	09012703          	lw	a4,144(sp)
   12998:	00d2a223          	sw	a3,4(t0)
   1299c:	00700693          	li	a3,7
   129a0:	00170713          	addi	a4,a4,1
   129a4:	08f12a23          	sw	a5,148(sp)
   129a8:	08e12823          	sw	a4,144(sp)
   129ac:	5ee6cc63          	blt	a3,a4,12fa4 <_vfprintf_r+0xcd0>
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
   129b0:	00828293          	addi	t0,t0,8
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   129b4:	00497913          	andi	s2,s2,4
   129b8:	0a090a63          	beqz	s2,12a6c <_vfprintf_r+0x798>
			PAD (width - realsz, blanks);
   129bc:	02012703          	lw	a4,32(sp)
   129c0:	40eb0433          	sub	s0,s6,a4
   129c4:	0a805463          	blez	s0,12a6c <_vfprintf_r+0x798>
   129c8:	01000913          	li	s2,16
   129cc:	09012703          	lw	a4,144(sp)
   129d0:	05712423          	sw	s7,72(sp)
   129d4:	04895e63          	ble	s0,s2,12a30 <_vfprintf_r+0x75c>
   129d8:	00700993          	li	s3,7
   129dc:	00c0006f          	j	129e8 <_vfprintf_r+0x714>
   129e0:	ff040413          	addi	s0,s0,-16
   129e4:	04895663          	ble	s0,s2,12a30 <_vfprintf_r+0x75c>
   129e8:	01078793          	addi	a5,a5,16
   129ec:	00170713          	addi	a4,a4,1
   129f0:	0172a023          	sw	s7,0(t0)
   129f4:	0122a223          	sw	s2,4(t0)
   129f8:	08f12a23          	sw	a5,148(sp)
   129fc:	08e12823          	sw	a4,144(sp)
   12a00:	00828293          	addi	t0,t0,8
   12a04:	fce9dee3          	ble	a4,s3,129e0 <_vfprintf_r+0x70c>
   12a08:	08c10613          	addi	a2,sp,140
   12a0c:	000a0593          	mv	a1,s4
   12a10:	000c0513          	mv	a0,s8
   12a14:	680060ef          	jal	19094 <__sprint_r>
   12a18:	b80510e3          	bnez	a0,12598 <_vfprintf_r+0x2c4>
   12a1c:	ff040413          	addi	s0,s0,-16
   12a20:	09412783          	lw	a5,148(sp)
   12a24:	09012703          	lw	a4,144(sp)
   12a28:	0c010293          	addi	t0,sp,192
   12a2c:	fa894ee3          	blt	s2,s0,129e8 <_vfprintf_r+0x714>
   12a30:	04812683          	lw	a3,72(sp)
   12a34:	008787b3          	add	a5,a5,s0
   12a38:	00170713          	addi	a4,a4,1
   12a3c:	00d2a023          	sw	a3,0(t0)
   12a40:	00700693          	li	a3,7
   12a44:	0082a223          	sw	s0,4(t0)
   12a48:	08f12a23          	sw	a5,148(sp)
   12a4c:	08e12823          	sw	a4,144(sp)
   12a50:	00e6de63          	ble	a4,a3,12a6c <_vfprintf_r+0x798>
   12a54:	08c10613          	addi	a2,sp,140
   12a58:	000a0593          	mv	a1,s4
   12a5c:	000c0513          	mv	a0,s8
   12a60:	634060ef          	jal	19094 <__sprint_r>
   12a64:	b2051ae3          	bnez	a0,12598 <_vfprintf_r+0x2c4>
   12a68:	09412783          	lw	a5,148(sp)

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   12a6c:	02012603          	lw	a2,32(sp)
   12a70:	000b0713          	mv	a4,s6
   12a74:	00cb5463          	ble	a2,s6,12a7c <_vfprintf_r+0x7a8>
   12a78:	00060713          	mv	a4,a2
   12a7c:	03412683          	lw	a3,52(sp)
   12a80:	00e686b3          	add	a3,a3,a4
   12a84:	02d12a23          	sw	a3,52(sp)

		FLUSH ();	/* copy out the I/O vectors */
   12a88:	74079c63          	bnez	a5,131e0 <_vfprintf_r+0xf0c>
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   12a8c:	0004c783          	lbu	a5,0(s1)
			PAD (width - realsz, blanks);

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;

		FLUSH ();	/* copy out the I/O vectors */
   12a90:	08012823          	sw	zero,144(sp)
   12a94:	0c010293          	addi	t0,sp,192
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   12a98:	940792e3          	bnez	a5,123dc <_vfprintf_r+0x108>
   12a9c:	00048413          	mv	s0,s1
   12aa0:	99dff06f          	j	1243c <_vfprintf_r+0x168>
   12aa4:	00058463          	beqz	a1,12aac <_vfprintf_r+0x7d8>
   12aa8:	5200106f          	j	13fc8 <_vfprintf_r+0x1cf4>
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   12aac:	01097793          	andi	a5,s2,16
   12ab0:	0e078663          	beqz	a5,12b9c <_vfprintf_r+0x8c8>
   12ab4:	03012683          	lw	a3,48(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12ab8:	02812603          	lw	a2,40(sp)
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   12abc:	0006a783          	lw	a5,0(a3)
   12ac0:	00468713          	addi	a4,a3,4

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   12ac4:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12ac8:	0e064a63          	bltz	a2,12bbc <_vfprintf_r+0x8e8>
				flags &= ~ZEROPAD;
   12acc:	f7f97913          	andi	s2,s2,-129
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   12ad0:	02e12823          	sw	a4,48(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12ad4:	00000613          	li	a2,0
   12ad8:	20078a63          	beqz	a5,12cec <_vfprintf_r+0xa18>
						*--cp = '0';
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   12adc:	00900713          	li	a4,9
   12ae0:	0c010413          	addi	s0,sp,192
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   12ae4:	00a00693          	li	a3,10
						*--cp = '0';
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   12ae8:	74f77a63          	bleu	a5,a4,1323c <_vfprintf_r+0xf68>
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   12aec:	02d7f733          	remu	a4,a5,a3
   12af0:	fff40413          	addi	s0,s0,-1
					       next cases. */
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
   12af4:	02d7d7b3          	divu	a5,a5,a3
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   12af8:	03070713          	addi	a4,a4,48
   12afc:	00e40023          	sb	a4,0(s0)
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
					} while (_uquad != 0);
   12b00:	fe0796e3          	bnez	a5,12aec <_vfprintf_r+0x818>
   12b04:	01c12783          	lw	a5,28(sp)
   12b08:	408787b3          	sub	a5,a5,s0
   12b0c:	02f12623          	sw	a5,44(sp)
   12b10:	1500006f          	j	12c60 <_vfprintf_r+0x98c>
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   12b14:	00000b13          	li	s6,0
   12b18:	fd098893          	addi	a7,s3,-48
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
   12b1c:	00148493          	addi	s1,s1,1
   12b20:	fff4c983          	lbu	s3,-1(s1)
			goto rflag;
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
   12b24:	001b1793          	slli	a5,s6,0x1
   12b28:	003b1b13          	slli	s6,s6,0x3
   12b2c:	01678b33          	add	s6,a5,s6
   12b30:	01688b33          	add	s6,a7,s6
				ch = *fmt++;
			} while (is_digit (ch));
   12b34:	fd098893          	addi	a7,s3,-48
   12b38:	ff1672e3          	bleu	a7,a2,12b1c <_vfprintf_r+0x848>
   12b3c:	93dff06f          	j	12478 <_vfprintf_r+0x1a4>
   12b40:	00058463          	beqz	a1,12b48 <_vfprintf_r+0x874>
   12b44:	4780106f          	j	13fbc <_vfprintf_r+0x1ce8>
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
   12b48:	01096913          	ori	s2,s2,16
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   12b4c:	01097793          	andi	a5,s2,16
   12b50:	ac0790e3          	bnez	a5,12610 <_vfprintf_r+0x33c>
   12b54:	03012683          	lw	a3,48(sp)
   12b58:	04097793          	andi	a5,s2,64
   12b5c:	00468713          	addi	a4,a3,4
   12b60:	200788e3          	beqz	a5,13570 <_vfprintf_r+0x129c>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12b64:	02812603          	lw	a2,40(sp)
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   12b68:	0006d783          	lhu	a5,0(a3)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   12b6c:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12b70:	aa065ce3          	bgez	a2,12628 <_vfprintf_r+0x354>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12b74:	02e12823          	sw	a4,48(sp)
   12b78:	00000613          	li	a2,0
   12b7c:	32078263          	beqz	a5,12ea0 <_vfprintf_r+0xbcc>
   12b80:	00000613          	li	a2,0
   12b84:	ac5ff06f          	j	12648 <_vfprintf_r+0x374>
   12b88:	00058463          	beqz	a1,12b90 <_vfprintf_r+0x8bc>
   12b8c:	4240106f          	j	13fb0 <_vfprintf_r+0x1cdc>
			} else
				size = strlen (cp);

			break;
		case 'U': /* extension */
			flags |= LONGINT;
   12b90:	01096913          	ori	s2,s2,16
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   12b94:	01097793          	andi	a5,s2,16
   12b98:	f0079ee3          	bnez	a5,12ab4 <_vfprintf_r+0x7e0>
   12b9c:	03012683          	lw	a3,48(sp)
   12ba0:	04097793          	andi	a5,s2,64
   12ba4:	00468713          	addi	a4,a3,4
   12ba8:	1a078ae3          	beqz	a5,1355c <_vfprintf_r+0x1288>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12bac:	02812603          	lw	a2,40(sp)
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   12bb0:	0006d783          	lhu	a5,0(a3)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   12bb4:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12bb8:	f0065ae3          	bgez	a2,12acc <_vfprintf_r+0x7f8>
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   12bbc:	02e12823          	sw	a4,48(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12bc0:	00000613          	li	a2,0
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12bc4:	f0079ce3          	bnez	a5,12adc <_vfprintf_r+0x808>
   12bc8:	00100793          	li	a5,1
   12bcc:	2d40006f          	j	12ea0 <_vfprintf_r+0xbcc>
   12bd0:	00058463          	beqz	a1,12bd8 <_vfprintf_r+0x904>
   12bd4:	3d40106f          	j	13fa8 <_vfprintf_r+0x1cd4>
		case 'u':
			_uquad = UARG ();
			base = DEC;
			goto nosign;
		case 'X':
			xdigs = "0123456789ABCDEF";
   12bd8:	0001d7b7          	lui	a5,0x1d
   12bdc:	bf478793          	addi	a5,a5,-1036 # 1cbf4 <__thenan_sf+0x24>
   12be0:	04f12c23          	sw	a5,88(sp)
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
   12be4:	01097793          	andi	a5,s2,16
   12be8:	12078c63          	beqz	a5,12d20 <_vfprintf_r+0xa4c>
   12bec:	03012683          	lw	a3,48(sp)
   12bf0:	0006a783          	lw	a5,0(a3)
   12bf4:	00468693          	addi	a3,a3,4
   12bf8:	02d12823          	sw	a3,48(sp)
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
   12bfc:	00197713          	andi	a4,s2,1
   12c00:	64070c63          	beqz	a4,13258 <_vfprintf_r+0xf84>
   12c04:	400780e3          	beqz	a5,13804 <_vfprintf_r+0x1530>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12c08:	02812603          	lw	a2,40(sp)
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
				ox[0] = '0';
   12c0c:	03000713          	li	a4,48
   12c10:	06e10823          	sb	a4,112(sp)
				ox[1] = ch;
   12c14:	073108a3          	sb	s3,113(sp)
				flags |= HEXPREFIX;
   12c18:	00296713          	ori	a4,s2,2

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   12c1c:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12c20:	760648e3          	bltz	a2,13b90 <_vfprintf_r+0x18bc>
   12c24:	f7f97913          	andi	s2,s2,-129
				flags &= ~ZEROPAD;
   12c28:	00296913          	ori	s2,s2,2
   12c2c:	00000613          	li	a2,0
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12c30:	05812683          	lw	a3,88(sp)
   12c34:	0c010413          	addi	s0,sp,192
					} while (_uquad != 0);
					break;

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   12c38:	00f7f713          	andi	a4,a5,15
   12c3c:	00e68733          	add	a4,a3,a4
   12c40:	00074703          	lbu	a4,0(a4)
   12c44:	fff40413          	addi	s0,s0,-1
						_uquad >>= 4;
   12c48:	0047d793          	srli	a5,a5,0x4
					} while (_uquad != 0);
					break;

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   12c4c:	00e40023          	sb	a4,0(s0)
						_uquad >>= 4;
					} while (_uquad);
   12c50:	fe0794e3          	bnez	a5,12c38 <_vfprintf_r+0x964>
   12c54:	01c12683          	lw	a3,28(sp)
   12c58:	408686b3          	sub	a3,a3,s0
   12c5c:	02d12623          	sw	a3,44(sp)
   12c60:	02c12a83          	lw	s5,44(sp)
   12c64:	02812783          	lw	a5,40(sp)
   12c68:	00fad463          	ble	a5,s5,12c70 <_vfprintf_r+0x99c>
   12c6c:	00078a93          	mv	s5,a5
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   12c70:	03512023          	sw	s5,32(sp)
   12c74:	02012e23          	sw	zero,60(sp)
   12c78:	af5ff06f          	j	1276c <_vfprintf_r+0x498>
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   12c7c:	03012603          	lw	a2,48(sp)
				size = 1;
			}
			sign = '\0';
			break;
   12c80:	00100713          	li	a4,1
   12c84:	02e12023          	sw	a4,32(sp)
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   12c88:	00062783          	lw	a5,0(a2) # 2000 <_reset+0x1e00>
   12c8c:	00460613          	addi	a2,a2,4
				size = 1;
			}
			sign = '\0';
   12c90:	060107a3          	sb	zero,111(sp)
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   12c94:	08f10c23          	sb	a5,152(sp)
   12c98:	02c12823          	sw	a2,48(sp)
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
   12c9c:	00000613          	li	a2,0
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
   12ca0:	02e12623          	sw	a4,44(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   12ca4:	02012423          	sw	zero,40(sp)
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   12ca8:	02012e23          	sw	zero,60(sp)
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
   12cac:	09810413          	addi	s0,sp,152
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
   12cb0:	acdff06f          	j	1277c <_vfprintf_r+0x4a8>
   12cb4:	00058463          	beqz	a1,12cbc <_vfprintf_r+0x9e8>
   12cb8:	2cc0106f          	j	13f84 <_vfprintf_r+0x1cb0>
		case 'D':  /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   12cbc:	01097793          	andi	a5,s2,16
   12cc0:	12078a63          	beqz	a5,12df4 <_vfprintf_r+0xb20>
   12cc4:	03012603          	lw	a2,48(sp)
   12cc8:	00062783          	lw	a5,0(a2)
   12ccc:	00460613          	addi	a2,a2,4
   12cd0:	02c12823          	sw	a2,48(sp)
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
#else
			if ((long) _uquad < 0)
   12cd4:	1207c4e3          	bltz	a5,135fc <_vfprintf_r+0x1328>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12cd8:	02812683          	lw	a3,40(sp)
   12cdc:	06f14603          	lbu	a2,111(sp)
   12ce0:	ee06c2e3          	bltz	a3,12bc4 <_vfprintf_r+0x8f0>
				flags &= ~ZEROPAD;
   12ce4:	f7f97913          	andi	s2,s2,-129
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12ce8:	de079ae3          	bnez	a5,12adc <_vfprintf_r+0x808>
   12cec:	02812703          	lw	a4,40(sp)
   12cf0:	54071463          	bnez	a4,13238 <_vfprintf_r+0xf64>
   12cf4:	02012423          	sw	zero,40(sp)
   12cf8:	02012623          	sw	zero,44(sp)
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   12cfc:	0c010413          	addi	s0,sp,192
   12d00:	f61ff06f          	j	12c60 <_vfprintf_r+0x98c>
   12d04:	00058463          	beqz	a1,12d0c <_vfprintf_r+0xa38>
   12d08:	2980106f          	j	13fa0 <_vfprintf_r+0x1ccc>
			goto nosign;
		case 'X':
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
   12d0c:	0001d7b7          	lui	a5,0x1d
   12d10:	c0878793          	addi	a5,a5,-1016 # 1cc08 <__thenan_sf+0x38>
   12d14:	04f12c23          	sw	a5,88(sp)
hex:			_uquad = UARG ();
   12d18:	01097793          	andi	a5,s2,16
   12d1c:	ec0798e3          	bnez	a5,12bec <_vfprintf_r+0x918>
   12d20:	04097793          	andi	a5,s2,64
   12d24:	2c0786e3          	beqz	a5,137f0 <_vfprintf_r+0x151c>
   12d28:	03012703          	lw	a4,48(sp)
   12d2c:	00075783          	lhu	a5,0(a4)
   12d30:	00470713          	addi	a4,a4,4
   12d34:	02e12823          	sw	a4,48(sp)
   12d38:	ec5ff06f          	j	12bfc <_vfprintf_r+0x928>
   12d3c:	00058463          	beqz	a1,12d44 <_vfprintf_r+0xa70>
   12d40:	2580106f          	j	13f98 <_vfprintf_r+0x1cc4>
		case 'E':
		case 'f':
		case 'g':
		case 'G':
# ifdef _NO_LONGDBL
			if (flags & LONGDBL) {
   12d44:	00897793          	andi	a5,s2,8
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
   12d48:	03012603          	lw	a2,48(sp)
		case 'E':
		case 'f':
		case 'g':
		case 'G':
# ifdef _NO_LONGDBL
			if (flags & LONGDBL) {
   12d4c:	280780e3          	beqz	a5,137cc <_vfprintf_r+0x14f8>
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
   12d50:	00760793          	addi	a5,a2,7
   12d54:	ff87f793          	andi	a5,a5,-8
   12d58:	00878693          	addi	a3,a5,8
   12d5c:	0007a703          	lw	a4,0(a5)
   12d60:	0047a783          	lw	a5,4(a5)
   12d64:	02d12823          	sw	a3,48(sp)
   12d68:	04e12823          	sw	a4,80(sp)
   12d6c:	04f12a23          	sw	a5,84(sp)

			   If the output is infinite or NaN, leading
			   zeros are not permitted.  Otherwise, scanf
			   could not read what printf wrote.
			 */
			if (isinf (_fpvalue)) {
   12d70:	05012503          	lw	a0,80(sp)
   12d74:	05412583          	lw	a1,84(sp)
   12d78:	00512a23          	sw	t0,20(sp)
   12d7c:	00100413          	li	s0,1
   12d80:	735050ef          	jal	18cb4 <__fpclassifyd>
   12d84:	01412283          	lw	t0,20(sp)
   12d88:	08851ae3          	bne	a0,s0,1361c <_vfprintf_r+0x1348>
				if (_fpvalue < 0)
   12d8c:	05012503          	lw	a0,80(sp)
   12d90:	05412583          	lw	a1,84(sp)
   12d94:	00000613          	li	a2,0
   12d98:	00000693          	li	a3,0
   12d9c:	03d080ef          	jal	1b5d8 <__ltdf2>
   12da0:	01412283          	lw	t0,20(sp)
   12da4:	600544e3          	bltz	a0,13bac <_vfprintf_r+0x18d8>
   12da8:	06f14603          	lbu	a2,111(sp)
					sign = '-';
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
   12dac:	04700793          	li	a5,71
   12db0:	3b37dae3          	ble	s3,a5,13964 <_vfprintf_r+0x1690>
					cp = "INF";
				else
					cp = "inf";
   12db4:	0001d437          	lui	s0,0x1d
   12db8:	be840413          	addi	s0,s0,-1048 # 1cbe8 <__thenan_sf+0x18>
				size = 3;
				flags &= ~ZEROPAD;
				break;
   12dbc:	00300793          	li	a5,3
   12dc0:	02f12023          	sw	a5,32(sp)
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "INF";
				else
					cp = "inf";
				size = 3;
				flags &= ~ZEROPAD;
   12dc4:	f7f97913          	andi	s2,s2,-129
					sign = '-';
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "INF";
				else
					cp = "inf";
				size = 3;
   12dc8:	02f12623          	sw	a5,44(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   12dcc:	02012423          	sw	zero,40(sp)
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   12dd0:	02012e23          	sw	zero,60(sp)
					cp = "INF";
				else
					cp = "inf";
				size = 3;
				flags &= ~ZEROPAD;
				break;
   12dd4:	999ff06f          	j	1276c <_vfprintf_r+0x498>
#endif /* !_NO_POS_ARGS */
			width = n;
			goto reswitch;
#ifdef FLOATING_POINT
		case 'L':
			flags |= LONGDBL;
   12dd8:	00896913          	ori	s2,s2,8
			goto rflag;
   12ddc:	e94ff06f          	j	12470 <_vfprintf_r+0x19c>
   12de0:	00058463          	beqz	a1,12de8 <_vfprintf_r+0xb14>
   12de4:	1a80106f          	j	13f8c <_vfprintf_r+0x1cb8>
				size = 1;
			}
			sign = '\0';
			break;
		case 'D':  /* extension */
			flags |= LONGINT;
   12de8:	01096913          	ori	s2,s2,16
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   12dec:	01097793          	andi	a5,s2,16
   12df0:	ec079ae3          	bnez	a5,12cc4 <_vfprintf_r+0x9f0>
   12df4:	04097793          	andi	a5,s2,64
   12df8:	1c0780e3          	beqz	a5,137b8 <_vfprintf_r+0x14e4>
   12dfc:	03012683          	lw	a3,48(sp)
   12e00:	00069783          	lh	a5,0(a3)
   12e04:	00468693          	addi	a3,a3,4
   12e08:	02d12823          	sw	a3,48(sp)
   12e0c:	ec9ff06f          	j	12cd4 <_vfprintf_r+0xa00>
   12e10:	00058463          	beqz	a1,12e18 <_vfprintf_r+0xb44>
   12e14:	1e40106f          	j	13ff8 <_vfprintf_r+0x1d24>
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
				*GET_ARG (N, ap, quad_ptr_t) = ret;
			else
#endif
			if (flags & LONGINT)
   12e18:	01097793          	andi	a5,s2,16
   12e1c:	16078ce3          	beqz	a5,13794 <_vfprintf_r+0x14c0>
				*GET_ARG (N, ap, long_ptr_t) = ret;
   12e20:	03012683          	lw	a3,48(sp)
   12e24:	03412703          	lw	a4,52(sp)
   12e28:	0006a783          	lw	a5,0(a3)
   12e2c:	00468693          	addi	a3,a3,4
   12e30:	02d12823          	sw	a3,48(sp)
   12e34:	00e7a023          	sw	a4,0(a5)
   12e38:	d9cff06f          	j	123d4 <_vfprintf_r+0x100>
			if (*fmt == 'h') {
				fmt++;
				flags |= CHARINT;
			} else
#endif
				flags |= SHORTINT;
   12e3c:	04096913          	ori	s2,s2,64
			goto rflag;
   12e40:	e30ff06f          	j	12470 <_vfprintf_r+0x19c>
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   12e44:	0001d737          	lui	a4,0x1d
   12e48:	c0870713          	addi	a4,a4,-1016 # 1cc08 <__thenan_sf+0x38>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12e4c:	00000613          	li	a2,0
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   12e50:	04e12c23          	sw	a4,88(sp)
			flags |= HEXPREFIX;
			ox[0] = '0';
			ox[1] = ch = 'x';
   12e54:	07800993          	li	s3,120
   12e58:	dd9ff06f          	j	12c30 <_vfprintf_r+0x95c>
   12e5c:	00058463          	beqz	a1,12e64 <_vfprintf_r+0xb90>
   12e60:	1900106f          	j	13ff0 <_vfprintf_r+0x1d1c>

			size = buf + BUF - cp;
		skipsize:
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
   12e64:	f0098e63          	beqz	s3,12580 <_vfprintf_r+0x2ac>
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
   12e68:	00100713          	li	a4,1
   12e6c:	02e12023          	sw	a4,32(sp)
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
   12e70:	09310c23          	sb	s3,152(sp)
			size = 1;
			sign = '\0';
   12e74:	060107a3          	sb	zero,111(sp)
   12e78:	e25ff06f          	j	12c9c <_vfprintf_r+0x9c8>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   12e7c:	02e12823          	sw	a4,48(sp)
			base = HEX;
			xdigs = "0123456789abcdef";
   12e80:	0001d737          	lui	a4,0x1d
   12e84:	c0870713          	addi	a4,a4,-1016 # 1cc08 <__thenan_sf+0x38>
			flags |= HEXPREFIX;
   12e88:	00060913          	mv	s2,a2
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   12e8c:	04e12c23          	sw	a4,88(sp)
			flags |= HEXPREFIX;
			ox[0] = '0';
			ox[1] = ch = 'x';
   12e90:	07800993          	li	s3,120
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12e94:	3c079c63          	bnez	a5,1326c <_vfprintf_r+0xf98>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12e98:	00000613          	li	a2,0
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
   12e9c:	00200793          	li	a5,2
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   12ea0:	00100713          	li	a4,1
   12ea4:	38e78a63          	beq	a5,a4,13238 <_vfprintf_r+0xf64>
   12ea8:	00200713          	li	a4,2
   12eac:	e6e78663          	beq	a5,a4,12518 <_vfprintf_r+0x244>
   12eb0:	00000793          	li	a5,0
   12eb4:	f94ff06f          	j	12648 <_vfprintf_r+0x374>
   12eb8:	09412783          	lw	a5,148(sp)
   12ebc:	98dff06f          	j	12848 <_vfprintf_r+0x574>
					PRINTANDPAD (cp, convbuf + ndig,
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
   12ec0:	09012983          	lw	s3,144(sp)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
   12ec4:	04012603          	lw	a2,64(sp)
   12ec8:	00100713          	li	a4,1
					PRINT (cp, 1);
   12ecc:	00178793          	addi	a5,a5,1
   12ed0:	00198993          	addi	s3,s3,1
   12ed4:	0082a023          	sw	s0,0(t0)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
   12ed8:	2cc75263          	ble	a2,a4,1319c <_vfprintf_r+0xec8>
					PRINT (cp, 1);
   12edc:	00100713          	li	a4,1
   12ee0:	00e2a223          	sw	a4,4(t0)
   12ee4:	00700713          	li	a4,7
   12ee8:	08f12a23          	sw	a5,148(sp)
   12eec:	09312823          	sw	s3,144(sp)
   12ef0:	00828293          	addi	t0,t0,8
   12ef4:	69374863          	blt	a4,s3,13584 <_vfprintf_r+0x12b0>
					cp++;
					PRINT (decimal_point, decp_len);
   12ef8:	04c12683          	lw	a3,76(sp)
   12efc:	04412703          	lw	a4,68(sp)
   12f00:	00198993          	addi	s3,s3,1
   12f04:	00f687b3          	add	a5,a3,a5
   12f08:	00e2a023          	sw	a4,0(t0)
   12f0c:	00700713          	li	a4,7
   12f10:	00d2a223          	sw	a3,4(t0)
   12f14:	08f12a23          	sw	a5,148(sp)
   12f18:	09312823          	sw	s3,144(sp)
   12f1c:	00828c93          	addi	s9,t0,8
   12f20:	69374663          	blt	a4,s3,135ac <_vfprintf_r+0x12d8>
					if (_fpvalue) {
   12f24:	05012503          	lw	a0,80(sp)
   12f28:	05412583          	lw	a1,84(sp)
   12f2c:	00000613          	li	a2,0
   12f30:	00000693          	li	a3,0
   12f34:	00f12c23          	sw	a5,24(sp)
   12f38:	6a4080ef          	jal	1b5dc <__nedf2>
   12f3c:	01812783          	lw	a5,24(sp)
   12f40:	40050863          	beqz	a0,13350 <_vfprintf_r+0x107c>
						PRINT (cp, ndig - 1);
   12f44:	04012603          	lw	a2,64(sp)
   12f48:	00140413          	addi	s0,s0,1
   12f4c:	00198993          	addi	s3,s3,1
   12f50:	fff60713          	addi	a4,a2,-1
   12f54:	00e787b3          	add	a5,a5,a4
   12f58:	00eca223          	sw	a4,4(s9)
   12f5c:	00700713          	li	a4,7
   12f60:	008ca023          	sw	s0,0(s9)
   12f64:	08f12a23          	sw	a5,148(sp)
   12f68:	09312823          	sw	s3,144(sp)
   12f6c:	25374863          	blt	a4,s3,131bc <_vfprintf_r+0xee8>
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
   12f70:	008c8c93          	addi	s9,s9,8
				} else	/* XeYYY */
					PRINT (cp, 1);
				PRINT (expstr, expsize);
   12f74:	05c12703          	lw	a4,92(sp)
   12f78:	05c12603          	lw	a2,92(sp)
   12f7c:	00198993          	addi	s3,s3,1
   12f80:	00f707b3          	add	a5,a4,a5
   12f84:	07c10713          	addi	a4,sp,124
   12f88:	00eca023          	sw	a4,0(s9)
   12f8c:	00700713          	li	a4,7
   12f90:	00cca223          	sw	a2,4(s9)
   12f94:	08f12a23          	sw	a5,148(sp)
   12f98:	09312823          	sw	s3,144(sp)
   12f9c:	008c8293          	addi	t0,s9,8
   12fa0:	a1375ae3          	ble	s3,a4,129b4 <_vfprintf_r+0x6e0>
   12fa4:	08c10613          	addi	a2,sp,140
   12fa8:	000a0593          	mv	a1,s4
   12fac:	000c0513          	mv	a0,s8
   12fb0:	0e4060ef          	jal	19094 <__sprint_r>
   12fb4:	de051263          	bnez	a0,12598 <_vfprintf_r+0x2c4>
   12fb8:	09412783          	lw	a5,148(sp)
   12fbc:	0c010293          	addi	t0,sp,192
   12fc0:	9f5ff06f          	j	129b4 <_vfprintf_r+0x6e0>
		/* the string or number proper */
#ifdef FLOATING_POINT
		if ((flags & FPT) == 0) {
			PRINT (cp, size);
		} else {	/* glue together f_p fragments */
			if (ch >= 'f') {	/* 'f' or 'g' */
   12fc4:	06500713          	li	a4,101
   12fc8:	ef375ce3          	ble	s3,a4,12ec0 <_vfprintf_r+0xbec>
				if (_fpvalue == 0) {
   12fcc:	05012503          	lw	a0,80(sp)
   12fd0:	05412583          	lw	a1,84(sp)
   12fd4:	00000613          	li	a2,0
   12fd8:	00000693          	li	a3,0
   12fdc:	00512a23          	sw	t0,20(sp)
   12fe0:	00f12c23          	sw	a5,24(sp)
   12fe4:	5fc080ef          	jal	1b5e0 <__eqdf2>
   12fe8:	01412283          	lw	t0,20(sp)
   12fec:	01812783          	lw	a5,24(sp)
   12ff0:	28051263          	bnez	a0,13274 <_vfprintf_r+0xfa0>
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
   12ff4:	09012703          	lw	a4,144(sp)
   12ff8:	00100693          	li	a3,1
   12ffc:	0001d637          	lui	a2,0x1d
   13000:	00d2a223          	sw	a3,4(t0)
   13004:	00178793          	addi	a5,a5,1
   13008:	00170713          	addi	a4,a4,1
   1300c:	c2460613          	addi	a2,a2,-988 # 1cc24 <__thenan_sf+0x54>
   13010:	00700693          	li	a3,7
   13014:	00c2a023          	sw	a2,0(t0)
   13018:	08f12a23          	sw	a5,148(sp)
   1301c:	08e12823          	sw	a4,144(sp)
   13020:	00828293          	addi	t0,t0,8
   13024:	7ee6ca63          	blt	a3,a4,13818 <_vfprintf_r+0x1544>
					if (expt < ndig || flags & ALT) {
   13028:	07412703          	lw	a4,116(sp)
   1302c:	04012683          	lw	a3,64(sp)
   13030:	00d74663          	blt	a4,a3,1303c <_vfprintf_r+0xd68>
   13034:	00197713          	andi	a4,s2,1
   13038:	96070ee3          	beqz	a4,129b4 <_vfprintf_r+0x6e0>
						PRINT (decimal_point, decp_len);
   1303c:	04c12703          	lw	a4,76(sp)
   13040:	04c12683          	lw	a3,76(sp)
   13044:	04412603          	lw	a2,68(sp)
   13048:	00e787b3          	add	a5,a5,a4
   1304c:	09012703          	lw	a4,144(sp)
   13050:	00d2a223          	sw	a3,4(t0)
   13054:	00700693          	li	a3,7
   13058:	00170713          	addi	a4,a4,1
   1305c:	00c2a023          	sw	a2,0(t0)
   13060:	08f12a23          	sw	a5,148(sp)
   13064:	08e12823          	sw	a4,144(sp)
   13068:	00828293          	addi	t0,t0,8
   1306c:	1ce6c8e3          	blt	a3,a4,13a3c <_vfprintf_r+0x1768>
						PAD (ndig - 1, zeroes);
   13070:	04012703          	lw	a4,64(sp)
   13074:	fff70413          	addi	s0,a4,-1
   13078:	92805ee3          	blez	s0,129b4 <_vfprintf_r+0x6e0>
   1307c:	01000993          	li	s3,16
   13080:	09012703          	lw	a4,144(sp)
   13084:	03a12223          	sw	s10,36(sp)
   13088:	3289de63          	ble	s0,s3,133c4 <_vfprintf_r+0x10f0>
   1308c:	00700c93          	li	s9,7
   13090:	00c0006f          	j	1309c <_vfprintf_r+0xdc8>
   13094:	ff040413          	addi	s0,s0,-16
   13098:	3289d663          	ble	s0,s3,133c4 <_vfprintf_r+0x10f0>
   1309c:	01078793          	addi	a5,a5,16
   130a0:	00170713          	addi	a4,a4,1
   130a4:	01a2a023          	sw	s10,0(t0)
   130a8:	0132a223          	sw	s3,4(t0)
   130ac:	08f12a23          	sw	a5,148(sp)
   130b0:	08e12823          	sw	a4,144(sp)
   130b4:	00828293          	addi	t0,t0,8
   130b8:	fcecdee3          	ble	a4,s9,13094 <_vfprintf_r+0xdc0>
   130bc:	08c10613          	addi	a2,sp,140
   130c0:	000a0593          	mv	a1,s4
   130c4:	000c0513          	mv	a0,s8
   130c8:	7cd050ef          	jal	19094 <__sprint_r>
   130cc:	cc051663          	bnez	a0,12598 <_vfprintf_r+0x2c4>
   130d0:	09412783          	lw	a5,148(sp)
   130d4:	09012703          	lw	a4,144(sp)
   130d8:	0c010293          	addi	t0,sp,192
   130dc:	fb9ff06f          	j	13094 <_vfprintf_r+0xdc0>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   130e0:	02012703          	lw	a4,32(sp)
   130e4:	40eb0cb3          	sub	s9,s6,a4
   130e8:	fd905c63          	blez	s9,128c0 <_vfprintf_r+0x5ec>
   130ec:	01000d93          	li	s11,16
   130f0:	09012703          	lw	a4,144(sp)
   130f4:	03a12223          	sw	s10,36(sp)
   130f8:	059dde63          	ble	s9,s11,13154 <_vfprintf_r+0xe80>
   130fc:	00700a93          	li	s5,7
   13100:	00c0006f          	j	1310c <_vfprintf_r+0xe38>
   13104:	ff0c8c93          	addi	s9,s9,-16
   13108:	059dd663          	ble	s9,s11,13154 <_vfprintf_r+0xe80>
   1310c:	01078793          	addi	a5,a5,16
   13110:	00170713          	addi	a4,a4,1
   13114:	01a2a023          	sw	s10,0(t0)
   13118:	01b2a223          	sw	s11,4(t0)
   1311c:	08f12a23          	sw	a5,148(sp)
   13120:	08e12823          	sw	a4,144(sp)
   13124:	00828293          	addi	t0,t0,8
   13128:	fceadee3          	ble	a4,s5,13104 <_vfprintf_r+0xe30>
   1312c:	08c10613          	addi	a2,sp,140
   13130:	000a0593          	mv	a1,s4
   13134:	000c0513          	mv	a0,s8
   13138:	75d050ef          	jal	19094 <__sprint_r>
   1313c:	c4051e63          	bnez	a0,12598 <_vfprintf_r+0x2c4>
   13140:	ff0c8c93          	addi	s9,s9,-16
   13144:	09412783          	lw	a5,148(sp)
   13148:	09012703          	lw	a4,144(sp)
   1314c:	0c010293          	addi	t0,sp,192
   13150:	fb9dcee3          	blt	s11,s9,1310c <_vfprintf_r+0xe38>
   13154:	02412683          	lw	a3,36(sp)
   13158:	019787b3          	add	a5,a5,s9
   1315c:	00170713          	addi	a4,a4,1
   13160:	00d2a023          	sw	a3,0(t0)
   13164:	00700693          	li	a3,7
   13168:	0192a223          	sw	s9,4(t0)
   1316c:	08f12a23          	sw	a5,148(sp)
   13170:	08e12823          	sw	a4,144(sp)
   13174:	00828293          	addi	t0,t0,8
   13178:	f4e6d463          	ble	a4,a3,128c0 <_vfprintf_r+0x5ec>
   1317c:	08c10613          	addi	a2,sp,140
   13180:	000a0593          	mv	a1,s4
   13184:	000c0513          	mv	a0,s8
   13188:	70d050ef          	jal	19094 <__sprint_r>
   1318c:	c0051663          	bnez	a0,12598 <_vfprintf_r+0x2c4>
   13190:	09412783          	lw	a5,148(sp)
   13194:	0c010293          	addi	t0,sp,192
   13198:	f28ff06f          	j	128c0 <_vfprintf_r+0x5ec>
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
   1319c:	00e976b3          	and	a3,s2,a4
   131a0:	d2069ee3          	bnez	a3,12edc <_vfprintf_r+0xc08>
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
				} else	/* XeYYY */
					PRINT (cp, 1);
   131a4:	00e2a223          	sw	a4,4(t0)
   131a8:	00700713          	li	a4,7
   131ac:	08f12a23          	sw	a5,148(sp)
   131b0:	09312823          	sw	s3,144(sp)
   131b4:	00828c93          	addi	s9,t0,8
   131b8:	db375ee3          	ble	s3,a4,12f74 <_vfprintf_r+0xca0>
   131bc:	08c10613          	addi	a2,sp,140
   131c0:	000a0593          	mv	a1,s4
   131c4:	000c0513          	mv	a0,s8
   131c8:	6cd050ef          	jal	19094 <__sprint_r>
   131cc:	bc051663          	bnez	a0,12598 <_vfprintf_r+0x2c4>
   131d0:	09412783          	lw	a5,148(sp)
   131d4:	09012983          	lw	s3,144(sp)
   131d8:	0c010c93          	addi	s9,sp,192
   131dc:	d99ff06f          	j	12f74 <_vfprintf_r+0xca0>
			PAD (width - realsz, blanks);

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;

		FLUSH ();	/* copy out the I/O vectors */
   131e0:	08c10613          	addi	a2,sp,140
   131e4:	000a0593          	mv	a1,s4
   131e8:	000c0513          	mv	a0,s8
   131ec:	6a9050ef          	jal	19094 <__sprint_r>
   131f0:	88050ee3          	beqz	a0,12a8c <_vfprintf_r+0x7b8>
   131f4:	ba4ff06f          	j	12598 <_vfprintf_r+0x2c4>
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
   131f8:	08c10613          	addi	a2,sp,140
   131fc:	000a0593          	mv	a1,s4
   13200:	000c0513          	mv	a0,s8
   13204:	691050ef          	jal	19094 <__sprint_r>
   13208:	b8051863          	bnez	a0,12598 <_vfprintf_r+0x2c4>
   1320c:	09412783          	lw	a5,148(sp)
   13210:	0c010293          	addi	t0,sp,192
   13214:	e68ff06f          	j	1287c <_vfprintf_r+0x5a8>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);
   13218:	08c10613          	addi	a2,sp,140
   1321c:	000a0593          	mv	a1,s4
   13220:	000c0513          	mv	a0,s8
   13224:	671050ef          	jal	19094 <__sprint_r>
   13228:	b6051863          	bnez	a0,12598 <_vfprintf_r+0x2c4>
   1322c:	09412783          	lw	a5,148(sp)
   13230:	0c010293          	addi	t0,sp,192
   13234:	e80ff06f          	j	128b4 <_vfprintf_r+0x5e0>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   13238:	00000793          	li	a5,0
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
						*--cp = to_char(_uquad);
   1323c:	03078793          	addi	a5,a5,48
   13240:	0bf10413          	addi	s0,sp,191
   13244:	0af10fa3          	sb	a5,191(sp)
   13248:	01c12703          	lw	a4,28(sp)
   1324c:	40870733          	sub	a4,a4,s0
   13250:	02e12623          	sw	a4,44(sp)
						break;
   13254:	a0dff06f          	j	12c60 <_vfprintf_r+0x98c>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   13258:	02812683          	lw	a3,40(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   1325c:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   13260:	c206cae3          	bltz	a3,12e94 <_vfprintf_r+0xbc0>
				flags &= ~ZEROPAD;
   13264:	f7f97913          	andi	s2,s2,-129
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   13268:	aa078263          	beqz	a5,1250c <_vfprintf_r+0x238>
   1326c:	00000613          	li	a2,0
   13270:	9c1ff06f          	j	12c30 <_vfprintf_r+0x95c>
					PRINT ("0", 1);
					if (expt < ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
   13274:	07412983          	lw	s3,116(sp)
   13278:	5d305263          	blez	s3,1383c <_vfprintf_r+0x1568>
   1327c:	03c12983          	lw	s3,60(sp)
   13280:	04012703          	lw	a4,64(sp)
   13284:	01375463          	ble	s3,a4,1328c <_vfprintf_r+0xfb8>
   13288:	00070993          	mv	s3,a4
						PAD (-expt, zeroes);
						PRINT (cp, ndig);
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
   1328c:	03305663          	blez	s3,132b8 <_vfprintf_r+0xfe4>
   13290:	09012703          	lw	a4,144(sp)
   13294:	013787b3          	add	a5,a5,s3
   13298:	00700693          	li	a3,7
   1329c:	00170713          	addi	a4,a4,1
   132a0:	0082a023          	sw	s0,0(t0)
   132a4:	0132a223          	sw	s3,4(t0)
   132a8:	08f12a23          	sw	a5,148(sp)
   132ac:	08e12823          	sw	a4,144(sp)
   132b0:	00828293          	addi	t0,t0,8
   132b4:	6ae6ce63          	blt	a3,a4,13970 <_vfprintf_r+0x169c>
   132b8:	0409c8e3          	bltz	s3,13b08 <_vfprintf_r+0x1834>
   132bc:	03c12703          	lw	a4,60(sp)
   132c0:	413709b3          	sub	s3,a4,s3
   132c4:	17305663          	blez	s3,13430 <_vfprintf_r+0x115c>
   132c8:	01000c93          	li	s9,16
   132cc:	09012703          	lw	a4,144(sp)
   132d0:	03a12223          	sw	s10,36(sp)
   132d4:	113cdc63          	ble	s3,s9,133ec <_vfprintf_r+0x1118>
   132d8:	00700d93          	li	s11,7
   132dc:	00c0006f          	j	132e8 <_vfprintf_r+0x1014>
   132e0:	ff098993          	addi	s3,s3,-16
   132e4:	113cd463          	ble	s3,s9,133ec <_vfprintf_r+0x1118>
   132e8:	01078793          	addi	a5,a5,16
   132ec:	00170713          	addi	a4,a4,1
   132f0:	01a2a023          	sw	s10,0(t0)
   132f4:	0192a223          	sw	s9,4(t0)
   132f8:	08f12a23          	sw	a5,148(sp)
   132fc:	08e12823          	sw	a4,144(sp)
   13300:	00828293          	addi	t0,t0,8
   13304:	fceddee3          	ble	a4,s11,132e0 <_vfprintf_r+0x100c>
   13308:	08c10613          	addi	a2,sp,140
   1330c:	000a0593          	mv	a1,s4
   13310:	000c0513          	mv	a0,s8
   13314:	581050ef          	jal	19094 <__sprint_r>
   13318:	a8051063          	bnez	a0,12598 <_vfprintf_r+0x2c4>
   1331c:	09412783          	lw	a5,148(sp)
   13320:	09012703          	lw	a4,144(sp)
   13324:	0c010293          	addi	t0,sp,192
   13328:	fb9ff06f          	j	132e0 <_vfprintf_r+0x100c>
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   1332c:	08c10613          	addi	a2,sp,140
   13330:	000a0593          	mv	a1,s4
   13334:	000c0513          	mv	a0,s8
   13338:	55d050ef          	jal	19094 <__sprint_r>
   1333c:	a4051e63          	bnez	a0,12598 <_vfprintf_r+0x2c4>
   13340:	06f14603          	lbu	a2,111(sp)
   13344:	09412783          	lw	a5,148(sp)
   13348:	0c010293          	addi	t0,sp,192
   1334c:	cfcff06f          	j	12848 <_vfprintf_r+0x574>
					PRINT (decimal_point, decp_len);
					if (_fpvalue) {
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
   13350:	04012703          	lw	a4,64(sp)
   13354:	fff70413          	addi	s0,a4,-1
   13358:	c0805ee3          	blez	s0,12f74 <_vfprintf_r+0xca0>
   1335c:	01000d93          	li	s11,16
   13360:	03a12223          	sw	s10,36(sp)
   13364:	268dd863          	ble	s0,s11,135d4 <_vfprintf_r+0x1300>
   13368:	00700713          	li	a4,7
   1336c:	00c0006f          	j	13378 <_vfprintf_r+0x10a4>
   13370:	ff040413          	addi	s0,s0,-16
   13374:	268dd063          	ble	s0,s11,135d4 <_vfprintf_r+0x1300>
   13378:	01078793          	addi	a5,a5,16
   1337c:	00198993          	addi	s3,s3,1
   13380:	01aca023          	sw	s10,0(s9)
   13384:	01bca223          	sw	s11,4(s9)
   13388:	08f12a23          	sw	a5,148(sp)
   1338c:	09312823          	sw	s3,144(sp)
   13390:	008c8c93          	addi	s9,s9,8
   13394:	fd375ee3          	ble	s3,a4,13370 <_vfprintf_r+0x109c>
   13398:	08c10613          	addi	a2,sp,140
   1339c:	000a0593          	mv	a1,s4
   133a0:	000c0513          	mv	a0,s8
   133a4:	00e12c23          	sw	a4,24(sp)
   133a8:	4ed050ef          	jal	19094 <__sprint_r>
   133ac:	01812703          	lw	a4,24(sp)
   133b0:	9e051463          	bnez	a0,12598 <_vfprintf_r+0x2c4>
   133b4:	09412783          	lw	a5,148(sp)
   133b8:	09012983          	lw	s3,144(sp)
   133bc:	0c010c93          	addi	s9,sp,192
   133c0:	fb1ff06f          	j	13370 <_vfprintf_r+0x109c>
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
   133c4:	02412683          	lw	a3,36(sp)
   133c8:	008787b3          	add	a5,a5,s0
   133cc:	00170713          	addi	a4,a4,1
   133d0:	00d2a023          	sw	a3,0(t0)
   133d4:	00700693          	li	a3,7
   133d8:	0082a223          	sw	s0,4(t0)
   133dc:	08f12a23          	sw	a5,148(sp)
   133e0:	08e12823          	sw	a4,144(sp)
   133e4:	dce6d663          	ble	a4,a3,129b0 <_vfprintf_r+0x6dc>
   133e8:	bbdff06f          	j	12fa4 <_vfprintf_r+0xcd0>
						PAD (-expt, zeroes);
						PRINT (cp, ndig);
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
   133ec:	02412683          	lw	a3,36(sp)
   133f0:	013787b3          	add	a5,a5,s3
   133f4:	00170713          	addi	a4,a4,1
   133f8:	00d2a023          	sw	a3,0(t0)
   133fc:	00700693          	li	a3,7
   13400:	0132a223          	sw	s3,4(t0)
   13404:	08f12a23          	sw	a5,148(sp)
   13408:	08e12823          	sw	a4,144(sp)
   1340c:	00828293          	addi	t0,t0,8
   13410:	02e6d063          	ble	a4,a3,13430 <_vfprintf_r+0x115c>
   13414:	08c10613          	addi	a2,sp,140
   13418:	000a0593          	mv	a1,s4
   1341c:	000c0513          	mv	a0,s8
   13420:	475050ef          	jal	19094 <__sprint_r>
   13424:	96051a63          	bnez	a0,12598 <_vfprintf_r+0x2c4>
   13428:	09412783          	lw	a5,148(sp)
   1342c:	0c010293          	addi	t0,sp,192
						    lead, zeroes);
					cp += lead;
   13430:	03c12603          	lw	a2,60(sp)
					    }
					    if (cp > convbuf + ndig)
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
   13434:	07412703          	lw	a4,116(sp)
   13438:	04012683          	lw	a3,64(sp)
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
						    lead, zeroes);
					cp += lead;
   1343c:	00c409b3          	add	s3,s0,a2
					    }
					    if (cp > convbuf + ndig)
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
   13440:	0cd74063          	blt	a4,a3,13500 <_vfprintf_r+0x122c>
   13444:	00197693          	andi	a3,s2,1
   13448:	0a069c63          	bnez	a3,13500 <_vfprintf_r+0x122c>
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
   1344c:	04012683          	lw	a3,64(sp)
   13450:	00d40433          	add	s0,s0,a3
   13454:	40e68733          	sub	a4,a3,a4
   13458:	41340433          	sub	s0,s0,s3
   1345c:	00875463          	ble	s0,a4,13464 <_vfprintf_r+0x1190>
   13460:	00070413          	mv	s0,a4
   13464:	02805663          	blez	s0,13490 <_vfprintf_r+0x11bc>
   13468:	09012683          	lw	a3,144(sp)
   1346c:	008787b3          	add	a5,a5,s0
   13470:	00700613          	li	a2,7
   13474:	00168693          	addi	a3,a3,1
   13478:	0132a023          	sw	s3,0(t0)
   1347c:	0082a223          	sw	s0,4(t0)
   13480:	08f12a23          	sw	a5,148(sp)
   13484:	08d12823          	sw	a3,144(sp)
   13488:	00828293          	addi	t0,t0,8
   1348c:	52d64063          	blt	a2,a3,139ac <_vfprintf_r+0x16d8>
   13490:	68044063          	bltz	s0,13b10 <_vfprintf_r+0x183c>
   13494:	40870433          	sub	s0,a4,s0
   13498:	d0805e63          	blez	s0,129b4 <_vfprintf_r+0x6e0>
   1349c:	01000993          	li	s3,16
   134a0:	09012703          	lw	a4,144(sp)
   134a4:	03a12223          	sw	s10,36(sp)
   134a8:	f089dee3          	ble	s0,s3,133c4 <_vfprintf_r+0x10f0>
   134ac:	00700c93          	li	s9,7
   134b0:	00c0006f          	j	134bc <_vfprintf_r+0x11e8>
   134b4:	ff040413          	addi	s0,s0,-16
   134b8:	f089d6e3          	ble	s0,s3,133c4 <_vfprintf_r+0x10f0>
   134bc:	01078793          	addi	a5,a5,16
   134c0:	00170713          	addi	a4,a4,1
   134c4:	01a2a023          	sw	s10,0(t0)
   134c8:	0132a223          	sw	s3,4(t0)
   134cc:	08f12a23          	sw	a5,148(sp)
   134d0:	08e12823          	sw	a4,144(sp)
   134d4:	00828293          	addi	t0,t0,8
   134d8:	fcecdee3          	ble	a4,s9,134b4 <_vfprintf_r+0x11e0>
   134dc:	08c10613          	addi	a2,sp,140
   134e0:	000a0593          	mv	a1,s4
   134e4:	000c0513          	mv	a0,s8
   134e8:	3ad050ef          	jal	19094 <__sprint_r>
   134ec:	8a051663          	bnez	a0,12598 <_vfprintf_r+0x2c4>
   134f0:	09412783          	lw	a5,148(sp)
   134f4:	09012703          	lw	a4,144(sp)
   134f8:	0c010293          	addi	t0,sp,192
   134fc:	fb9ff06f          	j	134b4 <_vfprintf_r+0x11e0>
					    if (cp > convbuf + ndig)
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
   13500:	04c12603          	lw	a2,76(sp)
   13504:	09012683          	lw	a3,144(sp)
   13508:	00828293          	addi	t0,t0,8
   1350c:	00c787b3          	add	a5,a5,a2
   13510:	04412603          	lw	a2,68(sp)
   13514:	00168693          	addi	a3,a3,1
   13518:	08f12a23          	sw	a5,148(sp)
   1351c:	fec2ac23          	sw	a2,-8(t0)
   13520:	04c12603          	lw	a2,76(sp)
   13524:	08d12823          	sw	a3,144(sp)
   13528:	fec2ae23          	sw	a2,-4(t0)
   1352c:	00700613          	li	a2,7
   13530:	f0d65ee3          	ble	a3,a2,1344c <_vfprintf_r+0x1178>
   13534:	08c10613          	addi	a2,sp,140
   13538:	000a0593          	mv	a1,s4
   1353c:	000c0513          	mv	a0,s8
   13540:	355050ef          	jal	19094 <__sprint_r>
   13544:	00050463          	beqz	a0,1354c <_vfprintf_r+0x1278>
   13548:	850ff06f          	j	12598 <_vfprintf_r+0x2c4>
   1354c:	07412703          	lw	a4,116(sp)
   13550:	09412783          	lw	a5,148(sp)
   13554:	0c010293          	addi	t0,sp,192
   13558:	ef5ff06f          	j	1344c <_vfprintf_r+0x1178>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   1355c:	02812603          	lw	a2,40(sp)
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   13560:	0006a783          	lw	a5,0(a3)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   13564:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   13568:	d6065263          	bgez	a2,12acc <_vfprintf_r+0x7f8>
   1356c:	e50ff06f          	j	12bbc <_vfprintf_r+0x8e8>
   13570:	02812603          	lw	a2,40(sp)
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   13574:	0006a783          	lw	a5,0(a3)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   13578:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   1357c:	8a065663          	bgez	a2,12628 <_vfprintf_r+0x354>
   13580:	df4ff06f          	j	12b74 <_vfprintf_r+0x8a0>
					PRINTANDPAD (cp, convbuf + ndig,
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
   13584:	08c10613          	addi	a2,sp,140
   13588:	000a0593          	mv	a1,s4
   1358c:	000c0513          	mv	a0,s8
   13590:	305050ef          	jal	19094 <__sprint_r>
   13594:	00050463          	beqz	a0,1359c <_vfprintf_r+0x12c8>
   13598:	800ff06f          	j	12598 <_vfprintf_r+0x2c4>
   1359c:	09412783          	lw	a5,148(sp)
   135a0:	09012983          	lw	s3,144(sp)
   135a4:	0c010293          	addi	t0,sp,192
   135a8:	951ff06f          	j	12ef8 <_vfprintf_r+0xc24>
					cp++;
					PRINT (decimal_point, decp_len);
   135ac:	08c10613          	addi	a2,sp,140
   135b0:	000a0593          	mv	a1,s4
   135b4:	000c0513          	mv	a0,s8
   135b8:	2dd050ef          	jal	19094 <__sprint_r>
   135bc:	00050463          	beqz	a0,135c4 <_vfprintf_r+0x12f0>
   135c0:	fd9fe06f          	j	12598 <_vfprintf_r+0x2c4>
   135c4:	09412783          	lw	a5,148(sp)
   135c8:	09012983          	lw	s3,144(sp)
   135cc:	0c010c93          	addi	s9,sp,192
   135d0:	955ff06f          	j	12f24 <_vfprintf_r+0xc50>
					if (_fpvalue) {
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
   135d4:	02412683          	lw	a3,36(sp)
   135d8:	008787b3          	add	a5,a5,s0
   135dc:	00198993          	addi	s3,s3,1
   135e0:	00700713          	li	a4,7
   135e4:	00dca023          	sw	a3,0(s9)
   135e8:	008ca223          	sw	s0,4(s9)
   135ec:	08f12a23          	sw	a5,148(sp)
   135f0:	09312823          	sw	s3,144(sp)
   135f4:	97375ee3          	ble	s3,a4,12f70 <_vfprintf_r+0xc9c>
   135f8:	bc5ff06f          	j	131bc <_vfprintf_r+0xee8>
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
				sign = '-';
   135fc:	02d00713          	li	a4,45
   13600:	06e107a3          	sb	a4,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   13604:	02812703          	lw	a4,40(sp)
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
   13608:	40f007b3          	neg	a5,a5
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   1360c:	50074663          	bltz	a4,13b18 <_vfprintf_r+0x1844>
				flags &= ~ZEROPAD;
   13610:	f7f97913          	andi	s2,s2,-129
   13614:	02d00613          	li	a2,45
   13618:	cc4ff06f          	j	12adc <_vfprintf_r+0x808>
					cp = "inf";
				size = 3;
				flags &= ~ZEROPAD;
				break;
			}
			if (isnan (_fpvalue)) {
   1361c:	05012503          	lw	a0,80(sp)
   13620:	05412583          	lw	a1,84(sp)
   13624:	00512a23          	sw	t0,20(sp)
   13628:	68c050ef          	jal	18cb4 <__fpclassifyd>
   1362c:	01412283          	lw	t0,20(sp)
   13630:	2e050463          	beqz	a0,13918 <_vfprintf_r+0x1644>
				  }
				else
				  cp = buf;
			} else
# endif /* _WANT_IO_C99_FORMATS */
			if (prec == -1) {
   13634:	02812603          	lw	a2,40(sp)
   13638:	fff00793          	li	a5,-1
   1363c:	6af60463          	beq	a2,a5,13ce4 <_vfprintf_r+0x1a10>
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
   13640:	fdf9f793          	andi	a5,s3,-33
   13644:	02f12023          	sw	a5,32(sp)
   13648:	02012603          	lw	a2,32(sp)
   1364c:	04700793          	li	a5,71
   13650:	64f60863          	beq	a2,a5,13ca0 <_vfprintf_r+0x19cc>
	int mode, dsgn;
	char *digits, *bp, *rve;
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
   13654:	05412a83          	lw	s5,84(sp)
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
				prec = 1;
			}

			flags |= FPT;
   13658:	10096713          	ori	a4,s2,256
   1365c:	02e12223          	sw	a4,36(sp)
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
		value = -value;
   13660:	05012c83          	lw	s9,80(sp)
	char *digits, *bp, *rve;
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
   13664:	6e0ac663          	bltz	s5,13d50 <_vfprintf_r+0x1a7c>
		value = -value;
		*sign = '-';
	} else
		*sign = '\000';
   13668:	02012c23          	sw	zero,56(sp)
		}
		*length = bp - buf;
		return buf;
	}
# endif /* _WANT_IO_C99_FORMATS */
	if (ch == 'f' || ch == 'F') {
   1366c:	06600793          	li	a5,102
   13670:	68f98463          	beq	s3,a5,13cf8 <_vfprintf_r+0x1a24>
   13674:	04600793          	li	a5,70
   13678:	7cf98463          	beq	s3,a5,13e40 <_vfprintf_r+0x1b6c>
		/* To obtain ndigits after the decimal point for the 'e'
		 * and 'E' formats, round to ndigits + 1 significant
		 * figures.
		 */
		if (ch == 'e' || ch == 'E') {
			ndigits++;
   1367c:	02012683          	lw	a3,32(sp)
   13680:	02812703          	lw	a4,40(sp)
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   13684:	08410793          	addi	a5,sp,132
		/* To obtain ndigits after the decimal point for the 'e'
		 * and 'E' formats, round to ndigits + 1 significant
		 * figures.
		 */
		if (ch == 'e' || ch == 'E') {
			ndigits++;
   13688:	fbb68313          	addi	t1,a3,-69
   1368c:	00133313          	seqz	t1,t1
   13690:	00670333          	add	t1,a4,t1
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   13694:	00f12023          	sw	a5,0(sp)
   13698:	000c8613          	mv	a2,s9
   1369c:	00030793          	mv	a5,t1
   136a0:	000a8693          	mv	a3,s5
   136a4:	07810893          	addi	a7,sp,120
   136a8:	07410813          	addi	a6,sp,116
   136ac:	00200713          	li	a4,2
   136b0:	000c0513          	mv	a0,s8
   136b4:	00512a23          	sw	t0,20(sp)
   136b8:	00612c23          	sw	t1,24(sp)
   136bc:	649000ef          	jal	14504 <_dtoa_r>

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   136c0:	06700793          	li	a5,103
			ndigits++;
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   136c4:	00050413          	mv	s0,a0

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   136c8:	01412283          	lw	t0,20(sp)
   136cc:	01812303          	lw	t1,24(sp)
   136d0:	4ef98663          	beq	s3,a5,13bbc <_vfprintf_r+0x18e8>
   136d4:	04700793          	li	a5,71
		bp = digits + ndigits;
   136d8:	00650db3          	add	s11,a0,t1
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   136dc:	4ef98a63          	beq	s3,a5,13bd0 <_vfprintf_r+0x18fc>
		if (ch == 'f' || ch == 'F') {
			if (*digits == '0' && value)
				*decpt = -ndigits + 1;
			bp += *decpt;
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
   136e0:	000c8513          	mv	a0,s9
   136e4:	000a8593          	mv	a1,s5
   136e8:	00000613          	li	a2,0
   136ec:	00000693          	li	a3,0
   136f0:	00512a23          	sw	t0,20(sp)
   136f4:	6ed070ef          	jal	1b5e0 <__eqdf2>
   136f8:	000d8793          	mv	a5,s11
   136fc:	01412283          	lw	t0,20(sp)
   13700:	02050263          	beqz	a0,13724 <_vfprintf_r+0x1450>
			rve = bp;
		while (rve < bp)
   13704:	08412783          	lw	a5,132(sp)
   13708:	01b7fe63          	bleu	s11,a5,13724 <_vfprintf_r+0x1450>
			*rve++ = '0';
   1370c:	03000693          	li	a3,48
   13710:	00178713          	addi	a4,a5,1
   13714:	08e12223          	sw	a4,132(sp)
   13718:	00d78023          	sb	a3,0(a5)
				*decpt = -ndigits + 1;
			bp += *decpt;
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
			rve = bp;
		while (rve < bp)
   1371c:	08412783          	lw	a5,132(sp)
   13720:	ffb7e8e3          	bltu	a5,s11,13710 <_vfprintf_r+0x143c>
			flags |= FPT;

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
   13724:	02012603          	lw	a2,32(sp)
		if (value == 0)	/* kludge for __dtoa irregularity */
			rve = bp;
		while (rve < bp)
			*rve++ = '0';
	}
	*length = rve - digits;
   13728:	408787b3          	sub	a5,a5,s0
   1372c:	04f12023          	sw	a5,64(sp)
			flags |= FPT;

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
   13730:	04700793          	li	a5,71
   13734:	4af60c63          	beq	a2,a5,13bec <_vfprintf_r+0x1918>
			}
# ifdef _WANT_IO_C99_FORMATS
			else if (ch == 'F')
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
   13738:	06500793          	li	a5,101
   1373c:	0b37d6e3          	ble	s3,a5,13fe8 <_vfprintf_r+0x1d14>
					++size;
# ifdef _WANT_IO_C99_FORMATS
				flags &= ~GROUPING;
# endif
			} else {
				if (ch == 'f') {		/* f fmt */
   13740:	06600793          	li	a5,102
   13744:	66f98663          	beq	s3,a5,13db0 <_vfprintf_r+0x1adc>
   13748:	07412703          	lw	a4,116(sp)
   1374c:	02e12e23          	sw	a4,60(sp)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
							  ? prec + 2
							  : 1;
				} else if (expt >= ndig) { /* fixed g fmt */
   13750:	03c12703          	lw	a4,60(sp)
   13754:	04012783          	lw	a5,64(sp)
   13758:	60f74863          	blt	a4,a5,13d68 <_vfprintf_r+0x1a94>
					size = expt;
					if (flags & ALT)
   1375c:	00197913          	andi	s2,s2,1
   13760:	62091863          	bnez	s2,13d90 <_vfprintf_r+0x1abc>
   13764:	00070a93          	mv	s5,a4
   13768:	060744e3          	bltz	a4,13fd0 <_vfprintf_r+0x1cfc>
   1376c:	03c12703          	lw	a4,60(sp)
   13770:	06700993          	li	s3,103
   13774:	02e12623          	sw	a4,44(sp)
				} else
# endif
					lead = expt;
			}

			if (softsign)
   13778:	03812603          	lw	a2,56(sp)
   1377c:	3e061c63          	bnez	a2,13b74 <_vfprintf_r+0x18a0>
   13780:	06f14603          	lbu	a2,111(sp)
   13784:	03512023          	sw	s5,32(sp)
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
				prec = 1;
			}

			flags |= FPT;
   13788:	02412903          	lw	s2,36(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   1378c:	02012423          	sw	zero,40(sp)
   13790:	fddfe06f          	j	1276c <_vfprintf_r+0x498>
				*GET_ARG (N, ap, quad_ptr_t) = ret;
			else
#endif
			if (flags & LONGINT)
				*GET_ARG (N, ap, long_ptr_t) = ret;
			else if (flags & SHORTINT)
   13794:	04097913          	andi	s2,s2,64
   13798:	1a090863          	beqz	s2,13948 <_vfprintf_r+0x1674>
				*GET_ARG (N, ap, short_ptr_t) = ret;
   1379c:	03012603          	lw	a2,48(sp)
   137a0:	03412683          	lw	a3,52(sp)
   137a4:	00062783          	lw	a5,0(a2)
   137a8:	00460613          	addi	a2,a2,4
   137ac:	02c12823          	sw	a2,48(sp)
   137b0:	00d79023          	sh	a3,0(a5)
   137b4:	c21fe06f          	j	123d4 <_vfprintf_r+0x100>
		case 'D':  /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   137b8:	03012703          	lw	a4,48(sp)
   137bc:	00072783          	lw	a5,0(a4)
   137c0:	00470713          	addi	a4,a4,4
   137c4:	02e12823          	sw	a4,48(sp)
   137c8:	d0cff06f          	j	12cd4 <_vfprintf_r+0xa00>
		case 'G':
# ifdef _NO_LONGDBL
			if (flags & LONGDBL) {
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
			} else {
				_fpvalue = GET_ARG (N, ap, double);
   137cc:	00760793          	addi	a5,a2,7
   137d0:	ff87f793          	andi	a5,a5,-8
   137d4:	0007a683          	lw	a3,0(a5)
   137d8:	0047a703          	lw	a4,4(a5)
   137dc:	00878793          	addi	a5,a5,8
   137e0:	04d12823          	sw	a3,80(sp)
   137e4:	04e12a23          	sw	a4,84(sp)
   137e8:	02f12823          	sw	a5,48(sp)
   137ec:	d84ff06f          	j	12d70 <_vfprintf_r+0xa9c>
		case 'X':
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
   137f0:	03012603          	lw	a2,48(sp)
   137f4:	00062783          	lw	a5,0(a2)
   137f8:	00460613          	addi	a2,a2,4
   137fc:	02c12823          	sw	a2,48(sp)
   13800:	bfcff06f          	j	12bfc <_vfprintf_r+0x928>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   13804:	02812683          	lw	a3,40(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   13808:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   1380c:	e806c663          	bltz	a3,12e98 <_vfprintf_r+0xbc4>
				flags &= ~ZEROPAD;
   13810:	f7f97913          	andi	s2,s2,-129
   13814:	cf9fe06f          	j	1250c <_vfprintf_r+0x238>
			PRINT (cp, size);
		} else {	/* glue together f_p fragments */
			if (ch >= 'f') {	/* 'f' or 'g' */
				if (_fpvalue == 0) {
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
   13818:	08c10613          	addi	a2,sp,140
   1381c:	000a0593          	mv	a1,s4
   13820:	000c0513          	mv	a0,s8
   13824:	071050ef          	jal	19094 <__sprint_r>
   13828:	00050463          	beqz	a0,13830 <_vfprintf_r+0x155c>
   1382c:	d6dfe06f          	j	12598 <_vfprintf_r+0x2c4>
   13830:	09412783          	lw	a5,148(sp)
   13834:	0c010293          	addi	t0,sp,192
   13838:	ff0ff06f          	j	13028 <_vfprintf_r+0xd54>
					if (expt < ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
   1383c:	09012703          	lw	a4,144(sp)
   13840:	00100693          	li	a3,1
   13844:	0001d637          	lui	a2,0x1d
   13848:	00d2a223          	sw	a3,4(t0)
   1384c:	00178793          	addi	a5,a5,1
   13850:	00170713          	addi	a4,a4,1
   13854:	c2460613          	addi	a2,a2,-988 # 1cc24 <__thenan_sf+0x54>
   13858:	00700693          	li	a3,7
   1385c:	00c2a023          	sw	a2,0(t0)
   13860:	08f12a23          	sw	a5,148(sp)
   13864:	08e12823          	sw	a4,144(sp)
   13868:	00828293          	addi	t0,t0,8
   1386c:	16e6c863          	blt	a3,a4,139dc <_vfprintf_r+0x1708>
					if (expt || ndig || flags & ALT) {
   13870:	12098263          	beqz	s3,13994 <_vfprintf_r+0x16c0>
						PRINT (decimal_point, decp_len);
   13874:	04c12603          	lw	a2,76(sp)
   13878:	09012703          	lw	a4,144(sp)
   1387c:	04412683          	lw	a3,68(sp)
   13880:	00f607b3          	add	a5,a2,a5
   13884:	00170713          	addi	a4,a4,1
   13888:	00d2a023          	sw	a3,0(t0)
   1388c:	00700693          	li	a3,7
   13890:	00c2a223          	sw	a2,4(t0)
   13894:	08f12a23          	sw	a5,148(sp)
   13898:	08e12823          	sw	a4,144(sp)
   1389c:	00828293          	addi	t0,t0,8
   138a0:	40e6c863          	blt	a3,a4,13cb0 <_vfprintf_r+0x19dc>
						PAD (-expt, zeroes);
   138a4:	413009b3          	neg	s3,s3
   138a8:	23305663          	blez	s3,13ad4 <_vfprintf_r+0x1800>
   138ac:	01000c93          	li	s9,16
   138b0:	03a12223          	sw	s10,36(sp)
   138b4:	1d3cda63          	ble	s3,s9,13a88 <_vfprintf_r+0x17b4>
   138b8:	00700d93          	li	s11,7
   138bc:	00c0006f          	j	138c8 <_vfprintf_r+0x15f4>
   138c0:	ff098993          	addi	s3,s3,-16
   138c4:	1d3cd263          	ble	s3,s9,13a88 <_vfprintf_r+0x17b4>
   138c8:	01078793          	addi	a5,a5,16
   138cc:	00170713          	addi	a4,a4,1
   138d0:	01a2a023          	sw	s10,0(t0)
   138d4:	0192a223          	sw	s9,4(t0)
   138d8:	08f12a23          	sw	a5,148(sp)
   138dc:	08e12823          	sw	a4,144(sp)
   138e0:	00828293          	addi	t0,t0,8
   138e4:	fceddee3          	ble	a4,s11,138c0 <_vfprintf_r+0x15ec>
   138e8:	08c10613          	addi	a2,sp,140
   138ec:	000a0593          	mv	a1,s4
   138f0:	000c0513          	mv	a0,s8
   138f4:	7a0050ef          	jal	19094 <__sprint_r>
   138f8:	00050463          	beqz	a0,13900 <_vfprintf_r+0x162c>
   138fc:	c9dfe06f          	j	12598 <_vfprintf_r+0x2c4>
   13900:	09412783          	lw	a5,148(sp)
   13904:	09012703          	lw	a4,144(sp)
   13908:	0c010293          	addi	t0,sp,192
   1390c:	fb5ff06f          	j	138c0 <_vfprintf_r+0x15ec>
	ORIENT(fp, -1);

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
		_newlib_flockfile_exit (fp);
		return (EOF);
   13910:	fff00513          	li	a0,-1
   13914:	c99fe06f          	j	125ac <_vfprintf_r+0x2d8>
				size = 3;
				flags &= ~ZEROPAD;
				break;
			}
			if (isnan (_fpvalue)) {
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
   13918:	04700793          	li	a5,71
   1391c:	2937c263          	blt	a5,s3,13ba0 <_vfprintf_r+0x18cc>
					cp = "NAN";
   13920:	0001d437          	lui	s0,0x1d
   13924:	bec40413          	addi	s0,s0,-1044 # 1cbec <__thenan_sf+0x1c>
				else
					cp = "nan";
				size = 3;
				flags &= ~ZEROPAD;
				break;
   13928:	00300713          	li	a4,3
   1392c:	02e12023          	sw	a4,32(sp)
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "NAN";
				else
					cp = "nan";
				size = 3;
				flags &= ~ZEROPAD;
   13930:	f7f97913          	andi	s2,s2,-129
   13934:	06f14603          	lbu	a2,111(sp)
			if (isnan (_fpvalue)) {
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "NAN";
				else
					cp = "nan";
				size = 3;
   13938:	02e12623          	sw	a4,44(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   1393c:	02012423          	sw	zero,40(sp)
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   13940:	02012e23          	sw	zero,60(sp)
					cp = "NAN";
				else
					cp = "nan";
				size = 3;
				flags &= ~ZEROPAD;
				break;
   13944:	e29fe06f          	j	1276c <_vfprintf_r+0x498>
#ifdef _WANT_IO_C99_FORMATS
			else if (flags & CHARINT)
				*GET_ARG (N, ap, char_ptr_t) = ret;
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
   13948:	03012703          	lw	a4,48(sp)
   1394c:	03412603          	lw	a2,52(sp)
   13950:	00072783          	lw	a5,0(a4)
   13954:	00470713          	addi	a4,a4,4
   13958:	02e12823          	sw	a4,48(sp)
   1395c:	00c7a023          	sw	a2,0(a5)
   13960:	a75fe06f          	j	123d4 <_vfprintf_r+0x100>
			 */
			if (isinf (_fpvalue)) {
				if (_fpvalue < 0)
					sign = '-';
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "INF";
   13964:	0001d437          	lui	s0,0x1d
   13968:	be440413          	addi	s0,s0,-1052 # 1cbe4 <__thenan_sf+0x14>
   1396c:	c50ff06f          	j	12dbc <_vfprintf_r+0xae8>
						PAD (-expt, zeroes);
						PRINT (cp, ndig);
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
   13970:	08c10613          	addi	a2,sp,140
   13974:	000a0593          	mv	a1,s4
   13978:	000c0513          	mv	a0,s8
   1397c:	718050ef          	jal	19094 <__sprint_r>
   13980:	00050463          	beqz	a0,13988 <_vfprintf_r+0x16b4>
   13984:	c15fe06f          	j	12598 <_vfprintf_r+0x2c4>
   13988:	09412783          	lw	a5,148(sp)
   1398c:	0c010293          	addi	t0,sp,192
   13990:	929ff06f          	j	132b8 <_vfprintf_r+0xfe4>
						PRINT (decimal_point, decp_len);
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
					if (expt || ndig || flags & ALT) {
   13994:	04012703          	lw	a4,64(sp)
   13998:	ec071ee3          	bnez	a4,13874 <_vfprintf_r+0x15a0>
   1399c:	00197713          	andi	a4,s2,1
   139a0:	00071463          	bnez	a4,139a8 <_vfprintf_r+0x16d4>
   139a4:	810ff06f          	j	129b4 <_vfprintf_r+0x6e0>
   139a8:	ecdff06f          	j	13874 <_vfprintf_r+0x15a0>
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
   139ac:	08c10613          	addi	a2,sp,140
   139b0:	000a0593          	mv	a1,s4
   139b4:	000c0513          	mv	a0,s8
   139b8:	6dc050ef          	jal	19094 <__sprint_r>
   139bc:	00050463          	beqz	a0,139c4 <_vfprintf_r+0x16f0>
   139c0:	bd9fe06f          	j	12598 <_vfprintf_r+0x2c4>
   139c4:	07412703          	lw	a4,116(sp)
   139c8:	04012603          	lw	a2,64(sp)
   139cc:	09412783          	lw	a5,148(sp)
   139d0:	0c010293          	addi	t0,sp,192
   139d4:	40e60733          	sub	a4,a2,a4
   139d8:	ab9ff06f          	j	13490 <_vfprintf_r+0x11bc>
					if (expt < ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
   139dc:	08c10613          	addi	a2,sp,140
   139e0:	000a0593          	mv	a1,s4
   139e4:	000c0513          	mv	a0,s8
   139e8:	6ac050ef          	jal	19094 <__sprint_r>
   139ec:	00050463          	beqz	a0,139f4 <_vfprintf_r+0x1720>
   139f0:	ba9fe06f          	j	12598 <_vfprintf_r+0x2c4>
   139f4:	07412983          	lw	s3,116(sp)
   139f8:	09412783          	lw	a5,148(sp)
   139fc:	0c010293          	addi	t0,sp,192
					if (expt || ndig || flags & ALT) {
   13a00:	e6099ae3          	bnez	s3,13874 <_vfprintf_r+0x15a0>
   13a04:	f91ff06f          	j	13994 <_vfprintf_r+0x16c0>
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   13a08:	00197793          	andi	a5,s2,1
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   13a0c:	00068613          	mv	a2,a3
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   13a10:	02078063          	beqz	a5,13a30 <_vfprintf_r+0x175c>
   13a14:	01c12703          	lw	a4,28(sp)
   13a18:	0bf10413          	addi	s0,sp,191
                         *--cp = '0';
   13a1c:	03000793          	li	a5,48
   13a20:	40870733          	sub	a4,a4,s0
   13a24:	0af10fa3          	sb	a5,191(sp)
   13a28:	02e12623          	sw	a4,44(sp)
   13a2c:	a34ff06f          	j	12c60 <_vfprintf_r+0x98c>
   13a30:	02012623          	sw	zero,44(sp)
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   13a34:	0c010413          	addi	s0,sp,192
   13a38:	a28ff06f          	j	12c60 <_vfprintf_r+0x98c>
			if (ch >= 'f') {	/* 'f' or 'g' */
				if (_fpvalue == 0) {
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
					if (expt < ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
   13a3c:	08c10613          	addi	a2,sp,140
   13a40:	000a0593          	mv	a1,s4
   13a44:	000c0513          	mv	a0,s8
   13a48:	64c050ef          	jal	19094 <__sprint_r>
   13a4c:	00050463          	beqz	a0,13a54 <_vfprintf_r+0x1780>
   13a50:	b49fe06f          	j	12598 <_vfprintf_r+0x2c4>
   13a54:	09412783          	lw	a5,148(sp)
   13a58:	0c010293          	addi	t0,sp,192
   13a5c:	e14ff06f          	j	13070 <_vfprintf_r+0xd9c>
				if (p != NULL)
					size = p - cp;
				else
					size = prec;
			} else
				size = strlen (cp);
   13a60:	00040513          	mv	a0,s0
   13a64:	00512a23          	sw	t0,20(sp)
   13a68:	fdcfe0ef          	jal	12244 <strlen>
   13a6c:	02a12623          	sw	a0,44(sp)
   13a70:	01412283          	lw	t0,20(sp)
   13a74:	00050a93          	mv	s5,a0
   13a78:	00054463          	bltz	a0,13a80 <_vfprintf_r+0x17ac>
   13a7c:	cddfe06f          	j	12758 <_vfprintf_r+0x484>
   13a80:	00000a93          	li	s5,0
   13a84:	cd5fe06f          	j	12758 <_vfprintf_r+0x484>
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
					if (expt || ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
						PAD (-expt, zeroes);
   13a88:	02412683          	lw	a3,36(sp)
   13a8c:	013787b3          	add	a5,a5,s3
   13a90:	00170713          	addi	a4,a4,1
   13a94:	00d2a023          	sw	a3,0(t0)
   13a98:	00700693          	li	a3,7
   13a9c:	0132a223          	sw	s3,4(t0)
   13aa0:	08f12a23          	sw	a5,148(sp)
   13aa4:	08e12823          	sw	a4,144(sp)
   13aa8:	00828293          	addi	t0,t0,8
   13aac:	02e6d463          	ble	a4,a3,13ad4 <_vfprintf_r+0x1800>
   13ab0:	08c10613          	addi	a2,sp,140
   13ab4:	000a0593          	mv	a1,s4
   13ab8:	000c0513          	mv	a0,s8
   13abc:	5d8050ef          	jal	19094 <__sprint_r>
   13ac0:	00050463          	beqz	a0,13ac8 <_vfprintf_r+0x17f4>
   13ac4:	ad5fe06f          	j	12598 <_vfprintf_r+0x2c4>
   13ac8:	09412783          	lw	a5,148(sp)
   13acc:	09012703          	lw	a4,144(sp)
   13ad0:	0c010293          	addi	t0,sp,192
						PRINT (cp, ndig);
   13ad4:	04012603          	lw	a2,64(sp)
   13ad8:	00170713          	addi	a4,a4,1
   13adc:	00700693          	li	a3,7
   13ae0:	00f607b3          	add	a5,a2,a5
   13ae4:	0082a023          	sw	s0,0(t0)
   13ae8:	00c2a223          	sw	a2,4(t0)
   13aec:	08f12a23          	sw	a5,148(sp)
   13af0:	08e12823          	sw	a4,144(sp)
   13af4:	00e6c463          	blt	a3,a4,13afc <_vfprintf_r+0x1828>
   13af8:	eb9fe06f          	j	129b0 <_vfprintf_r+0x6dc>
   13afc:	ca8ff06f          	j	12fa4 <_vfprintf_r+0xcd0>
   13b00:	fff00793          	li	a5,-1
   13b04:	bd5fe06f          	j	126d8 <_vfprintf_r+0x404>
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
   13b08:	00000993          	li	s3,0
   13b0c:	fb0ff06f          	j	132bc <_vfprintf_r+0xfe8>
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
   13b10:	00000413          	li	s0,0
   13b14:	981ff06f          	j	13494 <_vfprintf_r+0x11c0>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   13b18:	02d00613          	li	a2,45
			{

				_uquad = -_uquad;
				sign = '-';
			}
			base = DEC;
   13b1c:	00100713          	li	a4,1
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   13b20:	00100693          	li	a3,1
   13b24:	00d71463          	bne	a4,a3,13b2c <_vfprintf_r+0x1858>
   13b28:	fb5fe06f          	j	12adc <_vfprintf_r+0x808>
   13b2c:	00200693          	li	a3,2
   13b30:	90d70063          	beq	a4,a3,12c30 <_vfprintf_r+0x95c>
   13b34:	b15fe06f          	j	12648 <_vfprintf_r+0x374>
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
				size = ((unsigned) prec > 6U) ? 6 : prec;
   13b38:	02812503          	lw	a0,40(sp)
   13b3c:	00600793          	li	a5,6
   13b40:	00a7f463          	bleu	a0,a5,13b48 <_vfprintf_r+0x1874>
   13b44:	00078513          	mv	a0,a5
   13b48:	02a12623          	sw	a0,44(sp)
   13b4c:	00050a93          	mv	s5,a0
   13b50:	38054c63          	bltz	a0,13ee8 <_vfprintf_r+0x1c14>
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
   13b54:	0001d437          	lui	s0,0x1d
   13b58:	03512023          	sw	s5,32(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   13b5c:	03912823          	sw	s9,48(sp)
   13b60:	00000613          	li	a2,0
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   13b64:	02012423          	sw	zero,40(sp)
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   13b68:	02012e23          	sw	zero,60(sp)
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
   13b6c:	c1c40413          	addi	s0,s0,-996 # 1cc1c <__thenan_sf+0x4c>
   13b70:	c0dfe06f          	j	1277c <_vfprintf_r+0x4a8>
# endif
					lead = expt;
			}

			if (softsign)
				sign = '-';
   13b74:	02d00793          	li	a5,45
   13b78:	06f107a3          	sb	a5,111(sp)
   13b7c:	03512023          	sw	s5,32(sp)
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
				prec = 1;
			}

			flags |= FPT;
   13b80:	02412903          	lw	s2,36(sp)
# endif
					lead = expt;
			}

			if (softsign)
				sign = '-';
   13b84:	02d00613          	li	a2,45
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   13b88:	02012423          	sw	zero,40(sp)
   13b8c:	be5fe06f          	j	12770 <_vfprintf_r+0x49c>
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
				ox[0] = '0';
				ox[1] = ch;
				flags |= HEXPREFIX;
   13b90:	00070913          	mv	s2,a4
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   13b94:	00000613          	li	a2,0
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
   13b98:	00200713          	li	a4,2
   13b9c:	f85ff06f          	j	13b20 <_vfprintf_r+0x184c>
			}
			if (isnan (_fpvalue)) {
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "NAN";
				else
					cp = "nan";
   13ba0:	0001d437          	lui	s0,0x1d
   13ba4:	bf040413          	addi	s0,s0,-1040 # 1cbf0 <__thenan_sf+0x20>
   13ba8:	d81ff06f          	j	13928 <_vfprintf_r+0x1654>
			   zeros are not permitted.  Otherwise, scanf
			   could not read what printf wrote.
			 */
			if (isinf (_fpvalue)) {
				if (_fpvalue < 0)
					sign = '-';
   13bac:	02d00793          	li	a5,45
   13bb0:	06f107a3          	sb	a5,111(sp)
   13bb4:	02d00613          	li	a2,45
   13bb8:	9f4ff06f          	j	12dac <_vfprintf_r+0xad8>
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   13bbc:	00197793          	andi	a5,s2,1
		bp = digits + ndigits;
   13bc0:	00650db3          	add	s11,a0,t1
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   13bc4:	b0079ee3          	bnez	a5,136e0 <_vfprintf_r+0x140c>
   13bc8:	08412783          	lw	a5,132(sp)
   13bcc:	b59ff06f          	j	13724 <_vfprintf_r+0x1450>
   13bd0:	00197793          	andi	a5,s2,1
   13bd4:	2a079263          	bnez	a5,13e78 <_vfprintf_r+0x1ba4>
		if (value == 0)	/* kludge for __dtoa irregularity */
			rve = bp;
		while (rve < bp)
			*rve++ = '0';
	}
	*length = rve - digits;
   13bd8:	08412783          	lw	a5,132(sp)
   13bdc:	408787b3          	sub	a5,a5,s0
   13be0:	04f12023          	sw	a5,64(sp)
			flags |= FPT;

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
   13be4:	02012783          	lw	a5,32(sp)
   13be8:	41379063          	bne	a5,s3,13fe8 <_vfprintf_r+0x1d14>
				if (expt <= -4 || expt > prec)
   13bec:	07412783          	lw	a5,116(sp)
   13bf0:	ffd00713          	li	a4,-3
   13bf4:	02e7ca63          	blt	a5,a4,13c28 <_vfprintf_r+0x1954>
   13bf8:	02812683          	lw	a3,40(sp)
   13bfc:	02f6c663          	blt	a3,a5,13c28 <_vfprintf_r+0x1954>
   13c00:	02f12e23          	sw	a5,60(sp)
   13c04:	b4dff06f          	j	13750 <_vfprintf_r+0x147c>
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);

				if (p != NULL)
   13c08:	02812603          	lw	a2,40(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   13c0c:	03912823          	sw	s9,48(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   13c10:	02012423          	sw	zero,40(sp)
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);

				if (p != NULL)
   13c14:	02c12023          	sw	a2,32(sp)
   13c18:	02c12623          	sw	a2,44(sp)
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   13c1c:	02012e23          	sw	zero,60(sp)
   13c20:	06f14603          	lbu	a2,111(sp)
   13c24:	b49fe06f          	j	1276c <_vfprintf_r+0x498>
			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
				if (expt <= -4 || expt > prec)
					ch -= 2; /* 'e' or 'E' */
   13c28:	ffe98993          	addi	s3,s3,-2
# ifdef _WANT_IO_C99_FORMATS
			else if (ch == 'F')
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
   13c2c:	fff78793          	addi	a5,a5,-1
   13c30:	06f12a23          	sw	a5,116(sp)
# else
#  define isa 0
# endif

	p = p0;
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   13c34:	07310e23          	sb	s3,124(sp)
	if (exp < 0) {
   13c38:	2e07ca63          	bltz	a5,13f2c <_vfprintf_r+0x1c58>
		exp = -exp;
		*p++ = '-';
	}
	else
		*p++ = '+';
   13c3c:	02b00713          	li	a4,43
   13c40:	06e10ea3          	sb	a4,125(sp)
	t = expbuf + MAXEXPLEN;
	if (exp > 9) {
   13c44:	00900613          	li	a2,9
   13c48:	18f64863          	blt	a2,a5,13dd8 <_vfprintf_r+0x1b04>
		*--t = to_char (exp);
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
	}
	else {
		if (!isa)
			*p++ = '0';
   13c4c:	03000713          	li	a4,48
		*p++ = to_char (exp);
   13c50:	03078793          	addi	a5,a5,48
		*--t = to_char (exp);
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
	}
	else {
		if (!isa)
			*p++ = '0';
   13c54:	06e10f23          	sb	a4,126(sp)
		*p++ = to_char (exp);
   13c58:	06f10fa3          	sb	a5,127(sp)
   13c5c:	08010713          	addi	a4,sp,128
	}
	return (p - p0);
   13c60:	07c10793          	addi	a5,sp,124
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
   13c64:	04012683          	lw	a3,64(sp)
	else {
		if (!isa)
			*p++ = '0';
		*p++ = to_char (exp);
	}
	return (p - p0);
   13c68:	40f707b3          	sub	a5,a4,a5
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
				if (ndig > 1 || flags & ALT)
   13c6c:	04012703          	lw	a4,64(sp)
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
   13c70:	00d786b3          	add	a3,a5,a3
	else {
		if (!isa)
			*p++ = '0';
		*p++ = to_char (exp);
	}
	return (p - p0);
   13c74:	04f12e23          	sw	a5,92(sp)
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
				if (ndig > 1 || flags & ALT)
   13c78:	00100793          	li	a5,1
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
   13c7c:	02d12623          	sw	a3,44(sp)
				if (ndig > 1 || flags & ALT)
   13c80:	2ae7de63          	ble	a4,a5,13f3c <_vfprintf_r+0x1c68>
					++size;
   13c84:	02c12783          	lw	a5,44(sp)
   13c88:	00178793          	addi	a5,a5,1
   13c8c:	02f12623          	sw	a5,44(sp)
   13c90:	00078a93          	mv	s5,a5
   13c94:	2a07cc63          	bltz	a5,13f4c <_vfprintf_r+0x1c78>
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   13c98:	02012e23          	sw	zero,60(sp)
   13c9c:	addff06f          	j	13778 <_vfprintf_r+0x14a4>
				  cp = buf;
			} else
# endif /* _WANT_IO_C99_FORMATS */
			if (prec == -1) {
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
   13ca0:	02812683          	lw	a3,40(sp)
   13ca4:	9a0698e3          	bnez	a3,13654 <_vfprintf_r+0x1380>
				prec = 1;
   13ca8:	02812423          	sw	s0,40(sp)
   13cac:	9a9ff06f          	j	13654 <_vfprintf_r+0x1380>
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
					if (expt || ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
   13cb0:	08c10613          	addi	a2,sp,140
   13cb4:	000a0593          	mv	a1,s4
   13cb8:	000c0513          	mv	a0,s8
   13cbc:	3d8050ef          	jal	19094 <__sprint_r>
   13cc0:	00050463          	beqz	a0,13cc8 <_vfprintf_r+0x19f4>
   13cc4:	8d5fe06f          	j	12598 <_vfprintf_r+0x2c4>
   13cc8:	07412983          	lw	s3,116(sp)
   13ccc:	09412783          	lw	a5,148(sp)
   13cd0:	09012703          	lw	a4,144(sp)
   13cd4:	0c010293          	addi	t0,sp,192
   13cd8:	bcdff06f          	j	138a4 <_vfprintf_r+0x15d0>
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   13cdc:	02012423          	sw	zero,40(sp)
   13ce0:	f98fe06f          	j	12478 <_vfprintf_r+0x1a4>
   13ce4:	fdf9f693          	andi	a3,s3,-33
				else
				  cp = buf;
			} else
# endif /* _WANT_IO_C99_FORMATS */
			if (prec == -1) {
				prec = DEFPREC;
   13ce8:	00600713          	li	a4,6
   13cec:	02d12023          	sw	a3,32(sp)
   13cf0:	02e12423          	sw	a4,40(sp)
   13cf4:	961ff06f          	j	13654 <_vfprintf_r+0x1380>
			ndigits++;
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   13cf8:	08410793          	addi	a5,sp,132
   13cfc:	00f12023          	sw	a5,0(sp)
   13d00:	02812783          	lw	a5,40(sp)
   13d04:	00300713          	li	a4,3
   13d08:	000c8613          	mv	a2,s9
   13d0c:	000a8693          	mv	a3,s5
   13d10:	07810893          	addi	a7,sp,120
   13d14:	07410813          	addi	a6,sp,116
   13d18:	000c0513          	mv	a0,s8
   13d1c:	00512a23          	sw	t0,20(sp)
   13d20:	7e4000ef          	jal	14504 <_dtoa_r>

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
   13d24:	02812703          	lw	a4,40(sp)
   13d28:	01412283          	lw	t0,20(sp)
			ndigits++;
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   13d2c:	00050413          	mv	s0,a0

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
   13d30:	00e50db3          	add	s11,a0,a4
   13d34:	00070313          	mv	t1,a4
		if (ch == 'f' || ch == 'F') {
			if (*digits == '0' && value)
   13d38:	00044703          	lbu	a4,0(s0)
   13d3c:	03000793          	li	a5,48
   13d40:	16f70663          	beq	a4,a5,13eac <_vfprintf_r+0x1bd8>
   13d44:	07412303          	lw	t1,116(sp)
				*decpt = -ndigits + 1;
			bp += *decpt;
   13d48:	006d8db3          	add	s11,s11,t1
   13d4c:	995ff06f          	j	136e0 <_vfprintf_r+0x140c>
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
		value = -value;
   13d50:	05412783          	lw	a5,84(sp)
   13d54:	80000ab7          	lui	s5,0x80000
		*sign = '-';
   13d58:	02d00613          	li	a2,45
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
		value = -value;
   13d5c:	0157cab3          	xor	s5,a5,s5
		*sign = '-';
   13d60:	02c12c23          	sw	a2,56(sp)
   13d64:	909ff06f          	j	1366c <_vfprintf_r+0x1398>
					size = expt;
					if (flags & ALT)
						++size;
				} else
					size = ndig + (expt > 0 ?
						1 : 2 - expt);
   13d68:	03c12703          	lw	a4,60(sp)
   13d6c:	00100513          	li	a0,1
   13d70:	1ae05863          	blez	a4,13f20 <_vfprintf_r+0x1c4c>
				} else if (expt >= ndig) { /* fixed g fmt */
					size = expt;
					if (flags & ALT)
						++size;
				} else
					size = ndig + (expt > 0 ?
   13d74:	04012783          	lw	a5,64(sp)
   13d78:	00f50533          	add	a0,a0,a5
   13d7c:	02a12623          	sw	a0,44(sp)
   13d80:	00050a93          	mv	s5,a0
   13d84:	02054063          	bltz	a0,13da4 <_vfprintf_r+0x1ad0>
   13d88:	06700993          	li	s3,103
   13d8c:	9edff06f          	j	13778 <_vfprintf_r+0x14a4>
							  ? prec + 2
							  : 1;
				} else if (expt >= ndig) { /* fixed g fmt */
					size = expt;
					if (flags & ALT)
						++size;
   13d90:	03c12783          	lw	a5,60(sp)
   13d94:	00178793          	addi	a5,a5,1
   13d98:	02f12623          	sw	a5,44(sp)
   13d9c:	00078a93          	mv	s5,a5
   13da0:	fe07d4e3          	bgez	a5,13d88 <_vfprintf_r+0x1ab4>
   13da4:	00000a93          	li	s5,0
				} else
					size = ndig + (expt > 0 ?
   13da8:	06700993          	li	s3,103
   13dac:	9cdff06f          	j	13778 <_vfprintf_r+0x14a4>
# ifdef _WANT_IO_C99_FORMATS
				flags &= ~GROUPING;
# endif
			} else {
				if (ch == 'f') {		/* f fmt */
					if (expt > 0) {
   13db0:	07412783          	lw	a5,116(sp)
   13db4:	02f12e23          	sw	a5,60(sp)
   13db8:	12f05c63          	blez	a5,13ef0 <_vfprintf_r+0x1c1c>
						size = expt;
						if (prec || flags & ALT)
   13dbc:	02812603          	lw	a2,40(sp)
   13dc0:	0c061463          	bnez	a2,13e88 <_vfprintf_r+0x1bb4>
   13dc4:	00197913          	andi	s2,s2,1
   13dc8:	0c091063          	bnez	s2,13e88 <_vfprintf_r+0x1bb4>
   13dcc:	00078a93          	mv	s5,a5
   13dd0:	02f12623          	sw	a5,44(sp)
   13dd4:	9a5ff06f          	j	13778 <_vfprintf_r+0x14a4>
		*p++ = '-';
	}
	else
		*p++ = '+';
	t = expbuf + MAXEXPLEN;
	if (exp > 9) {
   13dd8:	08b10593          	addi	a1,sp,139
   13ddc:	00058713          	mv	a4,a1
		do {
			*--t = to_char (exp % 10);
   13de0:	00a00513          	li	a0,10
   13de4:	02a7e6b3          	rem	a3,a5,a0
   13de8:	fff70713          	addi	a4,a4,-1
		} while ((exp /= 10) > 9);
   13dec:	02a7c7b3          	div	a5,a5,a0
	else
		*p++ = '+';
	t = expbuf + MAXEXPLEN;
	if (exp > 9) {
		do {
			*--t = to_char (exp % 10);
   13df0:	03068693          	addi	a3,a3,48
   13df4:	00d70023          	sb	a3,0(a4)
		} while ((exp /= 10) > 9);
   13df8:	fef646e3          	blt	a2,a5,13de4 <_vfprintf_r+0x1b10>
		*--t = to_char (exp);
   13dfc:	03078793          	addi	a5,a5,48
   13e00:	0ff7f793          	andi	a5,a5,255
   13e04:	fff70693          	addi	a3,a4,-1
   13e08:	fef70fa3          	sb	a5,-1(a4)
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
   13e0c:	1cb6fa63          	bleu	a1,a3,13fe0 <_vfprintf_r+0x1d0c>
   13e10:	07e10613          	addi	a2,sp,126
   13e14:	0080006f          	j	13e1c <_vfprintf_r+0x1b48>
   13e18:	0006c783          	lbu	a5,0(a3)
   13e1c:	00160613          	addi	a2,a2,1
   13e20:	00168693          	addi	a3,a3,1
   13e24:	fef60fa3          	sb	a5,-1(a2)
   13e28:	feb698e3          	bne	a3,a1,13e18 <_vfprintf_r+0x1b44>
   13e2c:	08c10793          	addi	a5,sp,140
   13e30:	40e78733          	sub	a4,a5,a4
   13e34:	07e10793          	addi	a5,sp,126
   13e38:	00e78733          	add	a4,a5,a4
   13e3c:	e25ff06f          	j	13c60 <_vfprintf_r+0x198c>
			ndigits++;
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   13e40:	08410793          	addi	a5,sp,132
   13e44:	00f12023          	sw	a5,0(sp)
   13e48:	02812783          	lw	a5,40(sp)
   13e4c:	000c8613          	mv	a2,s9
   13e50:	000a8693          	mv	a3,s5
   13e54:	07810893          	addi	a7,sp,120
   13e58:	07410813          	addi	a6,sp,116
   13e5c:	00300713          	li	a4,3
   13e60:	000c0513          	mv	a0,s8
   13e64:	00512a23          	sw	t0,20(sp)
   13e68:	69c000ef          	jal	14504 <_dtoa_r>
   13e6c:	02812303          	lw	t1,40(sp)
   13e70:	01412283          	lw	t0,20(sp)
   13e74:	00050413          	mv	s0,a0

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
		if (ch == 'f' || ch == 'F') {
   13e78:	04600793          	li	a5,70
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
   13e7c:	00640db3          	add	s11,s0,t1
		if (ch == 'f' || ch == 'F') {
   13e80:	eaf98ce3          	beq	s3,a5,13d38 <_vfprintf_r+0x1a64>
   13e84:	85dff06f          	j	136e0 <_vfprintf_r+0x140c>
			} else {
				if (ch == 'f') {		/* f fmt */
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
   13e88:	02812683          	lw	a3,40(sp)
   13e8c:	03c12703          	lw	a4,60(sp)
   13e90:	00168513          	addi	a0,a3,1
   13e94:	00a70533          	add	a0,a4,a0
   13e98:	02a12623          	sw	a0,44(sp)
   13e9c:	00050a93          	mv	s5,a0
   13ea0:	8c055ce3          	bgez	a0,13778 <_vfprintf_r+0x14a4>
   13ea4:	00000a93          	li	s5,0
					} else	/* "0.X" */
						size = (prec || flags & ALT)
							  ? prec + 2
							  : 1;
   13ea8:	8d1ff06f          	j	13778 <_vfprintf_r+0x14a4>
	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
		if (ch == 'f' || ch == 'F') {
			if (*digits == '0' && value)
   13eac:	000c8513          	mv	a0,s9
   13eb0:	000a8593          	mv	a1,s5
   13eb4:	00000613          	li	a2,0
   13eb8:	00000693          	li	a3,0
   13ebc:	00512a23          	sw	t0,20(sp)
   13ec0:	00612c23          	sw	t1,24(sp)
   13ec4:	718070ef          	jal	1b5dc <__nedf2>
   13ec8:	01412283          	lw	t0,20(sp)
   13ecc:	01812303          	lw	t1,24(sp)
   13ed0:	e6050ae3          	beqz	a0,13d44 <_vfprintf_r+0x1a70>
				*decpt = -ndigits + 1;
   13ed4:	00100793          	li	a5,1
   13ed8:	40678333          	sub	t1,a5,t1
   13edc:	06612a23          	sw	t1,116(sp)
			bp += *decpt;
   13ee0:	006d8db3          	add	s11,s11,t1
   13ee4:	ffcff06f          	j	136e0 <_vfprintf_r+0x140c>
   13ee8:	00000a93          	li	s5,0
   13eec:	c69ff06f          	j	13b54 <_vfprintf_r+0x1880>
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
							  ? prec + 2
							  : 1;
   13ef0:	02812783          	lw	a5,40(sp)
   13ef4:	00079a63          	bnez	a5,13f08 <_vfprintf_r+0x1c34>
   13ef8:	00100a93          	li	s5,1
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
   13efc:	01597933          	and	s2,s2,s5
							  ? prec + 2
							  : 1;
   13f00:	03512623          	sw	s5,44(sp)
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
   13f04:	86090ae3          	beqz	s2,13778 <_vfprintf_r+0x14a4>
							  ? prec + 2
							  : 1;
   13f08:	02812683          	lw	a3,40(sp)
   13f0c:	00268693          	addi	a3,a3,2
   13f10:	02d12623          	sw	a3,44(sp)
   13f14:	00068a93          	mv	s5,a3
   13f18:	8606d0e3          	bgez	a3,13778 <_vfprintf_r+0x14a4>
   13f1c:	f89ff06f          	j	13ea4 <_vfprintf_r+0x1bd0>
					size = expt;
					if (flags & ALT)
						++size;
				} else
					size = ndig + (expt > 0 ?
						1 : 2 - expt);
   13f20:	00200513          	li	a0,2
   13f24:	40e50533          	sub	a0,a0,a4
   13f28:	e4dff06f          	j	13d74 <_vfprintf_r+0x1aa0>

	p = p0;
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
	if (exp < 0) {
		exp = -exp;
		*p++ = '-';
   13f2c:	02d00713          	li	a4,45
# endif

	p = p0;
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
	if (exp < 0) {
		exp = -exp;
   13f30:	40f007b3          	neg	a5,a5
		*p++ = '-';
   13f34:	06e10ea3          	sb	a4,125(sp)
   13f38:	d0dff06f          	j	13c44 <_vfprintf_r+0x1970>
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
				if (ndig > 1 || flags & ALT)
   13f3c:	00f97933          	and	s2,s2,a5
   13f40:	d40912e3          	bnez	s2,13c84 <_vfprintf_r+0x19b0>
   13f44:	00068a93          	mv	s5,a3
   13f48:	d406d8e3          	bgez	a3,13c98 <_vfprintf_r+0x19c4>
   13f4c:	00000a93          	li	s5,0
   13f50:	d49ff06f          	j	13c98 <_vfprintf_r+0x19c4>
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
   13f54:	03012703          	lw	a4,48(sp)
   13f58:	00072703          	lw	a4,0(a4)
   13f5c:	02e12423          	sw	a4,40(sp)
   13f60:	03012703          	lw	a4,48(sp)
   13f64:	00470793          	addi	a5,a4,4
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
   13f68:	02812703          	lw	a4,40(sp)
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
   13f6c:	02f12823          	sw	a5,48(sp)
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
   13f70:	00074463          	bltz	a4,13f78 <_vfprintf_r+0x1ca4>
   13f74:	cfcfe06f          	j	12470 <_vfprintf_r+0x19c>
					prec = -1;
   13f78:	fff00713          	li	a4,-1
   13f7c:	02e12423          	sw	a4,40(sp)
   13f80:	cf0fe06f          	j	12470 <_vfprintf_r+0x19c>
   13f84:	06a107a3          	sb	a0,111(sp)
   13f88:	d35fe06f          	j	12cbc <_vfprintf_r+0x9e8>
   13f8c:	06a107a3          	sb	a0,111(sp)
				size = 1;
			}
			sign = '\0';
			break;
		case 'D':  /* extension */
			flags |= LONGINT;
   13f90:	01096913          	ori	s2,s2,16
   13f94:	e59fe06f          	j	12dec <_vfprintf_r+0xb18>
   13f98:	06a107a3          	sb	a0,111(sp)
   13f9c:	da9fe06f          	j	12d44 <_vfprintf_r+0xa70>
   13fa0:	06a107a3          	sb	a0,111(sp)
   13fa4:	d69fe06f          	j	12d0c <_vfprintf_r+0xa38>
   13fa8:	06a107a3          	sb	a0,111(sp)
   13fac:	c2dfe06f          	j	12bd8 <_vfprintf_r+0x904>
   13fb0:	06a107a3          	sb	a0,111(sp)
			} else
				size = strlen (cp);

			break;
		case 'U': /* extension */
			flags |= LONGINT;
   13fb4:	01096913          	ori	s2,s2,16
   13fb8:	bddfe06f          	j	12b94 <_vfprintf_r+0x8c0>
   13fbc:	06a107a3          	sb	a0,111(sp)
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
   13fc0:	01096913          	ori	s2,s2,16
   13fc4:	b89fe06f          	j	12b4c <_vfprintf_r+0x878>
   13fc8:	06a107a3          	sb	a0,111(sp)
   13fcc:	ae1fe06f          	j	12aac <_vfprintf_r+0x7d8>
   13fd0:	00000a93          	li	s5,0
   13fd4:	f98ff06f          	j	1376c <_vfprintf_r+0x1498>
   13fd8:	06a107a3          	sb	a0,111(sp)
   13fdc:	e2cfe06f          	j	12608 <_vfprintf_r+0x334>
	if (exp > 9) {
		do {
			*--t = to_char (exp % 10);
		} while ((exp /= 10) > 9);
		*--t = to_char (exp);
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
   13fe0:	07e10713          	addi	a4,sp,126
   13fe4:	c7dff06f          	j	13c60 <_vfprintf_r+0x198c>
   13fe8:	07412783          	lw	a5,116(sp)
   13fec:	c41ff06f          	j	13c2c <_vfprintf_r+0x1958>
   13ff0:	06a107a3          	sb	a0,111(sp)
   13ff4:	e71fe06f          	j	12e64 <_vfprintf_r+0xb90>
   13ff8:	06a107a3          	sb	a0,111(sp)
   13ffc:	e1dfe06f          	j	12e18 <_vfprintf_r+0xb44>

00014000 <vfprintf>:
       FILE * fp         _AND
       _CONST char *fmt0 _AND
       va_list ap)
{
  int result;
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
   14000:	00060693          	mv	a3,a2
   14004:	00058613          	mv	a2,a1
   14008:	00050593          	mv	a1,a0
   1400c:	8101a503          	lw	a0,-2032(gp) # 1ece0 <_impure_ptr>
   14010:	ac4fe06f          	j	122d4 <_vfprintf_r>

00014014 <__sbprintf>:
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   14014:	00c5d783          	lhu	a5,12(a1)
	fake._flags2 = fp->_flags2;
   14018:	0685a303          	lw	t1,104(a1)
	fake._file = fp->_file;
   1401c:	00e5d283          	lhu	t0,14(a1)
	fake._cookie = fp->_cookie;
   14020:	01c5a883          	lw	a7,28(a1)
	fake._write = fp->_write;
   14024:	0245a803          	lw	a6,36(a1)
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   14028:	b8010113          	addi	sp,sp,-1152
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   1402c:	ffd7f793          	andi	a5,a5,-3
	fake._cookie = fp->_cookie;
	fake._write = fp->_write;

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
	fake._bf._size = fake._w = sizeof (buf);
   14030:	40000713          	li	a4,1024
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   14034:	46812c23          	sw	s0,1144(sp)
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   14038:	00f11623          	sh	a5,12(sp)
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   1403c:	00058413          	mv	s0,a1
	fake._file = fp->_file;
	fake._cookie = fp->_cookie;
	fake._write = fp->_write;

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
   14040:	07010793          	addi	a5,sp,112
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   14044:	00010593          	mv	a1,sp
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   14048:	46912a23          	sw	s1,1140(sp)
   1404c:	47212823          	sw	s2,1136(sp)
   14050:	46112e23          	sw	ra,1148(sp)
   14054:	00050913          	mv	s2,a0
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
	fake._flags2 = fp->_flags2;
   14058:	06612423          	sw	t1,104(sp)
	fake._file = fp->_file;
   1405c:	00511723          	sh	t0,14(sp)
	fake._cookie = fp->_cookie;
   14060:	01112e23          	sw	a7,28(sp)
	fake._write = fp->_write;
   14064:	03012223          	sw	a6,36(sp)

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
   14068:	00f12023          	sw	a5,0(sp)
   1406c:	00f12823          	sw	a5,16(sp)
	fake._bf._size = fake._w = sizeof (buf);
   14070:	00e12423          	sw	a4,8(sp)
   14074:	00e12a23          	sw	a4,20(sp)
	fake._lbfsize = 0;	/* not actually used, but Just In Case */
   14078:	00012c23          	sw	zero,24(sp)
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   1407c:	a58fe0ef          	jal	122d4 <_vfprintf_r>
   14080:	00050493          	mv	s1,a0
	if (ret >= 0 && _fflush_r (rptr, &fake))
   14084:	00054a63          	bltz	a0,14098 <__sbprintf+0x84>
   14088:	00010593          	mv	a1,sp
   1408c:	00090513          	mv	a0,s2
   14090:	41d010ef          	jal	15cac <_fflush_r>
   14094:	02051c63          	bnez	a0,140cc <__sbprintf+0xb8>
		ret = EOF;
	if (fake._flags & __SERR)
   14098:	00c15783          	lhu	a5,12(sp)
   1409c:	0407f793          	andi	a5,a5,64
   140a0:	00078863          	beqz	a5,140b0 <__sbprintf+0x9c>
		fp->_flags |= __SERR;
   140a4:	00c45783          	lhu	a5,12(s0)
   140a8:	0407e793          	ori	a5,a5,64
   140ac:	00f41623          	sh	a5,12(s0)

#ifndef __SINGLE_THREAD__
	__lock_close_recursive (fake._lock);
#endif
	return (ret);
}
   140b0:	47c12083          	lw	ra,1148(sp)
   140b4:	00048513          	mv	a0,s1
   140b8:	47812403          	lw	s0,1144(sp)
   140bc:	47412483          	lw	s1,1140(sp)
   140c0:	47012903          	lw	s2,1136(sp)
   140c4:	48010113          	addi	sp,sp,1152
   140c8:	00008067          	ret
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
	if (ret >= 0 && _fflush_r (rptr, &fake))
		ret = EOF;
   140cc:	fff00493          	li	s1,-1
   140d0:	fc9ff06f          	j	14098 <__sbprintf+0x84>

000140d4 <__swsetup_r>:
       struct _reent *ptr _AND
       register FILE * fp)
{
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   140d4:	8101a783          	lw	a5,-2032(gp) # 1ece0 <_impure_ptr>

int
_DEFUN(__swsetup_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   140d8:	ff010113          	addi	sp,sp,-16
   140dc:	00812423          	sw	s0,8(sp)
   140e0:	00912223          	sw	s1,4(sp)
   140e4:	00112623          	sw	ra,12(sp)
   140e8:	00050493          	mv	s1,a0
   140ec:	00058413          	mv	s0,a1
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   140f0:	00078663          	beqz	a5,140fc <__swsetup_r+0x28>
   140f4:	0387a703          	lw	a4,56(a5)
   140f8:	0c070c63          	beqz	a4,141d0 <__swsetup_r+0xfc>

  /*
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
   140fc:	00c41703          	lh	a4,12(s0)
   14100:	01071793          	slli	a5,a4,0x10
   14104:	0107d793          	srli	a5,a5,0x10
   14108:	0087f693          	andi	a3,a5,8
   1410c:	04068263          	beqz	a3,14150 <__swsetup_r+0x7c>
   14110:	01042683          	lw	a3,16(s0)
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
   14114:	06068263          	beqz	a3,14178 <__swsetup_r+0xa4>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
    __smakebuf_r (ptr, fp);

  if (fp->_flags & __SLBF)
   14118:	0017f713          	andi	a4,a5,1
   1411c:	08071063          	bnez	a4,1419c <__swsetup_r+0xc8>
       */
      fp->_w = 0;
      fp->_lbfsize = -fp->_bf._size;
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;
   14120:	0027f793          	andi	a5,a5,2
   14124:	00000713          	li	a4,0
   14128:	00079463          	bnez	a5,14130 <__swsetup_r+0x5c>
   1412c:	01442703          	lw	a4,20(s0)
   14130:	00e42423          	sw	a4,8(s0)
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
      return EOF;
    }
  return 0;
   14134:	00000513          	li	a0,0
      fp->_lbfsize = -fp->_bf._size;
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;

  if (!fp->_bf._base && (fp->_flags & __SMBF))
   14138:	06068e63          	beqz	a3,141b4 <__swsetup_r+0xe0>
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
      return EOF;
    }
  return 0;
}
   1413c:	00c12083          	lw	ra,12(sp)
   14140:	00812403          	lw	s0,8(sp)
   14144:	00412483          	lw	s1,4(sp)
   14148:	01010113          	addi	sp,sp,16
   1414c:	00008067          	ret
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
   14150:	0107f693          	andi	a3,a5,16
   14154:	0a068e63          	beqz	a3,14210 <__swsetup_r+0x13c>
        {
	  ptr->_errno = EBADF;
	  fp->_flags |= __SERR;
	  return EOF;
        }
      if (fp->_flags & __SRD)
   14158:	0047f793          	andi	a5,a5,4
   1415c:	08079063          	bnez	a5,141dc <__swsetup_r+0x108>
   14160:	01042683          	lw	a3,16(s0)
	    FREEUB (ptr, fp);
	  fp->_flags &= ~(__SRD | __SEOF);
	  fp->_r = 0;
	  fp->_p = fp->_bf._base;
	}
      fp->_flags |= __SWR;
   14164:	00876793          	ori	a5,a4,8
   14168:	00f41623          	sh	a5,12(s0)
   1416c:	01079793          	slli	a5,a5,0x10
   14170:	0107d793          	srli	a5,a5,0x10
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
   14174:	fa0692e3          	bnez	a3,14118 <__swsetup_r+0x44>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
   14178:	2807f713          	andi	a4,a5,640
   1417c:	20000613          	li	a2,512
   14180:	f8c70ce3          	beq	a4,a2,14118 <__swsetup_r+0x44>
    __smakebuf_r (ptr, fp);
   14184:	00040593          	mv	a1,s0
   14188:	00048513          	mv	a0,s1
   1418c:	1bd020ef          	jal	16b48 <__smakebuf_r>
   14190:	00c45783          	lhu	a5,12(s0)
   14194:	01042683          	lw	a3,16(s0)
   14198:	f81ff06f          	j	14118 <__swsetup_r+0x44>
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
      fp->_lbfsize = -fp->_bf._size;
   1419c:	01442783          	lw	a5,20(s0)
      /*
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
   141a0:	00042423          	sw	zero,8(s0)
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
      return EOF;
    }
  return 0;
   141a4:	00000513          	li	a0,0
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
      fp->_lbfsize = -fp->_bf._size;
   141a8:	40f007b3          	neg	a5,a5
   141ac:	00f42c23          	sw	a5,24(s0)
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;

  if (!fp->_bf._base && (fp->_flags & __SMBF))
   141b0:	f80696e3          	bnez	a3,1413c <__swsetup_r+0x68>
   141b4:	00c41783          	lh	a5,12(s0)
   141b8:	0807f713          	andi	a4,a5,128
   141bc:	f80700e3          	beqz	a4,1413c <__swsetup_r+0x68>
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
   141c0:	0407e793          	ori	a5,a5,64
   141c4:	00f41623          	sh	a5,12(s0)
      return EOF;
   141c8:	fff00513          	li	a0,-1
   141cc:	f71ff06f          	j	1413c <__swsetup_r+0x68>
       struct _reent *ptr _AND
       register FILE * fp)
{
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   141d0:	00078513          	mv	a0,a5
   141d4:	689010ef          	jal	1605c <__sinit>
   141d8:	f25ff06f          	j	140fc <__swsetup_r+0x28>
	  return EOF;
        }
      if (fp->_flags & __SRD)
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
   141dc:	03042583          	lw	a1,48(s0)
   141e0:	00058e63          	beqz	a1,141fc <__swsetup_r+0x128>
	    FREEUB (ptr, fp);
   141e4:	04040793          	addi	a5,s0,64
   141e8:	00f58863          	beq	a1,a5,141f8 <__swsetup_r+0x124>
   141ec:	00048513          	mv	a0,s1
   141f0:	7ad010ef          	jal	1619c <_free_r>
   141f4:	00c41703          	lh	a4,12(s0)
   141f8:	02042823          	sw	zero,48(s0)
	  fp->_flags &= ~(__SRD | __SEOF);
	  fp->_r = 0;
	  fp->_p = fp->_bf._base;
   141fc:	01042683          	lw	a3,16(s0)
      if (fp->_flags & __SRD)
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
	    FREEUB (ptr, fp);
	  fp->_flags &= ~(__SRD | __SEOF);
   14200:	fdb77713          	andi	a4,a4,-37
	  fp->_r = 0;
   14204:	00042223          	sw	zero,4(s0)
	  fp->_p = fp->_bf._base;
   14208:	00d42023          	sw	a3,0(s0)
   1420c:	f59ff06f          	j	14164 <__swsetup_r+0x90>
  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
        {
	  ptr->_errno = EBADF;
	  fp->_flags |= __SERR;
   14210:	04076713          	ori	a4,a4,64

  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
        {
	  ptr->_errno = EBADF;
   14214:	00900793          	li	a5,9
   14218:	00f4a023          	sw	a5,0(s1)
	  fp->_flags |= __SERR;
	  return EOF;
   1421c:	fff00513          	li	a0,-1
  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
        {
	  ptr->_errno = EBADF;
	  fp->_flags |= __SERR;
   14220:	00e41623          	sh	a4,12(s0)
	  return EOF;
   14224:	f19ff06f          	j	1413c <__swsetup_r+0x68>

00014228 <__register_exitproc>:
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
   14228:	fe010113          	addi	sp,sp,-32
   1422c:	00812c23          	sw	s0,24(sp)

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
   14230:	80c1a403          	lw	s0,-2036(gp) # 1ecdc <_global_impure_ptr>
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
   14234:	00912a23          	sw	s1,20(sp)
   14238:	00050493          	mv	s1,a0

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
   1423c:	14842503          	lw	a0,328(s0)
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
   14240:	00112e23          	sw	ra,28(sp)
#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
  if (p == NULL)
   14244:	0c050263          	beqz	a0,14308 <__register_exitproc+0xe0>
    _GLOBAL_ATEXIT = p = _GLOBAL_ATEXIT0;
  if (p->_ind >= _ATEXIT_SIZE)
   14248:	00452783          	lw	a5,4(a0)
   1424c:	01f00713          	li	a4,31
   14250:	00178813          	addi	a6,a5,1
   14254:	04f75863          	ble	a5,a4,142a4 <__register_exitproc+0x7c>
#ifndef _ATEXIT_DYNAMIC_ALLOC
      return -1;
#else
      /* Don't dynamically allocate the atexit array if malloc is not
	 available.  */
      if (!malloc)
   14258:	00000793          	li	a5,0
   1425c:	0a078c63          	beqz	a5,14314 <__register_exitproc+0xec>
	return -1;

      p = (struct _atexit *) malloc (sizeof *p);
   14260:	19000513          	li	a0,400
   14264:	00b12623          	sw	a1,12(sp)
   14268:	00c12423          	sw	a2,8(sp)
   1426c:	00d12223          	sw	a3,4(sp)
   14270:	d91eb0ef          	jal	0 <_reset-0x200>
      if (p == NULL)
   14274:	00c12583          	lw	a1,12(sp)
   14278:	00812603          	lw	a2,8(sp)
   1427c:	00412683          	lw	a3,4(sp)
   14280:	08050a63          	beqz	a0,14314 <__register_exitproc+0xec>
	  __lock_release_recursive(__atexit_lock);
#endif
	  return -1;
	}
      p->_ind = 0;
      p->_next = _GLOBAL_ATEXIT;
   14284:	14842783          	lw	a5,328(s0)
      _GLOBAL_ATEXIT = p;
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
      p->_on_exit_args._is_cxa = 0;
   14288:	00100813          	li	a6,1
#ifndef __SINGLE_THREAD__
	  __lock_release_recursive(__atexit_lock);
#endif
	  return -1;
	}
      p->_ind = 0;
   1428c:	00052223          	sw	zero,4(a0)
      p->_next = _GLOBAL_ATEXIT;
   14290:	00f52023          	sw	a5,0(a0)
      _GLOBAL_ATEXIT = p;
   14294:	14a42423          	sw	a0,328(s0)
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
      p->_on_exit_args._is_cxa = 0;
   14298:	00000793          	li	a5,0
	}
      p->_ind = 0;
      p->_next = _GLOBAL_ATEXIT;
      _GLOBAL_ATEXIT = p;
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
   1429c:	18052423          	sw	zero,392(a0)
      p->_on_exit_args._is_cxa = 0;
   142a0:	18052623          	sw	zero,396(a0)
   142a4:	00279713          	slli	a4,a5,0x2
      p->_on_exit_args_ptr = NULL;
#endif
#endif
    }

  if (type != __et_atexit)
   142a8:	02049463          	bnez	s1,142d0 <__register_exitproc+0xa8>
      args->_fntypes |= (1 << p->_ind);
      args->_dso_handle[p->_ind] = d;
      if (type == __et_cxa)
	args->_is_cxa |= (1 << p->_ind);
    }
  p->_fns[p->_ind++] = fn;
   142ac:	00e50733          	add	a4,a0,a4
   142b0:	01052223          	sw	a6,4(a0)
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif
  return 0;
   142b4:	00000513          	li	a0,0
      args->_fntypes |= (1 << p->_ind);
      args->_dso_handle[p->_ind] = d;
      if (type == __et_cxa)
	args->_is_cxa |= (1 << p->_ind);
    }
  p->_fns[p->_ind++] = fn;
   142b8:	00b72423          	sw	a1,8(a4)
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif
  return 0;
}
   142bc:	01c12083          	lw	ra,28(sp)
   142c0:	01812403          	lw	s0,24(sp)
   142c4:	01412483          	lw	s1,20(sp)
   142c8:	02010113          	addi	sp,sp,32
   142cc:	00008067          	ret
   142d0:	00e502b3          	add	t0,a0,a4
	  p->_on_exit_args_ptr = args;
	}
#else
      args = &p->_on_exit_args;
#endif
      args->_fnargs[p->_ind] = arg;
   142d4:	08c2a423          	sw	a2,136(t0)
      args->_fntypes |= (1 << p->_ind);
   142d8:	18852883          	lw	a7,392(a0)
   142dc:	00100613          	li	a2,1
   142e0:	00f617b3          	sll	a5,a2,a5
   142e4:	00f8e633          	or	a2,a7,a5
   142e8:	18c52423          	sw	a2,392(a0)
      args->_dso_handle[p->_ind] = d;
   142ec:	10d2a423          	sw	a3,264(t0)
      if (type == __et_cxa)
   142f0:	00200693          	li	a3,2
   142f4:	fad49ce3          	bne	s1,a3,142ac <__register_exitproc+0x84>
	args->_is_cxa |= (1 << p->_ind);
   142f8:	18c52683          	lw	a3,396(a0)
   142fc:	00f6e7b3          	or	a5,a3,a5
   14300:	18f52623          	sw	a5,396(a0)
   14304:	fa9ff06f          	j	142ac <__register_exitproc+0x84>
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
  if (p == NULL)
    _GLOBAL_ATEXIT = p = _GLOBAL_ATEXIT0;
   14308:	14c40513          	addi	a0,s0,332
   1430c:	14a42423          	sw	a0,328(s0)
   14310:	f39ff06f          	j	14248 <__register_exitproc+0x20>
      return -1;
#else
      /* Don't dynamically allocate the atexit array if malloc is not
	 available.  */
      if (!malloc)
	return -1;
   14314:	fff00513          	li	a0,-1
   14318:	fa5ff06f          	j	142bc <__register_exitproc+0x94>

0001431c <quorem>:

static int
_DEFUN (quorem,
	(b, S),
	_Bigint * b _AND _Bigint * S)
{
   1431c:	fe010113          	addi	sp,sp,-32
   14320:	01212823          	sw	s2,16(sp)
  n = S->_wds;
#ifdef DEBUG
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
   14324:	01052783          	lw	a5,16(a0)
#ifdef Pack_32
  __Long z;
  __ULong si, zs;
#endif

  n = S->_wds;
   14328:	0105a903          	lw	s2,16(a1)

static int
_DEFUN (quorem,
	(b, S),
	_Bigint * b _AND _Bigint * S)
{
   1432c:	00112e23          	sw	ra,28(sp)
   14330:	00812c23          	sw	s0,24(sp)
   14334:	00912a23          	sw	s1,20(sp)
   14338:	01312623          	sw	s3,12(sp)
   1433c:	01412423          	sw	s4,8(sp)
   14340:	01512223          	sw	s5,4(sp)
  n = S->_wds;
#ifdef DEBUG
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
   14344:	1b27cc63          	blt	a5,s2,144fc <quorem+0x1e0>
    return 0;
  sx = S->_x;
  sxe = sx + --n;
   14348:	fff90913          	addi	s2,s2,-1
   1434c:	00291e13          	slli	t3,s2,0x2
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
    return 0;
  sx = S->_x;
   14350:	01458413          	addi	s0,a1,20
  sxe = sx + --n;
   14354:	01c409b3          	add	s3,s0,t3
  bx = b->_x;
   14358:	01450a13          	addi	s4,a0,20
  bxe = bx + n;
   1435c:	01ca0e33          	add	t3,s4,t3
  q = *bxe / (*sxe + 1);	/* ensure q <= true quotient */
   14360:	0009a783          	lw	a5,0(s3)
   14364:	000e2483          	lw	s1,0(t3)
   14368:	00178793          	addi	a5,a5,1
   1436c:	02f4d4b3          	divu	s1,s1,a5
#ifdef DEBUG
  /*debug*/ if (q > 9)
    /*debug*/ Bug ("oversized quotient in quorem");
#endif
  if (q)
   14370:	0a048e63          	beqz	s1,1442c <quorem+0x110>
      carry = 0;
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
   14374:	000102b7          	lui	t0,0x10
   14378:	00040393          	mv	t2,s0
#endif
  if (b->_wds < n)
    return 0;
  sx = S->_x;
  sxe = sx + --n;
  bx = b->_x;
   1437c:	000a0313          	mv	t1,s4
   14380:	00000693          	li	a3,0
   14384:	00000793          	li	a5,0
      carry = 0;
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
   14388:	fff28293          	addi	t0,t0,-1 # ffff <_reset+0xfdff>
      borrow = 0;
      carry = 0;
      do
	{
#ifdef Pack_32
	  si = *sx++;
   1438c:	00438393          	addi	t2,t2,4
   14390:	ffc3a603          	lw	a2,-4(t2)
	  ys = (si & 0xffff) * q + carry;
	  zs = (si >> 16) * q + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   14394:	00032703          	lw	a4,0(t1)
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
	  borrow = z >> 16;
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   14398:	00430313          	addi	t1,t1,4
      carry = 0;
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
   1439c:	005678b3          	and	a7,a2,t0
   143a0:	029888b3          	mul	a7,a7,s1
	  zs = (si >> 16) * q + (ys >> 16);
   143a4:	01065613          	srli	a2,a2,0x10
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   143a8:	00577833          	and	a6,a4,t0
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   143ac:	01075713          	srli	a4,a4,0x10
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
	  zs = (si >> 16) * q + (ys >> 16);
   143b0:	02960633          	mul	a2,a2,s1
      carry = 0;
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
   143b4:	00d888b3          	add	a7,a7,a3
	  zs = (si >> 16) * q + (ys >> 16);
   143b8:	0108d693          	srli	a3,a7,0x10
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   143bc:	0058f8b3          	and	a7,a7,t0
   143c0:	411787b3          	sub	a5,a5,a7
   143c4:	01078833          	add	a6,a5,a6
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   143c8:	41085893          	srai	a7,a6,0x10
	  borrow = z >> 16;
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   143cc:	00587833          	and	a6,a6,t0
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
	  zs = (si >> 16) * q + (ys >> 16);
   143d0:	00d606b3          	add	a3,a2,a3
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   143d4:	0056f7b3          	and	a5,a3,t0
   143d8:	40f70733          	sub	a4,a4,a5
   143dc:	011707b3          	add	a5,a4,a7
	  borrow = z >> 16;
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   143e0:	01079713          	slli	a4,a5,0x10
   143e4:	01076833          	or	a6,a4,a6
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
	  zs = (si >> 16) * q + (ys >> 16);
	  carry = zs >> 16;
   143e8:	0106d693          	srli	a3,a3,0x10
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
	  borrow = z >> 16;
   143ec:	4107d793          	srai	a5,a5,0x10
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   143f0:	ff032e23          	sw	a6,-4(t1)
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
   143f4:	f879fce3          	bleu	t2,s3,1438c <quorem+0x70>
      if (!*bxe)
   143f8:	000e2783          	lw	a5,0(t3)
   143fc:	02079863          	bnez	a5,1442c <quorem+0x110>
	{
	  bx = b->_x;
	  while (--bxe > bx && !*bxe)
   14400:	ffce0793          	addi	a5,t3,-4
   14404:	02fa7263          	bleu	a5,s4,14428 <quorem+0x10c>
   14408:	ffce2703          	lw	a4,-4(t3)
   1440c:	00070863          	beqz	a4,1441c <quorem+0x100>
   14410:	0180006f          	j	14428 <quorem+0x10c>
   14414:	0007a703          	lw	a4,0(a5)
   14418:	00071863          	bnez	a4,14428 <quorem+0x10c>
   1441c:	ffc78793          	addi	a5,a5,-4
	    --n;
   14420:	fff90913          	addi	s2,s2,-1
	}
      while (sx <= sxe);
      if (!*bxe)
	{
	  bx = b->_x;
	  while (--bxe > bx && !*bxe)
   14424:	fefa68e3          	bltu	s4,a5,14414 <quorem+0xf8>
	    --n;
	  b->_wds = n;
   14428:	01252823          	sw	s2,16(a0)
   1442c:	00050a93          	mv	s5,a0
	}
    }
  if (cmp (b, S) >= 0)
   14430:	3ad030ef          	jal	17fdc <__mcmp>
   14434:	0a054063          	bltz	a0,144d4 <quorem+0x1b8>
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) + carry;
	  zs = (si >> 16) + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   14438:	00010837          	lui	a6,0x10
	  b->_wds = n;
	}
    }
  if (cmp (b, S) >= 0)
    {
      q++;
   1443c:	00148493          	addi	s1,s1,1
#endif
  if (b->_wds < n)
    return 0;
  sx = S->_x;
  sxe = sx + --n;
  bx = b->_x;
   14440:	000a0593          	mv	a1,s4
	}
    }
  if (cmp (b, S) >= 0)
    {
      q++;
      borrow = 0;
   14444:	00000793          	li	a5,0
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) + carry;
	  zs = (si >> 16) + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   14448:	fff80813          	addi	a6,a6,-1 # ffff <_reset+0xfdff>
      bx = b->_x;
      sx = S->_x;
      do
	{
#ifdef Pack_32
	  si = *sx++;
   1444c:	00440413          	addi	s0,s0,4
   14450:	ffc42603          	lw	a2,-4(s0)
	  ys = (si & 0xffff) + carry;
	  zs = (si >> 16) + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   14454:	0005a703          	lw	a4,0(a1)
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
	  borrow = z >> 16;
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   14458:	00458593          	addi	a1,a1,4
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) + carry;
	  zs = (si >> 16) + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   1445c:	010676b3          	and	a3,a2,a6
   14460:	40d787b3          	sub	a5,a5,a3
   14464:	010776b3          	and	a3,a4,a6
   14468:	00d786b3          	add	a3,a5,a3
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   1446c:	01075713          	srli	a4,a4,0x10
   14470:	01065793          	srli	a5,a2,0x10
   14474:	40f70733          	sub	a4,a4,a5
   14478:	4106d793          	srai	a5,a3,0x10
   1447c:	00f707b3          	add	a5,a4,a5
	  borrow = z >> 16;
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   14480:	01079713          	slli	a4,a5,0x10
   14484:	0106f6b3          	and	a3,a3,a6
   14488:	00d766b3          	or	a3,a4,a3
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
	  borrow = z >> 16;
   1448c:	4107d793          	srai	a5,a5,0x10
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   14490:	fed5ae23          	sw	a3,-4(a1)
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
   14494:	fa89fce3          	bleu	s0,s3,1444c <quorem+0x130>
      bx = b->_x;
      bxe = bx + n;
   14498:	00291713          	slli	a4,s2,0x2
   1449c:	00ea0733          	add	a4,s4,a4
      if (!*bxe)
   144a0:	00072783          	lw	a5,0(a4)
   144a4:	02079863          	bnez	a5,144d4 <quorem+0x1b8>
	{
	  while (--bxe > bx && !*bxe)
   144a8:	ffc70793          	addi	a5,a4,-4
   144ac:	02fa7263          	bleu	a5,s4,144d0 <quorem+0x1b4>
   144b0:	ffc72703          	lw	a4,-4(a4)
   144b4:	00070863          	beqz	a4,144c4 <quorem+0x1a8>
   144b8:	0180006f          	j	144d0 <quorem+0x1b4>
   144bc:	0007a703          	lw	a4,0(a5)
   144c0:	00071863          	bnez	a4,144d0 <quorem+0x1b4>
   144c4:	ffc78793          	addi	a5,a5,-4
	    --n;
   144c8:	fff90913          	addi	s2,s2,-1
      while (sx <= sxe);
      bx = b->_x;
      bxe = bx + n;
      if (!*bxe)
	{
	  while (--bxe > bx && !*bxe)
   144cc:	fefa68e3          	bltu	s4,a5,144bc <quorem+0x1a0>
	    --n;
	  b->_wds = n;
   144d0:	012aa823          	sw	s2,16(s5) # 80000010 <_gp+0x7ffe0b40>
	}
    }
  return q;
   144d4:	00048513          	mv	a0,s1
}
   144d8:	01c12083          	lw	ra,28(sp)
   144dc:	01812403          	lw	s0,24(sp)
   144e0:	01412483          	lw	s1,20(sp)
   144e4:	01012903          	lw	s2,16(sp)
   144e8:	00c12983          	lw	s3,12(sp)
   144ec:	00812a03          	lw	s4,8(sp)
   144f0:	00412a83          	lw	s5,4(sp)
   144f4:	02010113          	addi	sp,sp,32
   144f8:	00008067          	ret
#ifdef DEBUG
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
    return 0;
   144fc:	00000513          	li	a0,0
   14500:	fd9ff06f          	j	144d8 <quorem+0x1bc>

00014504 <_dtoa_r>:
  char *s, *s0;

  d.d = _d;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
   14504:	04052283          	lw	t0,64(a0)
	int mode _AND
	int ndigits _AND
	int *decpt _AND
	int *sign _AND
	char **rve)
{
   14508:	f6010113          	addi	sp,sp,-160
   1450c:	08812c23          	sw	s0,152(sp)
   14510:	09212823          	sw	s2,144(sp)
   14514:	09312623          	sw	s3,140(sp)
   14518:	07712e23          	sw	s7,124(sp)
   1451c:	07b12623          	sw	s11,108(sp)
   14520:	08112e23          	sw	ra,156(sp)
   14524:	08912a23          	sw	s1,148(sp)
   14528:	09412423          	sw	s4,136(sp)
   1452c:	09512223          	sw	s5,132(sp)
   14530:	09612023          	sw	s6,128(sp)
   14534:	07812c23          	sw	s8,120(sp)
   14538:	07912a23          	sw	s9,116(sp)
   1453c:	07a12823          	sw	s10,112(sp)
   14540:	00050413          	mv	s0,a0
   14544:	00070d93          	mv	s11,a4
   14548:	00078b93          	mv	s7,a5
   1454c:	01012a23          	sw	a6,20(sp)
#endif
  _Bigint *b, *b1, *delta, *mlo = NULL, *mhi, *S;
  double ds;
  char *s, *s0;

  d.d = _d;
   14550:	00060913          	mv	s2,a2
   14554:	00068993          	mv	s3,a3

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
   14558:	02028663          	beqz	t0,14584 <_dtoa_r+0x80>
    {
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
   1455c:	04452703          	lw	a4,68(a0)
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
   14560:	00100793          	li	a5,1
      Bfree (ptr, _REENT_MP_RESULT(ptr));
   14564:	00028593          	mv	a1,t0

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
    {
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
   14568:	00e797b3          	sll	a5,a5,a4
  d.d = _d;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
    {
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
   1456c:	00e2a223          	sw	a4,4(t0)
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
   14570:	00f2a423          	sw	a5,8(t0)
      Bfree (ptr, _REENT_MP_RESULT(ptr));
   14574:	01112423          	sw	a7,8(sp)
   14578:	254030ef          	jal	177cc <_Bfree>
      _REENT_MP_RESULT(ptr) = 0;
   1457c:	00812883          	lw	a7,8(sp)
   14580:	04042023          	sw	zero,64(s0)
    }

  if (word0 (d) & Sign_bit)
   14584:	00098b13          	mv	s6,s3
   14588:	0c09c863          	bltz	s3,14658 <_dtoa_r+0x154>
      /* set sign for everything, including 0's and NaNs */
      *sign = 1;
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
    }
  else
    *sign = 0;
   1458c:	0008a023          	sw	zero,0(a7)

#if defined(IEEE_Arith) + defined(VAX)
#ifdef IEEE_Arith
  if ((word0 (d) & Exp_mask) == Exp_mask)
   14590:	7ff007b7          	lui	a5,0x7ff00
   14594:	00fb7733          	and	a4,s6,a5
   14598:	08f70063          	beq	a4,a5,14618 <_dtoa_r+0x114>
    }
#endif
#ifdef IBM
  d.d += 0;			/* normalize */
#endif
  if (!d.d)
   1459c:	00000613          	li	a2,0
   145a0:	00000693          	li	a3,0
   145a4:	00090513          	mv	a0,s2
   145a8:	00098593          	mv	a1,s3
   145ac:	034070ef          	jal	1b5e0 <__eqdf2>
   145b0:	0c051263          	bnez	a0,14674 <_dtoa_r+0x170>
    {
      *decpt = 1;
   145b4:	01412583          	lw	a1,20(sp)
      s = "0";
      if (rve)
   145b8:	0a012603          	lw	a2,160(sp)
#ifdef IBM
  d.d += 0;			/* normalize */
#endif
  if (!d.d)
    {
      *decpt = 1;
   145bc:	00100793          	li	a5,1
   145c0:	00f5a023          	sw	a5,0(a1)
      s = "0";
      if (rve)
   145c4:	62060863          	beqz	a2,14bf4 <_dtoa_r+0x6f0>
	*rve = s + 1;
   145c8:	0001d7b7          	lui	a5,0x1d
   145cc:	c2578793          	addi	a5,a5,-987 # 1cc25 <__thenan_sf+0x55>
      return s;
   145d0:	0001d537          	lui	a0,0x1d
  if (!d.d)
    {
      *decpt = 1;
      s = "0";
      if (rve)
	*rve = s + 1;
   145d4:	00f62023          	sw	a5,0(a2)
      return s;
   145d8:	c2450513          	addi	a0,a0,-988 # 1cc24 <__thenan_sf+0x54>
  *s = 0;
  *decpt = k + 1;
  if (rve)
    *rve = s;
  return s0;
}
   145dc:	09c12083          	lw	ra,156(sp)
   145e0:	09812403          	lw	s0,152(sp)
   145e4:	09412483          	lw	s1,148(sp)
   145e8:	09012903          	lw	s2,144(sp)
   145ec:	08c12983          	lw	s3,140(sp)
   145f0:	08812a03          	lw	s4,136(sp)
   145f4:	08412a83          	lw	s5,132(sp)
   145f8:	08012b03          	lw	s6,128(sp)
   145fc:	07c12b83          	lw	s7,124(sp)
   14600:	07812c03          	lw	s8,120(sp)
   14604:	07412c83          	lw	s9,116(sp)
   14608:	07012d03          	lw	s10,112(sp)
   1460c:	06c12d83          	lw	s11,108(sp)
   14610:	0a010113          	addi	sp,sp,160
   14614:	00008067          	ret
#else
  if (word0 (d) == 0x8000)
#endif
    {
      /* Infinity or NaN */
      *decpt = 9999;
   14618:	01412583          	lw	a1,20(sp)
   1461c:	000027b7          	lui	a5,0x2
   14620:	70f78793          	addi	a5,a5,1807 # 270f <_reset+0x250f>
   14624:	00f5a023          	sw	a5,0(a1)
      s =
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
   14628:	56090663          	beqz	s2,14b94 <_dtoa_r+0x690>
   1462c:	0001d537          	lui	a0,0x1d
   14630:	c3450513          	addi	a0,a0,-972 # 1cc34 <__thenan_sf+0x64>
#endif
	"NaN";
      if (rve)
   14634:	0a012683          	lw	a3,160(sp)
   14638:	fa0682e3          	beqz	a3,145dc <_dtoa_r+0xd8>
	*rve =
#ifdef IEEE_Arith
	  s[3] ? s + 8 :
   1463c:	00354703          	lbu	a4,3(a0)
   14640:	00350793          	addi	a5,a0,3
   14644:	00070463          	beqz	a4,1464c <_dtoa_r+0x148>
   14648:	00850793          	addi	a5,a0,8
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
#endif
	"NaN";
      if (rve)
	*rve =
   1464c:	0a012703          	lw	a4,160(sp)
   14650:	00f72023          	sw	a5,0(a4)
   14654:	f89ff06f          	j	145dc <_dtoa_r+0xd8>

  if (word0 (d) & Sign_bit)
    {
      /* set sign for everything, including 0's and NaNs */
      *sign = 1;
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
   14658:	80000b37          	lui	s6,0x80000
   1465c:	fffb4b13          	not	s6,s6
   14660:	013b7b33          	and	s6,s6,s3
    }

  if (word0 (d) & Sign_bit)
    {
      /* set sign for everything, including 0's and NaNs */
      *sign = 1;
   14664:	00100793          	li	a5,1
   14668:	00f8a023          	sw	a5,0(a7)
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
   1466c:	000b0993          	mv	s3,s6
   14670:	f21ff06f          	j	14590 <_dtoa_r+0x8c>
      if (rve)
	*rve = s + 1;
      return s;
    }

  b = d2b (ptr, d.d, &be, &bbits);
   14674:	05810793          	addi	a5,sp,88
   14678:	05c10713          	addi	a4,sp,92
   1467c:	00090613          	mv	a2,s2
   14680:	00098693          	mv	a3,s3
   14684:	00040513          	mv	a0,s0
   14688:	551030ef          	jal	183d8 <__d2b>
#ifdef Sudden_Underflow
  i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1));
#else
  if ((i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1))) != 0)
   1468c:	014b5493          	srli	s1,s6,0x14
      if (rve)
	*rve = s + 1;
      return s;
    }

  b = d2b (ptr, d.d, &be, &bbits);
   14690:	00a12e23          	sw	a0,28(sp)
#ifdef Sudden_Underflow
  i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1));
#else
  if ((i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1))) != 0)
   14694:	50048a63          	beqz	s1,14ba8 <_dtoa_r+0x6a4>
    {
#endif
      d2.d = d.d;
      word0 (d2) &= Frac_mask1;
      word0 (d2) |= Exp_11;
   14698:	001007b7          	lui	a5,0x100
   1469c:	fff78793          	addi	a5,a5,-1 # fffff <_gp+0xe0b2f>
   146a0:	05812c83          	lw	s9,88(sp)
   146a4:	00f9f7b3          	and	a5,s3,a5
   146a8:	3ff00737          	lui	a4,0x3ff00
  i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1));
#else
  if ((i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1))) != 0)
    {
#endif
      d2.d = d.d;
   146ac:	00090513          	mv	a0,s2
      word0 (d2) &= Frac_mask1;
      word0 (d2) |= Exp_11;
   146b0:	00e7e5b3          	or	a1,a5,a4
		 * Hence we adjust the constant term to 0.1760912590558.
		 * (We could get a more accurate k by invoking log10,
		 *  but this is probably not worthwhile.)
		 */

      i -= Bias;
   146b4:	c0148493          	addi	s1,s1,-1023
#ifdef IBM
      i <<= 2;
      i += j;
#endif
#ifndef Sudden_Underflow
      denorm = 0;
   146b8:	04012423          	sw	zero,72(sp)
    }
#endif
#if defined (_DOUBLE_IS_32BITS)
  ds = (d2.d - 1.5) * 0.289529651 + 0.176091269 + i * 0.30103001;
#else
  ds = (d2.d - 1.5) * 0.289529654602168 + 0.1760912590558 + i * 0.301029995663981;
   146bc:	8281a603          	lw	a2,-2008(gp) # 1ecf8 <__wctomb+0x8>
   146c0:	82c1a683          	lw	a3,-2004(gp) # 1ecfc <__wctomb+0xc>
   146c4:	0c1060ef          	jal	1af84 <__subdf3>
   146c8:	8301a603          	lw	a2,-2000(gp) # 1ed00 <__wctomb+0x10>
   146cc:	8341a683          	lw	a3,-1996(gp) # 1ed04 <__wctomb+0x14>
   146d0:	111060ef          	jal	1afe0 <__muldf3>
   146d4:	8381a603          	lw	a2,-1992(gp) # 1ed08 <__wctomb+0x18>
   146d8:	83c1a683          	lw	a3,-1988(gp) # 1ed0c <__wctomb+0x1c>
   146dc:	059060ef          	jal	1af34 <__adddf3>
   146e0:	00050a13          	mv	s4,a0
   146e4:	00048513          	mv	a0,s1
   146e8:	00058a93          	mv	s5,a1
   146ec:	749060ef          	jal	1b634 <__floatsidf>
   146f0:	8401a603          	lw	a2,-1984(gp) # 1ed10 <__wctomb+0x20>
   146f4:	8441a683          	lw	a3,-1980(gp) # 1ed14 <__wctomb+0x24>
   146f8:	0e9060ef          	jal	1afe0 <__muldf3>
   146fc:	00050613          	mv	a2,a0
   14700:	00058693          	mv	a3,a1
   14704:	000a0513          	mv	a0,s4
   14708:	000a8593          	mv	a1,s5
   1470c:	029060ef          	jal	1af34 <__adddf3>
   14710:	00050a13          	mv	s4,a0
   14714:	00058a93          	mv	s5,a1
#endif
  k = (int) ds;
   14718:	064070ef          	jal	1b77c <__fixdfsi>
   1471c:	00a12823          	sw	a0,16(sp)
  if (ds < 0. && ds != k)
   14720:	00000613          	li	a2,0
   14724:	00000693          	li	a3,0
   14728:	000a0513          	mv	a0,s4
   1472c:	000a8593          	mv	a1,s5
   14730:	6a9060ef          	jal	1b5d8 <__ltdf2>
   14734:	02054ae3          	bltz	a0,14f68 <_dtoa_r+0xa64>
    k--;			/* want k = floor(ds) */
  k_check = 1;
   14738:	00100713          	li	a4,1
   1473c:	02e12223          	sw	a4,36(sp)
  if (k >= 0 && k <= Ten_pmax)
   14740:	01012703          	lw	a4,16(sp)
   14744:	01600793          	li	a5,22
   14748:	02e7ee63          	bltu	a5,a4,14784 <_dtoa_r+0x280>
    {
      if (d.d < tens[k])
   1474c:	00371793          	slli	a5,a4,0x3
   14750:	0001d737          	lui	a4,0x1d
   14754:	91870713          	addi	a4,a4,-1768 # 1c918 <__mprec_tens>
   14758:	00e787b3          	add	a5,a5,a4
   1475c:	0007a503          	lw	a0,0(a5)
   14760:	0047a583          	lw	a1,4(a5)
   14764:	00090613          	mv	a2,s2
   14768:	00098693          	mv	a3,s3
   1476c:	60d060ef          	jal	1b578 <__gtdf2>
   14770:	04a058e3          	blez	a0,14fc0 <_dtoa_r+0xabc>
	k--;
   14774:	01012783          	lw	a5,16(sp)
      k_check = 0;
   14778:	02012223          	sw	zero,36(sp)
    k--;			/* want k = floor(ds) */
  k_check = 1;
  if (k >= 0 && k <= Ten_pmax)
    {
      if (d.d < tens[k])
	k--;
   1477c:	fff78793          	addi	a5,a5,-1
   14780:	00f12823          	sw	a5,16(sp)
      k_check = 0;
    }
  j = bbits - i - 1;
   14784:	409c8cb3          	sub	s9,s9,s1
   14788:	fffc8c93          	addi	s9,s9,-1
   1478c:	01912623          	sw	s9,12(sp)
  if (j >= 0)
    {
      b2 = 0;
   14790:	00000a93          	li	s5,0
      if (d.d < tens[k])
	k--;
      k_check = 0;
    }
  j = bbits - i - 1;
  if (j >= 0)
   14794:	000cc2e3          	bltz	s9,14f98 <_dtoa_r+0xa94>
  else
    {
      b2 = -j;
      s2 = 0;
    }
  if (k >= 0)
   14798:	01012703          	lw	a4,16(sp)
   1479c:	7a074c63          	bltz	a4,14f54 <_dtoa_r+0xa50>
    {
      b5 = 0;
      s5 = k;
      s2 += k;
   147a0:	00c12783          	lw	a5,12(sp)
   147a4:	02e12423          	sw	a4,40(sp)
      b2 = -j;
      s2 = 0;
    }
  if (k >= 0)
    {
      b5 = 0;
   147a8:	00000b13          	li	s6,0
      s5 = k;
      s2 += k;
   147ac:	00e787b3          	add	a5,a5,a4
   147b0:	00f12623          	sw	a5,12(sp)
    {
      b2 -= k;
      b5 = -k;
      s5 = 0;
    }
  if (mode < 0 || mode > 9)
   147b4:	00900793          	li	a5,9
   147b8:	45b7e463          	bltu	a5,s11,14c00 <_dtoa_r+0x6fc>
    mode = 0;
  try_quick = 1;
  if (mode > 5)
   147bc:	00500793          	li	a5,5
      b5 = -k;
      s5 = 0;
    }
  if (mode < 0 || mode > 9)
    mode = 0;
  try_quick = 1;
   147c0:	00100a13          	li	s4,1
  if (mode > 5)
   147c4:	01b7d663          	ble	s11,a5,147d0 <_dtoa_r+0x2cc>
    {
      mode -= 4;
   147c8:	ffcd8d93          	addi	s11,s11,-4
      try_quick = 0;
   147cc:	00000a13          	li	s4,0
    }
  leftright = 1;
  ilim = ilim1 = -1;
  switch (mode)
   147d0:	00300793          	li	a5,3
   147d4:	50fd8ae3          	beq	s11,a5,154e8 <_dtoa_r+0xfe4>
   147d8:	47b7dce3          	ble	s11,a5,15450 <_dtoa_r+0xf4c>
   147dc:	00400793          	li	a5,4
   147e0:	32fd84e3          	beq	s11,a5,15308 <_dtoa_r+0xe04>
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   147e4:	00100713          	li	a4,1
  ilim = ilim1 = -1;
  switch (mode)
   147e8:	00500793          	li	a5,5
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   147ec:	02e12023          	sw	a4,32(sp)
  ilim = ilim1 = -1;
  switch (mode)
   147f0:	46fd96e3          	bne	s11,a5,1545c <_dtoa_r+0xf58>
      break;
    case 3:
      leftright = 0;
      /* no break */
    case 5:
      i = ndigits + k + 1;
   147f4:	01012703          	lw	a4,16(sp)
   147f8:	01770733          	add	a4,a4,s7
   147fc:	00170793          	addi	a5,a4,1
   14800:	02e12623          	sw	a4,44(sp)
   14804:	00f12c23          	sw	a5,24(sp)
   14808:	00078613          	mv	a2,a5
      ilim = i;
      ilim1 = i - 1;
      if (i <= 0)
   1480c:	00078493          	mv	s1,a5
   14810:	42f05ae3          	blez	a5,15444 <_dtoa_r+0xf40>
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   14814:	01700793          	li	a5,23
   14818:	04042223          	sw	zero,68(s0)
   1481c:	00000593          	li	a1,0
   14820:	02c7f263          	bleu	a2,a5,14844 <_dtoa_r+0x340>
   14824:	00100713          	li	a4,1
   14828:	00400793          	li	a5,4
       j <<= 1)
   1482c:	00179793          	slli	a5,a5,0x1
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   14830:	01478693          	addi	a3,a5,20
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
   14834:	00070593          	mv	a1,a4
   14838:	00170713          	addi	a4,a4,1
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   1483c:	fed678e3          	bleu	a3,a2,1482c <_dtoa_r+0x328>
   14840:	04b42223          	sw	a1,68(s0)
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   14844:	00040513          	mv	a0,s0
   14848:	6e1020ef          	jal	17728 <_Balloc>
  s = s0 = (char *) _REENT_MP_RESULT(ptr);

  if (ilim >= 0 && ilim <= Quick_max && try_quick)
   1484c:	00e00793          	li	a5,14
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   14850:	00050d13          	mv	s10,a0
   14854:	04a42023          	sw	a0,64(s0)
  s = s0 = (char *) _REENT_MP_RESULT(ptr);

  if (ilim >= 0 && ilim <= Quick_max && try_quick)
   14858:	3c97ee63          	bltu	a5,s1,14c34 <_dtoa_r+0x730>
   1485c:	3c0a0c63          	beqz	s4,14c34 <_dtoa_r+0x730>
      i = 0;
      d2.d = d.d;
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
      if (k > 0)
   14860:	01012703          	lw	a4,16(sp)
  if (ilim >= 0 && ilim <= Quick_max && try_quick)
    {
      /* Try to get by with floating-point arithmetic. */

      i = 0;
      d2.d = d.d;
   14864:	03212823          	sw	s2,48(sp)
   14868:	03312a23          	sw	s3,52(sp)
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
      if (k > 0)
   1486c:	58e056e3          	blez	a4,155f8 <_dtoa_r+0x10f4>
	{
	  ds = tens[k & 0xf];
   14870:	00f77793          	andi	a5,a4,15
   14874:	00379713          	slli	a4,a5,0x3
	  j = k >> 4;
   14878:	01012783          	lw	a5,16(sp)

      i = 0;
      d2.d = d.d;
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
   1487c:	00200493          	li	s1,2
      if (k > 0)
	{
	  ds = tens[k & 0xf];
	  j = k >> 4;
   14880:	4047da13          	srai	s4,a5,0x4
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
      if (k > 0)
	{
	  ds = tens[k & 0xf];
   14884:	0001d7b7          	lui	a5,0x1d
   14888:	91878793          	addi	a5,a5,-1768 # 1c918 <__mprec_tens>
   1488c:	00f707b3          	add	a5,a4,a5
	  j = k >> 4;
	  if (j & Bletch)
   14890:	010a7693          	andi	a3,s4,16
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
      if (k > 0)
	{
	  ds = tens[k & 0xf];
   14894:	0007a703          	lw	a4,0(a5)
   14898:	0047a783          	lw	a5,4(a5)
	  j = k >> 4;
	  if (j & Bletch)
   1489c:	02068e63          	beqz	a3,148d8 <_dtoa_r+0x3d4>
	    {
	      /* prevent overflows */
	      j &= Bletch - 1;
	      d.d /= bigtens[n_bigtens - 1];
   148a0:	0001d6b7          	lui	a3,0x1d
   148a4:	a286a603          	lw	a2,-1496(a3) # 1ca28 <__mprec_bigtens+0x20>
   148a8:	a2c6a683          	lw	a3,-1492(a3)
   148ac:	00090513          	mv	a0,s2
   148b0:	00098593          	mv	a1,s3
   148b4:	00e12423          	sw	a4,8(sp)
   148b8:	00f12223          	sw	a5,4(sp)
   148bc:	189060ef          	jal	1b244 <__divdf3>
	      ieps++;
   148c0:	00412783          	lw	a5,4(sp)
   148c4:	00812703          	lw	a4,8(sp)
	  ds = tens[k & 0xf];
	  j = k >> 4;
	  if (j & Bletch)
	    {
	      /* prevent overflows */
	      j &= Bletch - 1;
   148c8:	00fa7a13          	andi	s4,s4,15
	      d.d /= bigtens[n_bigtens - 1];
   148cc:	00050913          	mv	s2,a0
   148d0:	00058993          	mv	s3,a1
	      ieps++;
   148d4:	00300493          	li	s1,3
	    }
	  for (; j; j >>= 1, i++)
   148d8:	040a0063          	beqz	s4,14918 <_dtoa_r+0x414>
   148dc:	0001dc37          	lui	s8,0x1d
   148e0:	a08c0c13          	addi	s8,s8,-1528 # 1ca08 <__mprec_bigtens>
	    if (j & 1)
   148e4:	001a7693          	andi	a3,s4,1
	      {
		ieps++;
		ds *= bigtens[i];
   148e8:	00070513          	mv	a0,a4
	      /* prevent overflows */
	      j &= Bletch - 1;
	      d.d /= bigtens[n_bigtens - 1];
	      ieps++;
	    }
	  for (; j; j >>= 1, i++)
   148ec:	401a5a13          	srai	s4,s4,0x1
	    if (j & 1)
	      {
		ieps++;
		ds *= bigtens[i];
   148f0:	00078593          	mv	a1,a5
	      j &= Bletch - 1;
	      d.d /= bigtens[n_bigtens - 1];
	      ieps++;
	    }
	  for (; j; j >>= 1, i++)
	    if (j & 1)
   148f4:	00068e63          	beqz	a3,14910 <_dtoa_r+0x40c>
	      {
		ieps++;
		ds *= bigtens[i];
   148f8:	000c2603          	lw	a2,0(s8)
   148fc:	004c2683          	lw	a3,4(s8)
	      ieps++;
	    }
	  for (; j; j >>= 1, i++)
	    if (j & 1)
	      {
		ieps++;
   14900:	00148493          	addi	s1,s1,1
		ds *= bigtens[i];
   14904:	6dc060ef          	jal	1afe0 <__muldf3>
   14908:	00050713          	mv	a4,a0
   1490c:	00058793          	mv	a5,a1
   14910:	008c0c13          	addi	s8,s8,8
	      /* prevent overflows */
	      j &= Bletch - 1;
	      d.d /= bigtens[n_bigtens - 1];
	      ieps++;
	    }
	  for (; j; j >>= 1, i++)
   14914:	fc0a18e3          	bnez	s4,148e4 <_dtoa_r+0x3e0>
	    if (j & 1)
	      {
		ieps++;
		ds *= bigtens[i];
	      }
	  d.d /= ds;
   14918:	00090513          	mv	a0,s2
   1491c:	00098593          	mv	a1,s3
   14920:	00070613          	mv	a2,a4
   14924:	00078693          	mv	a3,a5
   14928:	11d060ef          	jal	1b244 <__divdf3>
   1492c:	00050913          	mv	s2,a0
   14930:	00058993          	mv	s3,a1
	      {
		ieps++;
		d.d *= bigtens[i];
	      }
	}
      if (k_check && d.d < 1. && ilim > 0)
   14934:	02412783          	lw	a5,36(sp)
   14938:	02078063          	beqz	a5,14958 <_dtoa_r+0x454>
   1493c:	8481a603          	lw	a2,-1976(gp) # 1ed18 <__wctomb+0x28>
   14940:	84c1a683          	lw	a3,-1972(gp) # 1ed1c <__wctomb+0x2c>
   14944:	00090513          	mv	a0,s2
   14948:	00098593          	mv	a1,s3
   1494c:	48d060ef          	jal	1b5d8 <__ltdf2>
   14950:	00055463          	bgez	a0,14958 <_dtoa_r+0x454>
   14954:	7650006f          	j	158b8 <_dtoa_r+0x13b4>
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   14958:	00048513          	mv	a0,s1
   1495c:	4d9060ef          	jal	1b634 <__floatsidf>
   14960:	00090613          	mv	a2,s2
   14964:	00098693          	mv	a3,s3
   14968:	678060ef          	jal	1afe0 <__muldf3>
   1496c:	85c1a683          	lw	a3,-1956(gp) # 1ed2c <__wctomb+0x3c>
   14970:	8581a603          	lw	a2,-1960(gp) # 1ed28 <__wctomb+0x38>
   14974:	5c0060ef          	jal	1af34 <__adddf3>
      word0 (eps) -= (P - 1) * Exp_msk1;
   14978:	fcc006b7          	lui	a3,0xfcc00
   1497c:	00b687b3          	add	a5,a3,a1
      if (ilim == 0)
   14980:	01812583          	lw	a1,24(sp)
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   14984:	00050713          	mv	a4,a0
      word0 (eps) -= (P - 1) * Exp_msk1;
      if (ilim == 0)
   14988:	3a0586e3          	beqz	a1,15534 <_dtoa_r+0x1030>
   1498c:	01012603          	lw	a2,16(sp)
   14990:	01812483          	lw	s1,24(sp)
   14994:	04c12623          	sw	a2,76(sp)
	  if (d.d < -eps.d)
	    goto no_digits;
	  goto fast_failed;
	}
#ifndef No_leftright
      if (leftright)
   14998:	02012683          	lw	a3,32(sp)
   1499c:	54068ae3          	beqz	a3,156f0 <_dtoa_r+0x11ec>
	{
	  /* Use Steele & White method of only
	   * generating digits needed.
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
   149a0:	fff48693          	addi	a3,s1,-1
   149a4:	00369613          	slli	a2,a3,0x3
   149a8:	0001d6b7          	lui	a3,0x1d
   149ac:	91868693          	addi	a3,a3,-1768 # 1c918 <__mprec_tens>
   149b0:	00d606b3          	add	a3,a2,a3
   149b4:	0006a603          	lw	a2,0(a3)
   149b8:	8681a503          	lw	a0,-1944(gp) # 1ed38 <__wctomb+0x48>
   149bc:	0046a683          	lw	a3,4(a3)
   149c0:	86c1a583          	lw	a1,-1940(gp) # 1ed3c <__wctomb+0x4c>
   149c4:	00e12423          	sw	a4,8(sp)
   149c8:	00f12223          	sw	a5,4(sp)
   149cc:	079060ef          	jal	1b244 <__divdf3>
   149d0:	00812703          	lw	a4,8(sp)
   149d4:	00412783          	lw	a5,4(sp)
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
   149d8:	001d0c93          	addi	s9,s10,1
      if (leftright)
	{
	  /* Use Steele & White method of only
	   * generating digits needed.
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
   149dc:	00070613          	mv	a2,a4
   149e0:	00078693          	mv	a3,a5
   149e4:	5a0060ef          	jal	1af84 <__subdf3>
   149e8:	02a12c23          	sw	a0,56(sp)
   149ec:	02b12e23          	sw	a1,60(sp)
	  for (i = 0;;)
	    {
	      L = d.d;
   149f0:	00090513          	mv	a0,s2
   149f4:	00098593          	mv	a1,s3
   149f8:	585060ef          	jal	1b77c <__fixdfsi>
   149fc:	00050a13          	mv	s4,a0
	      d.d -= L;
   14a00:	435060ef          	jal	1b634 <__floatsidf>
   14a04:	00050613          	mv	a2,a0
   14a08:	00058693          	mv	a3,a1
   14a0c:	00090513          	mv	a0,s2
   14a10:	00098593          	mv	a1,s3
   14a14:	570060ef          	jal	1af84 <__subdf3>
   14a18:	00050913          	mv	s2,a0
   14a1c:	00058993          	mv	s3,a1
	      *s++ = '0' + (int) L;
   14a20:	030a0a13          	addi	s4,s4,48
	      if (d.d < eps.d)
   14a24:	00050613          	mv	a2,a0
   14a28:	00058693          	mv	a3,a1
   14a2c:	03812503          	lw	a0,56(sp)
   14a30:	03c12583          	lw	a1,60(sp)
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
   14a34:	0ffa7a13          	andi	s4,s4,255
   14a38:	014d0023          	sb	s4,0(s10)
	      if (d.d < eps.d)
   14a3c:	33d060ef          	jal	1b578 <__gtdf2>
   14a40:	00a05463          	blez	a0,14a48 <_dtoa_r+0x544>
   14a44:	72d0006f          	j	15970 <_dtoa_r+0x146c>
		goto ret1;
	      if (1. - d.d < eps.d)
   14a48:	8481a503          	lw	a0,-1976(gp) # 1ed18 <__wctomb+0x28>
   14a4c:	84c1a583          	lw	a1,-1972(gp) # 1ed1c <__wctomb+0x2c>
   14a50:	00090613          	mv	a2,s2
   14a54:	00098693          	mv	a3,s3
   14a58:	00f12223          	sw	a5,4(sp)
   14a5c:	528060ef          	jal	1af84 <__subdf3>
   14a60:	00050613          	mv	a2,a0
   14a64:	00058693          	mv	a3,a1
   14a68:	03812503          	lw	a0,56(sp)
   14a6c:	03c12583          	lw	a1,60(sp)
   14a70:	309060ef          	jal	1b578 <__gtdf2>
   14a74:	00a05463          	blez	a0,14a7c <_dtoa_r+0x578>
   14a78:	7610006f          	j	159d8 <_dtoa_r+0x14d4>
		goto bump_up;
	      if (++i >= ilim)
   14a7c:	00100713          	li	a4,1
   14a80:	369756e3          	ble	s1,a4,155ec <_dtoa_r+0x10e8>
		break;
	      eps.d *= 10.;
	      d.d *= 10.;
   14a84:	05512023          	sw	s5,64(sp)
   14a88:	009d04b3          	add	s1,s10,s1
   14a8c:	000c8a93          	mv	s5,s9
   14a90:	03812c03          	lw	s8,56(sp)
   14a94:	03c12c83          	lw	s9,60(sp)
   14a98:	02c0006f          	j	14ac4 <_dtoa_r+0x5c0>
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
	      if (d.d < eps.d)
		goto ret1;
	      if (1. - d.d < eps.d)
   14a9c:	84818713          	addi	a4,gp,-1976 # 1ed18 <__wctomb+0x28>
   14aa0:	00072503          	lw	a0,0(a4)
   14aa4:	00472583          	lw	a1,4(a4)
   14aa8:	4dc060ef          	jal	1af84 <__subdf3>
   14aac:	000c0613          	mv	a2,s8
   14ab0:	000c8693          	mv	a3,s9
   14ab4:	325060ef          	jal	1b5d8 <__ltdf2>
   14ab8:	00055463          	bgez	a0,14ac0 <_dtoa_r+0x5bc>
   14abc:	6c10006f          	j	1597c <_dtoa_r+0x1478>
		goto bump_up;
	      if (++i >= ilim)
   14ac0:	329a84e3          	beq	s5,s1,155e8 <_dtoa_r+0x10e4>
		break;
	      eps.d *= 10.;
   14ac4:	85018793          	addi	a5,gp,-1968 # 1ed20 <__wctomb+0x30>
   14ac8:	0007a603          	lw	a2,0(a5)
   14acc:	0047a683          	lw	a3,4(a5)
   14ad0:	000c0513          	mv	a0,s8
   14ad4:	000c8593          	mv	a1,s9
   14ad8:	508060ef          	jal	1afe0 <__muldf3>
   14adc:	00058c93          	mv	s9,a1
	      d.d *= 10.;
   14ae0:	85018593          	addi	a1,gp,-1968 # 1ed20 <__wctomb+0x30>
   14ae4:	0005a603          	lw	a2,0(a1)
   14ae8:	0045a683          	lw	a3,4(a1)
		goto ret1;
	      if (1. - d.d < eps.d)
		goto bump_up;
	      if (++i >= ilim)
		break;
	      eps.d *= 10.;
   14aec:	00050c13          	mv	s8,a0
	      d.d *= 10.;
   14af0:	00098593          	mv	a1,s3
   14af4:	00090513          	mv	a0,s2
   14af8:	4e8060ef          	jal	1afe0 <__muldf3>
   14afc:	00058993          	mv	s3,a1
   14b00:	00050913          	mv	s2,a0
	   * generating digits needed.
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
	  for (i = 0;;)
	    {
	      L = d.d;
   14b04:	479060ef          	jal	1b77c <__fixdfsi>
   14b08:	00050a13          	mv	s4,a0
	      d.d -= L;
   14b0c:	329060ef          	jal	1b634 <__floatsidf>
   14b10:	00050613          	mv	a2,a0
   14b14:	00058693          	mv	a3,a1
   14b18:	00090513          	mv	a0,s2
   14b1c:	00098593          	mv	a1,s3
   14b20:	464060ef          	jal	1af84 <__subdf3>
	      *s++ = '0' + (int) L;
   14b24:	030a0793          	addi	a5,s4,48
   14b28:	0ff7fa13          	andi	s4,a5,255
   14b2c:	001a8a93          	addi	s5,s5,1
	      if (d.d < eps.d)
   14b30:	000c0613          	mv	a2,s8
   14b34:	000c8693          	mv	a3,s9
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
   14b38:	ff4a8fa3          	sb	s4,-1(s5)
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
   14b3c:	00050913          	mv	s2,a0
   14b40:	00058993          	mv	s3,a1
	      *s++ = '0' + (int) L;
	      if (d.d < eps.d)
   14b44:	295060ef          	jal	1b5d8 <__ltdf2>
		goto ret1;
	      if (1. - d.d < eps.d)
   14b48:	00090613          	mv	a2,s2
   14b4c:	00098693          	mv	a3,s3
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
	      if (d.d < eps.d)
   14b50:	f40556e3          	bgez	a0,14a9c <_dtoa_r+0x598>
   14b54:	04c12703          	lw	a4,76(sp)
   14b58:	000a8c93          	mv	s9,s5
   14b5c:	00e12823          	sw	a4,16(sp)
      if (mlo && mlo != mhi)
	Bfree (ptr, mlo);
      Bfree (ptr, mhi);
    }
ret1:
  Bfree (ptr, b);
   14b60:	01c12583          	lw	a1,28(sp)
   14b64:	00040513          	mv	a0,s0
   14b68:	465020ef          	jal	177cc <_Bfree>
  *s = 0;
  *decpt = k + 1;
   14b6c:	01012703          	lw	a4,16(sp)
   14b70:	01412583          	lw	a1,20(sp)
  if (rve)
   14b74:	0a012603          	lw	a2,160(sp)
      Bfree (ptr, mhi);
    }
ret1:
  Bfree (ptr, b);
  *s = 0;
  *decpt = k + 1;
   14b78:	00170793          	addi	a5,a4,1
	Bfree (ptr, mlo);
      Bfree (ptr, mhi);
    }
ret1:
  Bfree (ptr, b);
  *s = 0;
   14b7c:	000c8023          	sb	zero,0(s9)
  *decpt = k + 1;
   14b80:	00f5a023          	sw	a5,0(a1)
  if (rve)
   14b84:	22060ae3          	beqz	a2,155b8 <_dtoa_r+0x10b4>
    *rve = s;
   14b88:	01962023          	sw	s9,0(a2)
   14b8c:	000d0513          	mv	a0,s10
   14b90:	a4dff06f          	j	145dc <_dtoa_r+0xd8>
    {
      /* Infinity or NaN */
      *decpt = 9999;
      s =
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
   14b94:	00cb1613          	slli	a2,s6,0xc
   14b98:	a8061ae3          	bnez	a2,1462c <_dtoa_r+0x128>
   14b9c:	0001d537          	lui	a0,0x1d
   14ba0:	c2850513          	addi	a0,a0,-984 # 1cc28 <__thenan_sf+0x58>
   14ba4:	a91ff06f          	j	14634 <_dtoa_r+0x130>
    }
  else
    {
      /* d is denormalized */

      i = bbits + be + (Bias + (P - 1) - 1);
   14ba8:	05812c83          	lw	s9,88(sp)
   14bac:	05c12483          	lw	s1,92(sp)
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
       : (word1 (d) << (32 - i));
   14bb0:	02000793          	li	a5,32
    }
  else
    {
      /* d is denormalized */

      i = bbits + be + (Bias + (P - 1) - 1);
   14bb4:	009c84b3          	add	s1,s9,s1
   14bb8:	43248713          	addi	a4,s1,1074
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
       : (word1 (d) << (32 - i));
   14bbc:	3ee7dc63          	ble	a4,a5,14fb4 <_dtoa_r+0xab0>
   14bc0:	04000793          	li	a5,64
   14bc4:	41248513          	addi	a0,s1,1042
   14bc8:	40e78733          	sub	a4,a5,a4
   14bcc:	00a95533          	srl	a0,s2,a0
   14bd0:	00eb1b33          	sll	s6,s6,a4
   14bd4:	01656533          	or	a0,a0,s6
#endif
      d2.d = x;
   14bd8:	31d060ef          	jal	1b6f4 <__floatunsidf>
      word0 (d2) -= 31 * Exp_msk1;	/* adjust exponent */
   14bdc:	fe1007b7          	lui	a5,0xfe100
      i -= (Bias + (P - 1) - 1) + 1;
      denorm = 1;
   14be0:	00100713          	li	a4,1
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
       : (word1 (d) << (32 - i));
#endif
      d2.d = x;
      word0 (d2) -= 31 * Exp_msk1;	/* adjust exponent */
   14be4:	00b785b3          	add	a1,a5,a1
      i -= (Bias + (P - 1) - 1) + 1;
   14be8:	fff48493          	addi	s1,s1,-1
      denorm = 1;
   14bec:	04e12423          	sw	a4,72(sp)
   14bf0:	acdff06f          	j	146bc <_dtoa_r+0x1b8>
    {
      *decpt = 1;
      s = "0";
      if (rve)
	*rve = s + 1;
      return s;
   14bf4:	0001d537          	lui	a0,0x1d
   14bf8:	c2450513          	addi	a0,a0,-988 # 1cc24 <__thenan_sf+0x54>
   14bfc:	9e1ff06f          	j	145dc <_dtoa_r+0xd8>
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   14c00:	04042223          	sw	zero,68(s0)
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   14c04:	00000593          	li	a1,0
   14c08:	00040513          	mv	a0,s0
   14c0c:	31d020ef          	jal	17728 <_Balloc>
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   14c10:	fff00713          	li	a4,-1
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   14c14:	00100793          	li	a5,1
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   14c18:	00050d13          	mv	s10,a0
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   14c1c:	00e12c23          	sw	a4,24(sp)
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   14c20:	04a42023          	sw	a0,64(s0)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   14c24:	02e12623          	sw	a4,44(sp)
  switch (mode)
    {
    case 0:
    case 1:
      i = 18;
      ndigits = 0;
   14c28:	00000b93          	li	s7,0
      b2 -= k;
      b5 = -k;
      s5 = 0;
    }
  if (mode < 0 || mode > 9)
    mode = 0;
   14c2c:	00000d93          	li	s11,0
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   14c30:	02f12023          	sw	a5,32(sp)
      ilim = ilim0;
    }

  /* Do we have a "small" integer? */

  if (be >= 0 && k <= Int_max)
   14c34:	05c12783          	lw	a5,92(sp)
   14c38:	1c07c463          	bltz	a5,14e00 <_dtoa_r+0x8fc>
   14c3c:	01012683          	lw	a3,16(sp)
   14c40:	00e00713          	li	a4,14
   14c44:	1ad74e63          	blt	a4,a3,14e00 <_dtoa_r+0x8fc>
    {
      /* Yes. */
      ds = tens[k];
   14c48:	0001d737          	lui	a4,0x1d
   14c4c:	00369793          	slli	a5,a3,0x3
   14c50:	91870713          	addi	a4,a4,-1768 # 1c918 <__mprec_tens>
   14c54:	00e787b3          	add	a5,a5,a4
   14c58:	0007aa03          	lw	s4,0(a5) # fe100000 <_gp+0xfe0e0b30>
   14c5c:	0047aa83          	lw	s5,4(a5)
      if (ndigits < 0 && ilim <= 0)
   14c60:	6c0bc463          	bltz	s7,15328 <_dtoa_r+0xe24>
	    goto no_digits;
	  goto one_digit;
	}
      for (i = 1;; i++)
	{
	  L = d.d / ds;
   14c64:	000a0613          	mv	a2,s4
   14c68:	000a8693          	mv	a3,s5
   14c6c:	00090513          	mv	a0,s2
   14c70:	00098593          	mv	a1,s3
   14c74:	5d0060ef          	jal	1b244 <__divdf3>
   14c78:	305060ef          	jal	1b77c <__fixdfsi>
   14c7c:	00050c13          	mv	s8,a0
	  d.d -= L * ds;
   14c80:	1b5060ef          	jal	1b634 <__floatsidf>
   14c84:	000a0613          	mv	a2,s4
   14c88:	000a8693          	mv	a3,s5
   14c8c:	354060ef          	jal	1afe0 <__muldf3>
   14c90:	00050613          	mv	a2,a0
   14c94:	00058693          	mv	a3,a1
   14c98:	00090513          	mv	a0,s2
   14c9c:	00098593          	mv	a1,s3
   14ca0:	2e4060ef          	jal	1af84 <__subdf3>
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
	  if (i == ilim)
   14ca4:	01812603          	lw	a2,24(sp)
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
   14ca8:	030c0693          	addi	a3,s8,48
   14cac:	00dd0023          	sb	a3,0(s10)
	  if (i == ilim)
   14cb0:	00100693          	li	a3,1
	  goto one_digit;
	}
      for (i = 1;; i++)
	{
	  L = d.d / ds;
	  d.d -= L * ds;
   14cb4:	00050713          	mv	a4,a0
   14cb8:	00058793          	mv	a5,a1
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
   14cbc:	001d0c93          	addi	s9,s10,1
	  if (i == ilim)
   14cc0:	0cd60063          	beq	a2,a3,14d80 <_dtoa_r+0x87c>
		      }
		  ++*s++;
		}
	      break;
	    }
	  if (!(d.d *= 10.))
   14cc4:	8501a603          	lw	a2,-1968(gp) # 1ed20 <__wctomb+0x30>
   14cc8:	8541a683          	lw	a3,-1964(gp) # 1ed24 <__wctomb+0x34>
   14ccc:	314060ef          	jal	1afe0 <__muldf3>
   14cd0:	00000613          	li	a2,0
   14cd4:	00000693          	li	a3,0
   14cd8:	00050913          	mv	s2,a0
   14cdc:	00058993          	mv	s3,a1
   14ce0:	101060ef          	jal	1b5e0 <__eqdf2>
   14ce4:	e6050ee3          	beqz	a0,14b60 <_dtoa_r+0x65c>
   14ce8:	01812783          	lw	a5,24(sp)
   14cec:	8501ab03          	lw	s6,-1968(gp) # 1ed20 <__wctomb+0x30>
   14cf0:	8541ab83          	lw	s7,-1964(gp) # 1ed24 <__wctomb+0x34>
   14cf4:	002d0493          	addi	s1,s10,2
   14cf8:	00fd0db3          	add	s11,s10,a5
   14cfc:	0240006f          	j	14d20 <_dtoa_r+0x81c>
   14d00:	2e0060ef          	jal	1afe0 <__muldf3>
   14d04:	00000613          	li	a2,0
   14d08:	00000693          	li	a3,0
   14d0c:	00050913          	mv	s2,a0
   14d10:	00058993          	mv	s3,a1
   14d14:	00148493          	addi	s1,s1,1
   14d18:	0c9060ef          	jal	1b5e0 <__eqdf2>
   14d1c:	e40502e3          	beqz	a0,14b60 <_dtoa_r+0x65c>
	    goto no_digits;
	  goto one_digit;
	}
      for (i = 1;; i++)
	{
	  L = d.d / ds;
   14d20:	000a0613          	mv	a2,s4
   14d24:	000a8693          	mv	a3,s5
   14d28:	00090513          	mv	a0,s2
   14d2c:	00098593          	mv	a1,s3
   14d30:	514060ef          	jal	1b244 <__divdf3>
   14d34:	249060ef          	jal	1b77c <__fixdfsi>
   14d38:	00050c13          	mv	s8,a0
	  d.d -= L * ds;
   14d3c:	0f9060ef          	jal	1b634 <__floatsidf>
   14d40:	000a0613          	mv	a2,s4
   14d44:	000a8693          	mv	a3,s5
   14d48:	298060ef          	jal	1afe0 <__muldf3>
   14d4c:	00050613          	mv	a2,a0
   14d50:	00058693          	mv	a3,a1
   14d54:	00090513          	mv	a0,s2
   14d58:	00098593          	mv	a1,s3
   14d5c:	228060ef          	jal	1af84 <__subdf3>
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
   14d60:	030c0813          	addi	a6,s8,48
	  goto one_digit;
	}
      for (i = 1;; i++)
	{
	  L = d.d / ds;
	  d.d -= L * ds;
   14d64:	00050713          	mv	a4,a0
   14d68:	00058793          	mv	a5,a1
		      }
		  ++*s++;
		}
	      break;
	    }
	  if (!(d.d *= 10.))
   14d6c:	000b0613          	mv	a2,s6
   14d70:	000b8693          	mv	a3,s7
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
   14d74:	ff048fa3          	sb	a6,-1(s1)
   14d78:	00048c93          	mv	s9,s1
	  if (i == ilim)
   14d7c:	f89d92e3          	bne	s11,s1,14d00 <_dtoa_r+0x7fc>
	    {
	      d.d += d.d;
   14d80:	00070613          	mv	a2,a4
   14d84:	00078693          	mv	a3,a5
   14d88:	00070513          	mv	a0,a4
   14d8c:	00078593          	mv	a1,a5
   14d90:	1a4060ef          	jal	1af34 <__adddf3>
   14d94:	00050913          	mv	s2,a0
   14d98:	00058993          	mv	s3,a1
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
   14d9c:	00050613          	mv	a2,a0
   14da0:	00058693          	mv	a3,a1
   14da4:	000a0513          	mv	a0,s4
   14da8:	000a8593          	mv	a1,s5
   14dac:	02d060ef          	jal	1b5d8 <__ltdf2>
   14db0:	02054263          	bltz	a0,14dd4 <_dtoa_r+0x8d0>
   14db4:	00090613          	mv	a2,s2
   14db8:	00098693          	mv	a3,s3
   14dbc:	000a0513          	mv	a0,s4
   14dc0:	000a8593          	mv	a1,s5
   14dc4:	01d060ef          	jal	1b5e0 <__eqdf2>
   14dc8:	d8051ce3          	bnez	a0,14b60 <_dtoa_r+0x65c>
   14dcc:	001c7c13          	andi	s8,s8,1
   14dd0:	d80c08e3          	beqz	s8,14b60 <_dtoa_r+0x65c>
   14dd4:	fffcca03          	lbu	s4,-1(s9)
		{
		bump_up:
		  while (*--s == '9')
   14dd8:	03900713          	li	a4,57
   14ddc:	0100006f          	j	14dec <_dtoa_r+0x8e8>
		    if (s == s0)
   14de0:	0ba784e3          	beq	a5,s10,15688 <_dtoa_r+0x1184>
   14de4:	fff7ca03          	lbu	s4,-1(a5)
   14de8:	00078c93          	mv	s9,a5
	    {
	      d.d += d.d;
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
		{
		bump_up:
		  while (*--s == '9')
   14dec:	fffc8793          	addi	a5,s9,-1
   14df0:	feea08e3          	beq	s4,a4,14de0 <_dtoa_r+0x8dc>
		      {
			k++;
			*s = '0';
			break;
		      }
		  ++*s++;
   14df4:	001a0a13          	addi	s4,s4,1
   14df8:	01478023          	sb	s4,0(a5)
   14dfc:	d65ff06f          	j	14b60 <_dtoa_r+0x65c>
    }

  m2 = b2;
  m5 = b5;
  mhi = mlo = 0;
  if (leftright)
   14e00:	02012703          	lw	a4,32(sp)
   14e04:	1a070063          	beqz	a4,14fa4 <_dtoa_r+0xaa0>
    {
      if (mode < 2)
   14e08:	00100713          	li	a4,1
   14e0c:	57b75a63          	ble	s11,a4,15380 <_dtoa_r+0xe7c>
	    1 + P - bbits;
#endif
	}
      else
	{
	  j = ilim - 1;
   14e10:	01812703          	lw	a4,24(sp)
   14e14:	fff70793          	addi	a5,a4,-1
	  if (m5 >= j)
	    m5 -= j;
   14e18:	40fb0cb3          	sub	s9,s6,a5
#endif
	}
      else
	{
	  j = ilim - 1;
	  if (m5 >= j)
   14e1c:	00fb5e63          	ble	a5,s6,14e38 <_dtoa_r+0x934>
	    m5 -= j;
	  else
	    {
	      s5 += j -= m5;
   14e20:	02812583          	lw	a1,40(sp)
   14e24:	41678733          	sub	a4,a5,s6
	      b5 += j;
	      m5 = 0;
   14e28:	00000c93          	li	s9,0
	  j = ilim - 1;
	  if (m5 >= j)
	    m5 -= j;
	  else
	    {
	      s5 += j -= m5;
   14e2c:	00e585b3          	add	a1,a1,a4
   14e30:	02b12423          	sw	a1,40(sp)
   14e34:	00078b13          	mv	s6,a5
	      b5 += j;
	      m5 = 0;
	    }
	  if ((i = ilim) < 0)
   14e38:	01812783          	lw	a5,24(sp)
	    break;
	}
      goto ret1;
    }

  m2 = b2;
   14e3c:	000a8c13          	mv	s8,s5
	    {
	      s5 += j -= m5;
	      b5 += j;
	      m5 = 0;
	    }
	  if ((i = ilim) < 0)
   14e40:	2207c0e3          	bltz	a5,15860 <_dtoa_r+0x135c>
	      m2 -= i;
	      i = 0;
	    }
	}
      b2 += i;
      s2 += i;
   14e44:	00c12703          	lw	a4,12(sp)
      mhi = i2b (ptr, 1);
   14e48:	00100593          	li	a1,1
   14e4c:	00040513          	mv	a0,s0
	      m2 -= i;
	      i = 0;
	    }
	}
      b2 += i;
      s2 += i;
   14e50:	00f70733          	add	a4,a4,a5
	    {
	      m2 -= i;
	      i = 0;
	    }
	}
      b2 += i;
   14e54:	00fa8ab3          	add	s5,s5,a5
      s2 += i;
   14e58:	00e12623          	sw	a4,12(sp)
      mhi = i2b (ptr, 1);
   14e5c:	4d5020ef          	jal	17b30 <__i2b>
   14e60:	00050a13          	mv	s4,a0
    }
  if (m2 > 0 && s2 > 0)
   14e64:	020c0663          	beqz	s8,14e90 <_dtoa_r+0x98c>
   14e68:	00c12783          	lw	a5,12(sp)
   14e6c:	02f05263          	blez	a5,14e90 <_dtoa_r+0x98c>
    {
      i = m2 < s2 ? m2 : s2;
   14e70:	00c12703          	lw	a4,12(sp)
   14e74:	000c0793          	mv	a5,s8
   14e78:	45874463          	blt	a4,s8,152c0 <_dtoa_r+0xdbc>
      b2 -= i;
      m2 -= i;
      s2 -= i;
   14e7c:	00c12703          	lw	a4,12(sp)
      mhi = i2b (ptr, 1);
    }
  if (m2 > 0 && s2 > 0)
    {
      i = m2 < s2 ? m2 : s2;
      b2 -= i;
   14e80:	40fa8ab3          	sub	s5,s5,a5
      m2 -= i;
   14e84:	40fc0c33          	sub	s8,s8,a5
      s2 -= i;
   14e88:	40f70733          	sub	a4,a4,a5
   14e8c:	00e12623          	sw	a4,12(sp)
      if (rve)
	*rve = s + 1;
      return s;
    }

  b = d2b (ptr, d.d, &be, &bbits);
   14e90:	01c12483          	lw	s1,28(sp)
      i = m2 < s2 ? m2 : s2;
      b2 -= i;
      m2 -= i;
      s2 -= i;
    }
  if (b5 > 0)
   14e94:	07605263          	blez	s6,14ef8 <_dtoa_r+0x9f4>
    {
      if (leftright)
   14e98:	02012783          	lw	a5,32(sp)
   14e9c:	70078263          	beqz	a5,155a0 <_dtoa_r+0x109c>
	{
	  if (m5 > 0)
   14ea0:	040c8263          	beqz	s9,14ee4 <_dtoa_r+0x9e0>
	    {
	      mhi = pow5mult (ptr, mhi, m5);
   14ea4:	000a0593          	mv	a1,s4
   14ea8:	000c8613          	mv	a2,s9
   14eac:	00040513          	mv	a0,s0
   14eb0:	6a5020ef          	jal	17d54 <__pow5mult>
	      b1 = mult (ptr, mhi, b);
   14eb4:	01c12603          	lw	a2,28(sp)
   14eb8:	00050593          	mv	a1,a0
    {
      if (leftright)
	{
	  if (m5 > 0)
	    {
	      mhi = pow5mult (ptr, mhi, m5);
   14ebc:	00050a13          	mv	s4,a0
	      b1 = mult (ptr, mhi, b);
   14ec0:	00040513          	mv	a0,s0
   14ec4:	4a1020ef          	jal	17b64 <__multiply>
	      Bfree (ptr, b);
   14ec8:	01c12583          	lw	a1,28(sp)
      if (leftright)
	{
	  if (m5 > 0)
	    {
	      mhi = pow5mult (ptr, mhi, m5);
	      b1 = mult (ptr, mhi, b);
   14ecc:	00050493          	mv	s1,a0
	      Bfree (ptr, b);
	      b = b1;
	    }
         if ((j = b5 - m5) != 0)
   14ed0:	419b0b33          	sub	s6,s6,s9
	{
	  if (m5 > 0)
	    {
	      mhi = pow5mult (ptr, mhi, m5);
	      b1 = mult (ptr, mhi, b);
	      Bfree (ptr, b);
   14ed4:	00040513          	mv	a0,s0
   14ed8:	0f5020ef          	jal	177cc <_Bfree>
	      b = b1;
	    }
         if ((j = b5 - m5) != 0)
   14edc:	000b0e63          	beqz	s6,14ef8 <_dtoa_r+0x9f4>
	  if (m5 > 0)
	    {
	      mhi = pow5mult (ptr, mhi, m5);
	      b1 = mult (ptr, mhi, b);
	      Bfree (ptr, b);
	      b = b1;
   14ee0:	00912e23          	sw	s1,28(sp)
	    }
         if ((j = b5 - m5) != 0)
	    b = pow5mult (ptr, b, j);
   14ee4:	01c12583          	lw	a1,28(sp)
   14ee8:	000b0613          	mv	a2,s6
   14eec:	00040513          	mv	a0,s0
   14ef0:	665020ef          	jal	17d54 <__pow5mult>
   14ef4:	00050493          	mv	s1,a0
	}
      else
	b = pow5mult (ptr, b, b5);
    }
  S = i2b (ptr, 1);
   14ef8:	00100593          	li	a1,1
   14efc:	00040513          	mv	a0,s0
   14f00:	431020ef          	jal	17b30 <__i2b>
  if (s5 > 0)
   14f04:	02812703          	lw	a4,40(sp)
	    b = pow5mult (ptr, b, j);
	}
      else
	b = pow5mult (ptr, b, b5);
    }
  S = i2b (ptr, 1);
   14f08:	00050b13          	mv	s6,a0
  if (s5 > 0)
   14f0c:	0a070e63          	beqz	a4,14fc8 <_dtoa_r+0xac4>
    S = pow5mult (ptr, S, s5);
   14f10:	00050593          	mv	a1,a0
   14f14:	00070613          	mv	a2,a4
   14f18:	00040513          	mv	a0,s0
   14f1c:	639020ef          	jal	17d54 <__pow5mult>

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
  if (mode < 2)
   14f20:	00100793          	li	a5,1
      else
	b = pow5mult (ptr, b, b5);
    }
  S = i2b (ptr, 1);
  if (s5 > 0)
    S = pow5mult (ptr, S, s5);
   14f24:	00050b13          	mv	s6,a0

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
  if (mode < 2)
   14f28:	3bb7d063          	ble	s11,a5,152c8 <_dtoa_r+0xdc4>
  if (s5 > 0)
    S = pow5mult (ptr, S, s5);

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
   14f2c:	00000c93          	li	s9,0
   * and for all and pass them and a shift to quorem, so it
   * can do shifts and ors to compute the numerator for q.
   */

#ifdef Pack_32
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
   14f30:	010b2783          	lw	a5,16(s6) # 80000010 <_gp+0x7ffe0b40>
   14f34:	00378793          	addi	a5,a5,3
   14f38:	00279793          	slli	a5,a5,0x2
   14f3c:	00fb07b3          	add	a5,s6,a5
   14f40:	0047a503          	lw	a0,4(a5)
   14f44:	2c1020ef          	jal	17a04 <__hi0bits>
   14f48:	02000793          	li	a5,32
   14f4c:	40a78533          	sub	a0,a5,a0
   14f50:	0840006f          	j	14fd4 <_dtoa_r+0xad0>
      s5 = k;
      s2 += k;
    }
  else
    {
      b2 -= k;
   14f54:	01012703          	lw	a4,16(sp)
      b5 = -k;
      s5 = 0;
   14f58:	02012423          	sw	zero,40(sp)
      s5 = k;
      s2 += k;
    }
  else
    {
      b2 -= k;
   14f5c:	40ea8ab3          	sub	s5,s5,a4
      b5 = -k;
   14f60:	40e00b33          	neg	s6,a4
   14f64:	851ff06f          	j	147b4 <_dtoa_r+0x2b0>
  ds = (d2.d - 1.5) * 0.289529651 + 0.176091269 + i * 0.30103001;
#else
  ds = (d2.d - 1.5) * 0.289529654602168 + 0.1760912590558 + i * 0.301029995663981;
#endif
  k = (int) ds;
  if (ds < 0. && ds != k)
   14f68:	01012503          	lw	a0,16(sp)
   14f6c:	6c8060ef          	jal	1b634 <__floatsidf>
   14f70:	00050613          	mv	a2,a0
   14f74:	00058693          	mv	a3,a1
   14f78:	000a0513          	mv	a0,s4
   14f7c:	000a8593          	mv	a1,s5
   14f80:	65c060ef          	jal	1b5dc <__nedf2>
    k--;			/* want k = floor(ds) */
   14f84:	01012783          	lw	a5,16(sp)
   14f88:	00a03533          	snez	a0,a0
   14f8c:	40a787b3          	sub	a5,a5,a0
   14f90:	00f12823          	sw	a5,16(sp)
   14f94:	fa4ff06f          	j	14738 <_dtoa_r+0x234>
      b2 = 0;
      s2 = j;
    }
  else
    {
      b2 = -j;
   14f98:	41900ab3          	neg	s5,s9
      s2 = 0;
   14f9c:	00012623          	sw	zero,12(sp)
   14fa0:	ff8ff06f          	j	14798 <_dtoa_r+0x294>
   14fa4:	000b0c93          	mv	s9,s6
	    break;
	}
      goto ret1;
    }

  m2 = b2;
   14fa8:	000a8c13          	mv	s8,s5
  m5 = b5;
  mhi = mlo = 0;
   14fac:	00000a13          	li	s4,0
   14fb0:	eb5ff06f          	j	14e64 <_dtoa_r+0x960>
      i = bbits + be + (Bias + (P - 1) - 1);
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
       : (word1 (d) << (32 - i));
   14fb4:	40e78b33          	sub	s6,a5,a4
   14fb8:	01691533          	sll	a0,s2,s6
   14fbc:	c1dff06f          	j	14bd8 <_dtoa_r+0x6d4>
  k_check = 1;
  if (k >= 0 && k <= Ten_pmax)
    {
      if (d.d < tens[k])
	k--;
      k_check = 0;
   14fc0:	02012223          	sw	zero,36(sp)
   14fc4:	fc0ff06f          	j	14784 <_dtoa_r+0x280>
    S = pow5mult (ptr, S, s5);

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
  if (mode < 2)
   14fc8:	00100513          	li	a0,1
   14fcc:	45b55663          	ble	s11,a0,15418 <_dtoa_r+0xf14>
  if (s5 > 0)
    S = pow5mult (ptr, S, s5);

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
   14fd0:	00000c93          	li	s9,0
   * and for all and pass them and a shift to quorem, so it
   * can do shifts and ors to compute the numerator for q.
   */

#ifdef Pack_32
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
   14fd4:	00c12703          	lw	a4,12(sp)
   14fd8:	00e50533          	add	a0,a0,a4
   14fdc:	01f57513          	andi	a0,a0,31
   14fe0:	1a050663          	beqz	a0,1518c <_dtoa_r+0xc88>
    i = 32 - i;
   14fe4:	02000793          	li	a5,32
   14fe8:	40a787b3          	sub	a5,a5,a0
#else
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0xf) != 0)
    i = 16 - i;
#endif
  if (i > 4)
   14fec:	00400713          	li	a4,4
   14ff0:	20f752e3          	ble	a5,a4,159f4 <_dtoa_r+0x14f0>
    {
      i -= 4;
   14ff4:	01c00793          	li	a5,28
   14ff8:	40a78533          	sub	a0,a5,a0
      b2 += i;
      m2 += i;
      s2 += i;
   14ffc:	00c12783          	lw	a5,12(sp)
    i = 16 - i;
#endif
  if (i > 4)
    {
      i -= 4;
      b2 += i;
   15000:	00aa8ab3          	add	s5,s5,a0
      m2 += i;
   15004:	00ac0c33          	add	s8,s8,a0
      s2 += i;
   15008:	00a787b3          	add	a5,a5,a0
   1500c:	00f12623          	sw	a5,12(sp)
      i += 28;
      b2 += i;
      m2 += i;
      s2 += i;
    }
  if (b2 > 0)
   15010:	01505c63          	blez	s5,15028 <_dtoa_r+0xb24>
    b = lshift (ptr, b, b2);
   15014:	00048593          	mv	a1,s1
   15018:	000a8613          	mv	a2,s5
   1501c:	00040513          	mv	a0,s0
   15020:	66d020ef          	jal	17e8c <__lshift>
   15024:	00050493          	mv	s1,a0
  if (s2 > 0)
   15028:	00c12783          	lw	a5,12(sp)
   1502c:	00f05c63          	blez	a5,15044 <_dtoa_r+0xb40>
    S = lshift (ptr, S, s2);
   15030:	000b0593          	mv	a1,s6
   15034:	00078613          	mv	a2,a5
   15038:	00040513          	mv	a0,s0
   1503c:	651020ef          	jal	17e8c <__lshift>
   15040:	00050b13          	mv	s6,a0
  if (k_check)
   15044:	02412703          	lw	a4,36(sp)
   15048:	16071063          	bnez	a4,151a8 <_dtoa_r+0xca4>
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   1504c:	01812703          	lw	a4,24(sp)
   15050:	44e05063          	blez	a4,15490 <_dtoa_r+0xf8c>
    one_digit:
      *s++ = '1';
      k++;
      goto ret;
    }
  if (leftright)
   15054:	02012783          	lw	a5,32(sp)
   15058:	18078c63          	beqz	a5,151f0 <_dtoa_r+0xcec>
    {
      if (m2 > 0)
   1505c:	01805c63          	blez	s8,15074 <_dtoa_r+0xb70>
	mhi = lshift (ptr, mhi, m2);
   15060:	000a0593          	mv	a1,s4
   15064:	000c0613          	mv	a2,s8
   15068:	00040513          	mv	a0,s0
   1506c:	621020ef          	jal	17e8c <__lshift>
   15070:	00050a13          	mv	s4,a0
   15074:	000a0c13          	mv	s8,s4
      /* Compute mlo -- check for special case
       * that d is a normalized power of 2.
       */

      mlo = mhi;
      if (spec_case)
   15078:	620c9663          	bnez	s9,156a4 <_dtoa_r+0x11a0>
   1507c:	01812703          	lw	a4,24(sp)
	  j = cmp (b, mlo);
	  delta = diff (ptr, S, mhi);
	  j1 = delta->_sign ? 1 : cmp (b, delta);
	  Bfree (ptr, delta);
#ifndef ROUND_BIASED
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
   15080:	00197793          	andi	a5,s2,1
   15084:	001d0993          	addi	s3,s10,1
   15088:	00ed0733          	add	a4,s10,a4
   1508c:	00e12e23          	sw	a4,28(sp)
   15090:	00f12c23          	sw	a5,24(sp)
   15094:	03a12023          	sw	s10,32(sp)
	  mhi = lshift (ptr, mhi, Log2P);
	}

      for (i = 1;; i++)
	{
	  dig = quorem (b, S) + '0';
   15098:	000b0593          	mv	a1,s6
   1509c:	00048513          	mv	a0,s1
   150a0:	a7cff0ef          	jal	1431c <quorem>
   150a4:	00050c93          	mv	s9,a0
	  /* Do we yet have the shortest decimal string
	   * that will round to d?
	   */
	  j = cmp (b, mlo);
   150a8:	000a0593          	mv	a1,s4
   150ac:	00048513          	mv	a0,s1
   150b0:	72d020ef          	jal	17fdc <__mcmp>
   150b4:	00050a93          	mv	s5,a0
	  delta = diff (ptr, S, mhi);
   150b8:	000c0613          	mv	a2,s8
   150bc:	000b0593          	mv	a1,s6
   150c0:	00040513          	mv	a0,s0
   150c4:	779020ef          	jal	1803c <__mdiff>
	  j1 = delta->_sign ? 1 : cmp (b, delta);
   150c8:	00c52683          	lw	a3,12(a0)
   150cc:	fff98713          	addi	a4,s3,-1
	  dig = quorem (b, S) + '0';
	  /* Do we yet have the shortest decimal string
	   * that will round to d?
	   */
	  j = cmp (b, mlo);
	  delta = diff (ptr, S, mhi);
   150d0:	00050d13          	mv	s10,a0
   150d4:	00e12623          	sw	a4,12(sp)
	  mhi = lshift (ptr, mhi, Log2P);
	}

      for (i = 1;; i++)
	{
	  dig = quorem (b, S) + '0';
   150d8:	030c8b93          	addi	s7,s9,48
	  /* Do we yet have the shortest decimal string
	   * that will round to d?
	   */
	  j = cmp (b, mlo);
	  delta = diff (ptr, S, mhi);
	  j1 = delta->_sign ? 1 : cmp (b, delta);
   150dc:	00100913          	li	s2,1
   150e0:	00069a63          	bnez	a3,150f4 <_dtoa_r+0xbf0>
   150e4:	00050593          	mv	a1,a0
   150e8:	00048513          	mv	a0,s1
   150ec:	6f1020ef          	jal	17fdc <__mcmp>
   150f0:	00050913          	mv	s2,a0
	  Bfree (ptr, delta);
   150f4:	000d0593          	mv	a1,s10
   150f8:	00040513          	mv	a0,s0
   150fc:	6d0020ef          	jal	177cc <_Bfree>
#ifndef ROUND_BIASED
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
   15100:	01b967b3          	or	a5,s2,s11
   15104:	00079663          	bnez	a5,15110 <_dtoa_r+0xc0c>
   15108:	01812783          	lw	a5,24(sp)
   1510c:	28078663          	beqz	a5,15398 <_dtoa_r+0xe94>
		dig++;
	      *s++ = dig;
	      goto ret;
	    }
#endif
         if ((j < 0) || ((j == 0) && !mode
   15110:	2a0acc63          	bltz	s5,153c8 <_dtoa_r+0xec4>
   15114:	01baeab3          	or	s5,s5,s11
   15118:	000a9663          	bnez	s5,15124 <_dtoa_r+0xc20>
#ifndef ROUND_BIASED
	      && !(word1 (d) & 1)
   1511c:	01812703          	lw	a4,24(sp)
   15120:	2a070463          	beqz	a4,153c8 <_dtoa_r+0xec4>
		    goto round_9_up;
		}
	      *s++ = dig;
	      goto ret;
	    }
	  if (j1 > 0)
   15124:	71204063          	bgtz	s2,15824 <_dtoa_r+0x1320>
		}
	      *s++ = dig + 1;
	      goto ret;
	    }
	  *s++ = dig;
	  if (i == ilim)
   15128:	01c12783          	lw	a5,28(sp)
		  goto roundoff;
		}
	      *s++ = dig + 1;
	      goto ret;
	    }
	  *s++ = dig;
   1512c:	00098c93          	mv	s9,s3
   15130:	ff798fa3          	sb	s7,-1(s3)
	  if (i == ilim)
   15134:	71378e63          	beq	a5,s3,15850 <_dtoa_r+0x134c>
	    break;
	  b = multadd (ptr, b, 10, 0);
   15138:	00048593          	mv	a1,s1
   1513c:	00000693          	li	a3,0
   15140:	00a00613          	li	a2,10
   15144:	00040513          	mv	a0,s0
   15148:	6a8020ef          	jal	177f0 <__multadd>
   1514c:	00050493          	mv	s1,a0
	  if (mlo == mhi)
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
   15150:	00000693          	li	a3,0
   15154:	00a00613          	li	a2,10
   15158:	000a0593          	mv	a1,s4
   1515c:	00040513          	mv	a0,s0
	    }
	  *s++ = dig;
	  if (i == ilim)
	    break;
	  b = multadd (ptr, b, 10, 0);
	  if (mlo == mhi)
   15160:	2d8a0063          	beq	s4,s8,15420 <_dtoa_r+0xf1c>
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
	  else
	    {
	      mlo = multadd (ptr, mlo, 10, 0);
   15164:	68c020ef          	jal	177f0 <__multadd>
   15168:	00050a13          	mv	s4,a0
	      mhi = multadd (ptr, mhi, 10, 0);
   1516c:	000c0593          	mv	a1,s8
   15170:	00000693          	li	a3,0
   15174:	00a00613          	li	a2,10
   15178:	00040513          	mv	a0,s0
   1517c:	674020ef          	jal	177f0 <__multadd>
   15180:	00050c13          	mv	s8,a0
   15184:	00198993          	addi	s3,s3,1
	    }
	}
   15188:	f11ff06f          	j	15098 <_dtoa_r+0xb94>
   1518c:	01c00513          	li	a0,28
  else if (i < 4)
    {
      i += 28;
      b2 += i;
      m2 += i;
      s2 += i;
   15190:	00c12703          	lw	a4,12(sp)
      s2 += i;
    }
  else if (i < 4)
    {
      i += 28;
      b2 += i;
   15194:	00aa8ab3          	add	s5,s5,a0
      m2 += i;
   15198:	00ac0c33          	add	s8,s8,a0
      s2 += i;
   1519c:	00a70733          	add	a4,a4,a0
   151a0:	00e12623          	sw	a4,12(sp)
   151a4:	e6dff06f          	j	15010 <_dtoa_r+0xb0c>
    b = lshift (ptr, b, b2);
  if (s2 > 0)
    S = lshift (ptr, S, s2);
  if (k_check)
    {
      if (cmp (b, S) < 0)
   151a8:	000b0593          	mv	a1,s6
   151ac:	00048513          	mv	a0,s1
   151b0:	62d020ef          	jal	17fdc <__mcmp>
   151b4:	e8055ce3          	bgez	a0,1504c <_dtoa_r+0xb48>
	{
	  k--;
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
   151b8:	00048593          	mv	a1,s1
   151bc:	00000693          	li	a3,0
   151c0:	00a00613          	li	a2,10
   151c4:	00040513          	mv	a0,s0
   151c8:	628020ef          	jal	177f0 <__multadd>
    S = lshift (ptr, S, s2);
  if (k_check)
    {
      if (cmp (b, S) < 0)
	{
	  k--;
   151cc:	01012783          	lw	a5,16(sp)
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
	  if (leftright)
   151d0:	02012703          	lw	a4,32(sp)
  if (k_check)
    {
      if (cmp (b, S) < 0)
	{
	  k--;
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
   151d4:	00050493          	mv	s1,a0
    S = lshift (ptr, S, s2);
  if (k_check)
    {
      if (cmp (b, S) < 0)
	{
	  k--;
   151d8:	fff78793          	addi	a5,a5,-1
   151dc:	00f12823          	sw	a5,16(sp)
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
	  if (leftright)
   151e0:	7a071e63          	bnez	a4,1599c <_dtoa_r+0x1498>
	    mhi = multadd (ptr, mhi, 10, 0);
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   151e4:	02c12783          	lw	a5,44(sp)
   151e8:	7cf05e63          	blez	a5,159c4 <_dtoa_r+0x14c0>
   151ec:	00f12c23          	sw	a5,24(sp)
	  *s++ = dig;
	  if (i == ilim)
	    break;
	  b = multadd (ptr, b, 10, 0);
	  if (mlo == mhi)
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
   151f0:	000d0913          	mv	s2,s10
   151f4:	01812983          	lw	s3,24(sp)
   151f8:	00c0006f          	j	15204 <_dtoa_r+0xd00>
    for (i = 1;; i++)
      {
	*s++ = dig = quorem (b, S) + '0';
	if (i >= ilim)
	  break;
	b = multadd (ptr, b, 10, 0);
   151fc:	5f4020ef          	jal	177f0 <__multadd>
   15200:	00050493          	mv	s1,a0
	}
    }
  else
    for (i = 1;; i++)
      {
	*s++ = dig = quorem (b, S) + '0';
   15204:	000b0593          	mv	a1,s6
   15208:	00048513          	mv	a0,s1
   1520c:	910ff0ef          	jal	1431c <quorem>
   15210:	00190913          	addi	s2,s2,1
   15214:	03050b93          	addi	s7,a0,48
	if (i >= ilim)
   15218:	41a907b3          	sub	a5,s2,s10
	  break;
	b = multadd (ptr, b, 10, 0);
   1521c:	00000693          	li	a3,0
   15220:	00a00613          	li	a2,10
   15224:	00048593          	mv	a1,s1
   15228:	00040513          	mv	a0,s0
	}
    }
  else
    for (i = 1;; i++)
      {
	*s++ = dig = quorem (b, S) + '0';
   1522c:	ff790fa3          	sb	s7,-1(s2)
	if (i >= ilim)
   15230:	fd37c6e3          	blt	a5,s3,151fc <_dtoa_r+0xcf8>
   15234:	01812d83          	lw	s11,24(sp)
   15238:	63b05a63          	blez	s11,1586c <_dtoa_r+0x1368>
   1523c:	01bd0cb3          	add	s9,s10,s11
      goto ret1;
    }

  m2 = b2;
  m5 = b5;
  mhi = mlo = 0;
   15240:	00000913          	li	s2,0
	b = multadd (ptr, b, 10, 0);
      }

  /* Round off last digit */

  b = lshift (ptr, b, 1);
   15244:	00048593          	mv	a1,s1
   15248:	00100613          	li	a2,1
   1524c:	00040513          	mv	a0,s0
   15250:	43d020ef          	jal	17e8c <__lshift>
  j = cmp (b, S);
   15254:	000b0593          	mv	a1,s6
	b = multadd (ptr, b, 10, 0);
      }

  /* Round off last digit */

  b = lshift (ptr, b, 1);
   15258:	00a12e23          	sw	a0,28(sp)
  j = cmp (b, S);
   1525c:	581020ef          	jal	17fdc <__mcmp>
  if ((j > 0) || ((j == 0) && (dig & 1)))
   15260:	36a05063          	blez	a0,155c0 <_dtoa_r+0x10bc>
   15264:	fffcc703          	lbu	a4,-1(s9)
    {
    roundoff:
      while (*--s == '9')
   15268:	03900693          	li	a3,57
   1526c:	0100006f          	j	1527c <_dtoa_r+0xd78>
	if (s == s0)
   15270:	29a78063          	beq	a5,s10,154f0 <_dtoa_r+0xfec>
   15274:	fff7c703          	lbu	a4,-1(a5)
   15278:	00078c93          	mv	s9,a5
  b = lshift (ptr, b, 1);
  j = cmp (b, S);
  if ((j > 0) || ((j == 0) && (dig & 1)))
    {
    roundoff:
      while (*--s == '9')
   1527c:	fffc8793          	addi	a5,s9,-1
   15280:	fed708e3          	beq	a4,a3,15270 <_dtoa_r+0xd6c>
	  {
	    k++;
	    *s++ = '1';
	    goto ret;
	  }
      ++*s++;
   15284:	00170713          	addi	a4,a4,1
   15288:	00e78023          	sb	a4,0(a5)
    {
      while (*--s == '0');
      s++;
    }
ret:
  Bfree (ptr, S);
   1528c:	000b0593          	mv	a1,s6
   15290:	00040513          	mv	a0,s0
   15294:	538020ef          	jal	177cc <_Bfree>
  if (mhi)
   15298:	8c0a04e3          	beqz	s4,14b60 <_dtoa_r+0x65c>
    {
      if (mlo && mlo != mhi)
   1529c:	00090a63          	beqz	s2,152b0 <_dtoa_r+0xdac>
   152a0:	01490863          	beq	s2,s4,152b0 <_dtoa_r+0xdac>
	Bfree (ptr, mlo);
   152a4:	00090593          	mv	a1,s2
   152a8:	00040513          	mv	a0,s0
   152ac:	520020ef          	jal	177cc <_Bfree>
      Bfree (ptr, mhi);
   152b0:	000a0593          	mv	a1,s4
   152b4:	00040513          	mv	a0,s0
   152b8:	514020ef          	jal	177cc <_Bfree>
   152bc:	8a5ff06f          	j	14b60 <_dtoa_r+0x65c>
      s2 += i;
      mhi = i2b (ptr, 1);
    }
  if (m2 > 0 && s2 > 0)
    {
      i = m2 < s2 ? m2 : s2;
   152c0:	00070793          	mv	a5,a4
   152c4:	bb9ff06f          	j	14e7c <_dtoa_r+0x978>
  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
  if (mode < 2)
    {
      if (!word1 (d) && !(word0 (d) & Bndry_mask)
   152c8:	c60912e3          	bnez	s2,14f2c <_dtoa_r+0xa28>
   152cc:	00c99793          	slli	a5,s3,0xc
  if (s5 > 0)
    S = pow5mult (ptr, S, s5);

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
   152d0:	00000c93          	li	s9,0
  if (mode < 2)
    {
      if (!word1 (d) && !(word0 (d) & Bndry_mask)
   152d4:	02079263          	bnez	a5,152f8 <_dtoa_r+0xdf4>
#ifndef Sudden_Underflow
	  && word0 (d) & Exp_mask
   152d8:	7ff007b7          	lui	a5,0x7ff00
   152dc:	0137f7b3          	and	a5,a5,s3
   152e0:	00078c63          	beqz	a5,152f8 <_dtoa_r+0xdf4>
#endif
	)
	{
	  /* The special case */
	  b2 += Log2P;
	  s2 += Log2P;
   152e4:	00c12703          	lw	a4,12(sp)
	  && word0 (d) & Exp_mask
#endif
	)
	{
	  /* The special case */
	  b2 += Log2P;
   152e8:	001a8a93          	addi	s5,s5,1
	  s2 += Log2P;
	  spec_case = 1;
   152ec:	00100c93          	li	s9,1
#endif
	)
	{
	  /* The special case */
	  b2 += Log2P;
	  s2 += Log2P;
   152f0:	00170713          	addi	a4,a4,1
   152f4:	00e12623          	sw	a4,12(sp)
   * and for all and pass them and a shift to quorem, so it
   * can do shifts and ors to compute the numerator for q.
   */

#ifdef Pack_32
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
   152f8:	02812783          	lw	a5,40(sp)
   152fc:	00100513          	li	a0,1
   15300:	cc078ae3          	beqz	a5,14fd4 <_dtoa_r+0xad0>
   15304:	c2dff06f          	j	14f30 <_dtoa_r+0xa2c>
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   15308:	00100793          	li	a5,1
   1530c:	02f12023          	sw	a5,32(sp)
      break;
    case 2:
      leftright = 0;
      /* no break */
    case 4:
      if (ndigits <= 0)
   15310:	13705263          	blez	s7,15434 <_dtoa_r+0xf30>
   15314:	000b8613          	mv	a2,s7
   15318:	000b8493          	mv	s1,s7
   1531c:	03712623          	sw	s7,44(sp)
   15320:	01712c23          	sw	s7,24(sp)
   15324:	cf0ff06f          	j	14814 <_dtoa_r+0x310>

  if (be >= 0 && k <= Int_max)
    {
      /* Yes. */
      ds = tens[k];
      if (ndigits < 0 && ilim <= 0)
   15328:	01812703          	lw	a4,24(sp)
   1532c:	92e04ce3          	bgtz	a4,14c64 <_dtoa_r+0x760>
	{
	  S = mhi = 0;
	  if (ilim < 0 || d.d <= 5 * ds)
   15330:	26071263          	bnez	a4,15594 <_dtoa_r+0x1090>
   15334:	8601a603          	lw	a2,-1952(gp) # 1ed30 <__wctomb+0x40>
   15338:	8641a683          	lw	a3,-1948(gp) # 1ed34 <__wctomb+0x44>
   1533c:	000a0513          	mv	a0,s4
   15340:	000a8593          	mv	a1,s5
   15344:	49d050ef          	jal	1afe0 <__muldf3>
   15348:	00090613          	mv	a2,s2
   1534c:	00098693          	mv	a3,s3
   15350:	1c8060ef          	jal	1b518 <__gedf2>
    {
      /* Yes. */
      ds = tens[k];
      if (ndigits < 0 && ilim <= 0)
	{
	  S = mhi = 0;
   15354:	00000b13          	li	s6,0
   15358:	00000a13          	li	s4,0
	  if (ilim < 0 || d.d <= 5 * ds)
   1535c:	16054863          	bltz	a0,154cc <_dtoa_r+0xfc8>
    {
      if (ilim < 0 || cmp (b, S = multadd (ptr, S, 5, 0)) <= 0)
	{
	  /* no digits, fcvt style */
	no_digits:
	  k = -1 - ndigits;
   15360:	fffbcb93          	not	s7,s7
   15364:	01712823          	sw	s7,16(sp)
	  goto ret;
   15368:	000d0c93          	mv	s9,s10
    {
      while (*--s == '0');
      s++;
    }
ret:
  Bfree (ptr, S);
   1536c:	000b0593          	mv	a1,s6
   15370:	00040513          	mv	a0,s0
   15374:	458020ef          	jal	177cc <_Bfree>
  if (mhi)
   15378:	fe0a0463          	beqz	s4,14b60 <_dtoa_r+0x65c>
   1537c:	f35ff06f          	j	152b0 <_dtoa_r+0xdac>
    {
      if (mode < 2)
	{
	  i =
#ifndef Sudden_Underflow
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
   15380:	04812703          	lw	a4,72(sp)
   15384:	4e070863          	beqz	a4,15874 <_dtoa_r+0x1370>
   15388:	43378793          	addi	a5,a5,1075 # 7ff00433 <_gp+0x7fee0f63>
   1538c:	000b0c93          	mv	s9,s6
	    break;
	}
      goto ret1;
    }

  m2 = b2;
   15390:	000a8c13          	mv	s8,s5
   15394:	ab1ff06f          	j	14e44 <_dtoa_r+0x940>
	  j1 = delta->_sign ? 1 : cmp (b, delta);
	  Bfree (ptr, delta);
#ifndef ROUND_BIASED
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
	    {
	      if (dig == '9')
   15398:	03900793          	li	a5,57
   1539c:	02012d03          	lw	s10,32(sp)
   153a0:	4efb8a63          	beq	s7,a5,15894 <_dtoa_r+0x1390>
		goto round_9_up;
	      if (j > 0)
   153a4:	01505463          	blez	s5,153ac <_dtoa_r+0xea8>
		dig++;
   153a8:	031c8b93          	addi	s7,s9,49
	      *s++ = dig;
   153ac:	00c12683          	lw	a3,12(sp)
	      goto ret;
   153b0:	000a0913          	mv	s2,s4
   153b4:	00912e23          	sw	s1,28(sp)
	    {
	      if (dig == '9')
		goto round_9_up;
	      if (j > 0)
		dig++;
	      *s++ = dig;
   153b8:	00168c93          	addi	s9,a3,1
   153bc:	01768023          	sb	s7,0(a3)
	      goto ret;
   153c0:	000c0a13          	mv	s4,s8
   153c4:	ec9ff06f          	j	1528c <_dtoa_r+0xd88>
   153c8:	02012d03          	lw	s10,32(sp)
#ifndef ROUND_BIASED
	      && !(word1 (d) & 1)
#endif
           ))
	    {
	      if (j1 > 0)
   153cc:	03205863          	blez	s2,153fc <_dtoa_r+0xef8>
		{
		  b = lshift (ptr, b, 1);
   153d0:	00048593          	mv	a1,s1
   153d4:	00100613          	li	a2,1
   153d8:	00040513          	mv	a0,s0
   153dc:	2b1020ef          	jal	17e8c <__lshift>
		  j1 = cmp (b, S);
   153e0:	000b0593          	mv	a1,s6
#endif
           ))
	    {
	      if (j1 > 0)
		{
		  b = lshift (ptr, b, 1);
   153e4:	00050493          	mv	s1,a0
		  j1 = cmp (b, S);
   153e8:	3f5020ef          	jal	17fdc <__mcmp>
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
   153ec:	5aa05063          	blez	a0,1598c <_dtoa_r+0x1488>
		      && dig++ == '9')
   153f0:	03900793          	li	a5,57
   153f4:	4afb8063          	beq	s7,a5,15894 <_dtoa_r+0x1390>
   153f8:	031c8b93          	addi	s7,s9,49
		    goto round_9_up;
		}
	      *s++ = dig;
   153fc:	00c12783          	lw	a5,12(sp)
	      goto ret;
   15400:	000a0913          	mv	s2,s4
   15404:	00912e23          	sw	s1,28(sp)
		  j1 = cmp (b, S);
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
		      && dig++ == '9')
		    goto round_9_up;
		}
	      *s++ = dig;
   15408:	00178c93          	addi	s9,a5,1
   1540c:	01778023          	sb	s7,0(a5)
	      goto ret;
   15410:	000c0a13          	mv	s4,s8
   15414:	e79ff06f          	j	1528c <_dtoa_r+0xd88>
  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
  if (mode < 2)
    {
      if (!word1 (d) && !(word0 (d) & Bndry_mask)
   15418:	ba091ce3          	bnez	s2,14fd0 <_dtoa_r+0xacc>
   1541c:	eb1ff06f          	j	152cc <_dtoa_r+0xdc8>
	  *s++ = dig;
	  if (i == ilim)
	    break;
	  b = multadd (ptr, b, 10, 0);
	  if (mlo == mhi)
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
   15420:	3d0020ef          	jal	177f0 <__multadd>
   15424:	00050a13          	mv	s4,a0
   15428:	00050c13          	mv	s8,a0
   1542c:	00198993          	addi	s3,s3,1
   15430:	c69ff06f          	j	15098 <_dtoa_r+0xb94>
   15434:	00100493          	li	s1,1
    case 2:
      leftright = 0;
      /* no break */
    case 4:
      if (ndigits <= 0)
	ndigits = 1;
   15438:	02912623          	sw	s1,44(sp)
   1543c:	00912c23          	sw	s1,24(sp)
   15440:	00048b93          	mv	s7,s1
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   15444:	04042223          	sw	zero,68(s0)
   15448:	00000593          	li	a1,0
   1544c:	bf8ff06f          	j	14844 <_dtoa_r+0x340>
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
  switch (mode)
   15450:	00200793          	li	a5,2
    case 1:
      i = 18;
      ndigits = 0;
      break;
    case 2:
      leftright = 0;
   15454:	02012023          	sw	zero,32(sp)
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
  switch (mode)
   15458:	eafd8ce3          	beq	s11,a5,15310 <_dtoa_r+0xe0c>
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   1545c:	04042223          	sw	zero,68(s0)
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   15460:	00000593          	li	a1,0
   15464:	00040513          	mv	a0,s0
   15468:	2c0020ef          	jal	17728 <_Balloc>
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   1546c:	fff00713          	li	a4,-1
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   15470:	00100793          	li	a5,1
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   15474:	00050d13          	mv	s10,a0
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   15478:	00e12c23          	sw	a4,24(sp)
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   1547c:	04a42023          	sw	a0,64(s0)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   15480:	02e12623          	sw	a4,44(sp)
  switch (mode)
    {
    case 0:
    case 1:
      i = 18;
      ndigits = 0;
   15484:	00000b93          	li	s7,0
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   15488:	02f12023          	sw	a5,32(sp)
   1548c:	fa8ff06f          	j	14c34 <_dtoa_r+0x730>
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   15490:	00200793          	li	a5,2
   15494:	bdb7d0e3          	ble	s11,a5,15054 <_dtoa_r+0xb50>
    {
      if (ilim < 0 || cmp (b, S = multadd (ptr, S, 5, 0)) <= 0)
   15498:	01812783          	lw	a5,24(sp)
   1549c:	3e079863          	bnez	a5,1588c <_dtoa_r+0x1388>
   154a0:	000b0593          	mv	a1,s6
   154a4:	00000693          	li	a3,0
   154a8:	00500613          	li	a2,5
   154ac:	00040513          	mv	a0,s0
   154b0:	340020ef          	jal	177f0 <__multadd>
   154b4:	00050593          	mv	a1,a0
   154b8:	00050b13          	mv	s6,a0
   154bc:	00048513          	mv	a0,s1
   154c0:	31d020ef          	jal	17fdc <__mcmp>
   154c4:	00912e23          	sw	s1,28(sp)
   154c8:	e8a05ce3          	blez	a0,15360 <_dtoa_r+0xe5c>
	  k = -1 - ndigits;
	  goto ret;
	}
    one_digit:
      *s++ = '1';
      k++;
   154cc:	01012703          	lw	a4,16(sp)
	no_digits:
	  k = -1 - ndigits;
	  goto ret;
	}
    one_digit:
      *s++ = '1';
   154d0:	03100793          	li	a5,49
   154d4:	001d0c93          	addi	s9,s10,1
      k++;
   154d8:	00170713          	addi	a4,a4,1
	no_digits:
	  k = -1 - ndigits;
	  goto ret;
	}
    one_digit:
      *s++ = '1';
   154dc:	00fd0023          	sb	a5,0(s10)
      k++;
   154e0:	00e12823          	sw	a4,16(sp)
      goto ret;
   154e4:	e89ff06f          	j	1536c <_dtoa_r+0xe68>
      if (ndigits <= 0)
	ndigits = 1;
      ilim = ilim1 = i = ndigits;
      break;
    case 3:
      leftright = 0;
   154e8:	02012023          	sw	zero,32(sp)
   154ec:	b08ff06f          	j	147f4 <_dtoa_r+0x2f0>
    {
    roundoff:
      while (*--s == '9')
	if (s == s0)
	  {
	    k++;
   154f0:	01012703          	lw	a4,16(sp)
	    *s++ = '1';
   154f4:	03100793          	li	a5,49
   154f8:	00fd0023          	sb	a5,0(s10)
    {
    roundoff:
      while (*--s == '9')
	if (s == s0)
	  {
	    k++;
   154fc:	00170713          	addi	a4,a4,1
   15500:	00e12823          	sw	a4,16(sp)
	    *s++ = '1';
	    goto ret;
   15504:	d89ff06f          	j	1528c <_dtoa_r+0xd88>
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   15508:	00048513          	mv	a0,s1
   1550c:	128060ef          	jal	1b634 <__floatsidf>
   15510:	00090613          	mv	a2,s2
   15514:	00098693          	mv	a3,s3
   15518:	2c9050ef          	jal	1afe0 <__muldf3>
   1551c:	85c1a683          	lw	a3,-1956(gp) # 1ed2c <__wctomb+0x3c>
   15520:	8581a603          	lw	a2,-1960(gp) # 1ed28 <__wctomb+0x38>
   15524:	211050ef          	jal	1af34 <__adddf3>
      word0 (eps) -= (P - 1) * Exp_msk1;
   15528:	fcc006b7          	lui	a3,0xfcc00
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   1552c:	00050713          	mv	a4,a0
      word0 (eps) -= (P - 1) * Exp_msk1;
   15530:	00b687b3          	add	a5,a3,a1
      if (ilim == 0)
	{
	  S = mhi = 0;
	  d.d -= 5.;
   15534:	8601a603          	lw	a2,-1952(gp) # 1ed30 <__wctomb+0x40>
   15538:	8641a683          	lw	a3,-1948(gp) # 1ed34 <__wctomb+0x44>
   1553c:	00090513          	mv	a0,s2
   15540:	00098593          	mv	a1,s3
   15544:	00e12423          	sw	a4,8(sp)
   15548:	00f12223          	sw	a5,4(sp)
   1554c:	239050ef          	jal	1af84 <__subdf3>
	  if (d.d > eps.d)
   15550:	00812703          	lw	a4,8(sp)
   15554:	00412783          	lw	a5,4(sp)
      eps.d = ieps * d.d + 7.;
      word0 (eps) -= (P - 1) * Exp_msk1;
      if (ilim == 0)
	{
	  S = mhi = 0;
	  d.d -= 5.;
   15558:	00050913          	mv	s2,a0
	  if (d.d > eps.d)
   1555c:	00070613          	mv	a2,a4
   15560:	00078693          	mv	a3,a5
      eps.d = ieps * d.d + 7.;
      word0 (eps) -= (P - 1) * Exp_msk1;
      if (ilim == 0)
	{
	  S = mhi = 0;
	  d.d -= 5.;
   15564:	00058993          	mv	s3,a1
	  if (d.d > eps.d)
   15568:	010060ef          	jal	1b578 <__gtdf2>
   1556c:	00812703          	lw	a4,8(sp)
   15570:	00412783          	lw	a5,4(sp)
   15574:	16a04863          	bgtz	a0,156e4 <_dtoa_r+0x11e0>
	    goto one_digit;
	  if (d.d < -eps.d)
   15578:	00070613          	mv	a2,a4
   1557c:	80000737          	lui	a4,0x80000
   15580:	00f746b3          	xor	a3,a4,a5
   15584:	00090513          	mv	a0,s2
   15588:	00098593          	mv	a1,s3
   1558c:	04c060ef          	jal	1b5d8 <__ltdf2>
   15590:	04055e63          	bgez	a0,155ec <_dtoa_r+0x10e8>
    {
      /* Yes. */
      ds = tens[k];
      if (ndigits < 0 && ilim <= 0)
	{
	  S = mhi = 0;
   15594:	00000b13          	li	s6,0
   15598:	00000a13          	li	s4,0
   1559c:	dc5ff06f          	j	15360 <_dtoa_r+0xe5c>
	    }
         if ((j = b5 - m5) != 0)
	    b = pow5mult (ptr, b, j);
	}
      else
	b = pow5mult (ptr, b, b5);
   155a0:	00048593          	mv	a1,s1
   155a4:	000b0613          	mv	a2,s6
   155a8:	00040513          	mv	a0,s0
   155ac:	7a8020ef          	jal	17d54 <__pow5mult>
   155b0:	00050493          	mv	s1,a0
   155b4:	945ff06f          	j	14ef8 <_dtoa_r+0x9f4>
   155b8:	000d0513          	mv	a0,s10
   155bc:	820ff06f          	j	145dc <_dtoa_r+0xd8>

  /* Round off last digit */

  b = lshift (ptr, b, 1);
  j = cmp (b, S);
  if ((j > 0) || ((j == 0) && (dig & 1)))
   155c0:	00051663          	bnez	a0,155cc <_dtoa_r+0x10c8>
   155c4:	001bfb93          	andi	s7,s7,1
   155c8:	c80b9ee3          	bnez	s7,15264 <_dtoa_r+0xd60>
	  }
      ++*s++;
    }
  else
    {
      while (*--s == '0');
   155cc:	03000693          	li	a3,48
   155d0:	0080006f          	j	155d8 <_dtoa_r+0x10d4>
   155d4:	00070c93          	mv	s9,a4
   155d8:	fffcc783          	lbu	a5,-1(s9)
   155dc:	fffc8713          	addi	a4,s9,-1
   155e0:	fed78ae3          	beq	a5,a3,155d4 <_dtoa_r+0x10d0>
   155e4:	ca9ff06f          	j	1528c <_dtoa_r+0xd88>
   155e8:	04012a83          	lw	s5,64(sp)
#ifndef No_leftright
	}
#endif
    fast_failed:
      s = s0;
      d.d = d2.d;
   155ec:	03012903          	lw	s2,48(sp)
   155f0:	03412983          	lw	s3,52(sp)
   155f4:	e40ff06f          	j	14c34 <_dtoa_r+0x730>
		ieps++;
		ds *= bigtens[i];
	      }
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
   155f8:	01012703          	lw	a4,16(sp)
   155fc:	03012903          	lw	s2,48(sp)
   15600:	03412983          	lw	s3,52(sp)
   15604:	40e00a33          	neg	s4,a4

      i = 0;
      d2.d = d.d;
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
   15608:	00200493          	li	s1,2
		ieps++;
		ds *= bigtens[i];
	      }
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
   1560c:	b20a0463          	beqz	s4,14934 <_dtoa_r+0x430>
	{
	  d.d *= tens[j1 & 0xf];
   15610:	00fa7793          	andi	a5,s4,15
   15614:	00379713          	slli	a4,a5,0x3
   15618:	0001d7b7          	lui	a5,0x1d
   1561c:	91878793          	addi	a5,a5,-1768 # 1c918 <__mprec_tens>
   15620:	00f707b3          	add	a5,a4,a5
   15624:	0007a603          	lw	a2,0(a5)
   15628:	0047a683          	lw	a3,4(a5)
   1562c:	00090513          	mv	a0,s2
   15630:	00098593          	mv	a1,s3
   15634:	1ad050ef          	jal	1afe0 <__muldf3>
	  for (j = j1 >> 4; j; j >>= 1, i++)
   15638:	404a5a13          	srai	s4,s4,0x4
	      }
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
	{
	  d.d *= tens[j1 & 0xf];
   1563c:	00050913          	mv	s2,a0
   15640:	00058993          	mv	s3,a1
	  for (j = j1 >> 4; j; j >>= 1, i++)
   15644:	ae0a0863          	beqz	s4,14934 <_dtoa_r+0x430>
   15648:	0001dc37          	lui	s8,0x1d
   1564c:	a08c0c13          	addi	s8,s8,-1528 # 1ca08 <__mprec_bigtens>
	    if (j & 1)
   15650:	001a7793          	andi	a5,s4,1
	      {
		ieps++;
		d.d *= bigtens[i];
   15654:	00090513          	mv	a0,s2
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
	{
	  d.d *= tens[j1 & 0xf];
	  for (j = j1 >> 4; j; j >>= 1, i++)
   15658:	401a5a13          	srai	s4,s4,0x1
	    if (j & 1)
	      {
		ieps++;
		d.d *= bigtens[i];
   1565c:	00098593          	mv	a1,s3
	}
      else if ((j1 = -k) != 0)
	{
	  d.d *= tens[j1 & 0xf];
	  for (j = j1 >> 4; j; j >>= 1, i++)
	    if (j & 1)
   15660:	00078e63          	beqz	a5,1567c <_dtoa_r+0x1178>
	      {
		ieps++;
		d.d *= bigtens[i];
   15664:	000c2603          	lw	a2,0(s8)
   15668:	004c2683          	lw	a3,4(s8)
	{
	  d.d *= tens[j1 & 0xf];
	  for (j = j1 >> 4; j; j >>= 1, i++)
	    if (j & 1)
	      {
		ieps++;
   1566c:	00148493          	addi	s1,s1,1
		d.d *= bigtens[i];
   15670:	171050ef          	jal	1afe0 <__muldf3>
   15674:	00050913          	mv	s2,a0
   15678:	00058993          	mv	s3,a1
   1567c:	008c0c13          	addi	s8,s8,8
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
	{
	  d.d *= tens[j1 & 0xf];
	  for (j = j1 >> 4; j; j >>= 1, i++)
   15680:	fc0a18e3          	bnez	s4,15650 <_dtoa_r+0x114c>
   15684:	ab0ff06f          	j	14934 <_dtoa_r+0x430>
		bump_up:
		  while (*--s == '9')
		    if (s == s0)
		      {
			k++;
			*s = '0';
   15688:	03000713          	li	a4,48
   1568c:	00ed0023          	sb	a4,0(s10)
		{
		bump_up:
		  while (*--s == '9')
		    if (s == s0)
		      {
			k++;
   15690:	01012703          	lw	a4,16(sp)
   15694:	fffcca03          	lbu	s4,-1(s9)
   15698:	00170713          	addi	a4,a4,1 # 80000001 <_gp+0x7ffe0b31>
   1569c:	00e12823          	sw	a4,16(sp)
			*s = '0';
			break;
   156a0:	f54ff06f          	j	14df4 <_dtoa_r+0x8f0>
       */

      mlo = mhi;
      if (spec_case)
	{
	  mhi = Balloc (ptr, mhi->_k);
   156a4:	004a2583          	lw	a1,4(s4)
   156a8:	00040513          	mv	a0,s0
   156ac:	07c020ef          	jal	17728 <_Balloc>
	  Bcopy (mhi, mlo);
   156b0:	010a2603          	lw	a2,16(s4)
       */

      mlo = mhi;
      if (spec_case)
	{
	  mhi = Balloc (ptr, mhi->_k);
   156b4:	00050a93          	mv	s5,a0
	  Bcopy (mhi, mlo);
   156b8:	00ca0593          	addi	a1,s4,12
   156bc:	00260613          	addi	a2,a2,2
   156c0:	00261613          	slli	a2,a2,0x2
   156c4:	00c50513          	addi	a0,a0,12
   156c8:	90dfc0ef          	jal	11fd4 <memcpy>
	  mhi = lshift (ptr, mhi, Log2P);
   156cc:	00100613          	li	a2,1
   156d0:	000a8593          	mv	a1,s5
   156d4:	00040513          	mv	a0,s0
   156d8:	7b4020ef          	jal	17e8c <__lshift>
   156dc:	00050c13          	mv	s8,a0
   156e0:	99dff06f          	j	1507c <_dtoa_r+0xb78>
	}
      eps.d = ieps * d.d + 7.;
      word0 (eps) -= (P - 1) * Exp_msk1;
      if (ilim == 0)
	{
	  S = mhi = 0;
   156e4:	00000b13          	li	s6,0
   156e8:	00000a13          	li	s4,0
   156ec:	de1ff06f          	j	154cc <_dtoa_r+0xfc8>
	}
      else
	{
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
   156f0:	fff48613          	addi	a2,s1,-1
   156f4:	0001d6b7          	lui	a3,0x1d
   156f8:	02c12c23          	sw	a2,56(sp)
   156fc:	91868693          	addi	a3,a3,-1768 # 1c918 <__mprec_tens>
   15700:	00361613          	slli	a2,a2,0x3
   15704:	00d606b3          	add	a3,a2,a3
   15708:	0006a503          	lw	a0,0(a3)
   1570c:	0046a583          	lw	a1,4(a3)
   15710:	00070613          	mv	a2,a4
   15714:	00078693          	mv	a3,a5
   15718:	0c9050ef          	jal	1afe0 <__muldf3>
   1571c:	04a12023          	sw	a0,64(sp)
   15720:	04b12223          	sw	a1,68(sp)
	  for (i = 1;; i++, d.d *= 10.)
	    {
	      L = d.d;
   15724:	00090513          	mv	a0,s2
   15728:	00098593          	mv	a1,s3
   1572c:	050060ef          	jal	1b77c <__fixdfsi>
   15730:	00050c13          	mv	s8,a0
	      d.d -= L;
   15734:	701050ef          	jal	1b634 <__floatsidf>
   15738:	00058693          	mv	a3,a1
   1573c:	00050613          	mv	a2,a0
   15740:	00098593          	mv	a1,s3
   15744:	00090513          	mv	a0,s2
   15748:	03d050ef          	jal	1af84 <__subdf3>
	      *s++ = '0' + (int) L;
   1574c:	030c0c13          	addi	s8,s8,48
	      if (i == ilim)
   15750:	00100693          	li	a3,1
	  eps.d *= tens[ilim - 1];
	  for (i = 1;; i++, d.d *= 10.)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
   15754:	001d0c93          	addi	s9,s10,1
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
	  for (i = 1;; i++, d.d *= 10.)
	    {
	      L = d.d;
	      d.d -= L;
   15758:	00050713          	mv	a4,a0
   1575c:	00058793          	mv	a5,a1
	      *s++ = '0' + (int) L;
   15760:	018d0023          	sb	s8,0(s10)
	      if (i == ilim)
   15764:	06d48a63          	beq	s1,a3,157d8 <_dtoa_r+0x12d4>
   15768:	009d04b3          	add	s1,s10,s1
   1576c:	000c8c13          	mv	s8,s9
   15770:	000a8993          	mv	s3,s5
      else
	{
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
	  for (i = 1;; i++, d.d *= 10.)
   15774:	85018593          	addi	a1,gp,-1968 # 1ed20 <__wctomb+0x30>
   15778:	0005a603          	lw	a2,0(a1)
   1577c:	0045a683          	lw	a3,4(a1)
   15780:	00070513          	mv	a0,a4
   15784:	00078593          	mv	a1,a5
   15788:	059050ef          	jal	1afe0 <__muldf3>
   1578c:	00058a93          	mv	s5,a1
   15790:	00050a13          	mv	s4,a0
	    {
	      L = d.d;
   15794:	7e9050ef          	jal	1b77c <__fixdfsi>
   15798:	00050913          	mv	s2,a0
	      d.d -= L;
   1579c:	699050ef          	jal	1b634 <__floatsidf>
   157a0:	00050613          	mv	a2,a0
   157a4:	00058693          	mv	a3,a1
   157a8:	000a0513          	mv	a0,s4
   157ac:	000a8593          	mv	a1,s5
   157b0:	7d4050ef          	jal	1af84 <__subdf3>
	      *s++ = '0' + (int) L;
   157b4:	001c0c13          	addi	s8,s8,1
   157b8:	03090913          	addi	s2,s2,48
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
	  for (i = 1;; i++, d.d *= 10.)
	    {
	      L = d.d;
	      d.d -= L;
   157bc:	00050713          	mv	a4,a0
   157c0:	00058793          	mv	a5,a1
	      *s++ = '0' + (int) L;
   157c4:	ff2c0fa3          	sb	s2,-1(s8)
	      if (i == ilim)
   157c8:	fb8496e3          	bne	s1,s8,15774 <_dtoa_r+0x1270>
   157cc:	03812603          	lw	a2,56(sp)
   157d0:	00098a93          	mv	s5,s3
   157d4:	00cc8cb3          	add	s9,s9,a2
		{
		  if (d.d > 0.5 + eps.d)
   157d8:	8681a603          	lw	a2,-1944(gp) # 1ed38 <__wctomb+0x48>
   157dc:	86c1a683          	lw	a3,-1940(gp) # 1ed3c <__wctomb+0x4c>
   157e0:	04012503          	lw	a0,64(sp)
   157e4:	04412583          	lw	a1,68(sp)
   157e8:	00e12423          	sw	a4,8(sp)
   157ec:	00f12223          	sw	a5,4(sp)
   157f0:	744050ef          	jal	1af34 <__adddf3>
   157f4:	00812703          	lw	a4,8(sp)
   157f8:	00412783          	lw	a5,4(sp)
   157fc:	00070613          	mv	a2,a4
   15800:	00078693          	mv	a3,a5
   15804:	5d5050ef          	jal	1b5d8 <__ltdf2>
   15808:	00812703          	lw	a4,8(sp)
   1580c:	00412783          	lw	a5,4(sp)
   15810:	10055a63          	bgez	a0,15924 <_dtoa_r+0x1420>
   15814:	04c12703          	lw	a4,76(sp)
   15818:	fffcca03          	lbu	s4,-1(s9)
   1581c:	00e12823          	sw	a4,16(sp)
   15820:	db8ff06f          	j	14dd8 <_dtoa_r+0x8d4>
	      *s++ = dig;
	      goto ret;
	    }
	  if (j1 > 0)
	    {
	      if (dig == '9')
   15824:	03900793          	li	a5,57
   15828:	02012d03          	lw	s10,32(sp)
   1582c:	06fb8463          	beq	s7,a5,15894 <_dtoa_r+0x1390>
		{		/* possible if i == 1 */
		round_9_up:
		  *s++ = '9';
		  goto roundoff;
		}
	      *s++ = dig + 1;
   15830:	00c12703          	lw	a4,12(sp)
   15834:	001b8b93          	addi	s7,s7,1
	      goto ret;
   15838:	000a0913          	mv	s2,s4
		{		/* possible if i == 1 */
		round_9_up:
		  *s++ = '9';
		  goto roundoff;
		}
	      *s++ = dig + 1;
   1583c:	00170c93          	addi	s9,a4,1
   15840:	01770023          	sb	s7,0(a4)
	      goto ret;
   15844:	000c0a13          	mv	s4,s8
   15848:	00912e23          	sw	s1,28(sp)
   1584c:	a41ff06f          	j	1528c <_dtoa_r+0xd88>
   15850:	000a0913          	mv	s2,s4
   15854:	02012d03          	lw	s10,32(sp)
   15858:	000c0a13          	mv	s4,s8
   1585c:	9e9ff06f          	j	15244 <_dtoa_r+0xd40>
	      b5 += j;
	      m5 = 0;
	    }
	  if ((i = ilim) < 0)
	    {
	      m2 -= i;
   15860:	40fa8c33          	sub	s8,s5,a5
	      i = 0;
   15864:	00000793          	li	a5,0
   15868:	ddcff06f          	j	14e44 <_dtoa_r+0x940>
   1586c:	00100d93          	li	s11,1
   15870:	9cdff06f          	j	1523c <_dtoa_r+0xd38>
    {
      if (mode < 2)
	{
	  i =
#ifndef Sudden_Underflow
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
   15874:	05812703          	lw	a4,88(sp)
   15878:	03600793          	li	a5,54
   1587c:	000b0c93          	mv	s9,s6
   15880:	40e787b3          	sub	a5,a5,a4
	    break;
	}
      goto ret1;
    }

  m2 = b2;
   15884:	000a8c13          	mv	s8,s5
   15888:	dbcff06f          	j	14e44 <_dtoa_r+0x940>
   1588c:	00912e23          	sw	s1,28(sp)
   15890:	ad1ff06f          	j	15360 <_dtoa_r+0xe5c>
	  if (j1 > 0)
	    {
	      if (dig == '9')
		{		/* possible if i == 1 */
		round_9_up:
		  *s++ = '9';
   15894:	00c12683          	lw	a3,12(sp)
   15898:	03900793          	li	a5,57
		  goto roundoff;
   1589c:	000a0913          	mv	s2,s4
	  if (j1 > 0)
	    {
	      if (dig == '9')
		{		/* possible if i == 1 */
		round_9_up:
		  *s++ = '9';
   158a0:	00168c93          	addi	s9,a3,1
   158a4:	00f68023          	sb	a5,0(a3)
		  goto roundoff;
   158a8:	000c0a13          	mv	s4,s8
   158ac:	00912e23          	sw	s1,28(sp)
   158b0:	03900713          	li	a4,57
   158b4:	9b5ff06f          	j	15268 <_dtoa_r+0xd64>
	      {
		ieps++;
		d.d *= bigtens[i];
	      }
	}
      if (k_check && d.d < 1. && ilim > 0)
   158b8:	01812703          	lw	a4,24(sp)
   158bc:	c40706e3          	beqz	a4,15508 <_dtoa_r+0x1004>
	{
	  if (ilim1 <= 0)
   158c0:	02c12783          	lw	a5,44(sp)
   158c4:	d2f054e3          	blez	a5,155ec <_dtoa_r+0x10e8>
	    goto fast_failed;
	  ilim = ilim1;
	  k--;
   158c8:	01012703          	lw	a4,16(sp)
	  d.d *= 10.;
   158cc:	8501a603          	lw	a2,-1968(gp) # 1ed20 <__wctomb+0x30>
   158d0:	8541a683          	lw	a3,-1964(gp) # 1ed24 <__wctomb+0x34>
      if (k_check && d.d < 1. && ilim > 0)
	{
	  if (ilim1 <= 0)
	    goto fast_failed;
	  ilim = ilim1;
	  k--;
   158d4:	fff70713          	addi	a4,a4,-1
	  d.d *= 10.;
   158d8:	00090513          	mv	a0,s2
   158dc:	00098593          	mv	a1,s3
      if (k_check && d.d < 1. && ilim > 0)
	{
	  if (ilim1 <= 0)
	    goto fast_failed;
	  ilim = ilim1;
	  k--;
   158e0:	04e12623          	sw	a4,76(sp)
	  d.d *= 10.;
   158e4:	6fc050ef          	jal	1afe0 <__muldf3>
   158e8:	00050913          	mv	s2,a0
   158ec:	00058993          	mv	s3,a1
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   158f0:	00148513          	addi	a0,s1,1
   158f4:	541050ef          	jal	1b634 <__floatsidf>
   158f8:	00090613          	mv	a2,s2
   158fc:	00098693          	mv	a3,s3
   15900:	6e0050ef          	jal	1afe0 <__muldf3>
   15904:	85c1a683          	lw	a3,-1956(gp) # 1ed2c <__wctomb+0x3c>
   15908:	8581a603          	lw	a2,-1960(gp) # 1ed28 <__wctomb+0x38>
      word0 (eps) -= (P - 1) * Exp_msk1;
   1590c:	02c12483          	lw	s1,44(sp)
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   15910:	624050ef          	jal	1af34 <__adddf3>
      word0 (eps) -= (P - 1) * Exp_msk1;
   15914:	fcc006b7          	lui	a3,0xfcc00
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   15918:	00050713          	mv	a4,a0
      word0 (eps) -= (P - 1) * Exp_msk1;
   1591c:	00b687b3          	add	a5,a3,a1
   15920:	878ff06f          	j	14998 <_dtoa_r+0x494>
	      *s++ = '0' + (int) L;
	      if (i == ilim)
		{
		  if (d.d > 0.5 + eps.d)
		    goto bump_up;
		  else if (d.d < 0.5 - eps.d)
   15924:	04012603          	lw	a2,64(sp)
   15928:	04412683          	lw	a3,68(sp)
   1592c:	8681a503          	lw	a0,-1944(gp) # 1ed38 <__wctomb+0x48>
   15930:	86c1a583          	lw	a1,-1940(gp) # 1ed3c <__wctomb+0x4c>
   15934:	00e12423          	sw	a4,8(sp)
   15938:	00f12223          	sw	a5,4(sp)
   1593c:	648050ef          	jal	1af84 <__subdf3>
   15940:	00812703          	lw	a4,8(sp)
   15944:	00412783          	lw	a5,4(sp)
   15948:	00070613          	mv	a2,a4
   1594c:	00078693          	mv	a3,a5
   15950:	429050ef          	jal	1b578 <__gtdf2>
		    {
		      while (*--s == '0');
   15954:	03000693          	li	a3,48
	      *s++ = '0' + (int) L;
	      if (i == ilim)
		{
		  if (d.d > 0.5 + eps.d)
		    goto bump_up;
		  else if (d.d < 0.5 - eps.d)
   15958:	00a04663          	bgtz	a0,15964 <_dtoa_r+0x1460>
   1595c:	c91ff06f          	j	155ec <_dtoa_r+0x10e8>
   15960:	00070c93          	mv	s9,a4
		    {
		      while (*--s == '0');
   15964:	fffcc783          	lbu	a5,-1(s9)
   15968:	fffc8713          	addi	a4,s9,-1
   1596c:	fed78ae3          	beq	a5,a3,15960 <_dtoa_r+0x145c>
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
	      if (d.d < eps.d)
   15970:	04c12783          	lw	a5,76(sp)
   15974:	00f12823          	sw	a5,16(sp)
   15978:	9e8ff06f          	j	14b60 <_dtoa_r+0x65c>
   1597c:	04c12703          	lw	a4,76(sp)
   15980:	000a8c93          	mv	s9,s5
   15984:	00e12823          	sw	a4,16(sp)
   15988:	c50ff06f          	j	14dd8 <_dtoa_r+0x8d4>
	    {
	      if (j1 > 0)
		{
		  b = lshift (ptr, b, 1);
		  j1 = cmp (b, S);
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
   1598c:	a60518e3          	bnez	a0,153fc <_dtoa_r+0xef8>
   15990:	001bf793          	andi	a5,s7,1
   15994:	a60784e3          	beqz	a5,153fc <_dtoa_r+0xef8>
   15998:	a59ff06f          	j	153f0 <_dtoa_r+0xeec>
      if (cmp (b, S) < 0)
	{
	  k--;
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
   1599c:	000a0593          	mv	a1,s4
   159a0:	00000693          	li	a3,0
   159a4:	00a00613          	li	a2,10
   159a8:	00040513          	mv	a0,s0
   159ac:	645010ef          	jal	177f0 <__multadd>
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   159b0:	02c12783          	lw	a5,44(sp)
      if (cmp (b, S) < 0)
	{
	  k--;
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
   159b4:	00050a13          	mv	s4,a0
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   159b8:	02f05663          	blez	a5,159e4 <_dtoa_r+0x14e0>
   159bc:	00f12c23          	sw	a5,24(sp)
   159c0:	e9cff06f          	j	1505c <_dtoa_r+0xb58>
   159c4:	00200793          	li	a5,2
   159c8:	03b7ce63          	blt	a5,s11,15a04 <_dtoa_r+0x1500>
   159cc:	02c12703          	lw	a4,44(sp)
   159d0:	00e12c23          	sw	a4,24(sp)
   159d4:	81dff06f          	j	151f0 <_dtoa_r+0xcec>
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
	      if (d.d < eps.d)
		goto ret1;
	      if (1. - d.d < eps.d)
   159d8:	04c12783          	lw	a5,76(sp)
   159dc:	00f12823          	sw	a5,16(sp)
   159e0:	bf8ff06f          	j	14dd8 <_dtoa_r+0x8d4>
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   159e4:	00200793          	li	a5,2
   159e8:	03b7c463          	blt	a5,s11,15a10 <_dtoa_r+0x150c>
   159ec:	02c12783          	lw	a5,44(sp)
   159f0:	fcdff06f          	j	159bc <_dtoa_r+0x14b8>
      i -= 4;
      b2 += i;
      m2 += i;
      s2 += i;
    }
  else if (i < 4)
   159f4:	e0e78e63          	beq	a5,a4,15010 <_dtoa_r+0xb0c>
   159f8:	03c00793          	li	a5,60
   159fc:	40a78533          	sub	a0,a5,a0
   15a00:	f90ff06f          	j	15190 <_dtoa_r+0xc8c>
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   15a04:	02c12783          	lw	a5,44(sp)
   15a08:	00f12c23          	sw	a5,24(sp)
   15a0c:	a8dff06f          	j	15498 <_dtoa_r+0xf94>
   15a10:	02c12703          	lw	a4,44(sp)
   15a14:	00e12c23          	sw	a4,24(sp)
   15a18:	a81ff06f          	j	15498 <_dtoa_r+0xf94>

00015a1c <__sflush_r>:
  register unsigned char *p;
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
   15a1c:	00c59683          	lh	a3,12(a1)
   directly from __srefill. */
int
_DEFUN(__sflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   15a20:	fe010113          	addi	sp,sp,-32
   15a24:	00812c23          	sw	s0,24(sp)
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
  if ((flags & __SWR) == 0)
   15a28:	01069713          	slli	a4,a3,0x10
   15a2c:	01075713          	srli	a4,a4,0x10
   15a30:	00877793          	andi	a5,a4,8
   directly from __srefill. */
int
_DEFUN(__sflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   15a34:	01312623          	sw	s3,12(sp)
   15a38:	00112e23          	sw	ra,28(sp)
   15a3c:	00912a23          	sw	s1,20(sp)
   15a40:	01212823          	sw	s2,16(sp)
   15a44:	00058413          	mv	s0,a1
   15a48:	00050993          	mv	s3,a0
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
  if ((flags & __SWR) == 0)
   15a4c:	10079a63          	bnez	a5,15b60 <__sflush_r+0x144>
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
   15a50:	000017b7          	lui	a5,0x1
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   15a54:	0045a703          	lw	a4,4(a1)
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
   15a58:	80078793          	addi	a5,a5,-2048 # 800 <_reset+0x600>
   15a5c:	00f6e7b3          	or	a5,a3,a5
   15a60:	00f59623          	sh	a5,12(a1)
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   15a64:	1ce05663          	blez	a4,15c30 <__sflush_r+0x214>
   15a68:	02842803          	lw	a6,40(s0)
   15a6c:	0c080a63          	beqz	a6,15b40 <__sflush_r+0x124>
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
	  ptr->_errno = 0;
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
   15a70:	01079793          	slli	a5,a5,0x10
   15a74:	0107d793          	srli	a5,a5,0x10
   15a78:	01379693          	slli	a3,a5,0x13
#endif

	  /* Save last errno and set errno to 0, so we can check if a device
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
   15a7c:	0009a483          	lw	s1,0(s3)
	  ptr->_errno = 0;
   15a80:	0009a023          	sw	zero,0(s3)
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
   15a84:	1a06dc63          	bgez	a3,15c3c <__sflush_r+0x220>
	    curoff = fp->_offset;
   15a88:	05042603          	lw	a2,80(s0)
   15a8c:	05442683          	lw	a3,84(s0)
		  else
		    fp->_flags |= __SERR;
		  return result;
		}
            }
          if (fp->_flags & __SRD)
   15a90:	0047f793          	andi	a5,a5,4
   15a94:	04078263          	beqz	a5,15ad8 <__sflush_r+0xbc>
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
   15a98:	00442503          	lw	a0,4(s0)
              if (HASUB (fp))
   15a9c:	03042703          	lw	a4,48(s0)
            }
          if (fp->_flags & __SRD)
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
   15aa0:	40a607b3          	sub	a5,a2,a0
   15aa4:	41f55513          	srai	a0,a0,0x1f
   15aa8:	00f635b3          	sltu	a1,a2,a5
   15aac:	40a686b3          	sub	a3,a3,a0
   15ab0:	00078613          	mv	a2,a5
   15ab4:	40b686b3          	sub	a3,a3,a1
              if (HASUB (fp))
   15ab8:	02070063          	beqz	a4,15ad8 <__sflush_r+0xbc>
                curoff -= fp->_ur;
   15abc:	03c42503          	lw	a0,60(s0)
   15ac0:	40a787b3          	sub	a5,a5,a0
   15ac4:	41f55513          	srai	a0,a0,0x1f
   15ac8:	00f63733          	sltu	a4,a2,a5
   15acc:	40a686b3          	sub	a3,a3,a0
   15ad0:	00078613          	mv	a2,a5
   15ad4:	40e686b3          	sub	a3,a3,a4
#ifdef __LARGE64_FILES
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
   15ad8:	01c42583          	lw	a1,28(s0)
   15adc:	00000713          	li	a4,0
   15ae0:	00098513          	mv	a0,s3
   15ae4:	000800e7          	jalr	a6
	  if (curoff != -1 || ptr->_errno == 0
   15ae8:	fff00793          	li	a5,-1
   15aec:	0ef50063          	beq	a0,a5,15bcc <__sflush_r+0x1b0>
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   15af0:	00c45683          	lhu	a3,12(s0)
   15af4:	fffff7b7          	lui	a5,0xfffff
   15af8:	7ff78793          	addi	a5,a5,2047 # fffff7ff <_gp+0xfffe032f>
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   15afc:	01042703          	lw	a4,16(s0)
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   15b00:	00f6f7b3          	and	a5,a3,a5
   15b04:	01079793          	slli	a5,a5,0x10
   15b08:	4107d793          	srai	a5,a5,0x10
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   15b0c:	00e42023          	sw	a4,0(s0)
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   15b10:	01379713          	slli	a4,a5,0x13
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   15b14:	00f41623          	sh	a5,12(s0)
#endif
	      fp->_r = 0;
   15b18:	00042223          	sw	zero,4(s0)
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   15b1c:	10074463          	bltz	a4,15c24 <__sflush_r+0x208>
		fp->_offset = curoff;
	      ptr->_errno = tmp_errno;
	      if (HASUB (fp))
   15b20:	03042583          	lw	a1,48(s0)
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
		fp->_offset = curoff;
	      ptr->_errno = tmp_errno;
   15b24:	0099a023          	sw	s1,0(s3)
	      if (HASUB (fp))
   15b28:	00058c63          	beqz	a1,15b40 <__sflush_r+0x124>
		FREEUB (ptr, fp);
   15b2c:	04040793          	addi	a5,s0,64
   15b30:	00f58663          	beq	a1,a5,15b3c <__sflush_r+0x120>
   15b34:	00098513          	mv	a0,s3
   15b38:	664000ef          	jal	1619c <_free_r>
   15b3c:	02042823          	sw	zero,48(s0)
	    {
	      fp->_flags |= __SERR;
	      return EOF;
	    }
	}
      return 0;
   15b40:	00000513          	li	a0,0
	}
      p += t;
      n -= t;
    }
  return 0;
}
   15b44:	01c12083          	lw	ra,28(sp)
   15b48:	01812403          	lw	s0,24(sp)
   15b4c:	01412483          	lw	s1,20(sp)
   15b50:	01012903          	lw	s2,16(sp)
   15b54:	00c12983          	lw	s3,12(sp)
   15b58:	02010113          	addi	sp,sp,32
   15b5c:	00008067          	ret
	      return EOF;
	    }
	}
      return 0;
    }
  if ((p = fp->_bf._base) == NULL)
   15b60:	0105a903          	lw	s2,16(a1)
   15b64:	fc090ee3          	beqz	s2,15b40 <__sflush_r+0x124>
    {
      /* Nothing to flush.  */
      return 0;
    }
  n = fp->_p - p;		/* write this much */
   15b68:	0005a483          	lw	s1,0(a1)
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
   15b6c:	00377713          	andi	a4,a4,3
  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
   15b70:	0125a023          	sw	s2,0(a1)
  if ((p = fp->_bf._base) == NULL)
    {
      /* Nothing to flush.  */
      return 0;
    }
  n = fp->_p - p;		/* write this much */
   15b74:	412484b3          	sub	s1,s1,s2
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
   15b78:	00000793          	li	a5,0
   15b7c:	00071463          	bnez	a4,15b84 <__sflush_r+0x168>
   15b80:	0145a783          	lw	a5,20(a1)
   15b84:	00f42423          	sw	a5,8(s0)

  while (n > 0)
   15b88:	00904863          	bgtz	s1,15b98 <__sflush_r+0x17c>
   15b8c:	fb5ff06f          	j	15b40 <__sflush_r+0x124>
      if (t <= 0)
	{
          fp->_flags |= __SERR;
          return EOF;
	}
      p += t;
   15b90:	00a90933          	add	s2,s2,a0
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
   15b94:	fa9056e3          	blez	s1,15b40 <__sflush_r+0x124>
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
   15b98:	02442783          	lw	a5,36(s0)
   15b9c:	01c42583          	lw	a1,28(s0)
   15ba0:	00048693          	mv	a3,s1
   15ba4:	00090613          	mv	a2,s2
   15ba8:	00098513          	mv	a0,s3
   15bac:	000780e7          	jalr	a5
	{
          fp->_flags |= __SERR;
          return EOF;
	}
      p += t;
      n -= t;
   15bb0:	40a484b3          	sub	s1,s1,a0
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
      if (t <= 0)
   15bb4:	fca04ee3          	bgtz	a0,15b90 <__sflush_r+0x174>
	{
          fp->_flags |= __SERR;
   15bb8:	00c45783          	lhu	a5,12(s0)
          return EOF;
   15bbc:	fff00513          	li	a0,-1
  while (n > 0)
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
      if (t <= 0)
	{
          fp->_flags |= __SERR;
   15bc0:	0407e793          	ori	a5,a5,64
   15bc4:	00f41623          	sh	a5,12(s0)
          return EOF;
   15bc8:	f7dff06f          	j	15b44 <__sflush_r+0x128>
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
	  if (curoff != -1 || ptr->_errno == 0
   15bcc:	f2a592e3          	bne	a1,a0,15af0 <__sflush_r+0xd4>
   15bd0:	0009a703          	lw	a4,0(s3)
   15bd4:	01d00793          	li	a5,29
   15bd8:	fee7e0e3          	bltu	a5,a4,15bb8 <__sflush_r+0x19c>
   15bdc:	204007b7          	lui	a5,0x20400
   15be0:	00178793          	addi	a5,a5,1 # 20400001 <_gp+0x203e0b31>
   15be4:	00e7d7b3          	srl	a5,a5,a4
   15be8:	0017f793          	andi	a5,a5,1
   15bec:	fc0786e3          	beqz	a5,15bb8 <__sflush_r+0x19c>
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   15bf0:	00c45603          	lhu	a2,12(s0)
   15bf4:	fffff7b7          	lui	a5,0xfffff
   15bf8:	7ff78793          	addi	a5,a5,2047 # fffff7ff <_gp+0xfffe032f>
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   15bfc:	01042683          	lw	a3,16(s0)
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   15c00:	00f677b3          	and	a5,a2,a5
   15c04:	01079793          	slli	a5,a5,0x10
   15c08:	4107d793          	srai	a5,a5,0x10
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   15c0c:	00d42023          	sw	a3,0(s0)
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   15c10:	01379693          	slli	a3,a5,0x13
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   15c14:	00f41623          	sh	a5,12(s0)
#endif
	      fp->_r = 0;
   15c18:	00042223          	sw	zero,4(s0)
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   15c1c:	f006d2e3          	bgez	a3,15b20 <__sflush_r+0x104>
   15c20:	f00710e3          	bnez	a4,15b20 <__sflush_r+0x104>
		fp->_offset = curoff;
   15c24:	04a42823          	sw	a0,80(s0)
   15c28:	04b42a23          	sw	a1,84(s0)
   15c2c:	ef5ff06f          	j	15b20 <__sflush_r+0x104>
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   15c30:	03c5a703          	lw	a4,60(a1)
   15c34:	e2e04ae3          	bgtz	a4,15a68 <__sflush_r+0x4c>
   15c38:	f09ff06f          	j	15b40 <__sflush_r+0x124>
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
   15c3c:	01c42583          	lw	a1,28(s0)
   15c40:	00000613          	li	a2,0
   15c44:	00000693          	li	a3,0
   15c48:	00100713          	li	a4,1
   15c4c:	00098513          	mv	a0,s3
   15c50:	000800e7          	jalr	a6
	      if (curoff == -1L && ptr->_errno != 0)
   15c54:	fff00793          	li	a5,-1
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
   15c58:	00050613          	mv	a2,a0
   15c5c:	00058693          	mv	a3,a1
	      if (curoff == -1L && ptr->_errno != 0)
   15c60:	00f50863          	beq	a0,a5,15c70 <__sflush_r+0x254>
   15c64:	00c45783          	lhu	a5,12(s0)
   15c68:	02842803          	lw	a6,40(s0)
   15c6c:	e25ff06f          	j	15a90 <__sflush_r+0x74>
   15c70:	fea59ae3          	bne	a1,a0,15c64 <__sflush_r+0x248>
   15c74:	0009a783          	lw	a5,0(s3)
   15c78:	fe0786e3          	beqz	a5,15c64 <__sflush_r+0x248>
		{
		  int result = EOF;
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
   15c7c:	01d00713          	li	a4,29
   15c80:	00e78663          	beq	a5,a4,15c8c <__sflush_r+0x270>
   15c84:	01600713          	li	a4,22
   15c88:	00e79863          	bne	a5,a4,15c98 <__sflush_r+0x27c>
		    {
		      result = 0;
		      ptr->_errno = tmp_errno;
   15c8c:	0099a023          	sw	s1,0(s3)
	      if (curoff == -1L && ptr->_errno != 0)
		{
		  int result = EOF;
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
		    {
		      result = 0;
   15c90:	00000513          	li	a0,0
		      ptr->_errno = tmp_errno;
   15c94:	eb1ff06f          	j	15b44 <__sflush_r+0x128>
		    }
		  else
		    fp->_flags |= __SERR;
   15c98:	00c45783          	lhu	a5,12(s0)
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
	      if (curoff == -1L && ptr->_errno != 0)
		{
		  int result = EOF;
   15c9c:	00058513          	mv	a0,a1
		    {
		      result = 0;
		      ptr->_errno = tmp_errno;
		    }
		  else
		    fp->_flags |= __SERR;
   15ca0:	0407e793          	ori	a5,a5,64
   15ca4:	00f41623          	sh	a5,12(s0)
   15ca8:	e9dff06f          	j	15b44 <__sflush_r+0x128>

00015cac <_fflush_r>:

int
_DEFUN(_fflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   15cac:	fe010113          	addi	sp,sp,-32
   15cb0:	00812c23          	sw	s0,24(sp)
   15cb4:	00112e23          	sw	ra,28(sp)
   15cb8:	00050413          	mv	s0,a0
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
   15cbc:	00050663          	beqz	a0,15cc8 <_fflush_r+0x1c>
   15cc0:	03852783          	lw	a5,56(a0)
   15cc4:	02078a63          	beqz	a5,15cf8 <_fflush_r+0x4c>

  if (!fp->_flags)
   15cc8:	00c59783          	lh	a5,12(a1)
   15ccc:	00079c63          	bnez	a5,15ce4 <_fflush_r+0x38>

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
  _newlib_flockfile_end (fp);
  return ret;
}
   15cd0:	01c12083          	lw	ra,28(sp)
   15cd4:	00000513          	li	a0,0
   15cd8:	01812403          	lw	s0,24(sp)
   15cdc:	02010113          	addi	sp,sp,32
   15ce0:	00008067          	ret

  if (!fp->_flags)
    return 0;

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
   15ce4:	00040513          	mv	a0,s0
  _newlib_flockfile_end (fp);
  return ret;
}
   15ce8:	01c12083          	lw	ra,28(sp)
   15cec:	01812403          	lw	s0,24(sp)
   15cf0:	02010113          	addi	sp,sp,32

  if (!fp->_flags)
    return 0;

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
   15cf4:	d29ff06f          	j	15a1c <__sflush_r>
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
   15cf8:	00b12623          	sw	a1,12(sp)
   15cfc:	360000ef          	jal	1605c <__sinit>
   15d00:	00c12583          	lw	a1,12(sp)
   15d04:	fc5ff06f          	j	15cc8 <_fflush_r+0x1c>

00015d08 <fflush>:
#ifndef _REENT_ONLY

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
   15d08:	00050593          	mv	a1,a0
  if (fp == NULL)
   15d0c:	00050663          	beqz	a0,15d18 <fflush+0x10>
    return _fwalk_reent (_GLOBAL_REENT, _fflush_r);

  return _fflush_r (_REENT, fp);
   15d10:	8101a503          	lw	a0,-2032(gp) # 1ece0 <_impure_ptr>
   15d14:	f99ff06f          	j	15cac <_fflush_r>
int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
  if (fp == NULL)
    return _fwalk_reent (_GLOBAL_REENT, _fflush_r);
   15d18:	80c1a503          	lw	a0,-2036(gp) # 1ecdc <_global_impure_ptr>
   15d1c:	000165b7          	lui	a1,0x16
   15d20:	cac58593          	addi	a1,a1,-852 # 15cac <_fflush_r>
   15d24:	49d0006f          	j	169c0 <_fwalk_reent>

00015d28 <__fp_unlock>:
       FILE * ptr)
{
  _funlockfile (ptr);

  return 0;
}
   15d28:	00000513          	li	a0,0
   15d2c:	00008067          	ret

00015d30 <_cleanup_r>:
  cleanup_func = _fflush_r;
#else
  cleanup_func = _fclose_r;
#endif
#endif
  _CAST_VOID _fwalk_reent (ptr, cleanup_func);
   15d30:	0001a5b7          	lui	a1,0x1a
   15d34:	24858593          	addi	a1,a1,584 # 1a248 <_fclose_r>
   15d38:	4890006f          	j	169c0 <_fwalk_reent>

00015d3c <__sinit.part.1>:
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   15d3c:	fe010113          	addi	sp,sp,-32
      __sinit_lock_release ();
      return;
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
   15d40:	000167b7          	lui	a5,0x16
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   15d44:	00812c23          	sw	s0,24(sp)
      __sinit_lock_release ();
      return;
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
   15d48:	d3078793          	addi	a5,a5,-720 # 15d30 <_cleanup_r>
  s->_stdin = __sfp(s);
  s->_stdout = __sfp(s);
  s->_stderr = __sfp(s);
#endif

  std (s->_stdin,  __SRD, 0, s);
   15d4c:	00452403          	lw	s0,4(a0)
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   15d50:	00112e23          	sw	ra,28(sp)
   15d54:	00912a23          	sw	s1,20(sp)
   15d58:	01212823          	sw	s2,16(sp)
   15d5c:	01312623          	sw	s3,12(sp)
   15d60:	01412423          	sw	s4,8(sp)
   15d64:	01512223          	sw	s5,4(sp)
   15d68:	01612023          	sw	s6,0(sp)
      __sinit_lock_release ();
      return;
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
   15d6c:	02f52e23          	sw	a5,60(a0)

  s->__sglue._next = NULL;
#ifndef _REENT_SMALL
  s->__sglue._niobs = 3;
   15d70:	00300793          	li	a5,3
   15d74:	2ef52223          	sw	a5,740(a0)
  s->__sglue._iobs = &s->__sf[0];
   15d78:	2f050713          	addi	a4,a0,752
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   15d7c:	00400793          	li	a5,4
  s->__cleanup = _cleanup_r;	/* conservative */

  s->__sglue._next = NULL;
#ifndef _REENT_SMALL
  s->__sglue._niobs = 3;
  s->__sglue._iobs = &s->__sf[0];
   15d80:	2ee52423          	sw	a4,744(a0)
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */

  s->__sglue._next = NULL;
   15d84:	2e052023          	sw	zero,736(a0)
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   15d88:	00050913          	mv	s2,a0
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   15d8c:	00f41623          	sh	a5,12(s0)
  ptr->_flags2 = 0;
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   15d90:	00800613          	li	a2,8
   15d94:	00000593          	li	a1,0
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
  ptr->_p = 0;
   15d98:	00042023          	sw	zero,0(s0)
  ptr->_r = 0;
   15d9c:	00042223          	sw	zero,4(s0)
  ptr->_w = 0;
   15da0:	00042423          	sw	zero,8(s0)
  ptr->_flags = flags;
  ptr->_flags2 = 0;
   15da4:	06042423          	sw	zero,104(s0)
  ptr->_file = file;
   15da8:	00041723          	sh	zero,14(s0)
  ptr->_bf._base = 0;
   15dac:	00042823          	sw	zero,16(s0)
  ptr->_bf._size = 0;
   15db0:	00042a23          	sw	zero,20(s0)
  ptr->_lbfsize = 0;
   15db4:	00042c23          	sw	zero,24(s0)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   15db8:	06040513          	addi	a0,s0,96
   15dbc:	089010ef          	jal	17644 <memset>
     requires both stdin and stdout to be line-buffered, but tradition
     leaves stdin alone on systems without fcntl.  */
#ifdef HAVE_FCNTL
  std (s->_stdout, __SWR, 1, s);
#else
  std (s->_stdout, __SWR | __SLBF, 1, s);
   15dc0:	00892483          	lw	s1,8(s2)
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   15dc4:	00019b37          	lui	s6,0x19
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   15dc8:	00019ab7          	lui	s5,0x19
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   15dcc:	00019a37          	lui	s4,0x19
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   15dd0:	000199b7          	lui	s3,0x19
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   15dd4:	d28b0b13          	addi	s6,s6,-728 # 18d28 <__sread>
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   15dd8:	daca8a93          	addi	s5,s5,-596 # 18dac <__swrite>
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   15ddc:	e24a0a13          	addi	s4,s4,-476 # 18e24 <__sseek>
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   15de0:	e9098993          	addi	s3,s3,-368 # 18e90 <__sclose>
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   15de4:	00900793          	li	a5,9
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   15de8:	03642023          	sw	s6,32(s0)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   15dec:	03542223          	sw	s5,36(s0)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   15df0:	03442423          	sw	s4,40(s0)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   15df4:	03342623          	sw	s3,44(s0)
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
   15df8:	00842e23          	sw	s0,28(s0)
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   15dfc:	00f49623          	sh	a5,12(s1)
  ptr->_flags2 = 0;
  ptr->_file = file;
   15e00:	00100793          	li	a5,1
   15e04:	00f49723          	sh	a5,14(s1)
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   15e08:	00800613          	li	a2,8
   15e0c:	00000593          	li	a1,0
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
  ptr->_p = 0;
   15e10:	0004a023          	sw	zero,0(s1)
  ptr->_r = 0;
   15e14:	0004a223          	sw	zero,4(s1)
  ptr->_w = 0;
   15e18:	0004a423          	sw	zero,8(s1)
  ptr->_flags = flags;
  ptr->_flags2 = 0;
   15e1c:	0604a423          	sw	zero,104(s1)
  ptr->_file = file;
  ptr->_bf._base = 0;
   15e20:	0004a823          	sw	zero,16(s1)
  ptr->_bf._size = 0;
   15e24:	0004aa23          	sw	zero,20(s1)
  ptr->_lbfsize = 0;
   15e28:	0004ac23          	sw	zero,24(s1)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   15e2c:	06048513          	addi	a0,s1,96
   15e30:	015010ef          	jal	17644 <memset>
  std (s->_stdout, __SWR | __SLBF, 1, s);
#endif

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);
   15e34:	00c92403          	lw	s0,12(s2)
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   15e38:	01200793          	li	a5,18
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   15e3c:	0364a023          	sw	s6,32(s1)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   15e40:	0354a223          	sw	s5,36(s1)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   15e44:	0344a423          	sw	s4,40(s1)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   15e48:	0334a623          	sw	s3,44(s1)
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
   15e4c:	0094ae23          	sw	s1,28(s1)
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   15e50:	00f41623          	sh	a5,12(s0)
  ptr->_flags2 = 0;
  ptr->_file = file;
   15e54:	00200793          	li	a5,2
   15e58:	00f41723          	sh	a5,14(s0)
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
  ptr->_p = 0;
   15e5c:	00042023          	sw	zero,0(s0)
  ptr->_r = 0;
   15e60:	00042223          	sw	zero,4(s0)
  ptr->_w = 0;
   15e64:	00042423          	sw	zero,8(s0)
  ptr->_flags = flags;
  ptr->_flags2 = 0;
   15e68:	06042423          	sw	zero,104(s0)
  ptr->_file = file;
  ptr->_bf._base = 0;
   15e6c:	00042823          	sw	zero,16(s0)
  ptr->_bf._size = 0;
   15e70:	00042a23          	sw	zero,20(s0)
  ptr->_lbfsize = 0;
   15e74:	00042c23          	sw	zero,24(s0)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   15e78:	06040513          	addi	a0,s0,96
   15e7c:	00800613          	li	a2,8
   15e80:	00000593          	li	a1,0
   15e84:	7c0010ef          	jal	17644 <memset>
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;

  __sinit_lock_release ();
}
   15e88:	01c12083          	lw	ra,28(sp)

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;
   15e8c:	00100793          	li	a5,1
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   15e90:	03642023          	sw	s6,32(s0)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   15e94:	03542223          	sw	s5,36(s0)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   15e98:	03442423          	sw	s4,40(s0)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   15e9c:	03342623          	sw	s3,44(s0)
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
   15ea0:	00842e23          	sw	s0,28(s0)
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;

  __sinit_lock_release ();
}
   15ea4:	01412483          	lw	s1,20(sp)

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;
   15ea8:	02f92c23          	sw	a5,56(s2)

  __sinit_lock_release ();
}
   15eac:	01812403          	lw	s0,24(sp)
   15eb0:	01012903          	lw	s2,16(sp)
   15eb4:	00c12983          	lw	s3,12(sp)
   15eb8:	00812a03          	lw	s4,8(sp)
   15ebc:	00412a83          	lw	s5,4(sp)
   15ec0:	00012b03          	lw	s6,0(sp)
   15ec4:	02010113          	addi	sp,sp,32
   15ec8:	00008067          	ret

00015ecc <__fp_lock>:
   15ecc:	00000513          	li	a0,0
   15ed0:	00008067          	ret

00015ed4 <__sfmoreglue>:

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   15ed4:	ff010113          	addi	sp,sp,-16
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
   15ed8:	fff58793          	addi	a5,a1,-1

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   15edc:	00812423          	sw	s0,8(sp)
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
   15ee0:	00479413          	slli	s0,a5,0x4
   15ee4:	00779793          	slli	a5,a5,0x7
   15ee8:	40878433          	sub	s0,a5,s0

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   15eec:	01212023          	sw	s2,0(sp)
   15ef0:	00058913          	mv	s2,a1
  struct glue_with_file *g;

  g = (struct glue_with_file *)
   15ef4:	08040593          	addi	a1,s0,128

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   15ef8:	00912223          	sw	s1,4(sp)
   15efc:	00112623          	sw	ra,12(sp)
  struct glue_with_file *g;

  g = (struct glue_with_file *)
   15f00:	5d9000ef          	jal	16cd8 <_malloc_r>
   15f04:	00050493          	mv	s1,a0
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  if (g == NULL)
   15f08:	02050063          	beqz	a0,15f28 <__sfmoreglue+0x54>
    return NULL;
  g->glue._next = NULL;
  g->glue._niobs = n;
  g->glue._iobs = &g->file;
   15f0c:	01050513          	addi	a0,a0,16

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  if (g == NULL)
    return NULL;
  g->glue._next = NULL;
   15f10:	0004a023          	sw	zero,0(s1)
  g->glue._niobs = n;
   15f14:	0124a223          	sw	s2,4(s1)
  g->glue._iobs = &g->file;
   15f18:	00a4a423          	sw	a0,8(s1)
  memset (&g->file, 0, n * sizeof (FILE));
   15f1c:	07040613          	addi	a2,s0,112
   15f20:	00000593          	li	a1,0
   15f24:	720010ef          	jal	17644 <memset>
  return &g->glue;
}
   15f28:	00c12083          	lw	ra,12(sp)
   15f2c:	00048513          	mv	a0,s1
   15f30:	00812403          	lw	s0,8(sp)
   15f34:	00412483          	lw	s1,4(sp)
   15f38:	00012903          	lw	s2,0(sp)
   15f3c:	01010113          	addi	sp,sp,16
   15f40:	00008067          	ret

00015f44 <__sfp>:
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
   15f44:	fe010113          	addi	sp,sp,-32
   15f48:	01212823          	sw	s2,16(sp)
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
   15f4c:	80c1a903          	lw	s2,-2036(gp) # 1ecdc <_global_impure_ptr>
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
   15f50:	01312623          	sw	s3,12(sp)
   15f54:	00112e23          	sw	ra,28(sp)
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
   15f58:	03892783          	lw	a5,56(s2)
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
   15f5c:	00812c23          	sw	s0,24(sp)
   15f60:	00912a23          	sw	s1,20(sp)
   15f64:	00050993          	mv	s3,a0
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
   15f68:	00079663          	bnez	a5,15f74 <__sfp+0x30>
   15f6c:	00090513          	mv	a0,s2
   15f70:	dcdff0ef          	jal	15d3c <__sinit.part.1>
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
   15f74:	2e090913          	addi	s2,s2,736
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   15f78:	fff00493          	li	s1,-1
   15f7c:	00492783          	lw	a5,4(s2)
   15f80:	00892403          	lw	s0,8(s2)
   15f84:	fff78793          	addi	a5,a5,-1
   15f88:	0007da63          	bgez	a5,15f9c <__sfp+0x58>
   15f8c:	0840006f          	j	16010 <__sfp+0xcc>
   15f90:	fff78793          	addi	a5,a5,-1
   15f94:	07040413          	addi	s0,s0,112
   15f98:	06978c63          	beq	a5,s1,16010 <__sfp+0xcc>
	if (fp->_flags == 0)
   15f9c:	00c41703          	lh	a4,12(s0)
   15fa0:	fe0718e3          	bnez	a4,15f90 <__sfp+0x4c>
  _newlib_sfp_lock_exit ();
  d->_errno = ENOMEM;
  return NULL;

found:
  fp->_file = -1;		/* no file */
   15fa4:	fff00793          	li	a5,-1
   15fa8:	00f41723          	sh	a5,14(s0)
  fp->_flags = 1;		/* reserve this slot; caller sets real flags */
   15fac:	00100793          	li	a5,1
   15fb0:	00f41623          	sh	a5,12(s0)
  fp->_flags2 = 0;
   15fb4:	06042423          	sw	zero,104(s0)
#ifndef __SINGLE_THREAD__
  __lock_init_recursive (fp->_lock);
#endif
  _newlib_sfp_lock_end ();

  fp->_p = NULL;		/* no current pointer */
   15fb8:	00042023          	sw	zero,0(s0)
  fp->_w = 0;			/* nothing to read or write */
   15fbc:	00042423          	sw	zero,8(s0)
  fp->_r = 0;
   15fc0:	00042223          	sw	zero,4(s0)
  fp->_bf._base = NULL;		/* no buffer */
   15fc4:	00042823          	sw	zero,16(s0)
  fp->_bf._size = 0;
   15fc8:	00042a23          	sw	zero,20(s0)
  fp->_lbfsize = 0;		/* not line buffered */
   15fcc:	00042c23          	sw	zero,24(s0)
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
   15fd0:	00800613          	li	a2,8
   15fd4:	00000593          	li	a1,0
   15fd8:	06040513          	addi	a0,s0,96
   15fdc:	668010ef          	jal	17644 <memset>
  /* fp->_cookie = <any>; */	/* caller sets cookie, _read/_write etc */
  fp->_ub._base = NULL;		/* no ungetc buffer */
   15fe0:	02042823          	sw	zero,48(s0)
  fp->_ub._size = 0;
   15fe4:	02042a23          	sw	zero,52(s0)
  fp->_lb._base = NULL;		/* no line buffer */
   15fe8:	04042223          	sw	zero,68(s0)
  fp->_lb._size = 0;
   15fec:	04042423          	sw	zero,72(s0)

  return fp;
   15ff0:	00040513          	mv	a0,s0
}
   15ff4:	01c12083          	lw	ra,28(sp)
   15ff8:	01812403          	lw	s0,24(sp)
   15ffc:	01412483          	lw	s1,20(sp)
   16000:	01012903          	lw	s2,16(sp)
   16004:	00c12983          	lw	s3,12(sp)
   16008:	02010113          	addi	sp,sp,32
   1600c:	00008067          	ret
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
   16010:	00092783          	lw	a5,0(s2)
   16014:	00078663          	beqz	a5,16020 <__sfp+0xdc>
   16018:	00078913          	mv	s2,a5
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
    }
   1601c:	f61ff06f          	j	15f7c <__sfp+0x38>
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
   16020:	00400593          	li	a1,4
   16024:	00098513          	mv	a0,s3
   16028:	eadff0ef          	jal	15ed4 <__sfmoreglue>
   1602c:	00a92023          	sw	a0,0(s2)
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
   16030:	00050663          	beqz	a0,1603c <__sfp+0xf8>
   16034:	00050913          	mv	s2,a0
   16038:	f45ff06f          	j	15f7c <__sfp+0x38>
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
    }
  _newlib_sfp_lock_exit ();
  d->_errno = ENOMEM;
   1603c:	00c00793          	li	a5,12
   16040:	00f9a023          	sw	a5,0(s3)
  return NULL;
   16044:	00000513          	li	a0,0
   16048:	fadff06f          	j	15ff4 <__sfp+0xb0>

0001604c <_cleanup>:
  cleanup_func = _fflush_r;
#else
  cleanup_func = _fclose_r;
#endif
#endif
  _CAST_VOID _fwalk_reent (ptr, cleanup_func);
   1604c:	80c1a503          	lw	a0,-2036(gp) # 1ecdc <_global_impure_ptr>
   16050:	0001a5b7          	lui	a1,0x1a
   16054:	24858593          	addi	a1,a1,584 # 1a248 <_fclose_r>
   16058:	1690006f          	j	169c0 <_fwalk_reent>

0001605c <__sinit>:
_DEFUN(__sinit, (s),
       struct _reent *s)
{
  __sinit_lock_acquire ();

  if (s->__sdidinit)
   1605c:	03852783          	lw	a5,56(a0)
   16060:	00078463          	beqz	a5,16068 <__sinit+0xc>
   16064:	00008067          	ret
   16068:	cd5ff06f          	j	15d3c <__sinit.part.1>

0001606c <__sfp_lock_acquire>:
   1606c:	00008067          	ret

00016070 <__sfp_lock_release>:
   16070:	00008067          	ret

00016074 <__sinit_lock_acquire>:
   16074:	00008067          	ret

00016078 <__sinit_lock_release>:
  __lock_acquire_recursive (__sinit_lock);
}

_VOID
_DEFUN_VOID(__sinit_lock_release)
{
   16078:	00008067          	ret

0001607c <__fp_lock_all>:
_VOID
_DEFUN_VOID(__fp_lock_all)
{
  __sfp_lock_acquire ();

  _CAST_VOID _fwalk (_REENT, __fp_lock);
   1607c:	8101a503          	lw	a0,-2032(gp) # 1ece0 <_impure_ptr>
   16080:	000165b7          	lui	a1,0x16
   16084:	ecc58593          	addi	a1,a1,-308 # 15ecc <__fp_lock>
   16088:	0890006f          	j	16910 <_fwalk>

0001608c <__fp_unlock_all>:
}

_VOID
_DEFUN_VOID(__fp_unlock_all)
{
  _CAST_VOID _fwalk (_REENT, __fp_unlock);
   1608c:	8101a503          	lw	a0,-2032(gp) # 1ece0 <_impure_ptr>
   16090:	000165b7          	lui	a1,0x16
   16094:	d2858593          	addi	a1,a1,-728 # 15d28 <__fp_unlock>
   16098:	0790006f          	j	16910 <_fwalk>

0001609c <_malloc_trim_r>:
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
   1609c:	fe010113          	addi	sp,sp,-32
   160a0:	01212823          	sw	s2,16(sp)

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;

  top_size = chunksize(top);
   160a4:	0001f937          	lui	s2,0x1f
   160a8:	8c890913          	addi	s2,s2,-1848 # 1e8c8 <__malloc_av_>
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
   160ac:	00812c23          	sw	s0,24(sp)
   160b0:	00912a23          	sw	s1,20(sp)
   160b4:	00058413          	mv	s0,a1
   160b8:	01312623          	sw	s3,12(sp)
   160bc:	00112e23          	sw	ra,28(sp)
   160c0:	00050993          	mv	s3,a0
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;
   160c4:	65c010ef          	jal	17720 <__malloc_lock>

  top_size = chunksize(top);
   160c8:	00892703          	lw	a4,8(s2)
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
   160cc:	000017b7          	lui	a5,0x1
   160d0:	fef78593          	addi	a1,a5,-17 # fef <_reset+0xdef>

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;

  top_size = chunksize(top);
   160d4:	00472483          	lw	s1,4(a4)
   160d8:	ffc4f493          	andi	s1,s1,-4
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
   160dc:	40848433          	sub	s0,s1,s0
   160e0:	00b40433          	add	s0,s0,a1
   160e4:	00c45413          	srli	s0,s0,0xc
   160e8:	fff40413          	addi	s0,s0,-1
   160ec:	00c41413          	slli	s0,s0,0xc

  if (extra < (long)pagesz)  /* Not enough memory to release */
   160f0:	00f44c63          	blt	s0,a5,16108 <_malloc_trim_r+0x6c>
  }

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
   160f4:	00000513          	li	a0,0
   160f8:	ac8fa0ef          	jal	103c0 <sbrk>
    if (current_brk != (char*)(top) + top_size)
   160fc:	00892783          	lw	a5,8(s2)
   16100:	009787b3          	add	a5,a5,s1
   16104:	02f50663          	beq	a0,a5,16130 <_malloc_trim_r+0x94>
  top_size = chunksize(top);
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;

  if (extra < (long)pagesz)  /* Not enough memory to release */
  {
    MALLOC_UNLOCK;
   16108:	00098513          	mv	a0,s3
   1610c:	618010ef          	jal	17724 <__malloc_unlock>
    return 0;
   16110:	00000513          	li	a0,0
	MALLOC_UNLOCK;
        return 1;
      }
    }
  }
}
   16114:	01c12083          	lw	ra,28(sp)
   16118:	01812403          	lw	s0,24(sp)
   1611c:	01412483          	lw	s1,20(sp)
   16120:	01012903          	lw	s2,16(sp)
   16124:	00c12983          	lw	s3,12(sp)
   16128:	02010113          	addi	sp,sp,32
   1612c:	00008067          	ret
      return 0;     /* Apparently we don't own memory; must fail */
    }

    else
    {
      new_brk = (char*)(MORECORE (-extra));
   16130:	40800533          	neg	a0,s0
   16134:	a8cfa0ef          	jal	103c0 <sbrk>
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
   16138:	fff00793          	li	a5,-1
   1613c:	02f50863          	beq	a0,a5,1616c <_malloc_trim_r+0xd0>

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
        sbrked_mem -= extra;
   16140:	8bc1a783          	lw	a5,-1860(gp) # 1ed8c <__malloc_current_mallinfo>
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
   16144:	00892683          	lw	a3,8(s2)
   16148:	408484b3          	sub	s1,s1,s0
   1614c:	0014e493          	ori	s1,s1,1
        sbrked_mem -= extra;
   16150:	40878433          	sub	s0,a5,s0
        check_chunk(top);
	MALLOC_UNLOCK;
   16154:	00098513          	mv	a0,s3
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
   16158:	0096a223          	sw	s1,4(a3) # fcc00004 <_gp+0xfcbe0b34>
        sbrked_mem -= extra;
   1615c:	8a81ae23          	sw	s0,-1860(gp) # 1ed8c <__malloc_current_mallinfo>
        check_chunk(top);
	MALLOC_UNLOCK;
   16160:	5c4010ef          	jal	17724 <__malloc_unlock>
        return 1;
   16164:	00100513          	li	a0,1
   16168:	fadff06f          	j	16114 <_malloc_trim_r+0x78>
      new_brk = (char*)(MORECORE (-extra));
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
   1616c:	00000513          	li	a0,0
   16170:	a50fa0ef          	jal	103c0 <sbrk>
        top_size = current_brk - (char*)top;
   16174:	00892703          	lw	a4,8(s2)
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
   16178:	00f00693          	li	a3,15
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
        top_size = current_brk - (char*)top;
   1617c:	40e507b3          	sub	a5,a0,a4
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
   16180:	f8f6d4e3          	ble	a5,a3,16108 <_malloc_trim_r+0x6c>
        {
          sbrked_mem = current_brk - sbrk_base;
   16184:	8181a683          	lw	a3,-2024(gp) # 1ece8 <__malloc_sbrk_base>
          set_head(top, top_size | PREV_INUSE);
   16188:	0017e793          	ori	a5,a5,1
   1618c:	00f72223          	sw	a5,4(a4)
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
        top_size = current_brk - (char*)top;
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
        {
          sbrked_mem = current_brk - sbrk_base;
   16190:	40d50533          	sub	a0,a0,a3
   16194:	8aa1ae23          	sw	a0,-1860(gp) # 1ed8c <__malloc_current_mallinfo>
   16198:	f71ff06f          	j	16108 <_malloc_trim_r+0x6c>

0001619c <_free_r>:
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
   1619c:	0e058e63          	beqz	a1,16298 <_free_r+0xfc>
#if __STD_C
void fREe(RARG Void_t* mem)
#else
void fREe(RARG mem) RDECL Void_t* mem;
#endif
{
   161a0:	ff010113          	addi	sp,sp,-16
   161a4:	00812423          	sw	s0,8(sp)
   161a8:	00058413          	mv	s0,a1
   161ac:	00912223          	sw	s1,4(sp)
   161b0:	00112623          	sw	ra,12(sp)
   161b4:	00050493          	mv	s1,a0
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
    return;

  MALLOC_LOCK;
   161b8:	568010ef          	jal	17720 <__malloc_lock>

  p = mem2chunk(mem);
  hd = p->size;
   161bc:	ffc42503          	lw	a0,-4(s0)
  if (mem == 0)                              /* free(0) has no effect */
    return;

  MALLOC_LOCK;

  p = mem2chunk(mem);
   161c0:	ff840613          	addi	a2,s0,-8
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
   161c4:	0001f5b7          	lui	a1,0x1f
  }
#endif
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
   161c8:	ffe57793          	andi	a5,a0,-2
  next = chunk_at_offset(p, sz);
   161cc:	00f606b3          	add	a3,a2,a5
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
   161d0:	8c858593          	addi	a1,a1,-1848 # 1e8c8 <__malloc_av_>
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
   161d4:	0046a703          	lw	a4,4(a3)
  
  if (next == top)                            /* merge with top */
   161d8:	0085a803          	lw	a6,8(a1)
  {
    sz += nextsz;

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
   161dc:	00157513          	andi	a0,a0,1
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
   161e0:	ffc77713          	andi	a4,a4,-4
  
  if (next == top)                            /* merge with top */
   161e4:	15068463          	beq	a3,a6,1632c <_free_r+0x190>
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
    return;
  }

  set_head(next, nextsz);                    /* clear inuse bit */
   161e8:	00e6a223          	sw	a4,4(a3)

  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
   161ec:	02051663          	bnez	a0,16218 <_free_r+0x7c>
  {
    prevsz = p->prev_size;
   161f0:	ff842503          	lw	a0,-8(s0)
    p = chunk_at_offset(p, -prevsz);
   161f4:	40a60633          	sub	a2,a2,a0
    sz += prevsz;
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
   161f8:	00862803          	lw	a6,8(a2)

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
  {
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -prevsz);
    sz += prevsz;
   161fc:	00a787b3          	add	a5,a5,a0
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
   16200:	0001f537          	lui	a0,0x1f
   16204:	8d050513          	addi	a0,a0,-1840 # 1e8d0 <__malloc_av_+0x8>
   16208:	16a80663          	beq	a6,a0,16374 <_free_r+0x1d8>
      islr = 1;
    else
      unlink(p, bck, fwd);
   1620c:	00c62503          	lw	a0,12(a2)
   16210:	00a82623          	sw	a0,12(a6)
   16214:	01052423          	sw	a6,8(a0)
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
   16218:	00e68533          	add	a0,a3,a4
   1621c:	00452503          	lw	a0,4(a0)
   16220:	00157513          	andi	a0,a0,1
   16224:	0c050a63          	beqz	a0,162f8 <_free_r+0x15c>
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   16228:	0017e693          	ori	a3,a5,1
  set_foot(p, sz);
   1622c:	00f60733          	add	a4,a2,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   16230:	00d62223          	sw	a3,4(a2)
  set_foot(p, sz);
   16234:	00f72023          	sw	a5,0(a4)
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   16238:	1ff00713          	li	a4,511
   1623c:	06f76063          	bltu	a4,a5,1629c <_free_r+0x100>
   16240:	0037d793          	srli	a5,a5,0x3
   16244:	00178713          	addi	a4,a5,1
   16248:	00371713          	slli	a4,a4,0x3
   1624c:	0045a683          	lw	a3,4(a1)
   16250:	00e58733          	add	a4,a1,a4
   16254:	00072803          	lw	a6,0(a4)
   16258:	4027d793          	srai	a5,a5,0x2
   1625c:	00100513          	li	a0,1
   16260:	00f517b3          	sll	a5,a0,a5
   16264:	00d7e7b3          	or	a5,a5,a3
   16268:	ff870693          	addi	a3,a4,-8
   1626c:	00d62623          	sw	a3,12(a2)
   16270:	01062423          	sw	a6,8(a2)
   16274:	00f5a223          	sw	a5,4(a1)
   16278:	00c72023          	sw	a2,0(a4)
   1627c:	00c82623          	sw	a2,12(a6)

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
   16280:	00048513          	mv	a0,s1
    frontlink(p, sz, idx, bck, fwd);  

  MALLOC_UNLOCK;

#endif /* MALLOC_PROVIDED */
}
   16284:	00c12083          	lw	ra,12(sp)
   16288:	00812403          	lw	s0,8(sp)
   1628c:	00412483          	lw	s1,4(sp)
   16290:	01010113          	addi	sp,sp,16

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
   16294:	4900106f          	j	17724 <__malloc_unlock>
   16298:	00008067          	ret


  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   1629c:	0097d713          	srli	a4,a5,0x9
   162a0:	00400693          	li	a3,4
   162a4:	10e6e463          	bltu	a3,a4,163ac <_free_r+0x210>
   162a8:	0067d713          	srli	a4,a5,0x6
   162ac:	03970513          	addi	a0,a4,57
   162b0:	03870693          	addi	a3,a4,56
   162b4:	00151513          	slli	a0,a0,0x1
   162b8:	00251513          	slli	a0,a0,0x2
   162bc:	00a58533          	add	a0,a1,a0
   162c0:	00052703          	lw	a4,0(a0)
   162c4:	ff850513          	addi	a0,a0,-8
   162c8:	0ee50e63          	beq	a0,a4,163c4 <_free_r+0x228>
   162cc:	00472683          	lw	a3,4(a4)
   162d0:	ffc6f693          	andi	a3,a3,-4
   162d4:	00d7f663          	bleu	a3,a5,162e0 <_free_r+0x144>
   162d8:	00872703          	lw	a4,8(a4)
   162dc:	fee518e3          	bne	a0,a4,162cc <_free_r+0x130>
   162e0:	00c72503          	lw	a0,12(a4)
   162e4:	00a62623          	sw	a0,12(a2)
   162e8:	00e62423          	sw	a4,8(a2)
   162ec:	00c52423          	sw	a2,8(a0)
   162f0:	00c72623          	sw	a2,12(a4)
   162f4:	f8dff06f          	j	16280 <_free_r+0xe4>
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
   162f8:	0086a503          	lw	a0,8(a3)
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
   162fc:	00e787b3          	add	a5,a5,a4
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
   16300:	0001f737          	lui	a4,0x1f
   16304:	8d070713          	addi	a4,a4,-1840 # 1e8d0 <__malloc_av_+0x8>
   16308:	0ce50e63          	beq	a0,a4,163e4 <_free_r+0x248>
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   1630c:	00c6a803          	lw	a6,12(a3)
  }


  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
   16310:	00f60733          	add	a4,a2,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   16314:	0017e693          	ori	a3,a5,1
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   16318:	01052623          	sw	a6,12(a0)
   1631c:	00a82423          	sw	a0,8(a6)
  }


  set_head(p, sz | PREV_INUSE);
   16320:	00d62223          	sw	a3,4(a2)
  set_foot(p, sz);
   16324:	00f72023          	sw	a5,0(a4)
   16328:	f11ff06f          	j	16238 <_free_r+0x9c>
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
  {
    sz += nextsz;
   1632c:	00e787b3          	add	a5,a5,a4

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
   16330:	02051063          	bnez	a0,16350 <_free_r+0x1b4>
    {
      prevsz = p->prev_size;
   16334:	ff842503          	lw	a0,-8(s0)
      p = chunk_at_offset(p, -prevsz);
   16338:	40a60633          	sub	a2,a2,a0
      sz += prevsz;
      unlink(p, bck, fwd);
   1633c:	00c62703          	lw	a4,12(a2)
   16340:	00862683          	lw	a3,8(a2)

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
    {
      prevsz = p->prev_size;
      p = chunk_at_offset(p, -prevsz);
      sz += prevsz;
   16344:	00a787b3          	add	a5,a5,a0
      unlink(p, bck, fwd);
   16348:	00e6a623          	sw	a4,12(a3)
   1634c:	00d72423          	sw	a3,8(a4)
    }

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
   16350:	81c1a703          	lw	a4,-2020(gp) # 1ecec <__malloc_trim_threshold>
      p = chunk_at_offset(p, -prevsz);
      sz += prevsz;
      unlink(p, bck, fwd);
    }

    set_head(p, sz | PREV_INUSE);
   16354:	0017e693          	ori	a3,a5,1
   16358:	00d62223          	sw	a3,4(a2)
    top = p;
   1635c:	00c5a423          	sw	a2,8(a1)
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
   16360:	f2e7e0e3          	bltu	a5,a4,16280 <_free_r+0xe4>
      malloc_trim(RCALL top_pad); 
   16364:	8981a583          	lw	a1,-1896(gp) # 1ed68 <__malloc_top_pad>
   16368:	00048513          	mv	a0,s1
   1636c:	d31ff0ef          	jal	1609c <_malloc_trim_r>
   16370:	f11ff06f          	j	16280 <_free_r+0xe4>
      islr = 1;
    else
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
   16374:	00e685b3          	add	a1,a3,a4
   16378:	0045a583          	lw	a1,4(a1)
   1637c:	0015f593          	andi	a1,a1,1
   16380:	0e059263          	bnez	a1,16464 <_free_r+0x2c8>
   16384:	0086a583          	lw	a1,8(a3)
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   16388:	00c6a683          	lw	a3,12(a3)
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
   1638c:	00f707b3          	add	a5,a4,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   16390:	0017e513          	ori	a0,a5,1
  set_foot(p, sz);
   16394:	00f60733          	add	a4,a2,a5
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   16398:	00d5a623          	sw	a3,12(a1)
   1639c:	00b6a423          	sw	a1,8(a3)
  }


  set_head(p, sz | PREV_INUSE);
   163a0:	00a62223          	sw	a0,4(a2)
  set_foot(p, sz);
   163a4:	00f72023          	sw	a5,0(a4)
   163a8:	ed9ff06f          	j	16280 <_free_r+0xe4>
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   163ac:	01400693          	li	a3,20
   163b0:	04e6ec63          	bltu	a3,a4,16408 <_free_r+0x26c>
   163b4:	05c70513          	addi	a0,a4,92
   163b8:	05b70693          	addi	a3,a4,91
   163bc:	00151513          	slli	a0,a0,0x1
   163c0:	ef9ff06f          	j	162b8 <_free_r+0x11c>
   163c4:	0045a783          	lw	a5,4(a1)
   163c8:	4026d713          	srai	a4,a3,0x2
   163cc:	00100693          	li	a3,1
   163d0:	00e69733          	sll	a4,a3,a4
   163d4:	00f76733          	or	a4,a4,a5
   163d8:	00e5a223          	sw	a4,4(a1)
   163dc:	00050713          	mv	a4,a0
   163e0:	f05ff06f          	j	162e4 <_free_r+0x148>
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   163e4:	0017e693          	ori	a3,a5,1
  set_foot(p, sz);
   163e8:	00f60733          	add	a4,a2,a5
    sz += nextsz;
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
    {
      islr = 1;
      link_last_remainder(p);   
   163ec:	00c5aa23          	sw	a2,20(a1)
   163f0:	00c5a823          	sw	a2,16(a1)
   163f4:	00a62623          	sw	a0,12(a2)
   163f8:	00a62423          	sw	a0,8(a2)
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   163fc:	00d62223          	sw	a3,4(a2)
  set_foot(p, sz);
   16400:	00f72023          	sw	a5,0(a4)
   16404:	e7dff06f          	j	16280 <_free_r+0xe4>
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   16408:	05400693          	li	a3,84
   1640c:	00e6ec63          	bltu	a3,a4,16424 <_free_r+0x288>
   16410:	00c7d713          	srli	a4,a5,0xc
   16414:	06f70513          	addi	a0,a4,111
   16418:	06e70693          	addi	a3,a4,110
   1641c:	00151513          	slli	a0,a0,0x1
   16420:	e99ff06f          	j	162b8 <_free_r+0x11c>
   16424:	15400693          	li	a3,340
   16428:	00e6ec63          	bltu	a3,a4,16440 <_free_r+0x2a4>
   1642c:	00f7d713          	srli	a4,a5,0xf
   16430:	07870513          	addi	a0,a4,120
   16434:	07770693          	addi	a3,a4,119
   16438:	00151513          	slli	a0,a0,0x1
   1643c:	e7dff06f          	j	162b8 <_free_r+0x11c>
   16440:	55400813          	li	a6,1364
   16444:	0fe00513          	li	a0,254
   16448:	07e00693          	li	a3,126
   1644c:	e6e866e3          	bltu	a6,a4,162b8 <_free_r+0x11c>
   16450:	0127d713          	srli	a4,a5,0x12
   16454:	07d70513          	addi	a0,a4,125
   16458:	07c70693          	addi	a3,a4,124
   1645c:	00151513          	slli	a0,a0,0x1
   16460:	e59ff06f          	j	162b8 <_free_r+0x11c>
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   16464:	0017e693          	ori	a3,a5,1
  set_foot(p, sz);
   16468:	00f60733          	add	a4,a2,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   1646c:	00d62223          	sw	a3,4(a2)
  set_foot(p, sz);
   16470:	00f72023          	sw	a5,0(a4)
   16474:	e0dff06f          	j	16280 <_free_r+0xe4>

00016478 <__sfvwrite_r>:
  register struct __siov *iov;
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
   16478:	00862783          	lw	a5,8(a2)
   1647c:	1a078e63          	beqz	a5,16638 <__sfvwrite_r+0x1c0>
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   16480:	00c5d703          	lhu	a4,12(a1)
int
_DEFUN(__sfvwrite_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       register FILE *fp _AND
       register struct __suio *uio)
{
   16484:	fd010113          	addi	sp,sp,-48
   16488:	02812423          	sw	s0,40(sp)

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   1648c:	00877793          	andi	a5,a4,8
int
_DEFUN(__sfvwrite_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       register FILE *fp _AND
       register struct __suio *uio)
{
   16490:	01412c23          	sw	s4,24(sp)
   16494:	01512a23          	sw	s5,20(sp)
   16498:	02112623          	sw	ra,44(sp)
   1649c:	02912223          	sw	s1,36(sp)
   164a0:	03212023          	sw	s2,32(sp)
   164a4:	01312e23          	sw	s3,28(sp)
   164a8:	01612823          	sw	s6,16(sp)
   164ac:	01712623          	sw	s7,12(sp)
   164b0:	01812423          	sw	s8,8(sp)
   164b4:	01912223          	sw	s9,4(sp)
   164b8:	01a12023          	sw	s10,0(sp)
   164bc:	00058413          	mv	s0,a1
   164c0:	00050a93          	mv	s5,a0
   164c4:	00060a13          	mv	s4,a2

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   164c8:	0a078463          	beqz	a5,16570 <__sfvwrite_r+0xf8>
   164cc:	0105a783          	lw	a5,16(a1)
   164d0:	0a078063          	beqz	a5,16570 <__sfvwrite_r+0xf8>
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   164d4:	00277793          	andi	a5,a4,2

  /* make sure we can write */
  if (cantwrite (ptr, fp))
    return EOF;

  iov = uio->uio_iov;
   164d8:	000a2483          	lw	s1,0(s4)
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   164dc:	0a078c63          	beqz	a5,16594 <__sfvwrite_r+0x11c>
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
   164e0:	80000b37          	lui	s6,0x80000
   164e4:	00000993          	li	s3,0
   164e8:	00000913          	li	s2,0
   164ec:	c00b4b13          	xori	s6,s6,-1024
   164f0:	00098613          	mv	a2,s3
   164f4:	000a8513          	mv	a0,s5
       * Unbuffered: Split buffer in the largest multiple of BUFSIZ < INT_MAX
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
   164f8:	12090863          	beqz	s2,16628 <__sfvwrite_r+0x1b0>
	  w = fp->_write (ptr, fp->_cookie, p,
   164fc:	00090693          	mv	a3,s2
   16500:	012b7463          	bleu	s2,s6,16508 <__sfvwrite_r+0x90>
   16504:	000b0693          	mv	a3,s6
   16508:	02442783          	lw	a5,36(s0)
   1650c:	01c42583          	lw	a1,28(s0)
   16510:	000780e7          	jalr	a5
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
	  if (w <= 0)
   16514:	16a05863          	blez	a0,16684 <__sfvwrite_r+0x20c>
	    goto err;
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
   16518:	008a2783          	lw	a5,8(s4)
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
	  if (w <= 0)
	    goto err;
	  p += w;
   1651c:	00a989b3          	add	s3,s3,a0
	  len -= w;
   16520:	40a90933          	sub	s2,s2,a0
	}
      while ((uio->uio_resid -= w) != 0);
   16524:	40a78533          	sub	a0,a5,a0
   16528:	00aa2423          	sw	a0,8(s4)
   1652c:	fc0512e3          	bnez	a0,164f0 <__sfvwrite_r+0x78>
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
    return 0;
   16530:	00000793          	li	a5,0
  return 0;

err:
  fp->_flags |= __SERR;
  return EOF;
}
   16534:	02c12083          	lw	ra,44(sp)
   16538:	00078513          	mv	a0,a5
   1653c:	02812403          	lw	s0,40(sp)
   16540:	02412483          	lw	s1,36(sp)
   16544:	02012903          	lw	s2,32(sp)
   16548:	01c12983          	lw	s3,28(sp)
   1654c:	01812a03          	lw	s4,24(sp)
   16550:	01412a83          	lw	s5,20(sp)
   16554:	01012b03          	lw	s6,16(sp)
   16558:	00c12b83          	lw	s7,12(sp)
   1655c:	00812c03          	lw	s8,8(sp)
   16560:	00412c83          	lw	s9,4(sp)
   16564:	00012d03          	lw	s10,0(sp)
   16568:	03010113          	addi	sp,sp,48
   1656c:	00008067          	ret

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   16570:	00040593          	mv	a1,s0
   16574:	000a8513          	mv	a0,s5
   16578:	b5dfd0ef          	jal	140d4 <__swsetup_r>
    return EOF;
   1657c:	fff00793          	li	a5,-1

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   16580:	fa051ae3          	bnez	a0,16534 <__sfvwrite_r+0xbc>
   16584:	00c45703          	lhu	a4,12(s0)
    return EOF;

  iov = uio->uio_iov;
   16588:	000a2483          	lw	s1,0(s4)
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   1658c:	00277793          	andi	a5,a4,2
   16590:	f40798e3          	bnez	a5,164e0 <__sfvwrite_r+0x68>
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
    }
  else if ((fp->_flags & __SLBF) == 0)
   16594:	00177793          	andi	a5,a4,1
   16598:	10079063          	bnez	a5,16698 <__sfvwrite_r+0x220>
		goto err;
	    }
	  else
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
   1659c:	80000b37          	lui	s6,0x80000
   165a0:	00000b93          	li	s7,0
   165a4:	00000913          	li	s2,0
   165a8:	fffb4b13          	not	s6,s6
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
   165ac:	06090663          	beqz	s2,16618 <__sfvwrite_r+0x1a0>
	  w = fp->_w;
	  if (fp->_flags & __SSTR)
   165b0:	20077793          	andi	a5,a4,512
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
	  w = fp->_w;
   165b4:	00842983          	lw	s3,8(s0)
	  if (fp->_flags & __SSTR)
   165b8:	08078663          	beqz	a5,16644 <__sfvwrite_r+0x1cc>
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
   165bc:	23396e63          	bltu	s2,s3,167f8 <__sfvwrite_r+0x380>
   165c0:	48077793          	andi	a5,a4,1152
   165c4:	26079463          	bnez	a5,1682c <__sfvwrite_r+0x3b4>
   165c8:	00042503          	lw	a0,0(s0)
   165cc:	00098c13          	mv	s8,s3
		  w = len;
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
	      COPY (w);		/* copy MIN(fp->_w,len), */
   165d0:	000c0613          	mv	a2,s8
   165d4:	000b8593          	mv	a1,s7
   165d8:	74d000ef          	jal	17524 <memmove>
	      fp->_w -= w;
   165dc:	00842783          	lw	a5,8(s0)
	      fp->_p += w;
   165e0:	00042603          	lw	a2,0(s0)
   165e4:	00090513          	mv	a0,s2
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
	      COPY (w);		/* copy MIN(fp->_w,len), */
	      fp->_w -= w;
   165e8:	413789b3          	sub	s3,a5,s3
	      fp->_p += w;
   165ec:	01860633          	add	a2,a2,s8
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
	      COPY (w);		/* copy MIN(fp->_w,len), */
	      fp->_w -= w;
   165f0:	01342423          	sw	s3,8(s0)
	      fp->_p += w;
   165f4:	00c42023          	sw	a2,0(s0)
		goto err;
	    }
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
   165f8:	008a2783          	lw	a5,8(s4)
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
	      w = fp->_write (ptr, fp->_cookie, p, w);
	      if (w <= 0)
		goto err;
	    }
	  p += w;
   165fc:	00ab8bb3          	add	s7,s7,a0
	  len -= w;
   16600:	40a90933          	sub	s2,s2,a0
	}
      while ((uio->uio_resid -= w) != 0);
   16604:	40a789b3          	sub	s3,a5,a0
   16608:	013a2423          	sw	s3,8(s4)
   1660c:	f20982e3          	beqz	s3,16530 <__sfvwrite_r+0xb8>
   16610:	00c45703          	lhu	a4,12(s0)
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
   16614:	f8091ee3          	bnez	s2,165b0 <__sfvwrite_r+0x138>
   16618:	0004ab83          	lw	s7,0(s1)
   1661c:	0044a903          	lw	s2,4(s1)
   16620:	00848493          	addi	s1,s1,8
   16624:	f89ff06f          	j	165ac <__sfvwrite_r+0x134>
       * Unbuffered: Split buffer in the largest multiple of BUFSIZ < INT_MAX
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
   16628:	0004a983          	lw	s3,0(s1)
   1662c:	0044a903          	lw	s2,4(s1)
   16630:	00848493          	addi	s1,s1,8
   16634:	ebdff06f          	j	164f0 <__sfvwrite_r+0x78>
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
    return 0;
   16638:	00000793          	li	a5,0
  return 0;

err:
  fp->_flags |= __SERR;
  return EOF;
}
   1663c:	00078513          	mv	a0,a5
   16640:	00008067          	ret
	      COPY (w);		/* copy MIN(fp->_w,len), */
	      fp->_w -= w;
	      fp->_p += w;
	      w = len;		/* but pretend copied all */
	    }
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
   16644:	00042503          	lw	a0,0(s0)
   16648:	01042783          	lw	a5,16(s0)
   1664c:	12a7ea63          	bltu	a5,a0,16780 <__sfvwrite_r+0x308>
   16650:	01442783          	lw	a5,20(s0)
   16654:	12f96663          	bltu	s2,a5,16780 <__sfvwrite_r+0x308>
		goto err;
	    }
	  else
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
   16658:	00090693          	mv	a3,s2
   1665c:	012b7463          	bleu	s2,s6,16664 <__sfvwrite_r+0x1ec>
   16660:	000b0693          	mv	a3,s6
   16664:	02f6c6b3          	div	a3,a3,a5
	      w = fp->_write (ptr, fp->_cookie, p, w);
   16668:	02442703          	lw	a4,36(s0)
   1666c:	01c42583          	lw	a1,28(s0)
   16670:	000b8613          	mv	a2,s7
   16674:	000a8513          	mv	a0,s5
   16678:	02f686b3          	mul	a3,a3,a5
   1667c:	000700e7          	jalr	a4
	      if (w <= 0)
   16680:	f6a04ce3          	bgtz	a0,165f8 <__sfvwrite_r+0x180>
   16684:	00c41783          	lh	a5,12(s0)
      while ((uio->uio_resid -= w) != 0);
    }
  return 0;

err:
  fp->_flags |= __SERR;
   16688:	0407e793          	ori	a5,a5,64
   1668c:	00f41623          	sh	a5,12(s0)
  return EOF;
   16690:	fff00793          	li	a5,-1
   16694:	ea1ff06f          	j	16534 <__sfvwrite_r+0xbc>
   16698:	00000993          	li	s3,0
   1669c:	00000c13          	li	s8,0
   166a0:	00000d13          	li	s10,0
   166a4:	00000913          	li	s2,0
       */
      nlknown = 0;
      nldist = 0;
      do
	{
	  GETIOV (nlknown = 0);
   166a8:	06090c63          	beqz	s2,16720 <__sfvwrite_r+0x2a8>
	  if (!nlknown)
   166ac:	140c0e63          	beqz	s8,16808 <__sfvwrite_r+0x390>
	    {
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
	      nlknown = 1;
	    }
	  s = MIN (len, nldist);
   166b0:	00098b93          	mv	s7,s3
   166b4:	01397463          	bleu	s3,s2,166bc <__sfvwrite_r+0x244>
   166b8:	00090b93          	mv	s7,s2
	  w = fp->_w + fp->_bf._size;
	  if (fp->_p > fp->_bf._base && s > w)
   166bc:	00042503          	lw	a0,0(s0)
   166c0:	01042783          	lw	a5,16(s0)
	    {
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
	      nlknown = 1;
	    }
	  s = MIN (len, nldist);
   166c4:	000b8b13          	mv	s6,s7
	  w = fp->_w + fp->_bf._size;
   166c8:	01442683          	lw	a3,20(s0)
	  if (fp->_p > fp->_bf._base && s > w)
   166cc:	00a7f863          	bleu	a0,a5,166dc <__sfvwrite_r+0x264>
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
	      nlknown = 1;
	    }
	  s = MIN (len, nldist);
	  w = fp->_w + fp->_bf._size;
   166d0:	00842c83          	lw	s9,8(s0)
   166d4:	01968cb3          	add	s9,a3,s9
	  if (fp->_p > fp->_bf._base && s > w)
   166d8:	057cce63          	blt	s9,s7,16734 <__sfvwrite_r+0x2bc>
	      /* fp->_w -= w; */
	      fp->_p += w;
	      if (_fflush_r (ptr, fp))
		goto err;
	    }
	  else if (s >= (w = fp->_bf._size))
   166dc:	0edbca63          	blt	s7,a3,167d0 <__sfvwrite_r+0x358>
	    {
	      w = fp->_write (ptr, fp->_cookie, p, w);
   166e0:	02442783          	lw	a5,36(s0)
   166e4:	01c42583          	lw	a1,28(s0)
   166e8:	000d0613          	mv	a2,s10
   166ec:	000a8513          	mv	a0,s5
   166f0:	000780e7          	jalr	a5
   166f4:	00050b13          	mv	s6,a0
	      if (w <= 0)
   166f8:	f8a056e3          	blez	a0,16684 <__sfvwrite_r+0x20c>
	      w = s;
	      COPY (w);
	      fp->_w -= w;
	      fp->_p += w;
	    }
	  if ((nldist -= w) == 0)
   166fc:	416989b3          	sub	s3,s3,s6
   16700:	06098463          	beqz	s3,16768 <__sfvwrite_r+0x2f0>
	      nlknown = 0;
	    }
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
   16704:	008a2783          	lw	a5,8(s4)
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
		goto err;
	      nlknown = 0;
	    }
	  p += w;
   16708:	016d0d33          	add	s10,s10,s6
	  len -= w;
   1670c:	41690933          	sub	s2,s2,s6
	}
      while ((uio->uio_resid -= w) != 0);
   16710:	41678b33          	sub	s6,a5,s6
   16714:	016a2423          	sw	s6,8(s4)
   16718:	e00b0ce3          	beqz	s6,16530 <__sfvwrite_r+0xb8>
       */
      nlknown = 0;
      nldist = 0;
      do
	{
	  GETIOV (nlknown = 0);
   1671c:	f80918e3          	bnez	s2,166ac <__sfvwrite_r+0x234>
   16720:	0004ad03          	lw	s10,0(s1)
   16724:	0044a903          	lw	s2,4(s1)
   16728:	00000c13          	li	s8,0
   1672c:	00848493          	addi	s1,s1,8
   16730:	f79ff06f          	j	166a8 <__sfvwrite_r+0x230>
	    }
	  s = MIN (len, nldist);
	  w = fp->_w + fp->_bf._size;
	  if (fp->_p > fp->_bf._base && s > w)
	    {
	      COPY (w);
   16734:	000d0593          	mv	a1,s10
   16738:	000c8613          	mv	a2,s9
   1673c:	5e9000ef          	jal	17524 <memmove>
	      /* fp->_w -= w; */
	      fp->_p += w;
   16740:	00042783          	lw	a5,0(s0)
	      if (_fflush_r (ptr, fp))
   16744:	00040593          	mv	a1,s0
   16748:	000a8513          	mv	a0,s5
	  w = fp->_w + fp->_bf._size;
	  if (fp->_p > fp->_bf._base && s > w)
	    {
	      COPY (w);
	      /* fp->_w -= w; */
	      fp->_p += w;
   1674c:	019787b3          	add	a5,a5,s9
   16750:	00f42023          	sw	a5,0(s0)
	      if (_fflush_r (ptr, fp))
   16754:	d58ff0ef          	jal	15cac <_fflush_r>
   16758:	f20516e3          	bnez	a0,16684 <__sfvwrite_r+0x20c>
   1675c:	000c8b13          	mv	s6,s9
	      w = s;
	      COPY (w);
	      fp->_w -= w;
	      fp->_p += w;
	    }
	  if ((nldist -= w) == 0)
   16760:	416989b3          	sub	s3,s3,s6
   16764:	fa0990e3          	bnez	s3,16704 <__sfvwrite_r+0x28c>
	    {
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
   16768:	00040593          	mv	a1,s0
   1676c:	000a8513          	mv	a0,s5
   16770:	d3cff0ef          	jal	15cac <_fflush_r>
   16774:	f00518e3          	bnez	a0,16684 <__sfvwrite_r+0x20c>
		goto err;
	      nlknown = 0;
   16778:	00000c13          	li	s8,0
   1677c:	f89ff06f          	j	16704 <__sfvwrite_r+0x28c>
	      w = len;		/* but pretend copied all */
	    }
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
   16780:	01397463          	bleu	s3,s2,16788 <__sfvwrite_r+0x310>
   16784:	00090993          	mv	s3,s2
	      COPY (w);
   16788:	00098613          	mv	a2,s3
   1678c:	000b8593          	mv	a1,s7
   16790:	595000ef          	jal	17524 <memmove>
	      fp->_w -= w;
   16794:	00842783          	lw	a5,8(s0)
	      fp->_p += w;
   16798:	00042703          	lw	a4,0(s0)
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
	      COPY (w);
	      fp->_w -= w;
   1679c:	413787b3          	sub	a5,a5,s3
	      fp->_p += w;
   167a0:	01370733          	add	a4,a4,s3
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
	      COPY (w);
	      fp->_w -= w;
   167a4:	00f42423          	sw	a5,8(s0)
	      fp->_p += w;
   167a8:	00e42023          	sw	a4,0(s0)
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
   167ac:	00078663          	beqz	a5,167b8 <__sfvwrite_r+0x340>
   167b0:	00098513          	mv	a0,s3
   167b4:	e45ff06f          	j	165f8 <__sfvwrite_r+0x180>
   167b8:	00040593          	mv	a1,s0
   167bc:	000a8513          	mv	a0,s5
   167c0:	cecff0ef          	jal	15cac <_fflush_r>
   167c4:	ec0510e3          	bnez	a0,16684 <__sfvwrite_r+0x20c>
   167c8:	00098513          	mv	a0,s3
   167cc:	e2dff06f          	j	165f8 <__sfvwrite_r+0x180>
		goto err;
	    }
	  else
	    {
	      w = s;
	      COPY (w);
   167d0:	000b8613          	mv	a2,s7
   167d4:	000d0593          	mv	a1,s10
   167d8:	54d000ef          	jal	17524 <memmove>
	      fp->_w -= w;
   167dc:	00842703          	lw	a4,8(s0)
	      fp->_p += w;
   167e0:	00042783          	lw	a5,0(s0)
	    }
	  else
	    {
	      w = s;
	      COPY (w);
	      fp->_w -= w;
   167e4:	41770733          	sub	a4,a4,s7
	      fp->_p += w;
   167e8:	01778bb3          	add	s7,a5,s7
	    }
	  else
	    {
	      w = s;
	      COPY (w);
	      fp->_w -= w;
   167ec:	00e42423          	sw	a4,8(s0)
	      fp->_p += w;
   167f0:	01742023          	sw	s7,0(s0)
   167f4:	f09ff06f          	j	166fc <__sfvwrite_r+0x284>
   167f8:	00042503          	lw	a0,0(s0)
		  fp->_bf._size = newsize;
		  w = len;
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
   167fc:	00090993          	mv	s3,s2
   16800:	00090c13          	mv	s8,s2
   16804:	dcdff06f          	j	165d0 <__sfvwrite_r+0x158>
      do
	{
	  GETIOV (nlknown = 0);
	  if (!nlknown)
	    {
	      nl = memchr ((_PTR) p, '\n', len);
   16808:	00090613          	mv	a2,s2
   1680c:	00a00593          	li	a1,10
   16810:	000d0513          	mv	a0,s10
   16814:	43d000ef          	jal	17450 <memchr>
	      nldist = nl ? nl + 1 - p : len + 1;
   16818:	0c050e63          	beqz	a0,168f4 <__sfvwrite_r+0x47c>
   1681c:	00150513          	addi	a0,a0,1
   16820:	41a509b3          	sub	s3,a0,s10
	      nlknown = 1;
   16824:	00100c13          	li	s8,1
   16828:	e89ff06f          	j	166b0 <__sfvwrite_r+0x238>
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   1682c:	01442983          	lw	s3,20(s0)
	  if (fp->_flags & __SSTR)
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
   16830:	01042583          	lw	a1,16(s0)
   16834:	00042c03          	lw	s8,0(s0)
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   16838:	00199793          	slli	a5,s3,0x1
   1683c:	013789b3          	add	s3,a5,s3
   16840:	01f9d793          	srli	a5,s3,0x1f
	  if (fp->_flags & __SSTR)
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
   16844:	40bc0c33          	sub	s8,s8,a1
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   16848:	013789b3          	add	s3,a5,s3
		  if (newsize < curpos + len + 1)
   1684c:	001c0793          	addi	a5,s8,1
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   16850:	4019d993          	srai	s3,s3,0x1
		  if (newsize < curpos + len + 1)
   16854:	012787b3          	add	a5,a5,s2
   16858:	00098613          	mv	a2,s3
   1685c:	00f9f663          	bleu	a5,s3,16868 <__sfvwrite_r+0x3f0>
		    newsize = curpos + len + 1;
   16860:	00078993          	mv	s3,a5
   16864:	00078613          	mv	a2,a5
		  if (fp->_flags & __SOPT)
   16868:	40077713          	andi	a4,a4,1024
   1686c:	04070c63          	beqz	a4,168c4 <__sfvwrite_r+0x44c>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
   16870:	00060593          	mv	a1,a2
   16874:	000a8513          	mv	a0,s5
   16878:	460000ef          	jal	16cd8 <_malloc_r>
   1687c:	00050c93          	mv	s9,a0
		      if (!str)
   16880:	08050063          	beqz	a0,16900 <__sfvwrite_r+0x488>
			{
			  ptr->_errno = ENOMEM;
			  goto err;
			}
		      memcpy (str, fp->_bf._base, curpos);
   16884:	01042583          	lw	a1,16(s0)
   16888:	000c0613          	mv	a2,s8
   1688c:	f48fb0ef          	jal	11fd4 <memcpy>
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
   16890:	00c45783          	lhu	a5,12(s0)
   16894:	b7f7f793          	andi	a5,a5,-1153
   16898:	0807e793          	ori	a5,a5,128
   1689c:	00f41623          	sh	a5,12(s0)
			  ptr->_errno = ENOMEM;
			  goto err;
			}
		    }
		  fp->_bf._base = str;
		  fp->_p = str + curpos;
   168a0:	018c8533          	add	a0,s9,s8
		  fp->_bf._size = newsize;
		  w = len;
		  fp->_w = newsize - curpos;
   168a4:	41898c33          	sub	s8,s3,s8
			  goto err;
			}
		    }
		  fp->_bf._base = str;
		  fp->_p = str + curpos;
		  fp->_bf._size = newsize;
   168a8:	01342a23          	sw	s3,20(s0)
		  w = len;
		  fp->_w = newsize - curpos;
   168ac:	01842423          	sw	s8,8(s0)
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
			  goto err;
			}
		    }
		  fp->_bf._base = str;
   168b0:	01942823          	sw	s9,16(s0)
		  fp->_p = str + curpos;
   168b4:	00a42023          	sw	a0,0(s0)
		  fp->_bf._size = newsize;
		  w = len;
   168b8:	00090993          	mv	s3,s2
   168bc:	00090c13          	mv	s8,s2
   168c0:	d11ff06f          	j	165d0 <__sfvwrite_r+0x158>
		      memcpy (str, fp->_bf._base, curpos);
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
		    }
		  else
		    {
		      str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
   168c4:	000a8513          	mv	a0,s5
   168c8:	665010ef          	jal	1872c <_realloc_r>
   168cc:	00050c93          	mv	s9,a0
							 newsize);
		      if (!str)
   168d0:	fc0518e3          	bnez	a0,168a0 <__sfvwrite_r+0x428>
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
   168d4:	01042583          	lw	a1,16(s0)
   168d8:	000a8513          	mv	a0,s5
   168dc:	8c1ff0ef          	jal	1619c <_free_r>
			  fp->_flags &=  ~__SMBF;
   168e0:	00c41783          	lh	a5,12(s0)
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
   168e4:	00c00713          	li	a4,12
   168e8:	00eaa023          	sw	a4,0(s5)
		      if (!str)
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
			  fp->_flags &=  ~__SMBF;
   168ec:	f7f7f793          	andi	a5,a5,-129
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
			  goto err;
   168f0:	d99ff06f          	j	16688 <__sfvwrite_r+0x210>
	{
	  GETIOV (nlknown = 0);
	  if (!nlknown)
	    {
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
   168f4:	00190993          	addi	s3,s2,1
	      nlknown = 1;
   168f8:	00100c13          	li	s8,1
   168fc:	db5ff06f          	j	166b0 <__sfvwrite_r+0x238>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
		      if (!str)
			{
			  ptr->_errno = ENOMEM;
   16900:	00c00793          	li	a5,12
   16904:	00faa023          	sw	a5,0(s5)
   16908:	00c41783          	lh	a5,12(s0)
			  goto err;
   1690c:	d7dff06f          	j	16688 <__sfvwrite_r+0x210>

00016910 <_fwalk>:

int
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
   16910:	fe010113          	addi	sp,sp,-32
   16914:	01512223          	sw	s5,4(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   16918:	2e050a93          	addi	s5,a0,736

int
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
   1691c:	00112e23          	sw	ra,28(sp)
   16920:	00812c23          	sw	s0,24(sp)
   16924:	00912a23          	sw	s1,20(sp)
   16928:	01212823          	sw	s2,16(sp)
   1692c:	01312623          	sw	s3,12(sp)
   16930:	01412423          	sw	s4,8(sp)
   16934:	01612023          	sw	s6,0(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   16938:	080a8063          	beqz	s5,169b8 <_fwalk+0xa8>
   1693c:	00058b13          	mv	s6,a1
   16940:	00000a13          	li	s4,0
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   16944:	00100993          	li	s3,1
   16948:	fff00913          	li	s2,-1
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   1694c:	004aa483          	lw	s1,4(s5)
   16950:	008aa403          	lw	s0,8(s5)
   16954:	fff48493          	addi	s1,s1,-1
   16958:	0204c663          	bltz	s1,16984 <_fwalk+0x74>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   1695c:	00c45783          	lhu	a5,12(s0)
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   16960:	fff48493          	addi	s1,s1,-1
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   16964:	00f9fc63          	bleu	a5,s3,1697c <_fwalk+0x6c>
   16968:	00e41783          	lh	a5,14(s0)
	ret |= (*function) (fp);
   1696c:	00040513          	mv	a0,s0
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   16970:	01278663          	beq	a5,s2,1697c <_fwalk+0x6c>
	ret |= (*function) (fp);
   16974:	000b00e7          	jalr	s6
   16978:	00aa6a33          	or	s4,s4,a0
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   1697c:	07040413          	addi	s0,s0,112
   16980:	fd249ee3          	bne	s1,s2,1695c <_fwalk+0x4c>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   16984:	000aaa83          	lw	s5,0(s5)
   16988:	fc0a92e3          	bnez	s5,1694c <_fwalk+0x3c>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*function) (fp);

  return ret;
}
   1698c:	01c12083          	lw	ra,28(sp)
   16990:	000a0513          	mv	a0,s4
   16994:	01812403          	lw	s0,24(sp)
   16998:	01412483          	lw	s1,20(sp)
   1699c:	01012903          	lw	s2,16(sp)
   169a0:	00c12983          	lw	s3,12(sp)
   169a4:	00812a03          	lw	s4,8(sp)
   169a8:	00412a83          	lw	s5,4(sp)
   169ac:	00012b03          	lw	s6,0(sp)
   169b0:	02010113          	addi	sp,sp,32
   169b4:	00008067          	ret
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
  register FILE *fp;
  register int n, ret = 0;
   169b8:	00000a13          	li	s4,0
   169bc:	fd1ff06f          	j	1698c <_fwalk+0x7c>

000169c0 <_fwalk_reent>:
   I/O function (e.g. _fclose_r).  */
int
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
   169c0:	fd010113          	addi	sp,sp,-48
   169c4:	01612823          	sw	s6,16(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   169c8:	2e050b13          	addi	s6,a0,736
   I/O function (e.g. _fclose_r).  */
int
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
   169cc:	02112623          	sw	ra,44(sp)
   169d0:	02812423          	sw	s0,40(sp)
   169d4:	02912223          	sw	s1,36(sp)
   169d8:	03212023          	sw	s2,32(sp)
   169dc:	01312e23          	sw	s3,28(sp)
   169e0:	01412c23          	sw	s4,24(sp)
   169e4:	01512a23          	sw	s5,20(sp)
   169e8:	01712623          	sw	s7,12(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   169ec:	080b0663          	beqz	s6,16a78 <_fwalk_reent+0xb8>
   169f0:	00058b93          	mv	s7,a1
   169f4:	00050a93          	mv	s5,a0
   169f8:	00000a13          	li	s4,0
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   169fc:	00100993          	li	s3,1
   16a00:	fff00913          	li	s2,-1
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   16a04:	004b2483          	lw	s1,4(s6) # 80000004 <_gp+0x7ffe0b34>
   16a08:	008b2403          	lw	s0,8(s6)
   16a0c:	fff48493          	addi	s1,s1,-1
   16a10:	0204c863          	bltz	s1,16a40 <_fwalk_reent+0x80>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   16a14:	00c45783          	lhu	a5,12(s0)
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   16a18:	fff48493          	addi	s1,s1,-1
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   16a1c:	00f9fe63          	bleu	a5,s3,16a38 <_fwalk_reent+0x78>
   16a20:	00e41783          	lh	a5,14(s0)
	ret |= (*reent_function) (ptr, fp);
   16a24:	00040593          	mv	a1,s0
   16a28:	000a8513          	mv	a0,s5
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   16a2c:	01278663          	beq	a5,s2,16a38 <_fwalk_reent+0x78>
	ret |= (*reent_function) (ptr, fp);
   16a30:	000b80e7          	jalr	s7
   16a34:	00aa6a33          	or	s4,s4,a0
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   16a38:	07040413          	addi	s0,s0,112
   16a3c:	fd249ce3          	bne	s1,s2,16a14 <_fwalk_reent+0x54>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   16a40:	000b2b03          	lw	s6,0(s6)
   16a44:	fc0b10e3          	bnez	s6,16a04 <_fwalk_reent+0x44>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*reent_function) (ptr, fp);

  return ret;
}
   16a48:	02c12083          	lw	ra,44(sp)
   16a4c:	000a0513          	mv	a0,s4
   16a50:	02812403          	lw	s0,40(sp)
   16a54:	02412483          	lw	s1,36(sp)
   16a58:	02012903          	lw	s2,32(sp)
   16a5c:	01c12983          	lw	s3,28(sp)
   16a60:	01812a03          	lw	s4,24(sp)
   16a64:	01412a83          	lw	s5,20(sp)
   16a68:	01012b03          	lw	s6,16(sp)
   16a6c:	00c12b83          	lw	s7,12(sp)
   16a70:	03010113          	addi	sp,sp,48
   16a74:	00008067          	ret
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
  register FILE *fp;
  register int n, ret = 0;
   16a78:	00000a13          	li	s4,0
   16a7c:	fcdff06f          	j	16a48 <_fwalk_reent+0x88>

00016a80 <_setlocale_r>:
char *
_DEFUN(_setlocale_r, (p, category, locale),
       struct _reent *p _AND
       int category _AND
       _CONST char *locale)
{
   16a80:	ff010113          	addi	sp,sp,-16
   16a84:	00912223          	sw	s1,4(sp)
   16a88:	00112623          	sw	ra,12(sp)
   16a8c:	00812423          	sw	s0,8(sp)
   16a90:	0001d4b7          	lui	s1,0x1d
#ifndef _MB_CAPABLE
  if (locale)
   16a94:	02060063          	beqz	a2,16ab4 <_setlocale_r+0x34>
    { 
      if (strcmp (locale, "POSIX") && strcmp (locale, "C")
   16a98:	0001d5b7          	lui	a1,0x1d
   16a9c:	c3c58593          	addi	a1,a1,-964 # 1cc3c <__thenan_sf+0x6c>
   16aa0:	00060513          	mv	a0,a2
   16aa4:	00060413          	mv	s0,a2
   16aa8:	3f0020ef          	jal	18e98 <strcmp>
   16aac:	0001d4b7          	lui	s1,0x1d
   16ab0:	00051e63          	bnez	a0,16acc <_setlocale_r+0x4c>
	  && strcmp (locale, ""))
        return NULL;
    }
  return "C";
   16ab4:	c3848513          	addi	a0,s1,-968 # 1cc38 <__thenan_sf+0x68>
	  return NULL;
	}
    }
  return currentlocale ();
#endif /* !_MB_CAPABLE */
}
   16ab8:	00c12083          	lw	ra,12(sp)
   16abc:	00812403          	lw	s0,8(sp)
   16ac0:	00412483          	lw	s1,4(sp)
   16ac4:	01010113          	addi	sp,sp,16
   16ac8:	00008067          	ret
       _CONST char *locale)
{
#ifndef _MB_CAPABLE
  if (locale)
    { 
      if (strcmp (locale, "POSIX") && strcmp (locale, "C")
   16acc:	c3848593          	addi	a1,s1,-968
   16ad0:	00040513          	mv	a0,s0
   16ad4:	3c4020ef          	jal	18e98 <strcmp>
   16ad8:	fc050ee3          	beqz	a0,16ab4 <_setlocale_r+0x34>
	  && strcmp (locale, ""))
   16adc:	0001d5b7          	lui	a1,0x1d
   16ae0:	c0458593          	addi	a1,a1,-1020 # 1cc04 <__thenan_sf+0x34>
   16ae4:	00040513          	mv	a0,s0
   16ae8:	3b0020ef          	jal	18e98 <strcmp>
   16aec:	fc0504e3          	beqz	a0,16ab4 <_setlocale_r+0x34>
        return NULL;
   16af0:	00000513          	li	a0,0
   16af4:	fc5ff06f          	j	16ab8 <_setlocale_r+0x38>

00016af8 <__locale_charset>:
_DEFUN_VOID(__locale_charset)
{
#if 0//def __HAVE_LOCALE_INFO__
  return __get_current_ctype_locale ()->codeset;
#else
  return lc_ctype_charset;
   16af8:	0001f537          	lui	a0,0x1f
#endif
}
   16afc:	85050513          	addi	a0,a0,-1968 # 1e850 <lc_ctype_charset>
   16b00:	00008067          	ret

00016b04 <__locale_mb_cur_max>:
#if 0//def __HAVE_LOCALE_INFO__
  return __get_current_ctype_locale ()->mb_cur_max[0];
#else
  return __mb_cur_max;
#endif
}
   16b04:	8141a503          	lw	a0,-2028(gp) # 1ece4 <__mb_cur_max>
   16b08:	00008067          	ret

00016b0c <__locale_msgcharset>:
_DEFUN_VOID(__locale_msgcharset)
{
#ifdef __HAVE_LOCALE_INFO__
  return (char *) __get_current_messages_locale ()->codeset;
#else
  return lc_message_charset;
   16b0c:	0001f537          	lui	a0,0x1f
#endif
}
   16b10:	87050513          	addi	a0,a0,-1936 # 1e870 <lc_message_charset>
   16b14:	00008067          	ret

00016b18 <__locale_cjk_lang>:

int
_DEFUN_VOID(__locale_cjk_lang)
{
  return lc_ctype_cjk_lang;
}
   16b18:	00000513          	li	a0,0
   16b1c:	00008067          	ret

00016b20 <_localeconv_r>:
      lconv.int_p_sign_posn = m->p_sign_posn[0];
#endif /* !__HAVE_LOCALE_INFO_EXTENDED__ */
      __mlocale_changed = 0;
    }
#endif /* __HAVE_LOCALE_INFO__ */
  return (struct lconv *) &lconv;
   16b20:	0001f537          	lui	a0,0x1f
}
   16b24:	89050513          	addi	a0,a0,-1904 # 1e890 <lconv>
   16b28:	00008067          	ret

00016b2c <setlocale>:
char *
_DEFUN(setlocale, (category, locale),
       int category _AND
       _CONST char *locale)
{
  return _setlocale_r (_REENT, category, locale);
   16b2c:	00058613          	mv	a2,a1
   16b30:	00050593          	mv	a1,a0
   16b34:	8101a503          	lw	a0,-2032(gp) # 1ece0 <_impure_ptr>
   16b38:	f49ff06f          	j	16a80 <_setlocale_r>

00016b3c <localeconv>:
#endif /* __CYGWIN__ */

struct lconv *
_DEFUN_VOID(localeconv)
{
  return _localeconv_r (_REENT);
   16b3c:	0001f537          	lui	a0,0x1f
}
   16b40:	89050513          	addi	a0,a0,-1904 # 1e890 <lconv>
   16b44:	00008067          	ret

00016b48 <__smakebuf_r>:
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
   16b48:	00c59783          	lh	a5,12(a1)

_VOID
_DEFUN(__smakebuf_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE *fp)
{
   16b4c:	f7010113          	addi	sp,sp,-144
   16b50:	08912223          	sw	s1,132(sp)
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
   16b54:	01079493          	slli	s1,a5,0x10
   16b58:	0104d493          	srli	s1,s1,0x10
   16b5c:	0024f713          	andi	a4,s1,2

_VOID
_DEFUN(__smakebuf_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE *fp)
{
   16b60:	08112623          	sw	ra,140(sp)
   16b64:	08812423          	sw	s0,136(sp)
   16b68:	09212023          	sw	s2,128(sp)
   16b6c:	07312e23          	sw	s3,124(sp)
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
   16b70:	0e071063          	bnez	a4,16c50 <__smakebuf_r+0x108>
   16b74:	00050913          	mv	s2,a0
      return;
    }
#ifdef __USE_INTERNAL_STAT64
  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
   16b78:	00e59503          	lh	a0,14(a1)
   16b7c:	00058413          	mv	s0,a1
   16b80:	04054c63          	bltz	a0,16bd8 <__smakebuf_r+0x90>
   16b84:	00010593          	mv	a1,sp
   16b88:	e4cf90ef          	jal	101d4 <fstat>
   16b8c:	04054063          	bltz	a0,16bcc <__smakebuf_r+0x84>
      fp->_flags |= __SNPT;
#endif
    }
  else
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
   16b90:	01012703          	lw	a4,16(sp)
   16b94:	0000f7b7          	lui	a5,0xf
   16b98:	ffffe9b7          	lui	s3,0xffffe
   16b9c:	00f777b3          	and	a5,a4,a5
   16ba0:	013789b3          	add	s3,a5,s3
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
   16ba4:	00008737          	lui	a4,0x8
      fp->_flags |= __SNPT;
#endif
    }
  else
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
   16ba8:	0019b993          	seqz	s3,s3
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
   16bac:	0ae78e63          	beq	a5,a4,16c68 <__smakebuf_r+0x120>
#else
	  fp->_blksize = 1024;
#endif
	}
      else
	fp->_flags |= __SNPT;
   16bb0:	00c45703          	lhu	a4,12(s0)
   16bb4:	000017b7          	lui	a5,0x1
   16bb8:	80078793          	addi	a5,a5,-2048 # 800 <_reset+0x600>
   16bbc:	00f767b3          	or	a5,a4,a5
   16bc0:	00f41623          	sh	a5,12(s0)
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
#ifdef HAVE_BLKSIZE
      size = st.st_blksize <= 0 ? BUFSIZ : st.st_blksize;
#else
      size = BUFSIZ;
   16bc4:	40000493          	li	s1,1024
   16bc8:	0340006f          	j	16bfc <__smakebuf_r+0xb4>
   16bcc:	00c41783          	lh	a5,12(s0)
   16bd0:	01079493          	slli	s1,a5,0x10
   16bd4:	0104d493          	srli	s1,s1,0x10
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   16bd8:	01849493          	slli	s1,s1,0x18
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   16bdc:	00001737          	lui	a4,0x1
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   16be0:	41f4d493          	srai	s1,s1,0x1f
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   16be4:	80070713          	addi	a4,a4,-2048 # 800 <_reset+0x600>
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   16be8:	c404f493          	andi	s1,s1,-960
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   16bec:	00e7e7b3          	or	a5,a5,a4
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   16bf0:	40048493          	addi	s1,s1,1024
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   16bf4:	00f41623          	sh	a5,12(s0)
  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
#endif
    {
      couldbetty = 0;
   16bf8:	00000993          	li	s3,0
	}
      else
	fp->_flags |= __SNPT;
#endif
    }
  if ((p = _malloc_r (ptr, size)) == NULL)
   16bfc:	00048593          	mv	a1,s1
   16c00:	00090513          	mv	a0,s2
   16c04:	0d4000ef          	jal	16cd8 <_malloc_r>
   16c08:	0a050263          	beqz	a0,16cac <__smakebuf_r+0x164>
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
      fp->_flags |= __SMBF;
   16c0c:	00c45783          	lhu	a5,12(s0)
	  fp->_bf._size = 1;
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
   16c10:	00016737          	lui	a4,0x16
   16c14:	d3070713          	addi	a4,a4,-720 # 15d30 <_cleanup_r>
      fp->_flags |= __SMBF;
   16c18:	0807e793          	ori	a5,a5,128
	  fp->_bf._size = 1;
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
   16c1c:	02e92e23          	sw	a4,60(s2)
      fp->_flags |= __SMBF;
   16c20:	00f41623          	sh	a5,12(s0)
      fp->_bf._base = fp->_p = (unsigned char *) p;
   16c24:	00a42023          	sw	a0,0(s0)
   16c28:	00a42823          	sw	a0,16(s0)
      fp->_bf._size = size;
   16c2c:	00942a23          	sw	s1,20(s0)
      if (couldbetty && _isatty_r (ptr, fp->_file))
   16c30:	06099063          	bnez	s3,16c90 <__smakebuf_r+0x148>
	fp->_flags |= __SLBF;
    }
}
   16c34:	08c12083          	lw	ra,140(sp)
   16c38:	08812403          	lw	s0,136(sp)
   16c3c:	08412483          	lw	s1,132(sp)
   16c40:	08012903          	lw	s2,128(sp)
   16c44:	07c12983          	lw	s3,124(sp)
   16c48:	09010113          	addi	sp,sp,144
   16c4c:	00008067          	ret
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
    {
      fp->_bf._base = fp->_p = fp->_nbuf;
   16c50:	04358793          	addi	a5,a1,67
   16c54:	00f5a023          	sw	a5,0(a1)
   16c58:	00f5a823          	sw	a5,16(a1)
      fp->_bf._size = 1;
   16c5c:	00100793          	li	a5,1
   16c60:	00f5aa23          	sw	a5,20(a1)
   16c64:	fd1ff06f          	j	16c34 <__smakebuf_r+0xec>
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
   16c68:	02842703          	lw	a4,40(s0)
   16c6c:	000197b7          	lui	a5,0x19
   16c70:	e2478793          	addi	a5,a5,-476 # 18e24 <__sseek>
   16c74:	f2f71ee3          	bne	a4,a5,16bb0 <__smakebuf_r+0x68>
	{
	  fp->_flags |= __SOPT;
   16c78:	00c45783          	lhu	a5,12(s0)
#ifdef HAVE_BLKSIZE
	  fp->_blksize = st.st_blksize;
#else
	  fp->_blksize = 1024;
   16c7c:	40000493          	li	s1,1024
   16c80:	04942623          	sw	s1,76(s0)
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
	{
	  fp->_flags |= __SOPT;
   16c84:	0097e7b3          	or	a5,a5,s1
   16c88:	00f41623          	sh	a5,12(s0)
#ifdef HAVE_BLKSIZE
	  fp->_blksize = st.st_blksize;
#else
	  fp->_blksize = 1024;
   16c8c:	f71ff06f          	j	16bfc <__smakebuf_r+0xb4>
    {
      ptr->__cleanup = _cleanup_r;
      fp->_flags |= __SMBF;
      fp->_bf._base = fp->_p = (unsigned char *) p;
      fp->_bf._size = size;
      if (couldbetty && _isatty_r (ptr, fp->_file))
   16c90:	00e41503          	lh	a0,14(s0)
   16c94:	d94f90ef          	jal	10228 <isatty>
   16c98:	f8050ee3          	beqz	a0,16c34 <__smakebuf_r+0xec>
	fp->_flags |= __SLBF;
   16c9c:	00c45783          	lhu	a5,12(s0)
   16ca0:	0017e793          	ori	a5,a5,1
   16ca4:	00f41623          	sh	a5,12(s0)
   16ca8:	f8dff06f          	j	16c34 <__smakebuf_r+0xec>
	fp->_flags |= __SNPT;
#endif
    }
  if ((p = _malloc_r (ptr, size)) == NULL)
    {
      if (!(fp->_flags & __SSTR))
   16cac:	00c41783          	lh	a5,12(s0)
   16cb0:	2007f713          	andi	a4,a5,512
   16cb4:	f80710e3          	bnez	a4,16c34 <__smakebuf_r+0xec>
	{
	  fp->_flags |= __SNBF;
   16cb8:	0027e793          	ori	a5,a5,2
	  fp->_bf._base = fp->_p = fp->_nbuf;
   16cbc:	04340713          	addi	a4,s0,67
    }
  if ((p = _malloc_r (ptr, size)) == NULL)
    {
      if (!(fp->_flags & __SSTR))
	{
	  fp->_flags |= __SNBF;
   16cc0:	00f41623          	sh	a5,12(s0)
	  fp->_bf._base = fp->_p = fp->_nbuf;
	  fp->_bf._size = 1;
   16cc4:	00100793          	li	a5,1
  if ((p = _malloc_r (ptr, size)) == NULL)
    {
      if (!(fp->_flags & __SSTR))
	{
	  fp->_flags |= __SNBF;
	  fp->_bf._base = fp->_p = fp->_nbuf;
   16cc8:	00e42023          	sw	a4,0(s0)
   16ccc:	00e42823          	sw	a4,16(s0)
	  fp->_bf._size = 1;
   16cd0:	00f42a23          	sw	a5,20(s0)
   16cd4:	f61ff06f          	j	16c34 <__smakebuf_r+0xec>

00016cd8 <_malloc_r>:
#if __STD_C
Void_t* mALLOc(RARG size_t bytes)
#else
Void_t* mALLOc(RARG bytes) RDECL size_t bytes;
#endif
{
   16cd8:	fd010113          	addi	sp,sp,-48
   16cdc:	02912223          	sw	s1,36(sp)
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
   16ce0:	01600793          	li	a5,22
   16ce4:	00b58493          	addi	s1,a1,11
#if __STD_C
Void_t* mALLOc(RARG size_t bytes)
#else
Void_t* mALLOc(RARG bytes) RDECL size_t bytes;
#endif
{
   16ce8:	01312e23          	sw	s3,28(sp)
   16cec:	02112623          	sw	ra,44(sp)
   16cf0:	02812423          	sw	s0,40(sp)
   16cf4:	03212023          	sw	s2,32(sp)
   16cf8:	01412c23          	sw	s4,24(sp)
   16cfc:	01512a23          	sw	s5,20(sp)
   16d00:	01612823          	sw	s6,16(sp)
   16d04:	01712623          	sw	s7,12(sp)
   16d08:	01812423          	sw	s8,8(sp)
   16d0c:	01912223          	sw	s9,4(sp)
   16d10:	00050993          	mv	s3,a0
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
   16d14:	1a97fc63          	bleu	s1,a5,16ecc <_malloc_r+0x1f4>
   16d18:	ff84f493          	andi	s1,s1,-8

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   16d1c:	2404c463          	bltz	s1,16f64 <_malloc_r+0x28c>
   16d20:	24b4e263          	bltu	s1,a1,16f64 <_malloc_r+0x28c>
  {
    RERRNO = ENOMEM;
    return 0;
  }

  MALLOC_LOCK;
   16d24:	1fd000ef          	jal	17720 <__malloc_lock>

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
   16d28:	1f700793          	li	a5,503
   16d2c:	7097fa63          	bleu	s1,a5,17440 <_malloc_r+0x768>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   16d30:	0094d793          	srli	a5,s1,0x9
   16d34:	08000693          	li	a3,128
   16d38:	04000513          	li	a0,64
   16d3c:	03f00593          	li	a1,63
   16d40:	22079a63          	bnez	a5,16f74 <_malloc_r+0x29c>
    bin = bin_at(idx);
   16d44:	0001f937          	lui	s2,0x1f
   16d48:	8c890913          	addi	s2,s2,-1848 # 1e8c8 <__malloc_av_>
   16d4c:	00269693          	slli	a3,a3,0x2
   16d50:	00d906b3          	add	a3,s2,a3

    for (victim = last(bin); victim != bin; victim = victim->bk)
   16d54:	0046a403          	lw	s0,4(a3)

  }
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);
   16d58:	ff868693          	addi	a3,a3,-8

    for (victim = last(bin); victim != bin; victim = victim->bk)
   16d5c:	22868a63          	beq	a3,s0,16f90 <_malloc_r+0x2b8>
    {
      victim_size = chunksize(victim);
   16d60:	00442783          	lw	a5,4(s0)
      remainder_size = long_sub_size_t(victim_size, nb);
      
      if (remainder_size >= (long)MINSIZE) /* too big */
   16d64:	00f00613          	li	a2,15
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
    {
      victim_size = chunksize(victim);
   16d68:	ffc7f793          	andi	a5,a5,-4
      remainder_size = long_sub_size_t(victim_size, nb);
   16d6c:	40978733          	sub	a4,a5,s1
      
      if (remainder_size >= (long)MINSIZE) /* too big */
   16d70:	02e64063          	blt	a2,a4,16d90 <_malloc_r+0xb8>
      {
        --idx; /* adjust to rescan below after checking last remainder */
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
   16d74:	22075263          	bgez	a4,16f98 <_malloc_r+0x2c0>
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
   16d78:	00c42403          	lw	s0,12(s0)
   16d7c:	20868a63          	beq	a3,s0,16f90 <_malloc_r+0x2b8>
    {
      victim_size = chunksize(victim);
   16d80:	00442783          	lw	a5,4(s0)
   16d84:	ffc7f793          	andi	a5,a5,-4
      remainder_size = long_sub_size_t(victim_size, nb);
   16d88:	40978733          	sub	a4,a5,s1
      
      if (remainder_size >= (long)MINSIZE) /* too big */
   16d8c:	fee654e3          	ble	a4,a2,16d74 <_malloc_r+0x9c>
      {
        --idx; /* adjust to rescan below after checking last remainder */
        break;   
   16d90:	00058693          	mv	a3,a1

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
   16d94:	01092403          	lw	s0,16(s2)
   16d98:	00890813          	addi	a6,s2,8
   16d9c:	4b040263          	beq	s0,a6,17240 <_malloc_r+0x568>
  {
    victim_size = chunksize(victim);
   16da0:	00442783          	lw	a5,4(s0)
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
   16da4:	00f00613          	li	a2,15

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
  {
    victim_size = chunksize(victim);
   16da8:	ffc7f793          	andi	a5,a5,-4
    remainder_size = long_sub_size_t(victim_size, nb);
   16dac:	40978733          	sub	a4,a5,s1

    if (remainder_size >= (long)MINSIZE) /* re-split */
   16db0:	44e64a63          	blt	a2,a4,17204 <_malloc_r+0x52c>
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
      return chunk2mem(victim);
    }

    clear_last_remainder;
   16db4:	01092a23          	sw	a6,20(s2)
   16db8:	01092823          	sw	a6,16(s2)

    if (remainder_size >= 0)  /* exhaust */
   16dbc:	20075663          	bgez	a4,16fc8 <_malloc_r+0x2f0>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   16dc0:	1ff00713          	li	a4,511
   16dc4:	3cf76e63          	bltu	a4,a5,171a0 <_malloc_r+0x4c8>
   16dc8:	0037d793          	srli	a5,a5,0x3
   16dcc:	00178613          	addi	a2,a5,1
   16dd0:	00361613          	slli	a2,a2,0x3
   16dd4:	00492703          	lw	a4,4(s2)
   16dd8:	00c90633          	add	a2,s2,a2
   16ddc:	00062503          	lw	a0,0(a2)
   16de0:	4027d793          	srai	a5,a5,0x2
   16de4:	00100593          	li	a1,1
   16de8:	00f597b3          	sll	a5,a1,a5
   16dec:	00e7e7b3          	or	a5,a5,a4
   16df0:	ff860713          	addi	a4,a2,-8
   16df4:	00e42623          	sw	a4,12(s0)
   16df8:	00a42423          	sw	a0,8(s0)
   16dfc:	00f92223          	sw	a5,4(s2)
   16e00:	00862023          	sw	s0,0(a2)
   16e04:	00852623          	sw	s0,12(a0)
  /* 
     If there are any possibly nonempty big-enough blocks, 
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks)  
   16e08:	4026d713          	srai	a4,a3,0x2
   16e0c:	00100613          	li	a2,1
   16e10:	00e61633          	sll	a2,a2,a4
   16e14:	1cc7ea63          	bltu	a5,a2,16fe8 <_malloc_r+0x310>
  {

    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
   16e18:	00f67733          	and	a4,a2,a5
   16e1c:	02071463          	bnez	a4,16e44 <_malloc_r+0x16c>
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
   16e20:	00161613          	slli	a2,a2,0x1
    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
   16e24:	ffc6f693          	andi	a3,a3,-4
      block <<= 1;
      while ((block & binblocks) == 0)
   16e28:	00f67733          	and	a4,a2,a5
    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
   16e2c:	00468693          	addi	a3,a3,4
      block <<= 1;
      while ((block & binblocks) == 0)
   16e30:	00071a63          	bnez	a4,16e44 <_malloc_r+0x16c>
      {
        idx += BINBLOCKWIDTH;
        block <<= 1;
   16e34:	00161613          	slli	a2,a2,0x1
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
   16e38:	00f67733          	and	a4,a2,a5
      {
        idx += BINBLOCKWIDTH;
   16e3c:	00468693          	addi	a3,a3,4
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
   16e40:	fe070ae3          	beqz	a4,16e34 <_malloc_r+0x15c>
        for (victim = last(bin); victim != bin; victim = victim->bk)
        {
          victim_size = chunksize(victim);
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
   16e44:	00f00513          	li	a0,15
      
    /* For each possibly nonempty block ... */
    for (;;)  
    {
      startidx = idx;          /* (track incomplete blocks) */
      q = bin = bin_at(idx);
   16e48:	00369893          	slli	a7,a3,0x3
   16e4c:	012888b3          	add	a7,a7,s2
   16e50:	00088593          	mv	a1,a7
   16e54:	00068293          	mv	t0,a3
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
   16e58:	00c5a403          	lw	s0,12(a1)
   16e5c:	00859a63          	bne	a1,s0,16e70 <_malloc_r+0x198>
   16e60:	3e80006f          	j	17248 <_malloc_r+0x570>
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
   16e64:	40075463          	bgez	a4,1726c <_malloc_r+0x594>
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
   16e68:	00c42403          	lw	s0,12(s0)
   16e6c:	3c858e63          	beq	a1,s0,17248 <_malloc_r+0x570>
        {
          victim_size = chunksize(victim);
   16e70:	00442783          	lw	a5,4(s0)
   16e74:	ffc7f793          	andi	a5,a5,-4
          remainder_size = long_sub_size_t(victim_size, nb);
   16e78:	40978733          	sub	a4,a5,s1

          if (remainder_size >= (long)MINSIZE) /* split */
   16e7c:	fee554e3          	ble	a4,a0,16e64 <_malloc_r+0x18c>
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
   16e80:	00c42683          	lw	a3,12(s0)
   16e84:	00842603          	lw	a2,8(s0)
          victim_size = chunksize(victim);
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
   16e88:	009407b3          	add	a5,s0,s1
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
            link_last_remainder(remainder);
            set_head(remainder, remainder_size | PREV_INUSE);
   16e8c:	00176893          	ori	a7,a4,1
            set_foot(remainder, remainder_size);
   16e90:	00e785b3          	add	a1,a5,a4
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
   16e94:	0014e493          	ori	s1,s1,1
   16e98:	00942223          	sw	s1,4(s0)
            unlink(victim, bck, fwd);
            link_last_remainder(remainder);
            set_head(remainder, remainder_size | PREV_INUSE);
            set_foot(remainder, remainder_size);
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   16e9c:	00098513          	mv	a0,s3

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
   16ea0:	00d62623          	sw	a3,12(a2)
   16ea4:	00c6a423          	sw	a2,8(a3)
            link_last_remainder(remainder);
   16ea8:	00f92a23          	sw	a5,20(s2)
   16eac:	00f92823          	sw	a5,16(s2)
   16eb0:	0107a623          	sw	a6,12(a5)
   16eb4:	0107a423          	sw	a6,8(a5)
            set_head(remainder, remainder_size | PREV_INUSE);
   16eb8:	0117a223          	sw	a7,4(a5)
            set_foot(remainder, remainder_size);
   16ebc:	00e5a023          	sw	a4,0(a1)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   16ec0:	065000ef          	jal	17724 <__malloc_unlock>
            return chunk2mem(victim);
   16ec4:	00840513          	addi	a0,s0,8
   16ec8:	0680006f          	j	16f30 <_malloc_r+0x258>
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   16ecc:	01000493          	li	s1,16
   16ed0:	08b4ea63          	bltu	s1,a1,16f64 <_malloc_r+0x28c>
  {
    RERRNO = ENOMEM;
    return 0;
  }

  MALLOC_LOCK;
   16ed4:	04d000ef          	jal	17720 <__malloc_lock>
   16ed8:	00600793          	li	a5,6
   16edc:	00200693          	li	a3,2
  {
    idx = smallbin_index(nb); 

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
   16ee0:	0001f937          	lui	s2,0x1f
   16ee4:	8c890913          	addi	s2,s2,-1848 # 1e8c8 <__malloc_av_>
   16ee8:	00279793          	slli	a5,a5,0x2
   16eec:	00f907b3          	add	a5,s2,a5
    victim = last(q);
   16ef0:	0047a403          	lw	s0,4(a5)

#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
   16ef4:	ff878713          	addi	a4,a5,-8
   16ef8:	36e40263          	beq	s0,a4,1725c <_malloc_r+0x584>
      victim = last(q);
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
   16efc:	00442783          	lw	a5,4(s0)
      unlink(victim, bck, fwd);
   16f00:	00c42683          	lw	a3,12(s0)
   16f04:	00842603          	lw	a2,8(s0)
      victim = last(q);
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
   16f08:	ffc7f793          	andi	a5,a5,-4
      unlink(victim, bck, fwd);
      set_inuse_bit_at_offset(victim, victim_size);
   16f0c:	00f407b3          	add	a5,s0,a5
   16f10:	0047a703          	lw	a4,4(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   16f14:	00098513          	mv	a0,s3
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
      unlink(victim, bck, fwd);
   16f18:	00d62623          	sw	a3,12(a2)
      set_inuse_bit_at_offset(victim, victim_size);
   16f1c:	00176713          	ori	a4,a4,1
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
      unlink(victim, bck, fwd);
   16f20:	00c6a423          	sw	a2,8(a3)
      set_inuse_bit_at_offset(victim, victim_size);
   16f24:	00e7a223          	sw	a4,4(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   16f28:	7fc000ef          	jal	17724 <__malloc_unlock>
      return chunk2mem(victim);
   16f2c:	00840513          	addi	a0,s0,8
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
  return chunk2mem(victim);

#endif /* MALLOC_PROVIDED */
}
   16f30:	02c12083          	lw	ra,44(sp)
   16f34:	02812403          	lw	s0,40(sp)
   16f38:	02412483          	lw	s1,36(sp)
   16f3c:	02012903          	lw	s2,32(sp)
   16f40:	01c12983          	lw	s3,28(sp)
   16f44:	01812a03          	lw	s4,24(sp)
   16f48:	01412a83          	lw	s5,20(sp)
   16f4c:	01012b03          	lw	s6,16(sp)
   16f50:	00c12b83          	lw	s7,12(sp)
   16f54:	00812c03          	lw	s8,8(sp)
   16f58:	00412c83          	lw	s9,4(sp)
   16f5c:	03010113          	addi	sp,sp,48
   16f60:	00008067          	ret
  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
  {
    RERRNO = ENOMEM;
   16f64:	00c00793          	li	a5,12
   16f68:	00f9a023          	sw	a5,0(s3) # ffffe000 <_gp+0xfffdeb30>
    return 0;
   16f6c:	00000513          	li	a0,0
   16f70:	fc1ff06f          	j	16f30 <_malloc_r+0x258>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   16f74:	00400713          	li	a4,4
   16f78:	20f76263          	bltu	a4,a5,1717c <_malloc_r+0x4a4>
   16f7c:	0064d593          	srli	a1,s1,0x6
   16f80:	03958513          	addi	a0,a1,57
   16f84:	00151693          	slli	a3,a0,0x1
   16f88:	03858593          	addi	a1,a1,56
   16f8c:	db9ff06f          	j	16d44 <_malloc_r+0x6c>
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
   16f90:	00050693          	mv	a3,a0
   16f94:	e01ff06f          	j	16d94 <_malloc_r+0xbc>
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
        set_inuse_bit_at_offset(victim, victim_size);
   16f98:	00f407b3          	add	a5,s0,a5
   16f9c:	0047a703          	lw	a4,4(a5)
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
   16fa0:	00c42683          	lw	a3,12(s0)
   16fa4:	00842603          	lw	a2,8(s0)
        set_inuse_bit_at_offset(victim, victim_size);
   16fa8:	00176713          	ori	a4,a4,1
        check_malloced_chunk(victim, nb);
	MALLOC_UNLOCK;
   16fac:	00098513          	mv	a0,s3
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
   16fb0:	00d62623          	sw	a3,12(a2)
   16fb4:	00c6a423          	sw	a2,8(a3)
        set_inuse_bit_at_offset(victim, victim_size);
   16fb8:	00e7a223          	sw	a4,4(a5)
        check_malloced_chunk(victim, nb);
	MALLOC_UNLOCK;
   16fbc:	768000ef          	jal	17724 <__malloc_unlock>
        return chunk2mem(victim);
   16fc0:	00840513          	addi	a0,s0,8
   16fc4:	f6dff06f          	j	16f30 <_malloc_r+0x258>

    clear_last_remainder;

    if (remainder_size >= 0)  /* exhaust */
    {
      set_inuse_bit_at_offset(victim, victim_size);
   16fc8:	00f407b3          	add	a5,s0,a5
   16fcc:	0047a703          	lw	a4,4(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   16fd0:	00098513          	mv	a0,s3

    clear_last_remainder;

    if (remainder_size >= 0)  /* exhaust */
    {
      set_inuse_bit_at_offset(victim, victim_size);
   16fd4:	00176713          	ori	a4,a4,1
   16fd8:	00e7a223          	sw	a4,4(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   16fdc:	748000ef          	jal	17724 <__malloc_unlock>
      return chunk2mem(victim);
   16fe0:	00840513          	addi	a0,s0,8
   16fe4:	f4dff06f          	j	16f30 <_malloc_r+0x258>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  remainder_size = long_sub_size_t(chunksize(top), nb);
   16fe8:	00892403          	lw	s0,8(s2)
   16fec:	00442a03          	lw	s4,4(s0)
   16ff0:	ffca7a93          	andi	s5,s4,-4
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   16ff4:	009ae863          	bltu	s5,s1,17004 <_malloc_r+0x32c>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  remainder_size = long_sub_size_t(chunksize(top), nb);
   16ff8:	409a87b3          	sub	a5,s5,s1
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   16ffc:	00f00713          	li	a4,15
   17000:	14f74a63          	blt	a4,a5,17154 <_malloc_r+0x47c>
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
   17004:	8981a703          	lw	a4,-1896(gp) # 1ed68 <__malloc_top_pad>

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
   17008:	8181a683          	lw	a3,-2024(gp) # 1ece8 <__malloc_sbrk_base>
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
   1700c:	00e48733          	add	a4,s1,a4

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
   17010:	fff00793          	li	a5,-1
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
   17014:	01540b33          	add	s6,s0,s5

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
   17018:	01070a13          	addi	s4,a4,16

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
   1701c:	00f68c63          	beq	a3,a5,17034 <_malloc_r+0x35c>
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
   17020:	000016b7          	lui	a3,0x1
   17024:	00f68a13          	addi	s4,a3,15 # 100f <_reset+0xe0f>
   17028:	014706b3          	add	a3,a4,s4
   1702c:	fffff737          	lui	a4,0xfffff
   17030:	00e6fa33          	and	s4,a3,a4

  brk = (char*)(MORECORE (sbrk_size));
   17034:	000a0513          	mv	a0,s4
   17038:	b88f90ef          	jal	103c0 <sbrk>

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
   1703c:	fff00793          	li	a5,-1
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));
   17040:	00050b93          	mv	s7,a0

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
   17044:	28f50063          	beq	a0,a5,172c4 <_malloc_r+0x5ec>
   17048:	27656c63          	bltu	a0,s6,172c0 <_malloc_r+0x5e8>
      (brk < old_end && old_top != initial_top))
    return;

  sbrked_mem += sbrk_size;
   1704c:	8bc18c13          	addi	s8,gp,-1860 # 1ed8c <__malloc_current_mallinfo>
   17050:	000c2703          	lw	a4,0(s8)
   17054:	00ea0733          	add	a4,s4,a4
   17058:	00ec2023          	sw	a4,0(s8)

  if (brk == old_end /* can just add bytes to current top, unless
   1705c:	357b0c63          	beq	s6,s7,173b4 <_malloc_r+0x6dc>
    top_size = sbrk_size + old_top_size;
    set_head(top, top_size | PREV_INUSE);
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
   17060:	8181a683          	lw	a3,-2024(gp) # 1ece8 <__malloc_sbrk_base>
   17064:	fff00793          	li	a5,-1
   17068:	36f68a63          	beq	a3,a5,173dc <_malloc_r+0x704>
      sbrk_base = brk;
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
   1706c:	416b8b33          	sub	s6,s7,s6
   17070:	00eb0733          	add	a4,s6,a4
   17074:	00ec2023          	sw	a4,0(s8)

    /* Guarantee alignment of first new chunk made from this space */
    front_misalign = (POINTER_UINT)chunk2mem(brk) & MALLOC_ALIGN_MASK;
   17078:	007bf713          	andi	a4,s7,7
    if (front_misalign > 0) 
   1707c:	000017b7          	lui	a5,0x1
   17080:	00070a63          	beqz	a4,17094 <_malloc_r+0x3bc>
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
      brk += correction;
   17084:	40eb8bb3          	sub	s7,s7,a4
   17088:	00878793          	addi	a5,a5,8 # 1008 <_reset+0xe08>
   1708c:	008b8b93          	addi	s7,s7,8
   17090:	40e787b3          	sub	a5,a5,a4
    }
    else
      correction = 0;

    /* Guarantee the next brk will be at a page boundary */
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));
   17094:	00001737          	lui	a4,0x1
   17098:	fff70713          	addi	a4,a4,-1 # fff <_reset+0xdff>
   1709c:	014b8a33          	add	s4,s7,s4
   170a0:	00ea7a33          	and	s4,s4,a4
   170a4:	41478a33          	sub	s4,a5,s4

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
   170a8:	000a0513          	mv	a0,s4
   170ac:	b14f90ef          	jal	103c0 <sbrk>
    if (new_brk == (char*)(MORECORE_FAILURE))
   170b0:	fff00793          	li	a5,-1
   170b4:	30f50e63          	beq	a0,a5,173d0 <_malloc_r+0x6f8>
   170b8:	417507b3          	sub	a5,a0,s7
   170bc:	014787b3          	add	a5,a5,s4
   170c0:	0017e793          	ori	a5,a5,1
	correction = 0;
	correction_failed = 1;
	new_brk = brk;
      }

    sbrked_mem += correction;
   170c4:	000c2703          	lw	a4,0(s8)

    top = (mchunkptr)brk;
   170c8:	01792423          	sw	s7,8(s2)
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);
   170cc:	00fba223          	sw	a5,4(s7)
	correction = 0;
	correction_failed = 1;
	new_brk = brk;
      }

    sbrked_mem += correction;
   170d0:	00ea0733          	add	a4,s4,a4
   170d4:	00ec2023          	sw	a4,0(s8)

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);

    if (old_top != initial_top)
   170d8:	03240c63          	beq	s0,s2,17110 <_malloc_r+0x438>

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE) 
   170dc:	00f00613          	li	a2,15
   170e0:	29567263          	bleu	s5,a2,17364 <_malloc_r+0x68c>
        return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
   170e4:	00442683          	lw	a3,4(s0)
        set_head(top, PREV_INUSE); /* will force null return from malloc */
        return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
   170e8:	ff4a8793          	addi	a5,s5,-12
   170ec:	ff87f793          	andi	a5,a5,-8
      set_head_size(old_top, old_top_size);
   170f0:	0016f693          	andi	a3,a3,1
      chunk_at_offset(old_top, old_top_size          )->size =
   170f4:	00f405b3          	add	a1,s0,a5
   170f8:	00500513          	li	a0,5
        return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
   170fc:	00f6e6b3          	or	a3,a3,a5
   17100:	00d42223          	sw	a3,4(s0)
      chunk_at_offset(old_top, old_top_size          )->size =
   17104:	00a5a223          	sw	a0,4(a1)
        SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
   17108:	00a5a423          	sw	a0,8(a1)
        SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE) 
   1710c:	2cf66c63          	bltu	a2,a5,173e4 <_malloc_r+0x70c>
        fREe(RCALL chunk2mem(old_top));
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem) 
   17110:	8941a683          	lw	a3,-1900(gp) # 1ed64 <__malloc_max_sbrked_mem>
   17114:	00e6f463          	bleu	a4,a3,1711c <_malloc_r+0x444>
    max_sbrked_mem = sbrked_mem;
   17118:	88e1aa23          	sw	a4,-1900(gp) # 1ed64 <__malloc_max_sbrked_mem>
#if HAVE_MMAP
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem) 
    max_total_mem = mmapped_mem + sbrked_mem;
#else
  if ((unsigned long)(sbrked_mem) > (unsigned long)max_total_mem) 
   1711c:	8901a683          	lw	a3,-1904(gp) # 1ed60 <__malloc_max_total_mem>
   17120:	00892403          	lw	s0,8(s2)
   17124:	00e6f463          	bleu	a4,a3,1712c <_malloc_r+0x454>
    max_total_mem = sbrked_mem;
   17128:	88e1a823          	sw	a4,-1904(gp) # 1ed60 <__malloc_max_total_mem>
   1712c:	00442703          	lw	a4,4(s0)
   17130:	ffc77713          	andi	a4,a4,-4
    }
#endif

    /* Try to extend */
    malloc_extend_top(RCALL nb);
    remainder_size = long_sub_size_t(chunksize(top), nb);
   17134:	409707b3          	sub	a5,a4,s1
    if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   17138:	00976663          	bltu	a4,s1,17144 <_malloc_r+0x46c>
   1713c:	00f00713          	li	a4,15
   17140:	00f74a63          	blt	a4,a5,17154 <_malloc_r+0x47c>
    {
      MALLOC_UNLOCK;
   17144:	00098513          	mv	a0,s3
   17148:	5dc000ef          	jal	17724 <__malloc_unlock>
      return 0; /* propagate failure */
   1714c:	00000513          	li	a0,0
   17150:	de1ff06f          	j	16f30 <_malloc_r+0x258>
    }
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
   17154:	00940733          	add	a4,s0,s1
  set_head(top, remainder_size | PREV_INUSE);
   17158:	0017e793          	ori	a5,a5,1
      return 0; /* propagate failure */
    }
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
   1715c:	0014e493          	ori	s1,s1,1
   17160:	00942223          	sw	s1,4(s0)
  top = chunk_at_offset(victim, nb);
  set_head(top, remainder_size | PREV_INUSE);
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
   17164:	00098513          	mv	a0,s3
    }
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
   17168:	00e92423          	sw	a4,8(s2)
  set_head(top, remainder_size | PREV_INUSE);
   1716c:	00f72223          	sw	a5,4(a4)
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
   17170:	5b4000ef          	jal	17724 <__malloc_unlock>
  return chunk2mem(victim);
   17174:	00840513          	addi	a0,s0,8
   17178:	db9ff06f          	j	16f30 <_malloc_r+0x258>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   1717c:	01400713          	li	a4,20
   17180:	10f77e63          	bleu	a5,a4,1729c <_malloc_r+0x5c4>
   17184:	05400713          	li	a4,84
   17188:	1af76063          	bltu	a4,a5,17328 <_malloc_r+0x650>
   1718c:	00c4d593          	srli	a1,s1,0xc
   17190:	06f58513          	addi	a0,a1,111
   17194:	00151693          	slli	a3,a0,0x1
   17198:	06e58593          	addi	a1,a1,110
   1719c:	ba9ff06f          	j	16d44 <_malloc_r+0x6c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   171a0:	0097d713          	srli	a4,a5,0x9
   171a4:	00400613          	li	a2,4
   171a8:	10e67263          	bleu	a4,a2,172ac <_malloc_r+0x5d4>
   171ac:	01400613          	li	a2,20
   171b0:	1ee66463          	bltu	a2,a4,17398 <_malloc_r+0x6c0>
   171b4:	05c70593          	addi	a1,a4,92
   171b8:	05b70613          	addi	a2,a4,91
   171bc:	00159593          	slli	a1,a1,0x1
   171c0:	00259593          	slli	a1,a1,0x2
   171c4:	00b905b3          	add	a1,s2,a1
   171c8:	0005a703          	lw	a4,0(a1)
   171cc:	ff858593          	addi	a1,a1,-8
   171d0:	16e58a63          	beq	a1,a4,17344 <_malloc_r+0x66c>
   171d4:	00472603          	lw	a2,4(a4)
   171d8:	ffc67613          	andi	a2,a2,-4
   171dc:	00c7f663          	bleu	a2,a5,171e8 <_malloc_r+0x510>
   171e0:	00872703          	lw	a4,8(a4)
   171e4:	fee598e3          	bne	a1,a4,171d4 <_malloc_r+0x4fc>
   171e8:	00c72583          	lw	a1,12(a4)
   171ec:	00492783          	lw	a5,4(s2)
   171f0:	00b42623          	sw	a1,12(s0)
   171f4:	00e42423          	sw	a4,8(s0)
   171f8:	0085a423          	sw	s0,8(a1)
   171fc:	00872623          	sw	s0,12(a4)
   17200:	c09ff06f          	j	16e08 <_malloc_r+0x130>
    victim_size = chunksize(victim);
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
   17204:	009407b3          	add	a5,s0,s1
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
   17208:	00176613          	ori	a2,a4,1
      set_foot(remainder, remainder_size);
   1720c:	00e786b3          	add	a3,a5,a4
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
   17210:	0014e493          	ori	s1,s1,1
   17214:	00942223          	sw	s1,4(s0)
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
      set_foot(remainder, remainder_size);
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   17218:	00098513          	mv	a0,s3

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
   1721c:	00f92a23          	sw	a5,20(s2)
   17220:	00f92823          	sw	a5,16(s2)
   17224:	0107a623          	sw	a6,12(a5)
   17228:	0107a423          	sw	a6,8(a5)
      set_head(remainder, remainder_size | PREV_INUSE);
   1722c:	00c7a223          	sw	a2,4(a5)
      set_foot(remainder, remainder_size);
   17230:	00e6a023          	sw	a4,0(a3)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   17234:	4f0000ef          	jal	17724 <__malloc_unlock>
      return chunk2mem(victim);
   17238:	00840513          	addi	a0,s0,8
   1723c:	cf5ff06f          	j	16f30 <_malloc_r+0x258>
   17240:	00492783          	lw	a5,4(s2)
   17244:	bc5ff06f          	j	16e08 <_malloc_r+0x130>
         {
           bin = next_bin(bin);
           ++idx;
         }
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
   17248:	00128293          	addi	t0,t0,1
   1724c:	0032f793          	andi	a5,t0,3
            return chunk2mem(victim);
          }

        }

       bin = next_bin(bin);
   17250:	00858593          	addi	a1,a1,8
         {
           bin = next_bin(bin);
           ++idx;
         }
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
   17254:	c00792e3          	bnez	a5,16e58 <_malloc_r+0x180>
   17258:	0880006f          	j	172e0 <_malloc_r+0x608>
#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
    {
      q = next_bin(q);
      victim = last(q);
   1725c:	00c7a403          	lw	s0,12(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
      return chunk2mem(victim);
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
   17260:	00268693          	addi	a3,a3,2
    {
      q = next_bin(q);
      victim = last(q);
    }
#endif
    if (victim != q)
   17264:	b28788e3          	beq	a5,s0,16d94 <_malloc_r+0xbc>
   17268:	c95ff06f          	j	16efc <_malloc_r+0x224>
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
   1726c:	00f407b3          	add	a5,s0,a5
   17270:	0047a703          	lw	a4,4(a5)
            unlink(victim, bck, fwd);
   17274:	00c42683          	lw	a3,12(s0)
   17278:	00842603          	lw	a2,8(s0)
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
   1727c:	00176713          	ori	a4,a4,1
   17280:	00e7a223          	sw	a4,4(a5)
            unlink(victim, bck, fwd);
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   17284:	00098513          	mv	a0,s3
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
            unlink(victim, bck, fwd);
   17288:	00d62623          	sw	a3,12(a2)
   1728c:	00c6a423          	sw	a2,8(a3)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   17290:	494000ef          	jal	17724 <__malloc_unlock>
            return chunk2mem(victim);
   17294:	00840513          	addi	a0,s0,8
   17298:	c99ff06f          	j	16f30 <_malloc_r+0x258>
   1729c:	05c78513          	addi	a0,a5,92
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   172a0:	05b78593          	addi	a1,a5,91
   172a4:	00151693          	slli	a3,a0,0x1
   172a8:	a9dff06f          	j	16d44 <_malloc_r+0x6c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   172ac:	0067d613          	srli	a2,a5,0x6
   172b0:	03960593          	addi	a1,a2,57
   172b4:	00159593          	slli	a1,a1,0x1
   172b8:	03860613          	addi	a2,a2,56
   172bc:	f05ff06f          	j	171c0 <_malloc_r+0x4e8>

  brk = (char*)(MORECORE (sbrk_size));

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
      (brk < old_end && old_top != initial_top))
   172c0:	d92406e3          	beq	s0,s2,1704c <_malloc_r+0x374>
   172c4:	00892403          	lw	s0,8(s2)
   172c8:	00442703          	lw	a4,4(s0)
   172cc:	ffc77713          	andi	a4,a4,-4
   172d0:	e65ff06f          	j	17134 <_malloc_r+0x45c>
          binblocks &= ~block;
          break;
        }
        --startidx;
       q = prev_bin(q);
      } while (first(q) == q);
   172d4:	0088a783          	lw	a5,8(a7)
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
        {
          binblocks &= ~block;
          break;
        }
        --startidx;
   172d8:	fff68693          	addi	a3,a3,-1
       q = prev_bin(q);
      } while (first(q) == q);
   172dc:	14f89e63          	bne	a7,a5,17438 <_malloc_r+0x760>

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
   172e0:	0036f793          	andi	a5,a3,3
        {
          binblocks &= ~block;
          break;
        }
        --startidx;
       q = prev_bin(q);
   172e4:	ff888893          	addi	a7,a7,-8

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
   172e8:	fe0796e3          	bnez	a5,172d4 <_malloc_r+0x5fc>
        {
          binblocks &= ~block;
   172ec:	00492783          	lw	a5,4(s2)
   172f0:	fff64713          	not	a4,a2
   172f4:	00f777b3          	and	a5,a4,a5
   172f8:	00f92223          	sw	a5,4(s2)
       q = prev_bin(q);
      } while (first(q) == q);

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
   172fc:	00161613          	slli	a2,a2,0x1
   17300:	cec7e4e3          	bltu	a5,a2,16fe8 <_malloc_r+0x310>
   17304:	ce0602e3          	beqz	a2,16fe8 <_malloc_r+0x310>
      {
        while ((block & binblocks) == 0)
   17308:	00f67733          	and	a4,a2,a5
   1730c:	00028693          	mv	a3,t0
   17310:	b2071ce3          	bnez	a4,16e48 <_malloc_r+0x170>
        {
          idx += BINBLOCKWIDTH;
          block <<= 1;
   17314:	00161613          	slli	a2,a2,0x1

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
   17318:	00f67733          	and	a4,a2,a5
        {
          idx += BINBLOCKWIDTH;
   1731c:	00468693          	addi	a3,a3,4

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
   17320:	fe070ae3          	beqz	a4,17314 <_malloc_r+0x63c>
   17324:	b25ff06f          	j	16e48 <_malloc_r+0x170>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   17328:	15400713          	li	a4,340
   1732c:	04f76263          	bltu	a4,a5,17370 <_malloc_r+0x698>
   17330:	00f4d593          	srli	a1,s1,0xf
   17334:	07858513          	addi	a0,a1,120
   17338:	00151693          	slli	a3,a0,0x1
   1733c:	07758593          	addi	a1,a1,119
   17340:	a05ff06f          	j	16d44 <_malloc_r+0x6c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   17344:	00492703          	lw	a4,4(s2)
   17348:	40265613          	srai	a2,a2,0x2
   1734c:	00100793          	li	a5,1
   17350:	00c797b3          	sll	a5,a5,a2
   17354:	00e7e7b3          	or	a5,a5,a4
   17358:	00f92223          	sw	a5,4(s2)
   1735c:	00058713          	mv	a4,a1
   17360:	e91ff06f          	j	171f0 <_malloc_r+0x518>
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE) 
      {
        set_head(top, PREV_INUSE); /* will force null return from malloc */
   17364:	00100793          	li	a5,1
   17368:	00fba223          	sw	a5,4(s7)
   1736c:	dd9ff06f          	j	17144 <_malloc_r+0x46c>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   17370:	55400713          	li	a4,1364
   17374:	0fe00693          	li	a3,254
   17378:	07f00513          	li	a0,127
   1737c:	07e00593          	li	a1,126
   17380:	9cf762e3          	bltu	a4,a5,16d44 <_malloc_r+0x6c>
   17384:	0124d593          	srli	a1,s1,0x12
   17388:	07d58513          	addi	a0,a1,125
   1738c:	00151693          	slli	a3,a0,0x1
   17390:	07c58593          	addi	a1,a1,124
   17394:	9b1ff06f          	j	16d44 <_malloc_r+0x6c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   17398:	05400613          	li	a2,84
   1739c:	04e66e63          	bltu	a2,a4,173f8 <_malloc_r+0x720>
   173a0:	00c7d613          	srli	a2,a5,0xc
   173a4:	06f60593          	addi	a1,a2,111
   173a8:	00159593          	slli	a1,a1,0x1
   173ac:	06e60613          	addi	a2,a2,110
   173b0:	e11ff06f          	j	171c0 <_malloc_r+0x4e8>

  sbrked_mem += sbrk_size;

  if (brk == old_end /* can just add bytes to current top, unless
			previous correction failed */
      && ((POINTER_UINT)old_end & (pagesz - 1)) == 0)
   173b4:	014b1793          	slli	a5,s6,0x14
   173b8:	ca0794e3          	bnez	a5,17060 <_malloc_r+0x388>
  {
    top_size = sbrk_size + old_top_size;
    set_head(top, top_size | PREV_INUSE);
   173bc:	00892783          	lw	a5,8(s2)
   173c0:	014a8a33          	add	s4,s5,s4
   173c4:	001a6a13          	ori	s4,s4,1
   173c8:	0147a223          	sw	s4,4(a5)
   173cc:	d45ff06f          	j	17110 <_malloc_r+0x438>
    /* Guarantee the next brk will be at a page boundary */
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE))
   173d0:	00100793          	li	a5,1
      {
	correction = 0;
   173d4:	00000a13          	li	s4,0
   173d8:	cedff06f          	j	170c4 <_malloc_r+0x3ec>
    set_head(top, top_size | PREV_INUSE);
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
      sbrk_base = brk;
   173dc:	8171ac23          	sw	s7,-2024(gp) # 1ece8 <__malloc_sbrk_base>
   173e0:	c99ff06f          	j	17078 <_malloc_r+0x3a0>
        SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
        SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE) 
        fREe(RCALL chunk2mem(old_top));
   173e4:	00840593          	addi	a1,s0,8
   173e8:	00098513          	mv	a0,s3
   173ec:	db1fe0ef          	jal	1619c <_free_r>
   173f0:	000c2703          	lw	a4,0(s8)
   173f4:	d1dff06f          	j	17110 <_malloc_r+0x438>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   173f8:	15400613          	li	a2,340
   173fc:	00e66c63          	bltu	a2,a4,17414 <_malloc_r+0x73c>
   17400:	00f7d613          	srli	a2,a5,0xf
   17404:	07860593          	addi	a1,a2,120
   17408:	00159593          	slli	a1,a1,0x1
   1740c:	07760613          	addi	a2,a2,119
   17410:	db1ff06f          	j	171c0 <_malloc_r+0x4e8>
   17414:	55400513          	li	a0,1364
   17418:	0fe00593          	li	a1,254
   1741c:	07e00613          	li	a2,126
   17420:	dae560e3          	bltu	a0,a4,171c0 <_malloc_r+0x4e8>
   17424:	0127d613          	srli	a2,a5,0x12
   17428:	07d60593          	addi	a1,a2,125
   1742c:	00159593          	slli	a1,a1,0x1
   17430:	07c60613          	addi	a2,a2,124
   17434:	d8dff06f          	j	171c0 <_malloc_r+0x4e8>
   17438:	00492783          	lw	a5,4(s2)
   1743c:	ec1ff06f          	j	172fc <_malloc_r+0x624>
   17440:	0034d693          	srli	a3,s1,0x3
   17444:	00168793          	addi	a5,a3,1
   17448:	00179793          	slli	a5,a5,0x1
   1744c:	a95ff06f          	j	16ee0 <_malloc_r+0x208>

00017450 <memchr>:
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   17450:	00357793          	andi	a5,a0,3
	_CONST _PTR src_void _AND
	int c _AND
	size_t length)
{
  _CONST unsigned char *src = (_CONST unsigned char *) src_void;
  unsigned char d = c;
   17454:	0ff5f693          	andi	a3,a1,255
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   17458:	0c078063          	beqz	a5,17518 <memchr+0xc8>
    {
      if (!length--)
   1745c:	fff60793          	addi	a5,a2,-1
   17460:	06060063          	beqz	a2,174c0 <memchr+0x70>
        return NULL;
      if (*src == d)
   17464:	00054703          	lbu	a4,0(a0)
   17468:	00d71c63          	bne	a4,a3,17480 <memchr+0x30>
   1746c:	0b40006f          	j	17520 <memchr+0xd0>
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
    {
      if (!length--)
   17470:	04078863          	beqz	a5,174c0 <memchr+0x70>
        return NULL;
      if (*src == d)
   17474:	00054703          	lbu	a4,0(a0)
   17478:	fff78793          	addi	a5,a5,-1
   1747c:	04d70463          	beq	a4,a3,174c4 <memchr+0x74>
        return (void *) src;
      src++;
   17480:	00150513          	addi	a0,a0,1
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   17484:	00357713          	andi	a4,a0,3
   17488:	fe0714e3          	bnez	a4,17470 <memchr+0x20>
      if (*src == d)
        return (void *) src;
      src++;
    }

  if (!TOO_SMALL (length))
   1748c:	00300813          	li	a6,3
   17490:	02f86c63          	bltu	a6,a5,174c8 <memchr+0x78>
      src = (unsigned char *) asrc;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
   17494:	02078663          	beqz	a5,174c0 <memchr+0x70>
    {
      if (*src == d)
   17498:	00054703          	lbu	a4,0(a0)
   1749c:	02d70463          	beq	a4,a3,174c4 <memchr+0x74>
   174a0:	00150713          	addi	a4,a0,1
   174a4:	00f507b3          	add	a5,a0,a5
   174a8:	0100006f          	j	174b8 <memchr+0x68>
   174ac:	00170713          	addi	a4,a4,1
   174b0:	fff74603          	lbu	a2,-1(a4)
   174b4:	00d60863          	beq	a2,a3,174c4 <memchr+0x74>
        return (void *) src;
      src++;
   174b8:	00070513          	mv	a0,a4
      src = (unsigned char *) asrc;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
   174bc:	fee798e3          	bne	a5,a4,174ac <memchr+0x5c>
  unsigned int i;

  while (UNALIGNED (src))
    {
      if (!length--)
        return NULL;
   174c0:	00000513          	li	a0,0
        return (void *) src;
      src++;
    }

  return NULL;
}
   174c4:	00008067          	ret
   174c8:	0ff5f593          	andi	a1,a1,255
         contain the search character, which is detected by XORing
         the word-sized segment with a word-sized block of the search
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
      mask = d << 8 | d;
   174cc:	00859713          	slli	a4,a1,0x8
   174d0:	00b765b3          	or	a1,a4,a1
      mask = mask << 16 | mask;
   174d4:	01059713          	slli	a4,a1,0x10
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
        {
          if (DETECTCHAR (*asrc, mask))
   174d8:	feff02b7          	lui	t0,0xfeff0
   174dc:	808088b7          	lui	a7,0x80808
         the word-sized segment with a word-sized block of the search
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
      mask = d << 8 | d;
      mask = mask << 16 | mask;
   174e0:	00e5e5b3          	or	a1,a1,a4
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
        {
          if (DETECTCHAR (*asrc, mask))
   174e4:	eff28293          	addi	t0,t0,-257 # fefefeff <_gp+0xfefd0a2f>
   174e8:	08088893          	addi	a7,a7,128 # 80808080 <_gp+0x807e8bb0>
   174ec:	00052703          	lw	a4,0(a0)
   174f0:	00e5c733          	xor	a4,a1,a4
   174f4:	00570633          	add	a2,a4,t0
   174f8:	fff74713          	not	a4,a4
   174fc:	00e67733          	and	a4,a2,a4
   17500:	01177733          	and	a4,a4,a7
   17504:	f8071ae3          	bnez	a4,17498 <memchr+0x48>
            break;
          length -= LBLOCKSIZE;
   17508:	ffc78793          	addi	a5,a5,-4
          asrc++;
   1750c:	00450513          	addi	a0,a0,4
      mask = d << 8 | d;
      mask = mask << 16 | mask;
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
   17510:	fcf86ee3          	bltu	a6,a5,174ec <memchr+0x9c>
   17514:	f81ff06f          	j	17494 <memchr+0x44>
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   17518:	00060793          	mv	a5,a2
   1751c:	f71ff06f          	j	1748c <memchr+0x3c>
   17520:	00008067          	ret

00017524 <memmove>:
  char *dst = dst_void;
  _CONST char *src = src_void;
  long *aligned_dst;
  _CONST long *aligned_src;

  if (src < dst && dst < src + length)
   17524:	02a5f863          	bleu	a0,a1,17554 <memmove+0x30>
   17528:	00c58733          	add	a4,a1,a2
   1752c:	02e57463          	bleu	a4,a0,17554 <memmove+0x30>
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
      dst += length;
   17530:	00c507b3          	add	a5,a0,a2
   17534:	40c785b3          	sub	a1,a5,a2
      while (length--)
   17538:	0e060263          	beqz	a2,1761c <memmove+0xf8>
	{
	  *--dst = *--src;
   1753c:	fff70713          	addi	a4,a4,-1
   17540:	00074683          	lbu	a3,0(a4)
   17544:	fff78793          	addi	a5,a5,-1
   17548:	00d78023          	sb	a3,0(a5)
  if (src < dst && dst < src + length)
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
      dst += length;
      while (length--)
   1754c:	fef598e3          	bne	a1,a5,1753c <memmove+0x18>
   17550:	00008067          	ret
  else
    {
      /* Use optimizing algorithm for a non-destructive copy to closely 
         match memcpy. If the size is small or either SRC or DST is unaligned,
         then punt into the byte copy loop.  This should be rare.  */
      if (!TOO_SMALL(length) && !UNALIGNED (src, dst))
   17554:	00f00893          	li	a7,15
   17558:	0cc8f463          	bleu	a2,a7,17620 <memmove+0xfc>
   1755c:	00a5e7b3          	or	a5,a1,a0
   17560:	0037f793          	andi	a5,a5,3
   17564:	0c079463          	bnez	a5,1762c <memmove+0x108>
   17568:	00058713          	mv	a4,a1
   1756c:	00050793          	mv	a5,a0
   17570:	00060693          	mv	a3,a2
          aligned_src = (long*)src;

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
            {
              *aligned_dst++ = *aligned_src++;
   17574:	00072803          	lw	a6,0(a4)
   17578:	01078793          	addi	a5,a5,16
   1757c:	01070713          	addi	a4,a4,16
   17580:	ff07a823          	sw	a6,-16(a5)
              *aligned_dst++ = *aligned_src++;
   17584:	ff472803          	lw	a6,-12(a4)
              *aligned_dst++ = *aligned_src++;
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
   17588:	ff068693          	addi	a3,a3,-16

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
            {
              *aligned_dst++ = *aligned_src++;
              *aligned_dst++ = *aligned_src++;
   1758c:	ff07aa23          	sw	a6,-12(a5)
              *aligned_dst++ = *aligned_src++;
   17590:	ff872803          	lw	a6,-8(a4)
   17594:	ff07ac23          	sw	a6,-8(a5)
              *aligned_dst++ = *aligned_src++;
   17598:	ffc72803          	lw	a6,-4(a4)
   1759c:	ff07ae23          	sw	a6,-4(a5)
        {
          aligned_dst = (long*)dst;
          aligned_src = (long*)src;

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
   175a0:	fcd8eae3          	bltu	a7,a3,17574 <memmove+0x50>
   175a4:	ff060713          	addi	a4,a2,-16
   175a8:	ff077713          	andi	a4,a4,-16
   175ac:	01070713          	addi	a4,a4,16
   175b0:	00f67313          	andi	t1,a2,15
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   175b4:	00300293          	li	t0,3
   175b8:	00e507b3          	add	a5,a0,a4
   175bc:	00e585b3          	add	a1,a1,a4
   175c0:	0662fc63          	bleu	t1,t0,17638 <memmove+0x114>
   175c4:	00058813          	mv	a6,a1
   175c8:	00078693          	mv	a3,a5
   175cc:	00030713          	mv	a4,t1
            {
              *aligned_dst++ = *aligned_src++;
   175d0:	00480813          	addi	a6,a6,4
   175d4:	ffc82883          	lw	a7,-4(a6)
   175d8:	00468693          	addi	a3,a3,4
              length -= LITTLEBLOCKSIZE;
   175dc:	ffc70713          	addi	a4,a4,-4
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
            {
              *aligned_dst++ = *aligned_src++;
   175e0:	ff16ae23          	sw	a7,-4(a3)
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   175e4:	fee2e6e3          	bltu	t0,a4,175d0 <memmove+0xac>
   175e8:	ffc30713          	addi	a4,t1,-4
   175ec:	ffc77713          	andi	a4,a4,-4
   175f0:	00470713          	addi	a4,a4,4
   175f4:	00367613          	andi	a2,a2,3
   175f8:	00e787b3          	add	a5,a5,a4
   175fc:	00e585b3          	add	a1,a1,a4
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   17600:	02060a63          	beqz	a2,17634 <memmove+0x110>
   17604:	00c78633          	add	a2,a5,a2
        {
          *dst++ = *src++;
   17608:	00158593          	addi	a1,a1,1
   1760c:	fff5c703          	lbu	a4,-1(a1)
   17610:	00178793          	addi	a5,a5,1
   17614:	fee78fa3          	sb	a4,-1(a5)
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   17618:	fec798e3          	bne	a5,a2,17608 <memmove+0xe4>
        }
    }

  return dst_void;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   1761c:	00008067          	ret
   17620:	00050793          	mv	a5,a0
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   17624:	fe0610e3          	bnez	a2,17604 <memmove+0xe0>
   17628:	00c0006f          	j	17634 <memmove+0x110>
   1762c:	00050793          	mv	a5,a0
   17630:	fd5ff06f          	j	17604 <memmove+0xe0>
   17634:	00008067          	ret
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   17638:	00030613          	mv	a2,t1
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   1763c:	fc0614e3          	bnez	a2,17604 <memmove+0xe0>
   17640:	ff5ff06f          	j	17634 <memmove+0x110>

00017644 <memset>:
   17644:	00f00813          	li	a6,15
   17648:	00050713          	mv	a4,a0
   1764c:	02c87e63          	bleu	a2,a6,17688 <memset+0x44>
   17650:	00f77793          	andi	a5,a4,15
   17654:	0a079063          	bnez	a5,176f4 <memset+0xb0>
   17658:	08059263          	bnez	a1,176dc <memset+0x98>
   1765c:	ff067693          	andi	a3,a2,-16
   17660:	00f67613          	andi	a2,a2,15
   17664:	00e686b3          	add	a3,a3,a4
   17668:	00b72023          	sw	a1,0(a4)
   1766c:	00b72223          	sw	a1,4(a4)
   17670:	00b72423          	sw	a1,8(a4)
   17674:	00b72623          	sw	a1,12(a4)
   17678:	01070713          	addi	a4,a4,16
   1767c:	fed766e3          	bltu	a4,a3,17668 <memset+0x24>
   17680:	00061463          	bnez	a2,17688 <memset+0x44>
   17684:	00008067          	ret
   17688:	40c806b3          	sub	a3,a6,a2
   1768c:	00269693          	slli	a3,a3,0x2
   17690:	00000297          	auipc	t0,0x0
   17694:	005686b3          	add	a3,a3,t0
   17698:	00c68067          	jr	a3,12
   1769c:	00b70723          	sb	a1,14(a4)
   176a0:	00b706a3          	sb	a1,13(a4)
   176a4:	00b70623          	sb	a1,12(a4)
   176a8:	00b705a3          	sb	a1,11(a4)
   176ac:	00b70523          	sb	a1,10(a4)
   176b0:	00b704a3          	sb	a1,9(a4)
   176b4:	00b70423          	sb	a1,8(a4)
   176b8:	00b703a3          	sb	a1,7(a4)
   176bc:	00b70323          	sb	a1,6(a4)
   176c0:	00b702a3          	sb	a1,5(a4)
   176c4:	00b70223          	sb	a1,4(a4)
   176c8:	00b701a3          	sb	a1,3(a4)
   176cc:	00b70123          	sb	a1,2(a4)
   176d0:	00b700a3          	sb	a1,1(a4)
   176d4:	00b70023          	sb	a1,0(a4)
   176d8:	00008067          	ret
   176dc:	0ff5f593          	andi	a1,a1,255
   176e0:	00859693          	slli	a3,a1,0x8
   176e4:	00d5e5b3          	or	a1,a1,a3
   176e8:	01059693          	slli	a3,a1,0x10
   176ec:	00d5e5b3          	or	a1,a1,a3
   176f0:	f6dff06f          	j	1765c <memset+0x18>
   176f4:	00279693          	slli	a3,a5,0x2
   176f8:	00000297          	auipc	t0,0x0
   176fc:	005686b3          	add	a3,a3,t0
   17700:	00008293          	mv	t0,ra
   17704:	fa0680e7          	jalr	a3,-96
   17708:	00028093          	mv	ra,t0
   1770c:	ff078793          	addi	a5,a5,-16
   17710:	40f70733          	sub	a4,a4,a5
   17714:	00f60633          	add	a2,a2,a5
   17718:	f6c878e3          	bleu	a2,a6,17688 <memset+0x44>
   1771c:	f3dff06f          	j	17658 <memset+0x14>

00017720 <__malloc_lock>:
   17720:	00008067          	ret

00017724 <__malloc_unlock>:
}

void
__malloc_unlock (ptr)
     struct _reent *ptr;
{
   17724:	00008067          	ret

00017728 <_Balloc>:
{
  int x;
  _Bigint *rv ;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_FREELIST(ptr) == NULL)
   17728:	04c52783          	lw	a5,76(a0)
#define _Kmax 15
*/

_Bigint *
_DEFUN (Balloc, (ptr, k), struct _reent *ptr _AND int k)
{
   1772c:	ff010113          	addi	sp,sp,-16
   17730:	00812423          	sw	s0,8(sp)
   17734:	00912223          	sw	s1,4(sp)
   17738:	00112623          	sw	ra,12(sp)
   1773c:	01212023          	sw	s2,0(sp)
   17740:	00050413          	mv	s0,a0
   17744:	00058493          	mv	s1,a1
  int x;
  _Bigint *rv ;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_FREELIST(ptr) == NULL)
   17748:	02078e63          	beqz	a5,17784 <_Balloc+0x5c>
	{
	  return NULL;
	}
    }

  if ((rv = _REENT_MP_FREELIST(ptr)[k]) != 0)
   1774c:	00249713          	slli	a4,s1,0x2
   17750:	00e787b3          	add	a5,a5,a4
   17754:	0007a503          	lw	a0,0(a5)
   17758:	04050663          	beqz	a0,177a4 <_Balloc+0x7c>
    {
      _REENT_MP_FREELIST(ptr)[k] = rv->_next;
   1775c:	00052703          	lw	a4,0(a0)
   17760:	00e7a023          	sw	a4,0(a5)
				  (x-1) * sizeof(rv->_x));
      if (rv == NULL) return NULL;
      rv->_k = k;
      rv->_maxwds = x;
    }
  rv->_sign = rv->_wds = 0;
   17764:	00052823          	sw	zero,16(a0)
   17768:	00052623          	sw	zero,12(a0)
  return rv;
}
   1776c:	00c12083          	lw	ra,12(sp)
   17770:	00812403          	lw	s0,8(sp)
   17774:	00412483          	lw	s1,4(sp)
   17778:	00012903          	lw	s2,0(sp)
   1777c:	01010113          	addi	sp,sp,16
   17780:	00008067          	ret

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_FREELIST(ptr) == NULL)
    {
      /* Allocate a list of pointers to the mprec objects */
      _REENT_MP_FREELIST(ptr) = (struct _Bigint **) _calloc_r (ptr, 
   17784:	02100613          	li	a2,33
   17788:	00400593          	li	a1,4
   1778c:	209020ef          	jal	1a194 <_calloc_r>
   17790:	00050793          	mv	a5,a0
   17794:	04a42623          	sw	a0,76(s0)
						      sizeof (struct _Bigint *),
						      _Kmax + 1);
      if (_REENT_MP_FREELIST(ptr) == NULL)
   17798:	fa051ae3          	bnez	a0,1774c <_Balloc+0x24>
	{
	  return NULL;
   1779c:	00000513          	li	a0,0
   177a0:	fcdff06f          	j	1776c <_Balloc+0x44>
    {
      _REENT_MP_FREELIST(ptr)[k] = rv->_next;
    }
  else
    {
      x = 1 << k;
   177a4:	00100593          	li	a1,1
   177a8:	00959933          	sll	s2,a1,s1
      /* Allocate an mprec Bigint and stick in in the freelist */
      rv = (_Bigint *) _calloc_r (ptr,
   177ac:	00590613          	addi	a2,s2,5
   177b0:	00261613          	slli	a2,a2,0x2
   177b4:	00040513          	mv	a0,s0
   177b8:	1dd020ef          	jal	1a194 <_calloc_r>
				  1,
				  sizeof (_Bigint) +
				  (x-1) * sizeof(rv->_x));
      if (rv == NULL) return NULL;
   177bc:	fe0500e3          	beqz	a0,1779c <_Balloc+0x74>
      rv->_k = k;
   177c0:	00952223          	sw	s1,4(a0)
      rv->_maxwds = x;
   177c4:	01252423          	sw	s2,8(a0)
   177c8:	f9dff06f          	j	17764 <_Balloc+0x3c>

000177cc <_Bfree>:

void
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
   177cc:	02058063          	beqz	a1,177ec <_Bfree+0x20>
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   177d0:	0045a783          	lw	a5,4(a1)
   177d4:	04c52703          	lw	a4,76(a0)
   177d8:	00279793          	slli	a5,a5,0x2
   177dc:	00f707b3          	add	a5,a4,a5
   177e0:	0007a703          	lw	a4,0(a5)
   177e4:	00e5a023          	sw	a4,0(a1)
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   177e8:	00b7a023          	sw	a1,0(a5)
   177ec:	00008067          	ret

000177f0 <__multadd>:
_DEFUN (multadd, (ptr, b, m, a),
	struct _reent *ptr _AND
	_Bigint * b _AND
	int m _AND
	int a)
{
   177f0:	fd010113          	addi	sp,sp,-48
  i = 0;
  do
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
   177f4:	00010837          	lui	a6,0x10
_DEFUN (multadd, (ptr, b, m, a),
	struct _reent *ptr _AND
	_Bigint * b _AND
	int m _AND
	int a)
{
   177f8:	02812423          	sw	s0,40(sp)
   177fc:	02912223          	sw	s1,36(sp)
   17800:	03212023          	sw	s2,32(sp)
   17804:	00058493          	mv	s1,a1
#ifdef Pack_32
  __ULong xi, z;
#endif
  _Bigint *b1;

  wds = b->_wds;
   17808:	0105a403          	lw	s0,16(a1)
_DEFUN (multadd, (ptr, b, m, a),
	struct _reent *ptr _AND
	_Bigint * b _AND
	int m _AND
	int a)
{
   1780c:	00050913          	mv	s2,a0
   17810:	02112623          	sw	ra,44(sp)
   17814:	01312e23          	sw	s3,28(sp)
  __ULong xi, z;
#endif
  _Bigint *b1;

  wds = b->_wds;
  x = b->_x;
   17818:	01458593          	addi	a1,a1,20
  i = 0;
   1781c:	00000513          	li	a0,0
  do
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
   17820:	fff80813          	addi	a6,a6,-1 # ffff <_reset+0xfdff>
  x = b->_x;
  i = 0;
  do
    {
#ifdef Pack_32
      xi = *x;
   17824:	0005a783          	lw	a5,0(a1)
      y = *x * m + a;
      a = (int) (y >> 16);
      *x++ = y & 0xffff;
#endif
    }
  while (++i < wds);
   17828:	00150513          	addi	a0,a0,1
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
      z = (xi >> 16) * m + (y >> 16);
      a = (int) (z >> 16);
      *x++ = (z << 16) + (y & 0xffff);
   1782c:	00458593          	addi	a1,a1,4
  i = 0;
  do
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
   17830:	0107f733          	and	a4,a5,a6
   17834:	02c70733          	mul	a4,a4,a2
      z = (xi >> 16) * m + (y >> 16);
   17838:	0107d793          	srli	a5,a5,0x10
   1783c:	02c787b3          	mul	a5,a5,a2
  i = 0;
  do
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
   17840:	00d70733          	add	a4,a4,a3
      z = (xi >> 16) * m + (y >> 16);
   17844:	01075693          	srli	a3,a4,0x10
      a = (int) (z >> 16);
      *x++ = (z << 16) + (y & 0xffff);
   17848:	01077733          	and	a4,a4,a6
  do
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
      z = (xi >> 16) * m + (y >> 16);
   1784c:	00d786b3          	add	a3,a5,a3
      a = (int) (z >> 16);
      *x++ = (z << 16) + (y & 0xffff);
   17850:	01069793          	slli	a5,a3,0x10
   17854:	00e78733          	add	a4,a5,a4
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
      z = (xi >> 16) * m + (y >> 16);
      a = (int) (z >> 16);
   17858:	0106d693          	srli	a3,a3,0x10
      *x++ = (z << 16) + (y & 0xffff);
   1785c:	fee5ae23          	sw	a4,-4(a1)
      y = *x * m + a;
      a = (int) (y >> 16);
      *x++ = y & 0xffff;
#endif
    }
  while (++i < wds);
   17860:	fc8542e3          	blt	a0,s0,17824 <__multadd+0x34>
  if (a)
   17864:	02068263          	beqz	a3,17888 <__multadd+0x98>
    {
      if (wds >= b->_maxwds)
   17868:	0084a783          	lw	a5,8(s1)
   1786c:	02f45e63          	ble	a5,s0,178a8 <__multadd+0xb8>
	  b1 = Balloc (ptr, b->_k + 1);
	  Bcopy (b1, b);
	  Bfree (ptr, b);
	  b = b1;
	}
      b->_x[wds++] = a;
   17870:	00440793          	addi	a5,s0,4
   17874:	00279793          	slli	a5,a5,0x2
   17878:	00f487b3          	add	a5,s1,a5
      b->_wds = wds;
   1787c:	00140413          	addi	s0,s0,1
	  b1 = Balloc (ptr, b->_k + 1);
	  Bcopy (b1, b);
	  Bfree (ptr, b);
	  b = b1;
	}
      b->_x[wds++] = a;
   17880:	00d7a223          	sw	a3,4(a5)
      b->_wds = wds;
   17884:	0084a823          	sw	s0,16(s1)
    }
  return b;
}
   17888:	02c12083          	lw	ra,44(sp)
   1788c:	00048513          	mv	a0,s1
   17890:	02812403          	lw	s0,40(sp)
   17894:	02412483          	lw	s1,36(sp)
   17898:	02012903          	lw	s2,32(sp)
   1789c:	01c12983          	lw	s3,28(sp)
   178a0:	03010113          	addi	sp,sp,48
   178a4:	00008067          	ret
  while (++i < wds);
  if (a)
    {
      if (wds >= b->_maxwds)
	{
	  b1 = Balloc (ptr, b->_k + 1);
   178a8:	0044a583          	lw	a1,4(s1)
   178ac:	00090513          	mv	a0,s2
   178b0:	00d12623          	sw	a3,12(sp)
   178b4:	00158593          	addi	a1,a1,1
   178b8:	e71ff0ef          	jal	17728 <_Balloc>
	  Bcopy (b1, b);
   178bc:	0104a603          	lw	a2,16(s1)
  while (++i < wds);
  if (a)
    {
      if (wds >= b->_maxwds)
	{
	  b1 = Balloc (ptr, b->_k + 1);
   178c0:	00050993          	mv	s3,a0
	  Bcopy (b1, b);
   178c4:	00c48593          	addi	a1,s1,12
   178c8:	00260613          	addi	a2,a2,2
   178cc:	00c50513          	addi	a0,a0,12
   178d0:	00261613          	slli	a2,a2,0x2
   178d4:	f00fa0ef          	jal	11fd4 <memcpy>
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   178d8:	0044a783          	lw	a5,4(s1)
   178dc:	04c92703          	lw	a4,76(s2)
      if (wds >= b->_maxwds)
	{
	  b1 = Balloc (ptr, b->_k + 1);
	  Bcopy (b1, b);
	  Bfree (ptr, b);
	  b = b1;
   178e0:	00c12683          	lw	a3,12(sp)
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   178e4:	00279793          	slli	a5,a5,0x2
   178e8:	00f707b3          	add	a5,a4,a5
   178ec:	0007a703          	lw	a4,0(a5)
   178f0:	00e4a023          	sw	a4,0(s1)
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   178f4:	0097a023          	sw	s1,0(a5)
      if (wds >= b->_maxwds)
	{
	  b1 = Balloc (ptr, b->_k + 1);
	  Bcopy (b1, b);
	  Bfree (ptr, b);
	  b = b1;
   178f8:	00098493          	mv	s1,s3
   178fc:	f75ff06f          	j	17870 <__multadd+0x80>

00017900 <__s2b>:
	struct _reent * ptr _AND
	_CONST char *s _AND
	int nd0 _AND
	int nd _AND
	__ULong y9)
{
   17900:	fe010113          	addi	sp,sp,-32
  _Bigint *b;
  int i, k;
  __Long x, y;

  x = (nd + 8) / 9;
   17904:	00868793          	addi	a5,a3,8
	struct _reent * ptr _AND
	_CONST char *s _AND
	int nd0 _AND
	int nd _AND
	__ULong y9)
{
   17908:	01312623          	sw	s3,12(sp)
   1790c:	00068993          	mv	s3,a3
  _Bigint *b;
  int i, k;
  __Long x, y;

  x = (nd + 8) / 9;
   17910:	00900693          	li	a3,9
   17914:	02d7c6b3          	div	a3,a5,a3
  for (k = 0, y = 1; x > y; y <<= 1, k++);
   17918:	00100793          	li	a5,1
	struct _reent * ptr _AND
	_CONST char *s _AND
	int nd0 _AND
	int nd _AND
	__ULong y9)
{
   1791c:	00812c23          	sw	s0,24(sp)
   17920:	00912a23          	sw	s1,20(sp)
   17924:	01212823          	sw	s2,16(sp)
   17928:	01412423          	sw	s4,8(sp)
   1792c:	00058413          	mv	s0,a1
   17930:	00112e23          	sw	ra,28(sp)
   17934:	01512223          	sw	s5,4(sp)
   17938:	00050913          	mv	s2,a0
   1793c:	00060a13          	mv	s4,a2
   17940:	00070493          	mv	s1,a4
  _Bigint *b;
  int i, k;
  __Long x, y;

  x = (nd + 8) / 9;
  for (k = 0, y = 1; x > y; y <<= 1, k++);
   17944:	00000593          	li	a1,0
   17948:	00d7d863          	ble	a3,a5,17958 <__s2b+0x58>
   1794c:	00179793          	slli	a5,a5,0x1
   17950:	00158593          	addi	a1,a1,1
   17954:	fed7cce3          	blt	a5,a3,1794c <__s2b+0x4c>
#ifdef Pack_32
  b = Balloc (ptr, k);
   17958:	00090513          	mv	a0,s2
   1795c:	dcdff0ef          	jal	17728 <_Balloc>
  b->_x[0] = y9;
  b->_wds = 1;
   17960:	00100713          	li	a4,1
  b->_x[0] = y9 & 0xffff;
  b->_wds = (b->_x[1] = y9 >> 16) ? 2 : 1;
#endif

  i = 9;
  if (9 < nd0)
   17964:	00900793          	li	a5,9

  x = (nd + 8) / 9;
  for (k = 0, y = 1; x > y; y <<= 1, k++);
#ifdef Pack_32
  b = Balloc (ptr, k);
  b->_x[0] = y9;
   17968:	00952a23          	sw	s1,20(a0)
  b->_wds = 1;
   1796c:	00e52823          	sw	a4,16(a0)
  b->_x[0] = y9 & 0xffff;
  b->_wds = (b->_x[1] = y9 >> 16) ? 2 : 1;
#endif

  i = 9;
  if (9 < nd0)
   17970:	0947d463          	ble	s4,a5,179f8 <__s2b+0xf8>
    {
      s += 9;
   17974:	00f40ab3          	add	s5,s0,a5
   17978:	000a8493          	mv	s1,s5
   1797c:	01440433          	add	s0,s0,s4
      do
	b = multadd (ptr, b, 10, *s++ - '0');
   17980:	00148493          	addi	s1,s1,1
   17984:	fff4c683          	lbu	a3,-1(s1)
   17988:	00050593          	mv	a1,a0
   1798c:	00a00613          	li	a2,10
   17990:	fd068693          	addi	a3,a3,-48
   17994:	00090513          	mv	a0,s2
   17998:	e59ff0ef          	jal	177f0 <__multadd>
      while (++i < nd0);
   1799c:	fe8492e3          	bne	s1,s0,17980 <__s2b+0x80>
   179a0:	014a8433          	add	s0,s5,s4
      s++;
   179a4:	ff840413          	addi	s0,s0,-8
    }
  else
    s += 10;
  for (; i < nd; i++)
   179a8:	033a5663          	ble	s3,s4,179d4 <__s2b+0xd4>
   179ac:	414984b3          	sub	s1,s3,s4
   179b0:	009404b3          	add	s1,s0,s1
    b = multadd (ptr, b, 10, *s++ - '0');
   179b4:	00140413          	addi	s0,s0,1
   179b8:	fff44683          	lbu	a3,-1(s0)
   179bc:	00050593          	mv	a1,a0
   179c0:	00a00613          	li	a2,10
   179c4:	fd068693          	addi	a3,a3,-48
   179c8:	00090513          	mv	a0,s2
   179cc:	e25ff0ef          	jal	177f0 <__multadd>
      while (++i < nd0);
      s++;
    }
  else
    s += 10;
  for (; i < nd; i++)
   179d0:	fe8492e3          	bne	s1,s0,179b4 <__s2b+0xb4>
    b = multadd (ptr, b, 10, *s++ - '0');
  return b;
}
   179d4:	01c12083          	lw	ra,28(sp)
   179d8:	01812403          	lw	s0,24(sp)
   179dc:	01412483          	lw	s1,20(sp)
   179e0:	01012903          	lw	s2,16(sp)
   179e4:	00c12983          	lw	s3,12(sp)
   179e8:	00812a03          	lw	s4,8(sp)
   179ec:	00412a83          	lw	s5,4(sp)
   179f0:	02010113          	addi	sp,sp,32
   179f4:	00008067          	ret
	b = multadd (ptr, b, 10, *s++ - '0');
      while (++i < nd0);
      s++;
    }
  else
    s += 10;
   179f8:	00a40413          	addi	s0,s0,10
  b = Balloc (ptr, k + 1);
  b->_x[0] = y9 & 0xffff;
  b->_wds = (b->_x[1] = y9 >> 16) ? 2 : 1;
#endif

  i = 9;
   179fc:	00078a13          	mv	s4,a5
   17a00:	fa9ff06f          	j	179a8 <__s2b+0xa8>

00017a04 <__hi0bits>:
_DEFUN (hi0bits,
	(x), register __ULong x)
{
  register int k = 0;

  if (!(x & 0xffff0000))
   17a04:	ffff06b7          	lui	a3,0xffff0
   17a08:	00d576b3          	and	a3,a0,a3
}

int
_DEFUN (hi0bits,
	(x), register __ULong x)
{
   17a0c:	00050793          	mv	a5,a0
  register int k = 0;
   17a10:	00000713          	li	a4,0

  if (!(x & 0xffff0000))
   17a14:	00069663          	bnez	a3,17a20 <__hi0bits+0x1c>
    {
      k = 16;
      x <<= 16;
   17a18:	01051793          	slli	a5,a0,0x10
{
  register int k = 0;

  if (!(x & 0xffff0000))
    {
      k = 16;
   17a1c:	01000713          	li	a4,16
      x <<= 16;
    }
  if (!(x & 0xff000000))
   17a20:	ff0006b7          	lui	a3,0xff000
   17a24:	00d7f6b3          	and	a3,a5,a3
   17a28:	00069663          	bnez	a3,17a34 <__hi0bits+0x30>
    {
      k += 8;
   17a2c:	00870713          	addi	a4,a4,8
      x <<= 8;
   17a30:	00879793          	slli	a5,a5,0x8
    }
  if (!(x & 0xf0000000))
   17a34:	f00006b7          	lui	a3,0xf0000
   17a38:	00d7f6b3          	and	a3,a5,a3
   17a3c:	00069663          	bnez	a3,17a48 <__hi0bits+0x44>
    {
      k += 4;
   17a40:	00470713          	addi	a4,a4,4
      x <<= 4;
   17a44:	00479793          	slli	a5,a5,0x4
    }
  if (!(x & 0xc0000000))
   17a48:	c00006b7          	lui	a3,0xc0000
   17a4c:	00d7f6b3          	and	a3,a5,a3
   17a50:	00069663          	bnez	a3,17a5c <__hi0bits+0x58>
    {
      k += 2;
   17a54:	00270713          	addi	a4,a4,2
      x <<= 2;
   17a58:	00279793          	slli	a5,a5,0x2
    }
  if (!(x & 0x80000000))
   17a5c:	0007ce63          	bltz	a5,17a78 <__hi0bits+0x74>
    {
      k++;
      if (!(x & 0x40000000))
   17a60:	00179693          	slli	a3,a5,0x1
	return 32;
   17a64:	02000513          	li	a0,32
      x <<= 2;
    }
  if (!(x & 0x80000000))
    {
      k++;
      if (!(x & 0x40000000))
   17a68:	0006c463          	bltz	a3,17a70 <__hi0bits+0x6c>
	return 32;
    }
  return k;
}
   17a6c:	00008067          	ret
      k += 2;
      x <<= 2;
    }
  if (!(x & 0x80000000))
    {
      k++;
   17a70:	00170513          	addi	a0,a4,1
   17a74:	00008067          	ret
   17a78:	00070513          	mv	a0,a4
      if (!(x & 0x40000000))
	return 32;
    }
  return k;
}
   17a7c:	00008067          	ret

00017a80 <__lo0bits>:

int
_DEFUN (lo0bits, (y), __ULong *y)
{
  register int k;
  register __ULong x = *y;
   17a80:	00052783          	lw	a5,0(a0)
  return k;
}

int
_DEFUN (lo0bits, (y), __ULong *y)
{
   17a84:	00050693          	mv	a3,a0
  register int k;
  register __ULong x = *y;

  if (x & 7)
   17a88:	0077f713          	andi	a4,a5,7
   17a8c:	02070463          	beqz	a4,17ab4 <__lo0bits+0x34>
    {
      if (x & 1)
   17a90:	0017f713          	andi	a4,a5,1
	return 0;
   17a94:	00000513          	li	a0,0
  register int k;
  register __ULong x = *y;

  if (x & 7)
    {
      if (x & 1)
   17a98:	08071263          	bnez	a4,17b1c <__lo0bits+0x9c>
	return 0;
      if (x & 2)
   17a9c:	0027f713          	andi	a4,a5,2
   17aa0:	08071063          	bnez	a4,17b20 <__lo0bits+0xa0>
	{
	  *y = x >> 1;
	  return 1;
	}
      *y = x >> 2;
   17aa4:	0027d793          	srli	a5,a5,0x2
   17aa8:	00f6a023          	sw	a5,0(a3) # c0000000 <_gp+0xbffe0b30>
      return 2;
   17aac:	00200513          	li	a0,2
   17ab0:	00008067          	ret
    }
  k = 0;
  if (!(x & 0xffff))
   17ab4:	01079613          	slli	a2,a5,0x10
   17ab8:	01065613          	srli	a2,a2,0x10
	  return 1;
	}
      *y = x >> 2;
      return 2;
    }
  k = 0;
   17abc:	00000713          	li	a4,0
  if (!(x & 0xffff))
   17ac0:	00061663          	bnez	a2,17acc <__lo0bits+0x4c>
    {
      k = 16;
      x >>= 16;
   17ac4:	0107d793          	srli	a5,a5,0x10
      return 2;
    }
  k = 0;
  if (!(x & 0xffff))
    {
      k = 16;
   17ac8:	01000713          	li	a4,16
      x >>= 16;
    }
  if (!(x & 0xff))
   17acc:	0ff7f613          	andi	a2,a5,255
   17ad0:	00061663          	bnez	a2,17adc <__lo0bits+0x5c>
    {
      k += 8;
   17ad4:	00870713          	addi	a4,a4,8
      x >>= 8;
   17ad8:	0087d793          	srli	a5,a5,0x8
    }
  if (!(x & 0xf))
   17adc:	00f7f613          	andi	a2,a5,15
   17ae0:	00061663          	bnez	a2,17aec <__lo0bits+0x6c>
    {
      k += 4;
   17ae4:	00470713          	addi	a4,a4,4
      x >>= 4;
   17ae8:	0047d793          	srli	a5,a5,0x4
    }
  if (!(x & 0x3))
   17aec:	0037f613          	andi	a2,a5,3
   17af0:	00061663          	bnez	a2,17afc <__lo0bits+0x7c>
    {
      k += 2;
   17af4:	00270713          	addi	a4,a4,2
      x >>= 2;
   17af8:	0027d793          	srli	a5,a5,0x2
    }
  if (!(x & 1))
   17afc:	0017f613          	andi	a2,a5,1
   17b00:	00061a63          	bnez	a2,17b14 <__lo0bits+0x94>
    {
      k++;
      x >>= 1;
   17b04:	0017d793          	srli	a5,a5,0x1
      if (!x & 1)
	return 32;
   17b08:	02000513          	li	a0,32
    }
  if (!(x & 1))
    {
      k++;
      x >>= 1;
      if (!x & 1)
   17b0c:	00078863          	beqz	a5,17b1c <__lo0bits+0x9c>
      k += 2;
      x >>= 2;
    }
  if (!(x & 1))
    {
      k++;
   17b10:	00170713          	addi	a4,a4,1
      x >>= 1;
      if (!x & 1)
	return 32;
    }
  *y = x;
   17b14:	00f6a023          	sw	a5,0(a3)
  return k;
   17b18:	00070513          	mv	a0,a4
}
   17b1c:	00008067          	ret
    {
      if (x & 1)
	return 0;
      if (x & 2)
	{
	  *y = x >> 1;
   17b20:	0017d793          	srli	a5,a5,0x1
   17b24:	00f6a023          	sw	a5,0(a3)
	  return 1;
   17b28:	00100513          	li	a0,1
   17b2c:	00008067          	ret

00017b30 <__i2b>:
  return k;
}

_Bigint *
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
   17b30:	ff010113          	addi	sp,sp,-16
   17b34:	00812423          	sw	s0,8(sp)
   17b38:	00058413          	mv	s0,a1
  _Bigint *b;

  b = Balloc (ptr, 1);
   17b3c:	00100593          	li	a1,1
  return k;
}

_Bigint *
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
   17b40:	00112623          	sw	ra,12(sp)
  _Bigint *b;

  b = Balloc (ptr, 1);
   17b44:	be5ff0ef          	jal	17728 <_Balloc>
  b->_x[0] = i;
  b->_wds = 1;
  return b;
}
   17b48:	00c12083          	lw	ra,12(sp)
{
  _Bigint *b;

  b = Balloc (ptr, 1);
  b->_x[0] = i;
  b->_wds = 1;
   17b4c:	00100713          	li	a4,1
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
  _Bigint *b;

  b = Balloc (ptr, 1);
  b->_x[0] = i;
   17b50:	00852a23          	sw	s0,20(a0)
  b->_wds = 1;
   17b54:	00e52823          	sw	a4,16(a0)
  return b;
}
   17b58:	00812403          	lw	s0,8(sp)
   17b5c:	01010113          	addi	sp,sp,16
   17b60:	00008067          	ret

00017b64 <__multiply>:

_Bigint *
_DEFUN (mult, (ptr, a, b), struct _reent * ptr _AND _Bigint * a _AND _Bigint * b)
{
   17b64:	fe010113          	addi	sp,sp,-32
   17b68:	01312623          	sw	s3,12(sp)
   17b6c:	01412423          	sw	s4,8(sp)
  __ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;
#ifdef Pack_32
  __ULong z2;
#endif

  if (a->_wds < b->_wds)
   17b70:	0105a983          	lw	s3,16(a1)
   17b74:	01062a03          	lw	s4,16(a2)
  return b;
}

_Bigint *
_DEFUN (mult, (ptr, a, b), struct _reent * ptr _AND _Bigint * a _AND _Bigint * b)
{
   17b78:	00912a23          	sw	s1,20(sp)
   17b7c:	01212823          	sw	s2,16(sp)
   17b80:	00112e23          	sw	ra,28(sp)
   17b84:	00812c23          	sw	s0,24(sp)
   17b88:	00058913          	mv	s2,a1
   17b8c:	00060493          	mv	s1,a2
  __ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;
#ifdef Pack_32
  __ULong z2;
#endif

  if (a->_wds < b->_wds)
   17b90:	0149dc63          	ble	s4,s3,17ba8 <__multiply+0x44>
   17b94:	00098713          	mv	a4,s3
   17b98:	00060913          	mv	s2,a2
   17b9c:	000a0993          	mv	s3,s4
   17ba0:	00058493          	mv	s1,a1
   17ba4:	00070a13          	mv	s4,a4
    }
  k = a->_k;
  wa = a->_wds;
  wb = b->_wds;
  wc = wa + wb;
  if (wc > a->_maxwds)
   17ba8:	00892783          	lw	a5,8(s2)
    {
      c = a;
      a = b;
      b = c;
    }
  k = a->_k;
   17bac:	00492583          	lw	a1,4(s2)
  wa = a->_wds;
  wb = b->_wds;
  wc = wa + wb;
   17bb0:	01498433          	add	s0,s3,s4
  if (wc > a->_maxwds)
    k++;
   17bb4:	0087a7b3          	slt	a5,a5,s0
  c = Balloc (ptr, k);
   17bb8:	00f585b3          	add	a1,a1,a5
   17bbc:	b6dff0ef          	jal	17728 <_Balloc>
  for (x = c->_x, xa = x + wc; x < xa; x++)
   17bc0:	01450293          	addi	t0,a0,20
   17bc4:	00241893          	slli	a7,s0,0x2
   17bc8:	011288b3          	add	a7,t0,a7
   17bcc:	00028793          	mv	a5,t0
   17bd0:	0112f863          	bleu	a7,t0,17be0 <__multiply+0x7c>
    *x = 0;
   17bd4:	0007a023          	sw	zero,0(a5)
  wb = b->_wds;
  wc = wa + wb;
  if (wc > a->_maxwds)
    k++;
  c = Balloc (ptr, k);
  for (x = c->_x, xa = x + wc; x < xa; x++)
   17bd8:	00478793          	addi	a5,a5,4
   17bdc:	ff17ece3          	bltu	a5,a7,17bd4 <__multiply+0x70>
    *x = 0;
  xa = a->_x;
  xae = xa + wa;
  xb = b->_x;
   17be0:	01448613          	addi	a2,s1,20
  xbe = xb + wb;
   17be4:	002a1313          	slli	t1,s4,0x2
  if (wc > a->_maxwds)
    k++;
  c = Balloc (ptr, k);
  for (x = c->_x, xa = x + wc; x < xa; x++)
    *x = 0;
  xa = a->_x;
   17be8:	01490393          	addi	t2,s2,20
  xae = xa + wa;
   17bec:	00299813          	slli	a6,s3,0x2
  xbe = xb + wb;
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
    {
      if ((y = *xb & 0xffff) != 0)
   17bf0:	000105b7          	lui	a1,0x10
  for (x = c->_x, xa = x + wc; x < xa; x++)
    *x = 0;
  xa = a->_x;
  xae = xa + wa;
  xb = b->_x;
  xbe = xb + wb;
   17bf4:	00660333          	add	t1,a2,t1
    k++;
  c = Balloc (ptr, k);
  for (x = c->_x, xa = x + wc; x < xa; x++)
    *x = 0;
  xa = a->_x;
  xae = xa + wa;
   17bf8:	01038833          	add	a6,t2,a6
  xbe = xb + wb;
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
    {
      if ((y = *xb & 0xffff) != 0)
   17bfc:	fff58593          	addi	a1,a1,-1 # ffff <_reset+0xfdff>
  xae = xa + wa;
  xb = b->_x;
  xbe = xb + wb;
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
   17c00:	10667463          	bleu	t1,a2,17d08 <__multiply+0x1a4>
    {
      if ((y = *xb & 0xffff) != 0)
   17c04:	00062f83          	lw	t6,0(a2)
   17c08:	00bff933          	and	s2,t6,a1
   17c0c:	06090a63          	beqz	s2,17c80 <__multiply+0x11c>
   17c10:	00028f93          	mv	t6,t0
   17c14:	00038f13          	mv	t5,t2
   17c18:	00000693          	li	a3,0
   17c1c:	0080006f          	j	17c24 <__multiply+0xc0>
   17c20:	00048f93          	mv	t6,s1
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   17c24:	000f2e03          	lw	t3,0(t5)
   17c28:	000fae83          	lw	t4,0(t6)
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
	      carry = z2 >> 16;
	      Storeinc (xc, z2, z);
   17c2c:	004f8493          	addi	s1,t6,4
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   17c30:	00be7733          	and	a4,t3,a1
   17c34:	03270733          	mul	a4,a4,s2
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   17c38:	010e5e13          	srli	t3,t3,0x10
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   17c3c:	00bef7b3          	and	a5,t4,a1
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   17c40:	010ede93          	srli	t4,t4,0x10
   17c44:	004f0f13          	addi	t5,t5,4
   17c48:	032e0e33          	mul	t3,t3,s2
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   17c4c:	00f70733          	add	a4,a4,a5
   17c50:	00d707b3          	add	a5,a4,a3
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   17c54:	0107d693          	srli	a3,a5,0x10
	      carry = z2 >> 16;
	      Storeinc (xc, z2, z);
   17c58:	00b7f7b3          	and	a5,a5,a1
	  carry = 0;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   17c5c:	01de0e33          	add	t3,t3,t4
   17c60:	00de06b3          	add	a3,t3,a3
	      carry = z2 >> 16;
	      Storeinc (xc, z2, z);
   17c64:	01069713          	slli	a4,a3,0x10
   17c68:	00f76733          	or	a4,a4,a5
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
	      carry = z2 >> 16;
   17c6c:	0106d693          	srli	a3,a3,0x10
	      Storeinc (xc, z2, z);
   17c70:	fee4ae23          	sw	a4,-4(s1)
	    }
	  while (x < xae);
   17c74:	fb0f66e3          	bltu	t5,a6,17c20 <__multiply+0xbc>
	  *xc = carry;
   17c78:	00dfa223          	sw	a3,4(t6)
   17c7c:	00062f83          	lw	t6,0(a2)
	}
      if ((y = *xb >> 16) != 0)
   17c80:	010fdf93          	srli	t6,t6,0x10
   17c84:	060f8c63          	beqz	t6,17cfc <__multiply+0x198>
	{
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  z2 = *xc;
   17c88:	0002a783          	lw	a5,0(t0) # 176f8 <memset+0xb4>
   17c8c:	00028f13          	mv	t5,t0
	  while (x < xae);
	  *xc = carry;
	}
      if ((y = *xb >> 16) != 0)
	{
	  x = xa;
   17c90:	00038e93          	mv	t4,t2
	  xc = xc0;
	  carry = 0;
	  z2 = *xc;
   17c94:	00078e13          	mv	t3,a5
	}
      if ((y = *xb >> 16) != 0)
	{
	  x = xa;
	  xc = xc0;
	  carry = 0;
   17c98:	00000913          	li	s2,0
   17c9c:	0080006f          	j	17ca4 <__multiply+0x140>
   17ca0:	00048f13          	mv	t5,s1
	  z2 = *xc;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
   17ca4:	000ea703          	lw	a4,0(t4)
   17ca8:	010e5693          	srli	a3,t3,0x10
	      carry = z >> 16;
	      Storeinc (xc, z, z2);
   17cac:	00b7f7b3          	and	a5,a5,a1
	  xc = xc0;
	  carry = 0;
	  z2 = *xc;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
   17cb0:	00b77733          	and	a4,a4,a1
   17cb4:	03f70733          	mul	a4,a4,t6
	      carry = z >> 16;
	      Storeinc (xc, z, z2);
   17cb8:	004f0493          	addi	s1,t5,4
	      z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
   17cbc:	004e8e93          	addi	t4,t4,4
	  xc = xc0;
	  carry = 0;
	  z2 = *xc;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
   17cc0:	00d706b3          	add	a3,a4,a3
   17cc4:	012686b3          	add	a3,a3,s2
	      carry = z >> 16;
	      Storeinc (xc, z, z2);
   17cc8:	01069713          	slli	a4,a3,0x10
   17ccc:	00f767b3          	or	a5,a4,a5
   17cd0:	fef4ae23          	sw	a5,-4(s1)
	      z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
   17cd4:	ffeed703          	lhu	a4,-2(t4)
   17cd8:	004f2e03          	lw	t3,4(t5)
   17cdc:	0106d693          	srli	a3,a3,0x10
   17ce0:	03f70733          	mul	a4,a4,t6
   17ce4:	00be77b3          	and	a5,t3,a1
   17ce8:	00f707b3          	add	a5,a4,a5
   17cec:	00d787b3          	add	a5,a5,a3
	      carry = z2 >> 16;
   17cf0:	0107d913          	srli	s2,a5,0x10
	    }
	  while (x < xae);
   17cf4:	fb0ee6e3          	bltu	t4,a6,17ca0 <__multiply+0x13c>
	  *xc = z2;
   17cf8:	00ff2223          	sw	a5,4(t5)
  xae = xa + wa;
  xb = b->_x;
  xbe = xb + wb;
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
   17cfc:	00460613          	addi	a2,a2,4
   17d00:	00428293          	addi	t0,t0,4
   17d04:	f06660e3          	bltu	a2,t1,17c04 <__multiply+0xa0>
	  while (x < xae);
	  *xc = carry;
	}
    }
#endif
  for (xc0 = c->_x, xc = xc0 + wc; wc > 0 && !*--xc; --wc);
   17d08:	02805463          	blez	s0,17d30 <__multiply+0x1cc>
   17d0c:	ffc8a783          	lw	a5,-4(a7)
   17d10:	ffc88893          	addi	a7,a7,-4
   17d14:	00078863          	beqz	a5,17d24 <__multiply+0x1c0>
   17d18:	0180006f          	j	17d30 <__multiply+0x1cc>
   17d1c:	0008a783          	lw	a5,0(a7)
   17d20:	00079863          	bnez	a5,17d30 <__multiply+0x1cc>
   17d24:	fff40413          	addi	s0,s0,-1
   17d28:	ffc88893          	addi	a7,a7,-4
   17d2c:	fe0418e3          	bnez	s0,17d1c <__multiply+0x1b8>
  c->_wds = wc;
  return c;
}
   17d30:	01c12083          	lw	ra,28(sp)
	  *xc = carry;
	}
    }
#endif
  for (xc0 = c->_x, xc = xc0 + wc; wc > 0 && !*--xc; --wc);
  c->_wds = wc;
   17d34:	00852823          	sw	s0,16(a0)
  return c;
}
   17d38:	01412483          	lw	s1,20(sp)
   17d3c:	01812403          	lw	s0,24(sp)
   17d40:	01012903          	lw	s2,16(sp)
   17d44:	00c12983          	lw	s3,12(sp)
   17d48:	00812a03          	lw	s4,8(sp)
   17d4c:	02010113          	addi	sp,sp,32
   17d50:	00008067          	ret

00017d54 <__pow5mult>:

_Bigint *
_DEFUN (pow5mult,
	(ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   17d54:	fe010113          	addi	sp,sp,-32
  _Bigint *b1, *p5, *p51;
  int i;
  static _CONST int p05[3] = {5, 25, 125};

  if ((i = k & 3) != 0)
   17d58:	00367793          	andi	a5,a2,3
}

_Bigint *
_DEFUN (pow5mult,
	(ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   17d5c:	00812c23          	sw	s0,24(sp)
   17d60:	01212823          	sw	s2,16(sp)
   17d64:	01312623          	sw	s3,12(sp)
   17d68:	00112e23          	sw	ra,28(sp)
   17d6c:	00912a23          	sw	s1,20(sp)
   17d70:	00060413          	mv	s0,a2
   17d74:	00050993          	mv	s3,a0
   17d78:	00058913          	mv	s2,a1
  _Bigint *b1, *p5, *p51;
  int i;
  static _CONST int p05[3] = {5, 25, 125};

  if ((i = k & 3) != 0)
   17d7c:	0a079e63          	bnez	a5,17e38 <__pow5mult+0xe4>
    b = multadd (ptr, b, p05[i - 1], 0);

  if (!(k >>= 2))
   17d80:	40245413          	srai	s0,s0,0x2
   17d84:	06040663          	beqz	s0,17df0 <__pow5mult+0x9c>
    return b;
  _REENT_CHECK_MP(ptr);
  if (!(p5 = _REENT_MP_P5S(ptr)))
   17d88:	0489a483          	lw	s1,72(s3)
   17d8c:	0c048a63          	beqz	s1,17e60 <__pow5mult+0x10c>
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
      p5->_next = 0;
    }
  for (;;)
    {
      if (k & 1)
   17d90:	00147793          	andi	a5,s0,1
   17d94:	02079063          	bnez	a5,17db4 <__pow5mult+0x60>
	{
	  b1 = mult (ptr, b, p5);
	  Bfree (ptr, b);
	  b = b1;
	}
      if (!(k >>= 1))
   17d98:	40145413          	srai	s0,s0,0x1
   17d9c:	04040a63          	beqz	s0,17df0 <__pow5mult+0x9c>
	break;
      if (!(p51 = p5->_next))
   17da0:	0004a503          	lw	a0,0(s1)
   17da4:	06050663          	beqz	a0,17e10 <__pow5mult+0xbc>
}

_Bigint *
_DEFUN (pow5mult,
	(ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   17da8:	00050493          	mv	s1,a0
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
      p5->_next = 0;
    }
  for (;;)
    {
      if (k & 1)
   17dac:	00147793          	andi	a5,s0,1
   17db0:	fe0784e3          	beqz	a5,17d98 <__pow5mult+0x44>
	{
	  b1 = mult (ptr, b, p5);
   17db4:	00048613          	mv	a2,s1
   17db8:	00090593          	mv	a1,s2
   17dbc:	00098513          	mv	a0,s3
   17dc0:	da5ff0ef          	jal	17b64 <__multiply>

void
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
   17dc4:	06090663          	beqz	s2,17e30 <__pow5mult+0xdc>
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   17dc8:	00492783          	lw	a5,4(s2)
   17dcc:	04c9a703          	lw	a4,76(s3)
	{
	  b1 = mult (ptr, b, p5);
	  Bfree (ptr, b);
	  b = b1;
	}
      if (!(k >>= 1))
   17dd0:	40145413          	srai	s0,s0,0x1
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   17dd4:	00279793          	slli	a5,a5,0x2
   17dd8:	00f707b3          	add	a5,a4,a5
   17ddc:	0007a703          	lw	a4,0(a5)
   17de0:	00e92023          	sw	a4,0(s2)
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   17de4:	0127a023          	sw	s2,0(a5)
    {
      if (k & 1)
	{
	  b1 = mult (ptr, b, p5);
	  Bfree (ptr, b);
	  b = b1;
   17de8:	00050913          	mv	s2,a0
	}
      if (!(k >>= 1))
   17dec:	fa041ae3          	bnez	s0,17da0 <__pow5mult+0x4c>
	  p51->_next = 0;
	}
      p5 = p51;
    }
  return b;
}
   17df0:	01c12083          	lw	ra,28(sp)
   17df4:	00090513          	mv	a0,s2
   17df8:	01812403          	lw	s0,24(sp)
   17dfc:	01412483          	lw	s1,20(sp)
   17e00:	01012903          	lw	s2,16(sp)
   17e04:	00c12983          	lw	s3,12(sp)
   17e08:	02010113          	addi	sp,sp,32
   17e0c:	00008067          	ret
	}
      if (!(k >>= 1))
	break;
      if (!(p51 = p5->_next))
	{
	  p51 = p5->_next = mult (ptr, p5, p5);
   17e10:	00048613          	mv	a2,s1
   17e14:	00048593          	mv	a1,s1
   17e18:	00098513          	mv	a0,s3
   17e1c:	d49ff0ef          	jal	17b64 <__multiply>
   17e20:	00a4a023          	sw	a0,0(s1)
	  p51->_next = 0;
   17e24:	00052023          	sw	zero,0(a0)
}

_Bigint *
_DEFUN (pow5mult,
	(ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   17e28:	00050493          	mv	s1,a0
   17e2c:	f81ff06f          	j	17dac <__pow5mult+0x58>
    {
      if (k & 1)
	{
	  b1 = mult (ptr, b, p5);
	  Bfree (ptr, b);
	  b = b1;
   17e30:	00050913          	mv	s2,a0
   17e34:	f65ff06f          	j	17d98 <__pow5mult+0x44>
  _Bigint *b1, *p5, *p51;
  int i;
  static _CONST int p05[3] = {5, 25, 125};

  if ((i = k & 3) != 0)
    b = multadd (ptr, b, p05[i - 1], 0);
   17e38:	fff78793          	addi	a5,a5,-1
   17e3c:	0001d737          	lui	a4,0x1d
   17e40:	90870713          	addi	a4,a4,-1784 # 1c908 <p05.2565>
   17e44:	00279793          	slli	a5,a5,0x2
   17e48:	00f707b3          	add	a5,a4,a5
   17e4c:	0007a603          	lw	a2,0(a5)
   17e50:	00000693          	li	a3,0
   17e54:	99dff0ef          	jal	177f0 <__multadd>
   17e58:	00050913          	mv	s2,a0
   17e5c:	f25ff06f          	j	17d80 <__pow5mult+0x2c>
_Bigint *
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
  _Bigint *b;

  b = Balloc (ptr, 1);
   17e60:	00100593          	li	a1,1
   17e64:	00098513          	mv	a0,s3
   17e68:	8c1ff0ef          	jal	17728 <_Balloc>
  b->_x[0] = i;
   17e6c:	27100793          	li	a5,625
   17e70:	00f52a23          	sw	a5,20(a0)
  b->_wds = 1;
   17e74:	00100793          	li	a5,1
   17e78:	00f52823          	sw	a5,16(a0)
_Bigint *
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
  _Bigint *b;

  b = Balloc (ptr, 1);
   17e7c:	00050493          	mv	s1,a0
    return b;
  _REENT_CHECK_MP(ptr);
  if (!(p5 = _REENT_MP_P5S(ptr)))
    {
      /* first time */
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
   17e80:	04a9a423          	sw	a0,72(s3)
      p5->_next = 0;
   17e84:	00052023          	sw	zero,0(a0)
   17e88:	f09ff06f          	j	17d90 <__pow5mult+0x3c>

00017e8c <__lshift>:
  return b;
}

_Bigint *
_DEFUN (lshift, (ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   17e8c:	fe010113          	addi	sp,sp,-32
   17e90:	01412423          	sw	s4,8(sp)
  n = k >> 5;
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
   17e94:	0105aa03          	lw	s4,16(a1)
  return b;
}

_Bigint *
_DEFUN (lshift, (ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   17e98:	00812c23          	sw	s0,24(sp)
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
   17e9c:	0085a783          	lw	a5,8(a1)
  int i, k1, n, n1;
  _Bigint *b1;
  __ULong *x, *x1, *xe, z;

#ifdef Pack_32
  n = k >> 5;
   17ea0:	40565413          	srai	s0,a2,0x5
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
   17ea4:	01440a33          	add	s4,s0,s4
  return b;
}

_Bigint *
_DEFUN (lshift, (ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   17ea8:	00912a23          	sw	s1,20(sp)
  n = k >> 5;
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
   17eac:	001a0493          	addi	s1,s4,1
  return b;
}

_Bigint *
_DEFUN (lshift, (ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   17eb0:	01212823          	sw	s2,16(sp)
   17eb4:	01312623          	sw	s3,12(sp)
   17eb8:	01512223          	sw	s5,4(sp)
   17ebc:	00058993          	mv	s3,a1
   17ec0:	00112e23          	sw	ra,28(sp)
   17ec4:	00060913          	mv	s2,a2
   17ec8:	00050a93          	mv	s5,a0
#ifdef Pack_32
  n = k >> 5;
#else
  n = k >> 4;
#endif
  k1 = b->_k;
   17ecc:	0045a583          	lw	a1,4(a1)
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
   17ed0:	0097d863          	ble	s1,a5,17ee0 <__lshift+0x54>
   17ed4:	00179793          	slli	a5,a5,0x1
    k1++;
   17ed8:	00158593          	addi	a1,a1,1
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
   17edc:	fe97cce3          	blt	a5,s1,17ed4 <__lshift+0x48>
    k1++;
  b1 = Balloc (ptr, k1);
   17ee0:	000a8513          	mv	a0,s5
   17ee4:	845ff0ef          	jal	17728 <_Balloc>
  x1 = b1->_x;
   17ee8:	01450793          	addi	a5,a0,20
  for (i = 0; i < n; i++)
   17eec:	0e805463          	blez	s0,17fd4 <__lshift+0x148>
   17ef0:	00241713          	slli	a4,s0,0x2
   17ef4:	00e78733          	add	a4,a5,a4
    *x1++ = 0;
   17ef8:	00478793          	addi	a5,a5,4
   17efc:	fe07ae23          	sw	zero,-4(a5)
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
    k1++;
  b1 = Balloc (ptr, k1);
  x1 = b1->_x;
  for (i = 0; i < n; i++)
   17f00:	fee79ce3          	bne	a5,a4,17ef8 <__lshift+0x6c>
    *x1++ = 0;
  x = b->_x;
  xe = x + b->_wds;
   17f04:	0109a883          	lw	a7,16(s3)
    k1++;
  b1 = Balloc (ptr, k1);
  x1 = b1->_x;
  for (i = 0; i < n; i++)
    *x1++ = 0;
  x = b->_x;
   17f08:	01498793          	addi	a5,s3,20
  xe = x + b->_wds;
#ifdef Pack_32
  if (k &= 0x1f)
   17f0c:	01f97613          	andi	a2,s2,31
  b1 = Balloc (ptr, k1);
  x1 = b1->_x;
  for (i = 0; i < n; i++)
    *x1++ = 0;
  x = b->_x;
  xe = x + b->_wds;
   17f10:	00289893          	slli	a7,a7,0x2
   17f14:	011788b3          	add	a7,a5,a7
#ifdef Pack_32
  if (k &= 0x1f)
   17f18:	08060863          	beqz	a2,17fa8 <__lshift+0x11c>
    {
      k1 = 32 - k;
   17f1c:	02000293          	li	t0,32
   17f20:	40c282b3          	sub	t0,t0,a2
      z = 0;
   17f24:	00000693          	li	a3,0
   17f28:	0080006f          	j	17f30 <__lshift+0xa4>
   17f2c:	00080713          	mv	a4,a6
      do
	{
	  *x1++ = *x << k | z;
   17f30:	0007a583          	lw	a1,0(a5)
   17f34:	00470813          	addi	a6,a4,4
	  z = *x++ >> k1;
   17f38:	00478793          	addi	a5,a5,4
    {
      k1 = 32 - k;
      z = 0;
      do
	{
	  *x1++ = *x << k | z;
   17f3c:	00c595b3          	sll	a1,a1,a2
   17f40:	00d5e6b3          	or	a3,a1,a3
   17f44:	fed82e23          	sw	a3,-4(a6)
	  z = *x++ >> k1;
   17f48:	ffc7a683          	lw	a3,-4(a5)
   17f4c:	0056d6b3          	srl	a3,a3,t0
	}
      while (x < xe);
   17f50:	fd17eee3          	bltu	a5,a7,17f2c <__lshift+0xa0>
      if ((*x1 = z) != 0)
   17f54:	00d72223          	sw	a3,4(a4)
   17f58:	00068463          	beqz	a3,17f60 <__lshift+0xd4>
	++n1;
   17f5c:	002a0493          	addi	s1,s4,2
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   17f60:	0049a783          	lw	a5,4(s3)
   17f64:	04caa703          	lw	a4,76(s5)
      *x1++ = *x++;
    while (x < xe);
  b1->_wds = n1 - 1;
  Bfree (ptr, b);
  return b1;
}
   17f68:	01c12083          	lw	ra,28(sp)
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   17f6c:	00279793          	slli	a5,a5,0x2
   17f70:	00f707b3          	add	a5,a4,a5
   17f74:	0007a703          	lw	a4,0(a5)
#endif
  else
    do
      *x1++ = *x++;
    while (x < xe);
  b1->_wds = n1 - 1;
   17f78:	fff48493          	addi	s1,s1,-1
   17f7c:	00952823          	sw	s1,16(a0)
  Bfree (ptr, b);
  return b1;
}
   17f80:	01812403          	lw	s0,24(sp)
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   17f84:	00e9a023          	sw	a4,0(s3)
      *x1++ = *x++;
    while (x < xe);
  b1->_wds = n1 - 1;
  Bfree (ptr, b);
  return b1;
}
   17f88:	01412483          	lw	s1,20(sp)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   17f8c:	0137a023          	sw	s3,0(a5)
      *x1++ = *x++;
    while (x < xe);
  b1->_wds = n1 - 1;
  Bfree (ptr, b);
  return b1;
}
   17f90:	01012903          	lw	s2,16(sp)
   17f94:	00c12983          	lw	s3,12(sp)
   17f98:	00812a03          	lw	s4,8(sp)
   17f9c:	00412a83          	lw	s5,4(sp)
   17fa0:	02010113          	addi	sp,sp,32
   17fa4:	00008067          	ret
	++n1;
    }
#endif
  else
    do
      *x1++ = *x++;
   17fa8:	00478793          	addi	a5,a5,4
   17fac:	ffc7a683          	lw	a3,-4(a5)
   17fb0:	00470713          	addi	a4,a4,4
   17fb4:	fed72e23          	sw	a3,-4(a4)
    while (x < xe);
   17fb8:	fb17f4e3          	bleu	a7,a5,17f60 <__lshift+0xd4>
	++n1;
    }
#endif
  else
    do
      *x1++ = *x++;
   17fbc:	00478793          	addi	a5,a5,4
   17fc0:	ffc7a683          	lw	a3,-4(a5)
   17fc4:	00470713          	addi	a4,a4,4
   17fc8:	fed72e23          	sw	a3,-4(a4)
    while (x < xe);
   17fcc:	fd17eee3          	bltu	a5,a7,17fa8 <__lshift+0x11c>
   17fd0:	f91ff06f          	j	17f60 <__lshift+0xd4>
  k1 = b->_k;
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
    k1++;
  b1 = Balloc (ptr, k1);
  x1 = b1->_x;
   17fd4:	00078713          	mv	a4,a5
   17fd8:	f2dff06f          	j	17f04 <__lshift+0x78>

00017fdc <__mcmp>:
_DEFUN (cmp, (a, b), _Bigint * a _AND _Bigint * b)
{
  __ULong *xa, *xa0, *xb, *xb0;
  int i, j;

  i = a->_wds;
   17fdc:	01052703          	lw	a4,16(a0)
  j = b->_wds;
   17fe0:	0105a783          	lw	a5,16(a1)
  if (i > 1 && !a->_x[i - 1])
    Bug ("cmp called with a->_x[a->_wds-1] == 0");
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
   17fe4:	40f70733          	sub	a4,a4,a5
   17fe8:	04071263          	bnez	a4,1802c <__mcmp+0x50>
    return i;
  xa0 = a->_x;
  xa = xa0 + j;
   17fec:	00279713          	slli	a4,a5,0x2
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
    return i;
  xa0 = a->_x;
   17ff0:	01450513          	addi	a0,a0,20
  xa = xa0 + j;
  xb0 = b->_x;
   17ff4:	01458593          	addi	a1,a1,20
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
    return i;
  xa0 = a->_x;
  xa = xa0 + j;
   17ff8:	00e507b3          	add	a5,a0,a4
  xb0 = b->_x;
  xb = xb0 + j;
   17ffc:	00e585b3          	add	a1,a1,a4
   18000:	0080006f          	j	18008 <__mcmp+0x2c>
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
      if (xa <= xa0)
   18004:	02f57863          	bleu	a5,a0,18034 <__mcmp+0x58>
  xa = xa0 + j;
  xb0 = b->_x;
  xb = xb0 + j;
  for (;;)
    {
      if (*--xa != *--xb)
   18008:	ffc78793          	addi	a5,a5,-4
   1800c:	ffc58593          	addi	a1,a1,-4
   18010:	0007a703          	lw	a4,0(a5)
   18014:	0005a683          	lw	a3,0(a1)
   18018:	fed706e3          	beq	a4,a3,18004 <__mcmp+0x28>
	return *xa < *xb ? -1 : 1;
   1801c:	00d73733          	sltu	a4,a4,a3
   18020:	40e00733          	neg	a4,a4
   18024:	00176513          	ori	a0,a4,1
   18028:	00008067          	ret
   1802c:	00070513          	mv	a0,a4
      if (xa <= xa0)
	break;
    }
  return 0;
}
   18030:	00008067          	ret
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
      if (xa <= xa0)
	break;
    }
  return 0;
   18034:	00000513          	li	a0,0
   18038:	00008067          	ret

0001803c <__mdiff>:
_DEFUN (cmp, (a, b), _Bigint * a _AND _Bigint * b)
{
  __ULong *xa, *xa0, *xb, *xb0;
  int i, j;

  i = a->_wds;
   1803c:	0105a783          	lw	a5,16(a1)
  j = b->_wds;
   18040:	01062703          	lw	a4,16(a2)
}

_Bigint *
_DEFUN (diff, (ptr, a, b), struct _reent * ptr _AND
	_Bigint * a _AND _Bigint * b)
{
   18044:	fd010113          	addi	sp,sp,-48
   18048:	03212023          	sw	s2,32(sp)
  if (i > 1 && !a->_x[i - 1])
    Bug ("cmp called with a->_x[a->_wds-1] == 0");
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
   1804c:	40e787b3          	sub	a5,a5,a4
}

_Bigint *
_DEFUN (diff, (ptr, a, b), struct _reent * ptr _AND
	_Bigint * a _AND _Bigint * b)
{
   18050:	02112623          	sw	ra,44(sp)
   18054:	02812423          	sw	s0,40(sp)
   18058:	02912223          	sw	s1,36(sp)
   1805c:	01312e23          	sw	s3,28(sp)
   18060:	00058913          	mv	s2,a1
  if (i > 1 && !a->_x[i - 1])
    Bug ("cmp called with a->_x[a->_wds-1] == 0");
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
   18064:	04079863          	bnez	a5,180b4 <__mdiff+0x78>
    return i;
  xa0 = a->_x;
  xa = xa0 + j;
   18068:	00271713          	slli	a4,a4,0x2
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
    return i;
  xa0 = a->_x;
   1806c:	01458813          	addi	a6,a1,20
  xa = xa0 + j;
  xb0 = b->_x;
   18070:	01460413          	addi	s0,a2,20
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
    return i;
  xa0 = a->_x;
  xa = xa0 + j;
   18074:	00e807b3          	add	a5,a6,a4
  xb0 = b->_x;
  xb = xb0 + j;
   18078:	00e40733          	add	a4,s0,a4
   1807c:	0080006f          	j	18084 <__mdiff+0x48>
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
      if (xa <= xa0)
   18080:	16f87463          	bleu	a5,a6,181e8 <__mdiff+0x1ac>
  xa = xa0 + j;
  xb0 = b->_x;
  xb = xb0 + j;
  for (;;)
    {
      if (*--xa != *--xb)
   18084:	ffc78793          	addi	a5,a5,-4
   18088:	ffc70713          	addi	a4,a4,-4
   1808c:	0007a583          	lw	a1,0(a5)
   18090:	00072683          	lw	a3,0(a4)
   18094:	fed586e3          	beq	a1,a3,18080 <__mdiff+0x44>
	return *xa < *xb ? -1 : 1;
   18098:	16d5f463          	bleu	a3,a1,18200 <__mdiff+0x1c4>
   1809c:	00090793          	mv	a5,s2
   180a0:	00080493          	mv	s1,a6
   180a4:	00060913          	mv	s2,a2
  if (i < 0)
    {
      c = a;
      a = b;
      b = c;
      i = 1;
   180a8:	00100993          	li	s3,1
  xb0 = b->_x;
  xb = xb0 + j;
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
   180ac:	00078613          	mv	a2,a5
   180b0:	0140006f          	j	180c4 <__mdiff+0x88>
      c = Balloc (ptr, 0);
      c->_wds = 1;
      c->_x[0] = 0;
      return c;
    }
  if (i < 0)
   180b4:	1407ce63          	bltz	a5,18210 <__mdiff+0x1d4>
   180b8:	01460493          	addi	s1,a2,20
   180bc:	01458413          	addi	s0,a1,20
      a = b;
      b = c;
      i = 1;
    }
  else
    i = 0;
   180c0:	00000993          	li	s3,0
  c = Balloc (ptr, a->_k);
   180c4:	00492583          	lw	a1,4(s2)
   180c8:	00c12623          	sw	a2,12(sp)
   180cc:	e5cff0ef          	jal	17728 <_Balloc>
  wa = a->_wds;
  xa = a->_x;
  xae = xa + wa;
  wb = b->_wds;
  xb = b->_x;
  xbe = xb + wb;
   180d0:	00c12603          	lw	a2,12(sp)
    }
  else
    i = 0;
  c = Balloc (ptr, a->_k);
  c->_sign = i;
  wa = a->_wds;
   180d4:	01092303          	lw	t1,16(s2)
  xc = c->_x;
  borrow = 0;
#ifdef Pack_32
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
   180d8:	000102b7          	lui	t0,0x10
  wa = a->_wds;
  xa = a->_x;
  xae = xa + wa;
  wb = b->_wds;
  xb = b->_x;
  xbe = xb + wb;
   180dc:	01062e03          	lw	t3,16(a2)
    i = 0;
  c = Balloc (ptr, a->_k);
  c->_sign = i;
  wa = a->_wds;
  xa = a->_x;
  xae = xa + wa;
   180e0:	00231393          	slli	t2,t1,0x2
      i = 1;
    }
  else
    i = 0;
  c = Balloc (ptr, a->_k);
  c->_sign = i;
   180e4:	01352623          	sw	s3,12(a0)
  wa = a->_wds;
  xa = a->_x;
  xae = xa + wa;
  wb = b->_wds;
  xb = b->_x;
  xbe = xb + wb;
   180e8:	002e1e13          	slli	t3,t3,0x2
    i = 0;
  c = Balloc (ptr, a->_k);
  c->_sign = i;
  wa = a->_wds;
  xa = a->_x;
  xae = xa + wa;
   180ec:	007403b3          	add	t2,s0,t2
  wb = b->_wds;
  xb = b->_x;
  xbe = xb + wb;
   180f0:	01c48e33          	add	t3,s1,t3
  xc = c->_x;
   180f4:	01450813          	addi	a6,a0,20
  borrow = 0;
   180f8:	00000693          	li	a3,0
#ifdef Pack_32
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
   180fc:	fff28293          	addi	t0,t0,-1 # ffff <_reset+0xfdff>
   18100:	00042583          	lw	a1,0(s0)
   18104:	0004a883          	lw	a7,0(s1)
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   18108:	00480813          	addi	a6,a6,4
  xc = c->_x;
  borrow = 0;
#ifdef Pack_32
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
   1810c:	0055f633          	and	a2,a1,t0
   18110:	00d606b3          	add	a3,a2,a3
   18114:	0058f733          	and	a4,a7,t0
   18118:	40e68733          	sub	a4,a3,a4
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
   1811c:	0105d593          	srli	a1,a1,0x10
   18120:	0108d693          	srli	a3,a7,0x10
   18124:	40d585b3          	sub	a1,a1,a3
   18128:	41075693          	srai	a3,a4,0x10
   1812c:	00d586b3          	add	a3,a1,a3
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   18130:	01069793          	slli	a5,a3,0x10
   18134:	00577733          	and	a4,a4,t0
   18138:	00e7e7b3          	or	a5,a5,a4
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
   1813c:	00448493          	addi	s1,s1,4
   18140:	00440413          	addi	s0,s0,4
      borrow = z >> 16;
   18144:	4106d693          	srai	a3,a3,0x10
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   18148:	fef82e23          	sw	a5,-4(a6)
    }
  while (xb < xbe);
   1814c:	fbc4eae3          	bltu	s1,t3,18100 <__mdiff+0xc4>
  while (xa < xae)
   18150:	06747063          	bleu	t2,s0,181b0 <__mdiff+0x174>
    {
      y = (*xa & 0xffff) + borrow;
   18154:	00010e37          	lui	t3,0x10
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   18158:	00080293          	mv	t0,a6
    }
  while (xb < xbe);
  while (xa < xae)
   1815c:	00040893          	mv	a7,s0
    {
      y = (*xa & 0xffff) + borrow;
   18160:	fffe0e13          	addi	t3,t3,-1 # ffff <_reset+0xfdff>
   18164:	0008a583          	lw	a1,0(a7)
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   18168:	00428293          	addi	t0,t0,4
  while (xa < xae)
    {
      y = (*xa & 0xffff) + borrow;
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
   1816c:	00488893          	addi	a7,a7,4
      Storeinc (xc, z, y);
    }
  while (xb < xbe);
  while (xa < xae)
    {
      y = (*xa & 0xffff) + borrow;
   18170:	01c5f633          	and	a2,a1,t3
   18174:	00d606b3          	add	a3,a2,a3
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
   18178:	4106d713          	srai	a4,a3,0x10
   1817c:	0105d593          	srli	a1,a1,0x10
   18180:	00e58733          	add	a4,a1,a4
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   18184:	01c6f6b3          	and	a3,a3,t3
   18188:	01071793          	slli	a5,a4,0x10
   1818c:	00d7e7b3          	or	a5,a5,a3
   18190:	fef2ae23          	sw	a5,-4(t0)
    {
      y = (*xa & 0xffff) + borrow;
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
      borrow = z >> 16;
   18194:	41075693          	srai	a3,a4,0x10
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
    }
  while (xb < xbe);
  while (xa < xae)
   18198:	fc78e6e3          	bltu	a7,t2,18164 <__mdiff+0x128>
   1819c:	fff44413          	not	s0,s0
   181a0:	007403b3          	add	t2,s0,t2
   181a4:	ffc3f393          	andi	t2,t2,-4
   181a8:	00438393          	addi	t2,t2,4
   181ac:	00780833          	add	a6,a6,t2
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      *xc++ = y & 0xffff;
    }
#endif
  while (!*--xc)
   181b0:	ffc80813          	addi	a6,a6,-4
   181b4:	00079a63          	bnez	a5,181c8 <__mdiff+0x18c>
   181b8:	ffc80813          	addi	a6,a6,-4
   181bc:	00082783          	lw	a5,0(a6)
    wa--;
   181c0:	fff30313          	addi	t1,t1,-1
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      *xc++ = y & 0xffff;
    }
#endif
  while (!*--xc)
   181c4:	fe078ae3          	beqz	a5,181b8 <__mdiff+0x17c>
    wa--;
  c->_wds = wa;
   181c8:	00652823          	sw	t1,16(a0)
  return c;
}
   181cc:	02c12083          	lw	ra,44(sp)
   181d0:	02812403          	lw	s0,40(sp)
   181d4:	02412483          	lw	s1,36(sp)
   181d8:	02012903          	lw	s2,32(sp)
   181dc:	01c12983          	lw	s3,28(sp)
   181e0:	03010113          	addi	sp,sp,48
   181e4:	00008067          	ret
#endif

  i = cmp (a, b);
  if (!i)
    {
      c = Balloc (ptr, 0);
   181e8:	00000593          	li	a1,0
   181ec:	d3cff0ef          	jal	17728 <_Balloc>
      c->_wds = 1;
   181f0:	00100793          	li	a5,1
   181f4:	00f52823          	sw	a5,16(a0)
      c->_x[0] = 0;
   181f8:	00052a23          	sw	zero,20(a0)
      return c;
   181fc:	fd1ff06f          	j	181cc <__mdiff+0x190>
  xb0 = b->_x;
  xb = xb0 + j;
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
   18200:	00040493          	mv	s1,s0
      a = b;
      b = c;
      i = 1;
    }
  else
    i = 0;
   18204:	00000993          	li	s3,0
  xb0 = b->_x;
  xb = xb0 + j;
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
   18208:	00080413          	mv	s0,a6
   1820c:	eb9ff06f          	j	180c4 <__mdiff+0x88>
   18210:	00090793          	mv	a5,s2
   18214:	01490493          	addi	s1,s2,20
   18218:	01460413          	addi	s0,a2,20
   1821c:	00060913          	mv	s2,a2
  if (i < 0)
    {
      c = a;
      a = b;
      b = c;
      i = 1;
   18220:	00100993          	li	s3,1
   18224:	00078613          	mv	a2,a5
   18228:	e9dff06f          	j	180c4 <__mdiff+0x88>

0001822c <__ulp>:
  union double_union x, a;
  register __Long L;

  x.d = _x;

  L = (word0 (x) & Exp_mask) - (P - 1) * Exp_msk1;
   1822c:	7ff007b7          	lui	a5,0x7ff00
   18230:	00f5f5b3          	and	a1,a1,a5
   18234:	fcc007b7          	lui	a5,0xfcc00
   18238:	00f585b3          	add	a1,a1,a5
#ifndef Sudden_Underflow
  if (L > 0)
   1823c:	00b05c63          	blez	a1,18254 <__ulp+0x28>
    {
#endif
#ifdef IBM
      L |= Exp_msk1 >> 4;
#endif
      word0 (a) = L;
   18240:	00000713          	li	a4,0
   18244:	00058793          	mv	a5,a1
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
#endif
	}
    }
#endif
  return a.d;
   18248:	00070513          	mv	a0,a4
   1824c:	00078593          	mv	a1,a5
}
   18250:	00008067          	ret

#ifndef Sudden_Underflow
    }
  else
    {
      L = -L >> Exp_shift;
   18254:	40b005b3          	neg	a1,a1
   18258:	4145d593          	srai	a1,a1,0x14
      if (L < Exp_shift)
   1825c:	01300793          	li	a5,19
   18260:	02b7d863          	ble	a1,a5,18290 <__ulp+0x64>
#endif
	}
      else
	{
	  word0 (a) = 0;
	  L -= Exp_shift;
   18264:	fec58593          	addi	a1,a1,-20
#ifndef _DOUBLE_IS_32BITS
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
   18268:	01e00613          	li	a2,30
	  word1 (a) = 0;
#endif
	}
      else
	{
	  word0 (a) = 0;
   1826c:	00000793          	li	a5,0
	  L -= Exp_shift;
#ifndef _DOUBLE_IS_32BITS
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
   18270:	00100693          	li	a3,1
   18274:	00b64663          	blt	a2,a1,18280 <__ulp+0x54>
   18278:	fff5c593          	not	a1,a1
   1827c:	00b696b3          	sll	a3,a3,a1
   18280:	00068713          	mv	a4,a3
#endif
	}
    }
#endif
  return a.d;
   18284:	00070513          	mv	a0,a4
   18288:	00078593          	mv	a1,a5
}
   1828c:	00008067          	ret
  else
    {
      L = -L >> Exp_shift;
      if (L < Exp_shift)
	{
	  word0 (a) = 0x80000 >> L;
   18290:	000806b7          	lui	a3,0x80
   18294:	00000713          	li	a4,0
   18298:	40b6d7b3          	sra	a5,a3,a1
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
#endif
	}
    }
#endif
  return a.d;
   1829c:	00070513          	mv	a0,a4
   182a0:	00078593          	mv	a1,a5
}
   182a4:	00008067          	ret

000182a8 <__b2d>:

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   182a8:	fe010113          	addi	sp,sp,-32
   182ac:	00812c23          	sw	s0,24(sp)
#define d0 word0(d)
#define d1 word1(d)
#endif

  xa0 = a->_x;
  xa = xa0 + a->_wds;
   182b0:	01052403          	lw	s0,16(a0)
}

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   182b4:	00912a23          	sw	s1,20(sp)
#else
#define d0 word0(d)
#define d1 word1(d)
#endif

  xa0 = a->_x;
   182b8:	01450493          	addi	s1,a0,20
  xa = xa0 + a->_wds;
   182bc:	00241413          	slli	s0,s0,0x2
   182c0:	00848433          	add	s0,s1,s0
}

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   182c4:	01212823          	sw	s2,16(sp)
#define d1 word1(d)
#endif

  xa0 = a->_x;
  xa = xa0 + a->_wds;
  y = *--xa;
   182c8:	ffc42903          	lw	s2,-4(s0)
}

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   182cc:	01312623          	sw	s3,12(sp)
   182d0:	01412423          	sw	s4,8(sp)
  y = *--xa;
#ifdef DEBUG
  if (!y)
    Bug ("zero y in b2d");
#endif
  k = hi0bits (y);
   182d4:	00090513          	mv	a0,s2
}

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   182d8:	00058a13          	mv	s4,a1
   182dc:	00112e23          	sw	ra,28(sp)
  y = *--xa;
#ifdef DEBUG
  if (!y)
    Bug ("zero y in b2d");
#endif
  k = hi0bits (y);
   182e0:	f24ff0ef          	jal	17a04 <__hi0bits>
  *e = 32 - k;
   182e4:	02000793          	li	a5,32
   182e8:	40a78733          	sub	a4,a5,a0
   182ec:	00ea2023          	sw	a4,0(s4)
#ifdef Pack_32
  if (k < Ebits)
   182f0:	00a00713          	li	a4,10
#define d1 word1(d)
#endif

  xa0 = a->_x;
  xa = xa0 + a->_wds;
  y = *--xa;
   182f4:	ffc40993          	addi	s3,s0,-4
    Bug ("zero y in b2d");
#endif
  k = hi0bits (y);
  *e = 32 - k;
#ifdef Pack_32
  if (k < Ebits)
   182f8:	04a74e63          	blt	a4,a0,18354 <__b2d+0xac>
    {
      d0 = Exp_1 | y >> (Ebits - k);
   182fc:	00b00793          	li	a5,11
   18300:	40a787b3          	sub	a5,a5,a0
   18304:	3ff00737          	lui	a4,0x3ff00
   18308:	00f955b3          	srl	a1,s2,a5
   1830c:	00e5e6b3          	or	a3,a1,a4
   18310:	00000713          	li	a4,0
      w = xa > xa0 ? *--xa : 0;
   18314:	0134f663          	bleu	s3,s1,18320 <__b2d+0x78>
   18318:	ff842703          	lw	a4,-8(s0)
   1831c:	00f75733          	srl	a4,a4,a5
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
   18320:	01550793          	addi	a5,a0,21
   18324:	00f917b3          	sll	a5,s2,a5
   18328:	00e7e633          	or	a2,a5,a4
#else
#undef d0
#undef d1
#endif
  return d.d;
}
   1832c:	01c12083          	lw	ra,28(sp)
  word1 (d) = d1 >> 16 | d1 << 16;
#else
#undef d0
#undef d1
#endif
  return d.d;
   18330:	00060513          	mv	a0,a2
   18334:	00068593          	mv	a1,a3
}
   18338:	01812403          	lw	s0,24(sp)
   1833c:	01412483          	lw	s1,20(sp)
   18340:	01012903          	lw	s2,16(sp)
   18344:	00c12983          	lw	s3,12(sp)
   18348:	00812a03          	lw	s4,8(sp)
   1834c:	02010113          	addi	sp,sp,32
   18350:	00008067          	ret
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
#endif
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
   18354:	0534f463          	bleu	s3,s1,1839c <__b2d+0xf4>
  if (k -= Ebits)
   18358:	ff550713          	addi	a4,a0,-11
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
#endif
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
   1835c:	ff842503          	lw	a0,-8(s0)
  if (k -= Ebits)
   18360:	04070263          	beqz	a4,183a4 <__b2d+0xfc>
    {
      d0 = Exp_1 | y << k | z >> (32 - k);
   18364:	3ff006b7          	lui	a3,0x3ff00
   18368:	40e787b3          	sub	a5,a5,a4
   1836c:	00e91933          	sll	s2,s2,a4
   18370:	00d96933          	or	s2,s2,a3
   18374:	00f55833          	srl	a6,a0,a5
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
#endif
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
   18378:	ff840593          	addi	a1,s0,-8
  if (k -= Ebits)
    {
      d0 = Exp_1 | y << k | z >> (32 - k);
   1837c:	010966b3          	or	a3,s2,a6
      y = xa > xa0 ? *--xa : 0;
   18380:	04b4f663          	bleu	a1,s1,183cc <__b2d+0x124>
   18384:	ff442583          	lw	a1,-12(s0)
   18388:	00e51533          	sll	a0,a0,a4
   1838c:	00f5d7b3          	srl	a5,a1,a5
   18390:	00a7e533          	or	a0,a5,a0
    }
  else
    {
      d0 = Exp_1 | y;
#ifndef _DOUBLE_IS_32BITS
      d1 = z;
   18394:	00050613          	mv	a2,a0
   18398:	f95ff06f          	j	1832c <__b2d+0x84>
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
#endif
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
  if (k -= Ebits)
   1839c:	ff550513          	addi	a0,a0,-11
   183a0:	00051a63          	bnez	a0,183b4 <__b2d+0x10c>
      d1 = z << k | y >> (32 - k);
#endif
    }
  else
    {
      d0 = Exp_1 | y;
   183a4:	3ff007b7          	lui	a5,0x3ff00
   183a8:	00f966b3          	or	a3,s2,a5
#ifndef _DOUBLE_IS_32BITS
      d1 = z;
   183ac:	00050613          	mv	a2,a0
   183b0:	f7dff06f          	j	1832c <__b2d+0x84>
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
  if (k -= Ebits)
    {
      d0 = Exp_1 | y << k | z >> (32 - k);
   183b4:	00a91933          	sll	s2,s2,a0
   183b8:	3ff007b7          	lui	a5,0x3ff00
   183bc:	00000513          	li	a0,0
   183c0:	00f966b3          	or	a3,s2,a5
    }
  else
    {
      d0 = Exp_1 | y;
#ifndef _DOUBLE_IS_32BITS
      d1 = z;
   183c4:	00050613          	mv	a2,a0
   183c8:	f65ff06f          	j	1832c <__b2d+0x84>
   183cc:	00e51533          	sll	a0,a0,a4
   183d0:	00050613          	mv	a2,a0
   183d4:	f59ff06f          	j	1832c <__b2d+0x84>

000183d8 <__d2b>:
	struct _reent * ptr _AND
	double _d _AND
	int *e _AND
	int *bits)

{
   183d8:	fd010113          	addi	sp,sp,-48
   183dc:	02812423          	sw	s0,40(sp)
#define d1 word1(d)
  d.d = _d;
#endif

#ifdef Pack_32
  b = Balloc (ptr, 1);
   183e0:	00100593          	li	a1,1
  int de, i, k;
  __ULong *x, y, z;
#ifdef VAX
  __ULong d0, d1;
#endif
  d.d = _d;
   183e4:	00068413          	mv	s0,a3
	struct _reent * ptr _AND
	double _d _AND
	int *e _AND
	int *bits)

{
   183e8:	02912223          	sw	s1,36(sp)
   183ec:	03212023          	sw	s2,32(sp)
   183f0:	01312e23          	sw	s3,28(sp)
   183f4:	01412c23          	sw	s4,24(sp)
   183f8:	01512a23          	sw	s5,20(sp)
   183fc:	00078993          	mv	s3,a5
  de = (int) (d0 >> Exp_shift);
#ifndef IBM
  z |= Exp_msk11;
#endif
#else
  if ((de = (int) (d0 >> Exp_shift)) != 0)
   18400:	00141493          	slli	s1,s0,0x1
	struct _reent * ptr _AND
	double _d _AND
	int *e _AND
	int *bits)

{
   18404:	02112623          	sw	ra,44(sp)
   18408:	00070a13          	mv	s4,a4
  int de, i, k;
  __ULong *x, y, z;
#ifdef VAX
  __ULong d0, d1;
#endif
  d.d = _d;
   1840c:	00060a93          	mv	s5,a2
#define d1 word1(d)
  d.d = _d;
#endif

#ifdef Pack_32
  b = Balloc (ptr, 1);
   18410:	b18ff0ef          	jal	17728 <_Balloc>
#else
  b = Balloc (ptr, 2);
#endif
  x = b->_x;

  z = d0 & Frac_mask;
   18414:	001007b7          	lui	a5,0x100
   18418:	fff78693          	addi	a3,a5,-1 # fffff <_gp+0xe0b2f>
  de = (int) (d0 >> Exp_shift);
#ifndef IBM
  z |= Exp_msk11;
#endif
#else
  if ((de = (int) (d0 >> Exp_shift)) != 0)
   1841c:	0154d493          	srli	s1,s1,0x15
#define d1 word1(d)
  d.d = _d;
#endif

#ifdef Pack_32
  b = Balloc (ptr, 1);
   18420:	00050913          	mv	s2,a0
#else
  b = Balloc (ptr, 2);
#endif
  x = b->_x;

  z = d0 & Frac_mask;
   18424:	00d47433          	and	s0,s0,a3
  de = (int) (d0 >> Exp_shift);
#ifndef IBM
  z |= Exp_msk11;
#endif
#else
  if ((de = (int) (d0 >> Exp_shift)) != 0)
   18428:	00048463          	beqz	s1,18430 <__d2b+0x58>
    z |= Exp_msk1;
   1842c:	00f46433          	or	s0,s0,a5
   18430:	00812623          	sw	s0,12(sp)
#endif
#ifdef Pack_32
#ifndef _DOUBLE_IS_32BITS
  if (d1)
   18434:	080a8463          	beqz	s5,184bc <__d2b+0xe4>
    {
      y = d1;
      k = lo0bits (&y);
   18438:	00810513          	addi	a0,sp,8
#endif
#ifdef Pack_32
#ifndef _DOUBLE_IS_32BITS
  if (d1)
    {
      y = d1;
   1843c:	01512423          	sw	s5,8(sp)
      k = lo0bits (&y);
   18440:	e40ff0ef          	jal	17a80 <__lo0bits>
   18444:	00050793          	mv	a5,a0
      if (k)
	{
         x[0] = y | z << (32 - k);
   18448:	00c12703          	lw	a4,12(sp)
#ifndef _DOUBLE_IS_32BITS
  if (d1)
    {
      y = d1;
      k = lo0bits (&y);
      if (k)
   1844c:	0a051663          	bnez	a0,184f8 <__d2b+0x120>
	{
         x[0] = y | z << (32 - k);
	  z >>= k;
	}
      else
	x[0] = y;
   18450:	00812683          	lw	a3,8(sp)
   18454:	00d92a23          	sw	a3,20(s2)
      i = b->_wds = (x[1] = z) ? 2 : 1;
   18458:	00173413          	seqz	s0,a4
   1845c:	00200693          	li	a3,2
   18460:	40868433          	sub	s0,a3,s0
   18464:	00e92c23          	sw	a4,24(s2)
   18468:	00892823          	sw	s0,16(s2)
  while (!x[i])
    --i;
  b->_wds = i + 1;
#endif
#ifndef Sudden_Underflow
  if (de)
   1846c:	06049863          	bnez	s1,184dc <__d2b+0x104>
    }
  else
    {
      *e = de - Bias - (P - 1) + 1 + k;
#ifdef Pack_32
      *bits = 32 * i - hi0bits (x[i - 1]);
   18470:	00241713          	slli	a4,s0,0x2
   18474:	00e90733          	add	a4,s2,a4
   18478:	01072503          	lw	a0,16(a4) # 3ff00010 <_gp+0x3fee0b40>
#endif
#ifndef Sudden_Underflow
    }
  else
    {
      *e = de - Bias - (P - 1) + 1 + k;
   1847c:	bce78793          	addi	a5,a5,-1074
   18480:	00fa2023          	sw	a5,0(s4)
#ifdef Pack_32
      *bits = 32 * i - hi0bits (x[i - 1]);
   18484:	d80ff0ef          	jal	17a04 <__hi0bits>
   18488:	00541413          	slli	s0,s0,0x5
   1848c:	40a40533          	sub	a0,s0,a0
   18490:	00a9a023          	sw	a0,0(s3)
      *bits = (i + 2) * 16 - hi0bits (x[i]);
#endif
    }
#endif
  return b;
}
   18494:	02c12083          	lw	ra,44(sp)
   18498:	00090513          	mv	a0,s2
   1849c:	02812403          	lw	s0,40(sp)
   184a0:	02412483          	lw	s1,36(sp)
   184a4:	02012903          	lw	s2,32(sp)
   184a8:	01c12983          	lw	s3,28(sp)
   184ac:	01812a03          	lw	s4,24(sp)
   184b0:	01412a83          	lw	s5,20(sp)
   184b4:	03010113          	addi	sp,sp,48
   184b8:	00008067          	ret
    {
#ifdef DEBUG
      if (!z)
	Bug ("Zero passed to d2b");
#endif
      k = lo0bits (&z);
   184bc:	00c10513          	addi	a0,sp,12
   184c0:	dc0ff0ef          	jal	17a80 <__lo0bits>
      x[0] = z;
   184c4:	00c12783          	lw	a5,12(sp)
      i = b->_wds = 1;
   184c8:	00100413          	li	s0,1
   184cc:	00892823          	sw	s0,16(s2)
#ifdef DEBUG
      if (!z)
	Bug ("Zero passed to d2b");
#endif
      k = lo0bits (&z);
      x[0] = z;
   184d0:	00f92a23          	sw	a5,20(s2)
      i = b->_wds = 1;
#ifndef _DOUBLE_IS_32BITS
      k += 32;
   184d4:	02050793          	addi	a5,a0,32
  while (!x[i])
    --i;
  b->_wds = i + 1;
#endif
#ifndef Sudden_Underflow
  if (de)
   184d8:	f8048ce3          	beqz	s1,18470 <__d2b+0x98>
#endif
#ifdef IBM
      *e = (de - Bias - (P - 1) << 2) + k;
      *bits = 4 * P + 8 - k - hi0bits (word0 (d) & Frac_mask);
#else
      *e = de - Bias - (P - 1) + k;
   184dc:	bcd48493          	addi	s1,s1,-1075
      *bits = P - k;
   184e0:	03500713          	li	a4,53
#endif
#ifdef IBM
      *e = (de - Bias - (P - 1) << 2) + k;
      *bits = 4 * P + 8 - k - hi0bits (word0 (d) & Frac_mask);
#else
      *e = de - Bias - (P - 1) + k;
   184e4:	00f484b3          	add	s1,s1,a5
      *bits = P - k;
   184e8:	40f707b3          	sub	a5,a4,a5
#endif
#ifdef IBM
      *e = (de - Bias - (P - 1) << 2) + k;
      *bits = 4 * P + 8 - k - hi0bits (word0 (d) & Frac_mask);
#else
      *e = de - Bias - (P - 1) + k;
   184ec:	009a2023          	sw	s1,0(s4)
      *bits = P - k;
   184f0:	00f9a023          	sw	a5,0(s3)
   184f4:	fa1ff06f          	j	18494 <__d2b+0xbc>
    {
      y = d1;
      k = lo0bits (&y);
      if (k)
	{
         x[0] = y | z << (32 - k);
   184f8:	02000693          	li	a3,32
   184fc:	00812603          	lw	a2,8(sp)
   18500:	40a686b3          	sub	a3,a3,a0
   18504:	00d716b3          	sll	a3,a4,a3
   18508:	00c6e6b3          	or	a3,a3,a2
	  z >>= k;
   1850c:	00a75733          	srl	a4,a4,a0
    {
      y = d1;
      k = lo0bits (&y);
      if (k)
	{
         x[0] = y | z << (32 - k);
   18510:	00d92a23          	sw	a3,20(s2)
	  z >>= k;
   18514:	00e12623          	sw	a4,12(sp)
   18518:	f41ff06f          	j	18458 <__d2b+0x80>

0001851c <__ratio>:
#undef d1

double
_DEFUN (ratio, (a, b), _Bigint * a _AND _Bigint * b)

{
   1851c:	fd010113          	addi	sp,sp,-48
   18520:	03212023          	sw	s2,32(sp)
   18524:	00058913          	mv	s2,a1
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
   18528:	00810593          	addi	a1,sp,8
#undef d1

double
_DEFUN (ratio, (a, b), _Bigint * a _AND _Bigint * b)

{
   1852c:	02112623          	sw	ra,44(sp)
   18530:	02812423          	sw	s0,40(sp)
   18534:	02912223          	sw	s1,36(sp)
   18538:	01312e23          	sw	s3,28(sp)
   1853c:	00050993          	mv	s3,a0
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
   18540:	d69ff0ef          	jal	182a8 <__b2d>
   18544:	00050413          	mv	s0,a0
   18548:	00058493          	mv	s1,a1
  db.d = b2d (b, &kb);
   1854c:	00090513          	mv	a0,s2
   18550:	00c10593          	addi	a1,sp,12
   18554:	d55ff0ef          	jal	182a8 <__b2d>
#ifdef Pack_32
  k = ka - kb + 32 * (a->_wds - b->_wds);
   18558:	01092703          	lw	a4,16(s2)
   1855c:	0109a783          	lw	a5,16(s3)
{
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
  db.d = b2d (b, &kb);
   18560:	00058693          	mv	a3,a1
#ifdef Pack_32
  k = ka - kb + 32 * (a->_wds - b->_wds);
   18564:	00c12583          	lw	a1,12(sp)
   18568:	40e787b3          	sub	a5,a5,a4
   1856c:	00579713          	slli	a4,a5,0x5
   18570:	00812783          	lw	a5,8(sp)
{
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
  db.d = b2d (b, &kb);
   18574:	00050613          	mv	a2,a0
#ifdef Pack_32
  k = ka - kb + 32 * (a->_wds - b->_wds);
   18578:	40b787b3          	sub	a5,a5,a1
   1857c:	00f707b3          	add	a5,a4,a5
      word0 (db) += (k >> 2) * Exp_msk1;
      if (k &= 3)
	db.d *= 1 << k;
    }
#else
  if (k > 0)
   18580:	02f05c63          	blez	a5,185b8 <__ratio+0x9c>
    word0 (da) += k * Exp_msk1;
   18584:	01479793          	slli	a5,a5,0x14
   18588:	009785b3          	add	a1,a5,s1
   1858c:	00058493          	mv	s1,a1
    {
      k = -k;
      word0 (db) += k * Exp_msk1;
    }
#endif
  return da.d / db.d;
   18590:	00040513          	mv	a0,s0
   18594:	00048593          	mv	a1,s1
   18598:	4ad020ef          	jal	1b244 <__divdf3>
}
   1859c:	02c12083          	lw	ra,44(sp)
   185a0:	02812403          	lw	s0,40(sp)
   185a4:	02412483          	lw	s1,36(sp)
   185a8:	02012903          	lw	s2,32(sp)
   185ac:	01c12983          	lw	s3,28(sp)
   185b0:	03010113          	addi	sp,sp,48
   185b4:	00008067          	ret
  if (k > 0)
    word0 (da) += k * Exp_msk1;
  else
    {
      k = -k;
      word0 (db) += k * Exp_msk1;
   185b8:	01479793          	slli	a5,a5,0x14
   185bc:	40f688b3          	sub	a7,a3,a5
   185c0:	00088693          	mv	a3,a7
   185c4:	fcdff06f          	j	18590 <__ratio+0x74>

000185c8 <_mprec_log10>:


double
_DEFUN (_mprec_log10, (dig),
	int dig)
{
   185c8:	ff010113          	addi	sp,sp,-16
  double v = 1.0;
  if (dig < 24)
   185cc:	01700793          	li	a5,23


double
_DEFUN (_mprec_log10, (dig),
	int dig)
{
   185d0:	00812423          	sw	s0,8(sp)
   185d4:	00112623          	sw	ra,12(sp)
   185d8:	01212223          	sw	s2,4(sp)
   185dc:	01312023          	sw	s3,0(sp)
   185e0:	00050413          	mv	s0,a0
  double v = 1.0;
  if (dig < 24)
   185e4:	04a7d063          	ble	a0,a5,18624 <_mprec_log10+0x5c>
   185e8:	8481a503          	lw	a0,-1976(gp) # 1ed18 <__wctomb+0x28>
   185ec:	84c1a583          	lw	a1,-1972(gp) # 1ed1c <__wctomb+0x2c>
    return tens[dig];
  while (dig > 0)
    {
      v *= 10;
   185f0:	8501a903          	lw	s2,-1968(gp) # 1ed20 <__wctomb+0x30>
   185f4:	8541a983          	lw	s3,-1964(gp) # 1ed24 <__wctomb+0x34>
      dig--;
   185f8:	fff40413          	addi	s0,s0,-1
  double v = 1.0;
  if (dig < 24)
    return tens[dig];
  while (dig > 0)
    {
      v *= 10;
   185fc:	00090613          	mv	a2,s2
   18600:	00098693          	mv	a3,s3
   18604:	1dd020ef          	jal	1afe0 <__muldf3>
	int dig)
{
  double v = 1.0;
  if (dig < 24)
    return tens[dig];
  while (dig > 0)
   18608:	fe0418e3          	bnez	s0,185f8 <_mprec_log10+0x30>
    {
      v *= 10;
      dig--;
    }
  return v;
}
   1860c:	00c12083          	lw	ra,12(sp)
   18610:	00812403          	lw	s0,8(sp)
   18614:	00412903          	lw	s2,4(sp)
   18618:	00012983          	lw	s3,0(sp)
   1861c:	01010113          	addi	sp,sp,16
   18620:	00008067          	ret
_DEFUN (_mprec_log10, (dig),
	int dig)
{
  double v = 1.0;
  if (dig < 24)
    return tens[dig];
   18624:	0001d7b7          	lui	a5,0x1d
   18628:	00351413          	slli	s0,a0,0x3
   1862c:	90878793          	addi	a5,a5,-1784 # 1c908 <p05.2565>
   18630:	00878433          	add	s0,a5,s0
   18634:	01042503          	lw	a0,16(s0)
   18638:	01442583          	lw	a1,20(s0)
   1863c:	fd1ff06f          	j	1860c <_mprec_log10+0x44>

00018640 <__copybits>:
#endif

	ce = c + ((n-1) >> kshift) + 1;
	x = b->_x;
#ifdef Pack_32
	xe = x + b->_wds;
   18640:	01062683          	lw	a3,16(a2)
	__ULong *ce, *x, *xe;
#ifdef Pack_16
	int nw, nw1;
#endif

	ce = c + ((n-1) >> kshift) + 1;
   18644:	fff58593          	addi	a1,a1,-1
   18648:	4055d813          	srai	a6,a1,0x5
   1864c:	00180813          	addi	a6,a6,1
	x = b->_x;
   18650:	01460793          	addi	a5,a2,20
#ifdef Pack_32
	xe = x + b->_wds;
   18654:	00269693          	slli	a3,a3,0x2
	__ULong *ce, *x, *xe;
#ifdef Pack_16
	int nw, nw1;
#endif

	ce = c + ((n-1) >> kshift) + 1;
   18658:	00281813          	slli	a6,a6,0x2
	x = b->_x;
#ifdef Pack_32
	xe = x + b->_wds;
   1865c:	00d786b3          	add	a3,a5,a3
	__ULong *ce, *x, *xe;
#ifdef Pack_16
	int nw, nw1;
#endif

	ce = c + ((n-1) >> kshift) + 1;
   18660:	01050833          	add	a6,a0,a6
	x = b->_x;
#ifdef Pack_32
	xe = x + b->_wds;
	while(x < xe)
   18664:	02d7f863          	bleu	a3,a5,18694 <__copybits+0x54>
   18668:	00050713          	mv	a4,a0
		*c++ = *x++;
   1866c:	00478793          	addi	a5,a5,4
   18670:	ffc7a583          	lw	a1,-4(a5)
   18674:	00470713          	addi	a4,a4,4
   18678:	feb72e23          	sw	a1,-4(a4)

	ce = c + ((n-1) >> kshift) + 1;
	x = b->_x;
#ifdef Pack_32
	xe = x + b->_wds;
	while(x < xe)
   1867c:	fed7e8e3          	bltu	a5,a3,1866c <__copybits+0x2c>
   18680:	40c687b3          	sub	a5,a3,a2
   18684:	feb78793          	addi	a5,a5,-21
   18688:	ffc7f793          	andi	a5,a5,-4
   1868c:	00478793          	addi	a5,a5,4
   18690:	00f50533          	add	a0,a0,a5
	for(xe = x + (nw - nw1); x < xe; x += 2)
		Storeinc(c, x[1], x[0]);
	if (nw1)
		*c++ = *x;
#endif
	while(c < ce)
   18694:	01057863          	bleu	a6,a0,186a4 <__copybits+0x64>
		*c++ = 0;
   18698:	00450513          	addi	a0,a0,4
   1869c:	fe052e23          	sw	zero,-4(a0)
	for(xe = x + (nw - nw1); x < xe; x += 2)
		Storeinc(c, x[1], x[0]);
	if (nw1)
		*c++ = *x;
#endif
	while(c < ce)
   186a0:	ff056ce3          	bltu	a0,a6,18698 <__copybits+0x58>
   186a4:	00008067          	ret

000186a8 <__any_on>:
{
	int n, nwds;
	__ULong *x, *x0, x1, x2;

	x = b->_x;
	nwds = b->_wds;
   186a8:	01052783          	lw	a5,16(a0)
	n = k >> kshift;
   186ac:	4055d713          	srai	a4,a1,0x5
	int k)
{
	int n, nwds;
	__ULong *x, *x0, x1, x2;

	x = b->_x;
   186b0:	01450693          	addi	a3,a0,20
	nwds = b->_wds;
	n = k >> kshift;
	if (n > nwds)
   186b4:	02e7da63          	ble	a4,a5,186e8 <__any_on+0x40>
   186b8:	00279793          	slli	a5,a5,0x2
   186bc:	00f687b3          	add	a5,a3,a5
		if (x1 != x2)
			return 1;
		}
	x0 = x;
	x += n;
	while(x > x0)
   186c0:	06f6f263          	bleu	a5,a3,18724 <__any_on+0x7c>
		if (*--x)
   186c4:	ffc7a503          	lw	a0,-4(a5)
   186c8:	ffc78793          	addi	a5,a5,-4
   186cc:	00051a63          	bnez	a0,186e0 <__any_on+0x38>
		if (x1 != x2)
			return 1;
		}
	x0 = x;
	x += n;
	while(x > x0)
   186d0:	04f6f863          	bleu	a5,a3,18720 <__any_on+0x78>
		if (*--x)
   186d4:	ffc78793          	addi	a5,a5,-4
   186d8:	0007a703          	lw	a4,0(a5)
   186dc:	fe070ae3          	beqz	a4,186d0 <__any_on+0x28>
	else if (n < nwds && (k &= kmask)) {
		x1 = x2 = x[n];
		x1 >>= k;
		x1 <<= k;
		if (x1 != x2)
			return 1;
   186e0:	00100513          	li	a0,1
	x += n;
	while(x > x0)
		if (*--x)
			return 1;
	return 0;
}
   186e4:	00008067          	ret
	x = b->_x;
	nwds = b->_wds;
	n = k >> kshift;
	if (n > nwds)
		n = nwds;
	else if (n < nwds && (k &= kmask)) {
   186e8:	02f75663          	ble	a5,a4,18714 <__any_on+0x6c>
		x1 = x2 = x[n];
   186ec:	00271793          	slli	a5,a4,0x2
	x = b->_x;
	nwds = b->_wds;
	n = k >> kshift;
	if (n > nwds)
		n = nwds;
	else if (n < nwds && (k &= kmask)) {
   186f0:	01f5f593          	andi	a1,a1,31
		x1 = x2 = x[n];
   186f4:	00f687b3          	add	a5,a3,a5
	x = b->_x;
	nwds = b->_wds;
	n = k >> kshift;
	if (n > nwds)
		n = nwds;
	else if (n < nwds && (k &= kmask)) {
   186f8:	fc0584e3          	beqz	a1,186c0 <__any_on+0x18>
		x1 = x2 = x[n];
   186fc:	0007a603          	lw	a2,0(a5)
		x1 >>= k;
		x1 <<= k;
		if (x1 != x2)
			return 1;
   18700:	00100513          	li	a0,1
	n = k >> kshift;
	if (n > nwds)
		n = nwds;
	else if (n < nwds && (k &= kmask)) {
		x1 = x2 = x[n];
		x1 >>= k;
   18704:	00b65733          	srl	a4,a2,a1
		x1 <<= k;
		if (x1 != x2)
   18708:	00b715b3          	sll	a1,a4,a1
   1870c:	fab60ae3          	beq	a2,a1,186c0 <__any_on+0x18>
	x += n;
	while(x > x0)
		if (*--x)
			return 1;
	return 0;
}
   18710:	00008067          	ret
   18714:	00271793          	slli	a5,a4,0x2
   18718:	00f687b3          	add	a5,a3,a5
   1871c:	fa5ff06f          	j	186c0 <__any_on+0x18>
   18720:	00008067          	ret
	x0 = x;
	x += n;
	while(x > x0)
		if (*--x)
			return 1;
	return 0;
   18724:	00000513          	li	a0,0
   18728:	00008067          	ret

0001872c <_realloc_r>:
#if __STD_C
Void_t* rEALLOc(RARG Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(RARG oldmem, bytes) RDECL Void_t* oldmem; size_t bytes;
#endif
{
   1872c:	fd010113          	addi	sp,sp,-48
   18730:	01312e23          	sw	s3,28(sp)
   18734:	02112623          	sw	ra,44(sp)
   18738:	02812423          	sw	s0,40(sp)
   1873c:	02912223          	sw	s1,36(sp)
   18740:	03212023          	sw	s2,32(sp)
   18744:	01412c23          	sw	s4,24(sp)
   18748:	01512a23          	sw	s5,20(sp)
   1874c:	01612823          	sw	s6,16(sp)
   18750:	01712623          	sw	s7,12(sp)
   18754:	01812423          	sw	s8,8(sp)
   18758:	01912223          	sw	s9,4(sp)
   1875c:	00060993          	mv	s3,a2
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
   18760:	1c058863          	beqz	a1,18930 <_realloc_r+0x204>
   18764:	00058a13          	mv	s4,a1
   18768:	00050493          	mv	s1,a0

  MALLOC_LOCK;
   1876c:	fb5fe0ef          	jal	17720 <__malloc_lock>

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
   18770:	ffca2783          	lw	a5,-4(s4)


  nb = request2size(bytes);
   18774:	00b98713          	addi	a4,s3,11
   18778:	01600693          	li	a3,22
  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);

  MALLOC_LOCK;

  newp    = oldp    = mem2chunk(oldmem);
   1877c:	ff8a0b13          	addi	s6,s4,-8
  newsize = oldsize = chunksize(oldp);
   18780:	ffc7fa93          	andi	s5,a5,-4


  nb = request2size(bytes);
   18784:	0ce6f263          	bleu	a4,a3,18848 <_realloc_r+0x11c>
   18788:	ff877913          	andi	s2,a4,-8

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   1878c:	00090713          	mv	a4,s2
   18790:	14094c63          	bltz	s2,188e8 <_realloc_r+0x1bc>
   18794:	15396a63          	bltu	s2,s3,188e8 <_realloc_r+0x1bc>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
   18798:	0aeade63          	ble	a4,s5,18854 <_realloc_r+0x128>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next)) 
   1879c:	0001fc37          	lui	s8,0x1f
   187a0:	8c8c0c13          	addi	s8,s8,-1848 # 1e8c8 <__malloc_av_>
   187a4:	008c2683          	lw	a3,8(s8)
  if ((long)(oldsize) < (long)(nb))  
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
   187a8:	015b0533          	add	a0,s6,s5
    if (next == top || !inuse(next)) 
   187ac:	30d50263          	beq	a0,a3,18ab0 <_realloc_r+0x384>
   187b0:	00452683          	lw	a3,4(a0)
   187b4:	ffe6f613          	andi	a2,a3,-2
   187b8:	00c50633          	add	a2,a0,a2
   187bc:	00462603          	lw	a2,4(a2)
   187c0:	00167613          	andi	a2,a2,1
   187c4:	0e060e63          	beqz	a2,188c0 <_realloc_r+0x194>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   187c8:	0017f793          	andi	a5,a5,1
   187cc:	26078463          	beqz	a5,18a34 <_realloc_r+0x308>
      }
    }

    /* Must allocate */

    newmem = mALLOc (RCALL bytes);
   187d0:	00098593          	mv	a1,s3
   187d4:	00048513          	mv	a0,s1
   187d8:	d00fe0ef          	jal	16cd8 <_malloc_r>
   187dc:	00050413          	mv	s0,a0

    if (newmem == 0)  /* propagate failure */
   187e0:	4a050463          	beqz	a0,18c88 <_realloc_r+0x55c>
    }

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
   187e4:	ffca2783          	lw	a5,-4(s4)
   187e8:	ff850693          	addi	a3,a0,-8
   187ec:	ffe7f713          	andi	a4,a5,-2
   187f0:	00eb0733          	add	a4,s6,a4
   187f4:	42e68463          	beq	a3,a4,18c1c <_realloc_r+0x4f0>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   187f8:	ffca8613          	addi	a2,s5,-4
   187fc:	02400793          	li	a5,36
   18800:	3cc7ea63          	bltu	a5,a2,18bd4 <_realloc_r+0x4a8>
   18804:	01300713          	li	a4,19
   18808:	36c76a63          	bltu	a4,a2,18b7c <_realloc_r+0x450>
   1880c:	00050793          	mv	a5,a0
   18810:	000a0713          	mv	a4,s4
   18814:	00072683          	lw	a3,0(a4)
   18818:	00d7a023          	sw	a3,0(a5)
   1881c:	00472683          	lw	a3,4(a4)
   18820:	00d7a223          	sw	a3,4(a5)
   18824:	00872703          	lw	a4,8(a4)
   18828:	00e7a423          	sw	a4,8(a5)
    fREe(RCALL oldmem);
   1882c:	000a0593          	mv	a1,s4
   18830:	00048513          	mv	a0,s1
   18834:	969fd0ef          	jal	1619c <_free_r>
    MALLOC_UNLOCK;
   18838:	00048513          	mv	a0,s1
   1883c:	ee9fe0ef          	jal	17724 <__malloc_unlock>
    return newmem;
   18840:	00040513          	mv	a0,s0
   18844:	0480006f          	j	1888c <_realloc_r+0x160>


  nb = request2size(bytes);

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   18848:	01000713          	li	a4,16

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);


  nb = request2size(bytes);
   1884c:	00070913          	mv	s2,a4
   18850:	f45ff06f          	j	18794 <_realloc_r+0x68>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
   18854:	000a0993          	mv	s3,s4
  }


 split:  /* split off extra room in old or expanded chunk */

  remainder_size = long_sub_size_t(newsize, nb);
   18858:	412a86b3          	sub	a3,s5,s2

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
   1885c:	00f00713          	li	a4,15
   18860:	08d76c63          	bltu	a4,a3,188f8 <_realloc_r+0x1cc>
    set_inuse_bit_at_offset(remainder, remainder_size);
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
  }
  else
  {
    set_head_size(newp, newsize);
   18864:	0017f793          	andi	a5,a5,1
   18868:	0157e7b3          	or	a5,a5,s5
   1886c:	00fb2223          	sw	a5,4(s6)
    set_inuse_bit_at_offset(newp, newsize);
   18870:	015b0633          	add	a2,s6,s5
   18874:	00462783          	lw	a5,4(a2)
   18878:	0017e793          	ori	a5,a5,1
   1887c:	00f62223          	sw	a5,4(a2)
  }

  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
   18880:	00048513          	mv	a0,s1
   18884:	ea1fe0ef          	jal	17724 <__malloc_unlock>
  return chunk2mem(newp);
   18888:	00098513          	mv	a0,s3

#endif /* MALLOC_PROVIDED */
}
   1888c:	02c12083          	lw	ra,44(sp)
   18890:	02812403          	lw	s0,40(sp)
   18894:	02412483          	lw	s1,36(sp)
   18898:	02012903          	lw	s2,32(sp)
   1889c:	01c12983          	lw	s3,28(sp)
   188a0:	01812a03          	lw	s4,24(sp)
   188a4:	01412a83          	lw	s5,20(sp)
   188a8:	01012b03          	lw	s6,16(sp)
   188ac:	00c12b83          	lw	s7,12(sp)
   188b0:	00812c03          	lw	s8,8(sp)
   188b4:	00412c83          	lw	s9,4(sp)
   188b8:	03010113          	addi	sp,sp,48
   188bc:	00008067          	ret
          return chunk2mem(oldp);
        }
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
   188c0:	ffc6f693          	andi	a3,a3,-4
   188c4:	015686b3          	add	a3,a3,s5
   188c8:	0ae6c063          	blt	a3,a4,18968 <_realloc_r+0x23c>
      { 
        unlink(next, bck, fwd);
   188cc:	00c52703          	lw	a4,12(a0)
   188d0:	00852603          	lw	a2,8(a0)
        newsize  += nextsize;
        goto split;
   188d4:	000a0993          	mv	s3,s4

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
      { 
        unlink(next, bck, fwd);
        newsize  += nextsize;
   188d8:	00068a93          	mv	s5,a3
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
      { 
        unlink(next, bck, fwd);
   188dc:	00e62623          	sw	a4,12(a2)
   188e0:	00c72423          	sw	a2,8(a4)
        newsize  += nextsize;
        goto split;
   188e4:	f75ff06f          	j	18858 <_realloc_r+0x12c>
  nb = request2size(bytes);

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
  {
    RERRNO = ENOMEM;
   188e8:	00c00793          	li	a5,12
   188ec:	00f4a023          	sw	a5,0(s1)
    return 0;
   188f0:	00000513          	li	a0,0
   188f4:	f99ff06f          	j	1888c <_realloc_r+0x160>
  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
   188f8:	0017f713          	andi	a4,a5,1

  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
   188fc:	012b05b3          	add	a1,s6,s2
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
   18900:	0016e793          	ori	a5,a3,1
  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
   18904:	01276733          	or	a4,a4,s2
   18908:	00eb2223          	sw	a4,4(s6)
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
   1890c:	00d586b3          	add	a3,a1,a3

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
   18910:	00f5a223          	sw	a5,4(a1)
    set_inuse_bit_at_offset(remainder, remainder_size);
   18914:	0046a783          	lw	a5,4(a3) # 3ff00004 <_gp+0x3fee0b34>
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
   18918:	00858593          	addi	a1,a1,8
   1891c:	00048513          	mv	a0,s1
  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
   18920:	0017e793          	ori	a5,a5,1
   18924:	00f6a223          	sw	a5,4(a3)
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
   18928:	875fd0ef          	jal	1619c <_free_r>
   1892c:	f55ff06f          	j	18880 <_realloc_r+0x154>
  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
  return chunk2mem(newp);

#endif /* MALLOC_PROVIDED */
}
   18930:	02c12083          	lw	ra,44(sp)
   18934:	02812403          	lw	s0,40(sp)
   18938:	02412483          	lw	s1,36(sp)
   1893c:	02012903          	lw	s2,32(sp)
   18940:	01c12983          	lw	s3,28(sp)
   18944:	01812a03          	lw	s4,24(sp)
   18948:	01412a83          	lw	s5,20(sp)
   1894c:	01012b03          	lw	s6,16(sp)
   18950:	00c12b83          	lw	s7,12(sp)
   18954:	00812c03          	lw	s8,8(sp)
   18958:	00412c83          	lw	s9,4(sp)
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
   1895c:	00060593          	mv	a1,a2
  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
  return chunk2mem(newp);

#endif /* MALLOC_PROVIDED */
}
   18960:	03010113          	addi	sp,sp,48
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
   18964:	b74fe06f          	j	16cd8 <_malloc_r>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   18968:	0017f793          	andi	a5,a5,1
   1896c:	e60792e3          	bnez	a5,187d0 <_realloc_r+0xa4>
    {
      prev = prev_chunk(oldp);
   18970:	ff8a2b83          	lw	s7,-8(s4)
   18974:	417b0bb3          	sub	s7,s6,s7
      prevsize = chunksize(prev);
   18978:	004ba783          	lw	a5,4(s7)
   1897c:	ffc7f793          	andi	a5,a5,-4
            return newmem;
          }
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
   18980:	00f68433          	add	s0,a3,a5
   18984:	0ce44063          	blt	s0,a4,18a44 <_realloc_r+0x318>
        {
          unlink(next, bck, fwd);
   18988:	00c52783          	lw	a5,12(a0)
   1898c:	00852703          	lw	a4,8(a0)
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18990:	ffca8613          	addi	a2,s5,-4
        {
          unlink(next, bck, fwd);
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
   18994:	008b8993          	addi	s3,s7,8
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
        {
          unlink(next, bck, fwd);
   18998:	00f72623          	sw	a5,12(a4)
   1899c:	00e7a423          	sw	a4,8(a5)
          unlink(prev, bck, fwd);
   189a0:	008ba703          	lw	a4,8(s7)
   189a4:	00cba783          	lw	a5,12(s7)
   189a8:	00f72623          	sw	a5,12(a4)
   189ac:	00e7a423          	sw	a4,8(a5)
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   189b0:	02400793          	li	a5,36
   189b4:	22c7e663          	bltu	a5,a2,18be0 <_realloc_r+0x4b4>
   189b8:	01300713          	li	a4,19
   189bc:	00098793          	mv	a5,s3
   189c0:	04c77663          	bleu	a2,a4,18a0c <_realloc_r+0x2e0>
   189c4:	000a2783          	lw	a5,0(s4)
   189c8:	00fba423          	sw	a5,8(s7)
   189cc:	004a2783          	lw	a5,4(s4)
   189d0:	00fba623          	sw	a5,12(s7)
   189d4:	01b00793          	li	a5,27
   189d8:	24c7fc63          	bleu	a2,a5,18c30 <_realloc_r+0x504>
   189dc:	008a2783          	lw	a5,8(s4)
   189e0:	00fba823          	sw	a5,16(s7)
   189e4:	00ca2783          	lw	a5,12(s4)
   189e8:	00fbaa23          	sw	a5,20(s7)
   189ec:	02400793          	li	a5,36
   189f0:	0af61a63          	bne	a2,a5,18aa4 <_realloc_r+0x378>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   189f4:	010a2703          	lw	a4,16(s4)
   189f8:	020b8793          	addi	a5,s7,32
   189fc:	018a0a13          	addi	s4,s4,24
   18a00:	00ebac23          	sw	a4,24(s7)
   18a04:	ffca2703          	lw	a4,-4(s4)
   18a08:	00ebae23          	sw	a4,28(s7)
   18a0c:	000a2703          	lw	a4,0(s4)
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
   18a10:	00040a93          	mv	s5,s0
   18a14:	000b8b13          	mv	s6,s7
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18a18:	00e7a023          	sw	a4,0(a5)
   18a1c:	004a2703          	lw	a4,4(s4)
   18a20:	00e7a223          	sw	a4,4(a5)
   18a24:	008a2703          	lw	a4,8(s4)
   18a28:	00e7a423          	sw	a4,8(a5)
   18a2c:	004ba783          	lw	a5,4(s7)
   18a30:	e29ff06f          	j	18858 <_realloc_r+0x12c>

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
    {
      prev = prev_chunk(oldp);
   18a34:	ff8a2b83          	lw	s7,-8(s4)
   18a38:	417b0bb3          	sub	s7,s6,s7
      prevsize = chunksize(prev);
   18a3c:	004ba783          	lw	a5,4(s7)
   18a40:	ffc7f793          	andi	a5,a5,-4
          goto split;
        }
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
   18a44:	00fa8433          	add	s0,s5,a5
   18a48:	d8e444e3          	blt	s0,a4,187d0 <_realloc_r+0xa4>
      {
        unlink(prev, bck, fwd);
   18a4c:	00cba783          	lw	a5,12(s7)
   18a50:	008ba703          	lw	a4,8(s7)
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18a54:	ffca8613          	addi	a2,s5,-4
   18a58:	02400693          	li	a3,36
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
   18a5c:	00f72623          	sw	a5,12(a4)
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
   18a60:	008b8993          	addi	s3,s7,8
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
   18a64:	00e7a423          	sw	a4,8(a5)
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18a68:	16c6ec63          	bltu	a3,a2,18be0 <_realloc_r+0x4b4>
   18a6c:	01300713          	li	a4,19
   18a70:	00098793          	mv	a5,s3
   18a74:	f8c77ce3          	bleu	a2,a4,18a0c <_realloc_r+0x2e0>
   18a78:	000a2783          	lw	a5,0(s4)
   18a7c:	00fba423          	sw	a5,8(s7)
   18a80:	004a2783          	lw	a5,4(s4)
   18a84:	00fba623          	sw	a5,12(s7)
   18a88:	01b00793          	li	a5,27
   18a8c:	1ac7f263          	bleu	a2,a5,18c30 <_realloc_r+0x504>
   18a90:	008a2783          	lw	a5,8(s4)
   18a94:	00fba823          	sw	a5,16(s7)
   18a98:	00ca2783          	lw	a5,12(s4)
   18a9c:	00fbaa23          	sw	a5,20(s7)
   18aa0:	f4d60ae3          	beq	a2,a3,189f4 <_realloc_r+0x2c8>
   18aa4:	018b8793          	addi	a5,s7,24
   18aa8:	010a0a13          	addi	s4,s4,16
   18aac:	f61ff06f          	j	18a0c <_realloc_r+0x2e0>
      nextsize = chunksize(next);

      /* Forward into top only if a remainder */
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
   18ab0:	00452683          	lw	a3,4(a0)
   18ab4:	01090613          	addi	a2,s2,16
   18ab8:	ffc6f693          	andi	a3,a3,-4
   18abc:	015686b3          	add	a3,a3,s5
   18ac0:	0ec6d063          	ble	a2,a3,18ba0 <_realloc_r+0x474>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   18ac4:	0017f793          	andi	a5,a5,1
   18ac8:	d00794e3          	bnez	a5,187d0 <_realloc_r+0xa4>
    {
      prev = prev_chunk(oldp);
   18acc:	ff8a2b83          	lw	s7,-8(s4)
   18ad0:	417b0bb3          	sub	s7,s6,s7
      prevsize = chunksize(prev);
   18ad4:	004ba783          	lw	a5,4(s7)
   18ad8:	ffc7f793          	andi	a5,a5,-4
      if (next != 0)
      {
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
   18adc:	00d78cb3          	add	s9,a5,a3
   18ae0:	f6ccc2e3          	blt	s9,a2,18a44 <_realloc_r+0x318>
          {
            unlink(prev, bck, fwd);
   18ae4:	00cba783          	lw	a5,12(s7)
   18ae8:	008ba703          	lw	a4,8(s7)
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18aec:	ffca8613          	addi	a2,s5,-4
   18af0:	02400693          	li	a3,36
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
          {
            unlink(prev, bck, fwd);
   18af4:	00f72623          	sw	a5,12(a4)
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
   18af8:	008b8413          	addi	s0,s7,8
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
          {
            unlink(prev, bck, fwd);
   18afc:	00e7a423          	sw	a4,8(a5)
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18b00:	14c6ec63          	bltu	a3,a2,18c58 <_realloc_r+0x52c>
   18b04:	01300713          	li	a4,19
   18b08:	00040793          	mv	a5,s0
   18b0c:	02c77263          	bleu	a2,a4,18b30 <_realloc_r+0x404>
   18b10:	000a2783          	lw	a5,0(s4)
   18b14:	00fba423          	sw	a5,8(s7)
   18b18:	004a2783          	lw	a5,4(s4)
   18b1c:	00fba623          	sw	a5,12(s7)
   18b20:	01b00793          	li	a5,27
   18b24:	14c7e263          	bltu	a5,a2,18c68 <_realloc_r+0x53c>
   18b28:	010b8793          	addi	a5,s7,16
   18b2c:	008a0a13          	addi	s4,s4,8
   18b30:	000a2703          	lw	a4,0(s4)
   18b34:	00e7a023          	sw	a4,0(a5)
   18b38:	004a2703          	lw	a4,4(s4)
   18b3c:	00e7a223          	sw	a4,4(a5)
   18b40:	008a2703          	lw	a4,8(s4)
   18b44:	00e7a423          	sw	a4,8(a5)
            top = chunk_at_offset(newp, nb);
            set_head(top, (newsize - nb) | PREV_INUSE);
   18b48:	412c86b3          	sub	a3,s9,s2
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
   18b4c:	012b87b3          	add	a5,s7,s2
            set_head(top, (newsize - nb) | PREV_INUSE);
   18b50:	0016e693          	ori	a3,a3,1
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
   18b54:	00fc2423          	sw	a5,8(s8)
            set_head(top, (newsize - nb) | PREV_INUSE);
   18b58:	00d7a223          	sw	a3,4(a5)
            set_head_size(newp, nb);
   18b5c:	004ba703          	lw	a4,4(s7)
	    MALLOC_UNLOCK;
   18b60:	00048513          	mv	a0,s1
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
            set_head(top, (newsize - nb) | PREV_INUSE);
            set_head_size(newp, nb);
   18b64:	00177713          	andi	a4,a4,1
   18b68:	01276733          	or	a4,a4,s2
   18b6c:	00eba223          	sw	a4,4(s7)
	    MALLOC_UNLOCK;
   18b70:	bb5fe0ef          	jal	17724 <__malloc_unlock>
            return newmem;
   18b74:	00040513          	mv	a0,s0
   18b78:	d15ff06f          	j	1888c <_realloc_r+0x160>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18b7c:	000a2703          	lw	a4,0(s4)
   18b80:	00e52023          	sw	a4,0(a0)
   18b84:	004a2703          	lw	a4,4(s4)
   18b88:	00e52223          	sw	a4,4(a0)
   18b8c:	01b00713          	li	a4,27
   18b90:	06c76663          	bltu	a4,a2,18bfc <_realloc_r+0x4d0>
   18b94:	00850793          	addi	a5,a0,8
   18b98:	008a0713          	addi	a4,s4,8
   18b9c:	c79ff06f          	j	18814 <_realloc_r+0xe8>
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
          set_head(top, (newsize - nb) | PREV_INUSE);
   18ba0:	412686b3          	sub	a3,a3,s2
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
   18ba4:	012b0b33          	add	s6,s6,s2
          set_head(top, (newsize - nb) | PREV_INUSE);
   18ba8:	0016e693          	ori	a3,a3,1
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
   18bac:	016c2423          	sw	s6,8(s8)
          set_head(top, (newsize - nb) | PREV_INUSE);
   18bb0:	00db2223          	sw	a3,4(s6)
          set_head_size(oldp, nb);
   18bb4:	ffca2703          	lw	a4,-4(s4)
	  MALLOC_UNLOCK;
   18bb8:	00048513          	mv	a0,s1
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
          set_head(top, (newsize - nb) | PREV_INUSE);
          set_head_size(oldp, nb);
   18bbc:	00177713          	andi	a4,a4,1
   18bc0:	01276733          	or	a4,a4,s2
   18bc4:	feea2e23          	sw	a4,-4(s4)
	  MALLOC_UNLOCK;
   18bc8:	b5dfe0ef          	jal	17724 <__malloc_unlock>
          return chunk2mem(oldp);
   18bcc:	000a0513          	mv	a0,s4
   18bd0:	cbdff06f          	j	1888c <_realloc_r+0x160>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18bd4:	000a0593          	mv	a1,s4
   18bd8:	94dfe0ef          	jal	17524 <memmove>
   18bdc:	c51ff06f          	j	1882c <_realloc_r+0x100>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18be0:	000a0593          	mv	a1,s4
   18be4:	00098513          	mv	a0,s3
   18be8:	93dfe0ef          	jal	17524 <memmove>
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
   18bec:	00040a93          	mv	s5,s0
   18bf0:	004ba783          	lw	a5,4(s7)
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18bf4:	000b8b13          	mv	s6,s7
   18bf8:	c61ff06f          	j	18858 <_realloc_r+0x12c>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18bfc:	008a2703          	lw	a4,8(s4)
   18c00:	00e52423          	sw	a4,8(a0)
   18c04:	00ca2703          	lw	a4,12(s4)
   18c08:	00e52623          	sw	a4,12(a0)
   18c0c:	02f60863          	beq	a2,a5,18c3c <_realloc_r+0x510>
   18c10:	01050793          	addi	a5,a0,16
   18c14:	010a0713          	addi	a4,s4,16
   18c18:	bfdff06f          	j	18814 <_realloc_r+0xe8>
    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
    {
      newsize += chunksize(newp);
   18c1c:	ffc52703          	lw	a4,-4(a0)
      newp = oldp;
      goto split;
   18c20:	000a0993          	mv	s3,s4
    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
    {
      newsize += chunksize(newp);
   18c24:	ffc77713          	andi	a4,a4,-4
   18c28:	00ea8ab3          	add	s5,s5,a4
      newp = oldp;
      goto split;
   18c2c:	c2dff06f          	j	18858 <_realloc_r+0x12c>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18c30:	010b8793          	addi	a5,s7,16
   18c34:	008a0a13          	addi	s4,s4,8
   18c38:	dd5ff06f          	j	18a0c <_realloc_r+0x2e0>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18c3c:	010a2683          	lw	a3,16(s4)
   18c40:	01850793          	addi	a5,a0,24
   18c44:	018a0713          	addi	a4,s4,24
   18c48:	00d52823          	sw	a3,16(a0)
   18c4c:	014a2683          	lw	a3,20(s4)
   18c50:	00d52a23          	sw	a3,20(a0)
   18c54:	bc1ff06f          	j	18814 <_realloc_r+0xe8>
          {
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18c58:	000a0593          	mv	a1,s4
   18c5c:	00040513          	mv	a0,s0
   18c60:	8c5fe0ef          	jal	17524 <memmove>
   18c64:	ee5ff06f          	j	18b48 <_realloc_r+0x41c>
   18c68:	008a2783          	lw	a5,8(s4)
   18c6c:	00fba823          	sw	a5,16(s7)
   18c70:	00ca2783          	lw	a5,12(s4)
   18c74:	00fbaa23          	sw	a5,20(s7)
   18c78:	02d60063          	beq	a2,a3,18c98 <_realloc_r+0x56c>
   18c7c:	018b8793          	addi	a5,s7,24
   18c80:	010a0a13          	addi	s4,s4,16
   18c84:	eadff06f          	j	18b30 <_realloc_r+0x404>

    newmem = mALLOc (RCALL bytes);

    if (newmem == 0)  /* propagate failure */
    {
      MALLOC_UNLOCK;
   18c88:	00048513          	mv	a0,s1
   18c8c:	a99fe0ef          	jal	17724 <__malloc_unlock>
      return 0;
   18c90:	00000513          	li	a0,0
   18c94:	bf9ff06f          	j	1888c <_realloc_r+0x160>
          {
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18c98:	010a2703          	lw	a4,16(s4)
   18c9c:	020b8793          	addi	a5,s7,32
   18ca0:	018a0a13          	addi	s4,s4,24
   18ca4:	00ebac23          	sw	a4,24(s7)
   18ca8:	ffca2703          	lw	a4,-4(s4)
   18cac:	00ebae23          	sw	a4,28(s7)
   18cb0:	e81ff06f          	j	18b30 <_realloc_r+0x404>

00018cb4 <__fpclassifyd>:
{
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
   18cb4:	00a5e733          	or	a4,a1,a0
int
__fpclassifyd (double x)
{
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);
   18cb8:	00050793          	mv	a5,a0

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
   18cbc:	00200513          	li	a0,2
{
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
   18cc0:	00071463          	bnez	a4,18cc8 <__fpclassifyd+0x14>
  else if ((msw == 0x7ff00000 && lsw == 0x00000000) ||
           (msw == 0xfff00000 && lsw == 0x00000000))
    return FP_INFINITE;
  else
    return FP_NAN;
}
   18cc4:	00008067          	ret
{
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
   18cc8:	80000737          	lui	a4,0x80000
   18ccc:	04e58863          	beq	a1,a4,18d1c <__fpclassifyd+0x68>
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
   18cd0:	fff00737          	lui	a4,0xfff00
   18cd4:	00e58733          	add	a4,a1,a4
   18cd8:	7fe006b7          	lui	a3,0x7fe00
           (msw >= 0x80100000 && msw <= 0xffefffff))
    return FP_NORMAL;
   18cdc:	00400513          	li	a0,4
  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
   18ce0:	fed762e3          	bltu	a4,a3,18cc4 <__fpclassifyd+0x10>
   18ce4:	7ff00737          	lui	a4,0x7ff00
   18ce8:	00e58733          	add	a4,a1,a4
   18cec:	fcd76ce3          	bltu	a4,a3,18cc4 <__fpclassifyd+0x10>
           (msw >= 0x80100000 && msw <= 0xffefffff))
    return FP_NORMAL;
  else if ((msw >= 0x00000000 && msw <= 0x000fffff) ||
   18cf0:	80000737          	lui	a4,0x80000
   18cf4:	fff74713          	not	a4,a4
   18cf8:	00e5f5b3          	and	a1,a1,a4
   18cfc:	00100737          	lui	a4,0x100
           (msw >= 0x80000000 && msw <= 0x800fffff))
    /* zero is already handled above */
    return FP_SUBNORMAL;
   18d00:	00300513          	li	a0,3
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
           (msw >= 0x80100000 && msw <= 0xffefffff))
    return FP_NORMAL;
  else if ((msw >= 0x00000000 && msw <= 0x000fffff) ||
   18d04:	fce5e0e3          	bltu	a1,a4,18cc4 <__fpclassifyd+0x10>
           (msw >= 0x80000000 && msw <= 0x800fffff))
    /* zero is already handled above */
    return FP_SUBNORMAL;
  else if ((msw == 0x7ff00000 && lsw == 0x00000000) ||
   18d08:	7ff00737          	lui	a4,0x7ff00
           (msw == 0xfff00000 && lsw == 0x00000000))
    return FP_INFINITE;
  else
    return FP_NAN;
   18d0c:	00000513          	li	a0,0
    return FP_NORMAL;
  else if ((msw >= 0x00000000 && msw <= 0x000fffff) ||
           (msw >= 0x80000000 && msw <= 0x800fffff))
    /* zero is already handled above */
    return FP_SUBNORMAL;
  else if ((msw == 0x7ff00000 && lsw == 0x00000000) ||
   18d10:	fae59ae3          	bne	a1,a4,18cc4 <__fpclassifyd+0x10>
  if ((msw == 0x00000000 && lsw == 0x00000000) ||
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
           (msw >= 0x80100000 && msw <= 0xffefffff))
    return FP_NORMAL;
   18d14:	0017b513          	seqz	a0,a5
   18d18:	00008067          	ret

  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
   18d1c:	00200513          	li	a0,2
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
      (msw == 0x80000000 && lsw == 0x00000000))
   18d20:	fc0798e3          	bnez	a5,18cf0 <__fpclassifyd+0x3c>
  else if ((msw == 0x7ff00000 && lsw == 0x00000000) ||
           (msw == 0xfff00000 && lsw == 0x00000000))
    return FP_INFINITE;
  else
    return FP_NAN;
}
   18d24:	00008067          	ret

00018d28 <__sread>:
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   18d28:	00e59503          	lh	a0,14(a1)
_DEFUN(__sread, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   18d2c:	ff010113          	addi	sp,sp,-16
   18d30:	00812423          	sw	s0,8(sp)
   18d34:	00058413          	mv	s0,a1
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   18d38:	00060593          	mv	a1,a2
   18d3c:	00068613          	mv	a2,a3
_DEFUN(__sread, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   18d40:	00112623          	sw	ra,12(sp)
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   18d44:	dc0f70ef          	jal	10304 <read>
    setmode (fp->_file, oldmode);
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
   18d48:	02054c63          	bltz	a0,18d80 <__sread+0x58>
    fp->_offset += ret;
   18d4c:	05042783          	lw	a5,80(s0)
   18d50:	05442683          	lw	a3,84(s0)
   18d54:	41f55613          	srai	a2,a0,0x1f
   18d58:	00a785b3          	add	a1,a5,a0
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
  return ret;
}
   18d5c:	00c12083          	lw	ra,12(sp)
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
    fp->_offset += ret;
   18d60:	00f5b733          	sltu	a4,a1,a5
   18d64:	00c687b3          	add	a5,a3,a2
   18d68:	00f707b3          	add	a5,a4,a5
   18d6c:	04b42823          	sw	a1,80(s0)
   18d70:	04f42a23          	sw	a5,84(s0)
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
  return ret;
}
   18d74:	00812403          	lw	s0,8(sp)
   18d78:	01010113          	addi	sp,sp,16
   18d7c:	00008067          	ret
  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
    fp->_offset += ret;
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
   18d80:	00c45703          	lhu	a4,12(s0)
   18d84:	fffff7b7          	lui	a5,0xfffff
  return ret;
}
   18d88:	00c12083          	lw	ra,12(sp)
  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
    fp->_offset += ret;
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
   18d8c:	fff78793          	addi	a5,a5,-1 # ffffefff <_gp+0xfffdfb2f>
   18d90:	00f777b3          	and	a5,a4,a5
   18d94:	00f41623          	sh	a5,12(s0)
  return ret;
}
   18d98:	00812403          	lw	s0,8(sp)
   18d9c:	01010113          	addi	sp,sp,16
   18da0:	00008067          	ret

00018da4 <__seofread>:
       _PTR cookie _AND
       char *buf   _AND
       _READ_WRITE_BUFSIZE_TYPE len)
{
  return 0;
}
   18da4:	00000513          	li	a0,0
   18da8:	00008067          	ret

00018dac <__swrite>:
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   18dac:	00c59703          	lh	a4,12(a1)
_DEFUN(__swrite, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char const *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   18db0:	ff010113          	addi	sp,sp,-16
   18db4:	00812423          	sw	s0,8(sp)
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   18db8:	10077793          	andi	a5,a4,256
_DEFUN(__swrite, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char const *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   18dbc:	00912223          	sw	s1,4(sp)
   18dc0:	01212023          	sw	s2,0(sp)
   18dc4:	00112623          	sw	ra,12(sp)
   18dc8:	00058413          	mv	s0,a1
   18dcc:	00060493          	mv	s1,a2
   18dd0:	00068913          	mv	s2,a3
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   18dd4:	00078e63          	beqz	a5,18df0 <__swrite+0x44>
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
   18dd8:	00e59503          	lh	a0,14(a1)
   18ddc:	00200713          	li	a4,2
   18de0:	00000613          	li	a2,0
   18de4:	00000693          	li	a3,0
   18de8:	cc4f70ef          	jal	102ac <lseek>
   18dec:	00c41703          	lh	a4,12(s0)
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
   18df0:	fffff7b7          	lui	a5,0xfffff
   18df4:	fff78793          	addi	a5,a5,-1 # ffffefff <_gp+0xfffdfb2f>
   18df8:	00f777b3          	and	a5,a4,a5
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   18dfc:	00e41503          	lh	a0,14(s0)
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
   18e00:	00f41623          	sh	a5,12(s0)
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   18e04:	00090613          	mv	a2,s2
   18e08:	00048593          	mv	a1,s1
  if (oldmode)
    setmode (fp->_file, oldmode);
#endif

  return w;
}
   18e0c:	00c12083          	lw	ra,12(sp)
   18e10:	00812403          	lw	s0,8(sp)
   18e14:	00412483          	lw	s1,4(sp)
   18e18:	00012903          	lw	s2,0(sp)
   18e1c:	01010113          	addi	sp,sp,16
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   18e20:	ec0f706f          	j	104e0 <write>

00018e24 <__sseek>:
       int whence)
{
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
   18e24:	00e59503          	lh	a0,14(a1)
_DEFUN(__sseek, (ptr, cookie, offset, whence),
       struct _reent *ptr _AND
       void *cookie _AND
       _fpos_t offset _AND
       int whence)
{
   18e28:	ff010113          	addi	sp,sp,-16
   18e2c:	00812423          	sw	s0,8(sp)
   18e30:	00112623          	sw	ra,12(sp)
   18e34:	00058413          	mv	s0,a1
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
   18e38:	c74f70ef          	jal	102ac <lseek>
  if (ret == -1L)
   18e3c:	fff00793          	li	a5,-1
    fp->_flags &= ~__SOFF;
   18e40:	00c45703          	lhu	a4,12(s0)
{
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
   18e44:	02f50463          	beq	a0,a5,18e6c <__sseek+0x48>
    {
      fp->_flags |= __SOFF;
      fp->_offset = ret;
    }
  return ret;
}
   18e48:	00c12083          	lw	ra,12(sp)
  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
    fp->_flags &= ~__SOFF;
  else
    {
      fp->_flags |= __SOFF;
   18e4c:	000017b7          	lui	a5,0x1
   18e50:	00f767b3          	or	a5,a4,a5
      fp->_offset = ret;
   18e54:	04a42823          	sw	a0,80(s0)
  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
    fp->_flags &= ~__SOFF;
  else
    {
      fp->_flags |= __SOFF;
   18e58:	00f41623          	sh	a5,12(s0)
      fp->_offset = ret;
   18e5c:	04b42a23          	sw	a1,84(s0)
    }
  return ret;
}
   18e60:	00812403          	lw	s0,8(sp)
   18e64:	01010113          	addi	sp,sp,16
   18e68:	00008067          	ret
{
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
   18e6c:	fca59ee3          	bne	a1,a0,18e48 <__sseek+0x24>
    fp->_flags &= ~__SOFF;
   18e70:	fffff7b7          	lui	a5,0xfffff
    {
      fp->_flags |= __SOFF;
      fp->_offset = ret;
    }
  return ret;
}
   18e74:	00c12083          	lw	ra,12(sp)
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
    fp->_flags &= ~__SOFF;
   18e78:	fff78793          	addi	a5,a5,-1 # ffffefff <_gp+0xfffdfb2f>
   18e7c:	00f777b3          	and	a5,a4,a5
   18e80:	00f41623          	sh	a5,12(s0)
    {
      fp->_flags |= __SOFF;
      fp->_offset = ret;
    }
  return ret;
}
   18e84:	00812403          	lw	s0,8(sp)
   18e88:	01010113          	addi	sp,sp,16
   18e8c:	00008067          	ret

00018e90 <__sclose>:
       struct _reent *ptr _AND
       void *cookie)
{
  FILE *fp = (FILE *) cookie;

  return _close_r (ptr, fp->_file);
   18e90:	00e59503          	lh	a0,14(a1)
   18e94:	ac0f706f          	j	10154 <close>

00018e98 <strcmp>:
   18e98:	00b56733          	or	a4,a0,a1
   18e9c:	fff00393          	li	t2,-1
   18ea0:	00377713          	andi	a4,a4,3
   18ea4:	0c071063          	bnez	a4,18f64 <strcmp+0xcc>
   18ea8:	7f7f8e37          	lui	t3,0x7f7f8
   18eac:	f7fe0e13          	addi	t3,t3,-129 # 7f7f7f7f <_gp+0x7f7d8aaf>
   18eb0:	00052603          	lw	a2,0(a0)
   18eb4:	0005a683          	lw	a3,0(a1)
   18eb8:	01c672b3          	and	t0,a2,t3
   18ebc:	01c66333          	or	t1,a2,t3
   18ec0:	01c282b3          	add	t0,t0,t3
   18ec4:	0062e2b3          	or	t0,t0,t1
   18ec8:	0c729263          	bne	t0,t2,18f8c <strcmp+0xf4>
   18ecc:	04d61663          	bne	a2,a3,18f18 <strcmp+0x80>
   18ed0:	00452603          	lw	a2,4(a0)
   18ed4:	0045a683          	lw	a3,4(a1)
   18ed8:	01c672b3          	and	t0,a2,t3
   18edc:	01c66333          	or	t1,a2,t3
   18ee0:	01c282b3          	add	t0,t0,t3
   18ee4:	0062e2b3          	or	t0,t0,t1
   18ee8:	08729e63          	bne	t0,t2,18f84 <strcmp+0xec>
   18eec:	02d61663          	bne	a2,a3,18f18 <strcmp+0x80>
   18ef0:	00852603          	lw	a2,8(a0)
   18ef4:	0085a683          	lw	a3,8(a1)
   18ef8:	01c672b3          	and	t0,a2,t3
   18efc:	01c66333          	or	t1,a2,t3
   18f00:	01c282b3          	add	t0,t0,t3
   18f04:	0062e2b3          	or	t0,t0,t1
   18f08:	08729863          	bne	t0,t2,18f98 <strcmp+0x100>
   18f0c:	00c50513          	addi	a0,a0,12
   18f10:	00c58593          	addi	a1,a1,12
   18f14:	f8d60ee3          	beq	a2,a3,18eb0 <strcmp+0x18>
   18f18:	01061713          	slli	a4,a2,0x10
   18f1c:	01069793          	slli	a5,a3,0x10
   18f20:	00f71e63          	bne	a4,a5,18f3c <strcmp+0xa4>
   18f24:	01065713          	srli	a4,a2,0x10
   18f28:	0106d793          	srli	a5,a3,0x10
   18f2c:	40f70533          	sub	a0,a4,a5
   18f30:	0ff57593          	andi	a1,a0,255
   18f34:	02059063          	bnez	a1,18f54 <strcmp+0xbc>
   18f38:	00008067          	ret
   18f3c:	01075713          	srli	a4,a4,0x10
   18f40:	0107d793          	srli	a5,a5,0x10
   18f44:	40f70533          	sub	a0,a4,a5
   18f48:	0ff57593          	andi	a1,a0,255
   18f4c:	00059463          	bnez	a1,18f54 <strcmp+0xbc>
   18f50:	00008067          	ret
   18f54:	0ff77713          	andi	a4,a4,255
   18f58:	0ff7f793          	andi	a5,a5,255
   18f5c:	40f70533          	sub	a0,a4,a5
   18f60:	00008067          	ret
   18f64:	00054603          	lbu	a2,0(a0)
   18f68:	0005c683          	lbu	a3,0(a1)
   18f6c:	00150513          	addi	a0,a0,1
   18f70:	00158593          	addi	a1,a1,1
   18f74:	00d61463          	bne	a2,a3,18f7c <strcmp+0xe4>
   18f78:	fe0616e3          	bnez	a2,18f64 <strcmp+0xcc>
   18f7c:	40d60533          	sub	a0,a2,a3
   18f80:	00008067          	ret
   18f84:	00450513          	addi	a0,a0,4
   18f88:	00458593          	addi	a1,a1,4
   18f8c:	fcd61ce3          	bne	a2,a3,18f64 <strcmp+0xcc>
   18f90:	00000513          	li	a0,0
   18f94:	00008067          	ret
   18f98:	00850513          	addi	a0,a0,8
   18f9c:	00858593          	addi	a1,a1,8
   18fa0:	fcd612e3          	bne	a2,a3,18f64 <strcmp+0xcc>
   18fa4:	00000513          	li	a0,0
   18fa8:	00008067          	ret

00018fac <__sprint_r.part.0>:
	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
		return (0);
	}
#ifdef _WIDE_ORIENT
	if (fp->_flags2 & __SWID) {
   18fac:	0685a783          	lw	a5,104(a1)
/*
 * Flush out all the vectors defined by the given uio,
 * then reset it so that it can be reused.
 */
int
_DEFUN(__sprint_r, (ptr, fp, uio),
   18fb0:	fd010113          	addi	sp,sp,-48
   18fb4:	01612823          	sw	s6,16(sp)
	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
		return (0);
	}
#ifdef _WIDE_ORIENT
	if (fp->_flags2 & __SWID) {
   18fb8:	01279713          	slli	a4,a5,0x12
/*
 * Flush out all the vectors defined by the given uio,
 * then reset it so that it can be reused.
 */
int
_DEFUN(__sprint_r, (ptr, fp, uio),
   18fbc:	02112623          	sw	ra,44(sp)
   18fc0:	02812423          	sw	s0,40(sp)
   18fc4:	02912223          	sw	s1,36(sp)
   18fc8:	03212023          	sw	s2,32(sp)
   18fcc:	01312e23          	sw	s3,28(sp)
   18fd0:	01412c23          	sw	s4,24(sp)
   18fd4:	01512a23          	sw	s5,20(sp)
   18fd8:	01712623          	sw	s7,12(sp)
   18fdc:	00060b13          	mv	s6,a2
	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
		return (0);
	}
#ifdef _WIDE_ORIENT
	if (fp->_flags2 & __SWID) {
   18fe0:	0a075663          	bgez	a4,1908c <__sprint_r.part.0+0xe0>
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
   18fe4:	00862783          	lw	a5,8(a2)
   18fe8:	00058a13          	mv	s4,a1
   18fec:	00050a93          	mv	s5,a0
	if (fp->_flags2 & __SWID) {
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
   18ff0:	00062b83          	lw	s7,0(a2)
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
			len = iov->iov_len / sizeof (wchar_t);
			for (i = 0; i < len; i++) {
				if (_fputwc_r (ptr, p[i], fp) == WEOF) {
   18ff4:	fff00993          	li	s3,-1
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
   18ff8:	08078663          	beqz	a5,19084 <__sprint_r.part.0+0xd8>
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
			len = iov->iov_len / sizeof (wchar_t);
   18ffc:	004ba903          	lw	s2,4(s7)
   19000:	000ba483          	lw	s1,0(s7)
			for (i = 0; i < len; i++) {
   19004:	00000413          	li	s0,0

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
			len = iov->iov_len / sizeof (wchar_t);
   19008:	00295913          	srli	s2,s2,0x2
			for (i = 0; i < len; i++) {
   1900c:	00091863          	bnez	s2,1901c <__sprint_r.part.0+0x70>
   19010:	0600006f          	j	19070 <__sprint_r.part.0+0xc4>
   19014:	00448493          	addi	s1,s1,4
   19018:	04890a63          	beq	s2,s0,1906c <__sprint_r.part.0+0xc0>
				if (_fputwc_r (ptr, p[i], fp) == WEOF) {
   1901c:	0004a583          	lw	a1,0(s1)
   19020:	000a0613          	mv	a2,s4
   19024:	000a8513          	mv	a0,s5
   19028:	47c010ef          	jal	1a4a4 <_fputwc_r>
		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
			len = iov->iov_len / sizeof (wchar_t);
			for (i = 0; i < len; i++) {
   1902c:	00140413          	addi	s0,s0,1
				if (_fputwc_r (ptr, p[i], fp) == WEOF) {
   19030:	ff3512e3          	bne	a0,s3,19014 <__sprint_r.part.0+0x68>
					err = -1;
   19034:	00098513          	mv	a0,s3
		err = __sfvwrite_r(ptr, fp, uio);
out:
	uio->uio_resid = 0;
	uio->uio_iovcnt = 0;
	return (err);
}
   19038:	02c12083          	lw	ra,44(sp)
		}
	} else
#endif
		err = __sfvwrite_r(ptr, fp, uio);
out:
	uio->uio_resid = 0;
   1903c:	000b2423          	sw	zero,8(s6)
	uio->uio_iovcnt = 0;
   19040:	000b2223          	sw	zero,4(s6)
	return (err);
}
   19044:	02812403          	lw	s0,40(sp)
   19048:	02412483          	lw	s1,36(sp)
   1904c:	02012903          	lw	s2,32(sp)
   19050:	01c12983          	lw	s3,28(sp)
   19054:	01812a03          	lw	s4,24(sp)
   19058:	01412a83          	lw	s5,20(sp)
   1905c:	01012b03          	lw	s6,16(sp)
   19060:	00c12b83          	lw	s7,12(sp)
   19064:	03010113          	addi	sp,sp,48
   19068:	00008067          	ret
   1906c:	008b2783          	lw	a5,8(s6)
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
   19070:	00291913          	slli	s2,s2,0x2
   19074:	412787b3          	sub	a5,a5,s2
   19078:	00fb2423          	sw	a5,8(s6)
   1907c:	008b8b93          	addi	s7,s7,8
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
   19080:	f6079ee3          	bnez	a5,18ffc <__sprint_r.part.0+0x50>
_DEFUN(__sprint_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;
   19084:	00000513          	li	a0,0
   19088:	fb1ff06f          	j	19038 <__sprint_r.part.0+0x8c>
				}
			}
		}
	} else
#endif
		err = __sfvwrite_r(ptr, fp, uio);
   1908c:	becfd0ef          	jal	16478 <__sfvwrite_r>
   19090:	fa9ff06f          	j	19038 <__sprint_r.part.0+0x8c>

00019094 <__sprint_r>:
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   19094:	00862703          	lw	a4,8(a2)
   19098:	00070463          	beqz	a4,190a0 <__sprint_r+0xc>
   1909c:	f11ff06f          	j	18fac <__sprint_r.part.0>
		uio->uio_iovcnt = 0;
   190a0:	00062223          	sw	zero,4(a2)
		err = __sfvwrite_r(ptr, fp, uio);
out:
	uio->uio_resid = 0;
	uio->uio_iovcnt = 0;
	return (err);
}
   190a4:	00000513          	li	a0,0
   190a8:	00008067          	ret

000190ac <_vfiprintf_r>:
_DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
       struct _reent *data _AND
       FILE * fp           _AND
       _CONST char *fmt0   _AND
       va_list ap)
{
   190ac:	f1010113          	addi	sp,sp,-240
   190b0:	0e912223          	sw	s1,228(sp)
   190b4:	0d512a23          	sw	s5,212(sp)
   190b8:	0da12023          	sw	s10,192(sp)
   190bc:	0e112623          	sw	ra,236(sp)
   190c0:	0e812423          	sw	s0,232(sp)
   190c4:	0f212023          	sw	s2,224(sp)
   190c8:	0d312e23          	sw	s3,220(sp)
   190cc:	0d412c23          	sw	s4,216(sp)
   190d0:	0d612823          	sw	s6,208(sp)
   190d4:	0d712623          	sw	s7,204(sp)
   190d8:	0d812423          	sw	s8,200(sp)
   190dc:	0d912223          	sw	s9,196(sp)
   190e0:	0bb12e23          	sw	s11,188(sp)
   190e4:	00050a93          	mv	s5,a0
   190e8:	00058d13          	mv	s10,a1
   190ec:	00060493          	mv	s1,a2
   190f0:	00d12823          	sw	a3,16(sp)
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
   190f4:	00050663          	beqz	a0,19100 <_vfiprintf_r+0x54>
   190f8:	03852783          	lw	a5,56(a0)
   190fc:	1e078863          	beqz	a5,192ec <_vfiprintf_r+0x240>
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);
   19100:	00cd1683          	lh	a3,12(s10)
   19104:	01069793          	slli	a5,a3,0x10
   19108:	0107d793          	srli	a5,a5,0x10
   1910c:	01279593          	slli	a1,a5,0x12
   19110:	0205c663          	bltz	a1,1913c <_vfiprintf_r+0x90>
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
	_newlib_flockfile_start (fp);
   19114:	068d2603          	lw	a2,104(s10)

	ORIENT(fp, -1);
   19118:	000027b7          	lui	a5,0x2
   1911c:	ffffe737          	lui	a4,0xffffe
   19120:	00f6e7b3          	or	a5,a3,a5
   19124:	fff70713          	addi	a4,a4,-1 # ffffdfff <_gp+0xfffdeb2f>
   19128:	00e67733          	and	a4,a2,a4
   1912c:	00fd1623          	sh	a5,12(s10)
   19130:	01079793          	slli	a5,a5,0x10
   19134:	06ed2423          	sw	a4,104(s10)
   19138:	0107d793          	srli	a5,a5,0x10

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   1913c:	0087f713          	andi	a4,a5,8
   19140:	12070a63          	beqz	a4,19274 <_vfiprintf_r+0x1c8>
   19144:	010d2703          	lw	a4,16(s10)
   19148:	12070663          	beqz	a4,19274 <_vfiprintf_r+0x1c8>
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   1914c:	01a7f793          	andi	a5,a5,26
   19150:	00a00713          	li	a4,10
   19154:	14e78063          	beq	a5,a4,19294 <_vfiprintf_r+0x1e8>
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   19158:	07010c93          	addi	s9,sp,112
   1915c:	06f10713          	addi	a4,sp,111
   19160:	0001d337          	lui	t1,0x1d
   19164:	0001d8b7          	lui	a7,0x1d
   19168:	40ec87b3          	sub	a5,s9,a4
   1916c:	00e12623          	sw	a4,12(sp)
   19170:	03912e23          	sw	s9,60(sp)
	uio.uio_resid = 0;
   19174:	04012223          	sw	zero,68(sp)
	uio.uio_iovcnt = 0;
   19178:	04012023          	sw	zero,64(sp)
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
   1917c:	00012e23          	sw	zero,28(sp)
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
	uio.uio_resid = 0;
	uio.uio_iovcnt = 0;
#endif
	ret = 0;
   19180:	00012a23          	sw	zero,20(sp)
   19184:	b9430b13          	addi	s6,t1,-1132 # 1cb94 <blanks.4133>
   19188:	ba488c13          	addi	s8,a7,-1116 # 1cba4 <zeroes.4134>
   1918c:	02f12223          	sw	a5,36(sp)
   19190:	000c8693          	mv	a3,s9
   19194:	00048d93          	mv	s11,s1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   19198:	000dc783          	lbu	a5,0(s11)
   1919c:	4a078ce3          	beqz	a5,19e54 <_vfiprintf_r+0xda8>
   191a0:	02500713          	li	a4,37
   191a4:	000d8913          	mv	s2,s11
   191a8:	00e79663          	bne	a5,a4,191b4 <_vfiprintf_r+0x108>
   191ac:	0540006f          	j	19200 <_vfiprintf_r+0x154>
   191b0:	00e78863          	beq	a5,a4,191c0 <_vfiprintf_r+0x114>
                    fmt += 1;
   191b4:	00190913          	addi	s2,s2,1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   191b8:	00094783          	lbu	a5,0(s2)
   191bc:	fe079ae3          	bnez	a5,191b0 <_vfiprintf_r+0x104>
   191c0:	41b90433          	sub	s0,s2,s11
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
   191c4:	02040e63          	beqz	s0,19200 <_vfiprintf_r+0x154>
			PRINT (cp, m);
   191c8:	04412703          	lw	a4,68(sp)
   191cc:	04012783          	lw	a5,64(sp)
   191d0:	00700613          	li	a2,7
   191d4:	00e40733          	add	a4,s0,a4
   191d8:	00178793          	addi	a5,a5,1 # 2001 <_reset+0x1e01>
   191dc:	01b6a023          	sw	s11,0(a3) # 7fe00000 <_gp+0x7fde0b30>
   191e0:	0086a223          	sw	s0,4(a3)
   191e4:	04e12223          	sw	a4,68(sp)
   191e8:	04f12023          	sw	a5,64(sp)
   191ec:	00868693          	addi	a3,a3,8
   191f0:	06f64463          	blt	a2,a5,19258 <_vfiprintf_r+0x1ac>
			ret += m;
   191f4:	01412883          	lw	a7,20(sp)
   191f8:	008888b3          	add	a7,a7,s0
   191fc:	01112a23          	sw	a7,20(sp)
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
   19200:	00094783          	lbu	a5,0(s2)
   19204:	060788e3          	beqz	a5,19a74 <_vfiprintf_r+0x9c8>
                    goto done;
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */
   19208:	00190493          	addi	s1,s2,1

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
   1920c:	02010ba3          	sb	zero,55(sp)
   19210:	00000813          	li	a6,0
   19214:	00000313          	li	t1,0
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
   19218:	fff00713          	li	a4,-1
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
   1921c:	00000913          	li	s2,0
                    goto done;
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
   19220:	00000b93          	li	s7,0
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   19224:	05800593          	li	a1,88
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			} while (is_digit (ch));
   19228:	00900513          	li	a0,9
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
   1922c:	02a00393          	li	t2,42
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
   19230:	0004c603          	lbu	a2,0(s1)
   19234:	00148d93          	addi	s11,s1,1
reswitch:	switch (ch) {
   19238:	fe060793          	addi	a5,a2,-32
   1923c:	6af5e263          	bltu	a1,a5,198e0 <_vfiprintf_r+0x834>
   19240:	0001d8b7          	lui	a7,0x1d
   19244:	00279793          	slli	a5,a5,0x2
   19248:	a3088893          	addi	a7,a7,-1488 # 1ca30 <__mprec_bigtens+0x28>
   1924c:	011787b3          	add	a5,a5,a7
   19250:	0007a783          	lw	a5,0(a5)
   19254:	00078067          	jr	a5
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   19258:	300710e3          	bnez	a4,19d58 <_vfiprintf_r+0xcac>
		uio->uio_iovcnt = 0;
   1925c:	04012023          	sw	zero,64(sp)
#else
                while (*fmt != '\0' && *fmt != '%')
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
			PRINT (cp, m);
   19260:	000c8693          	mv	a3,s9
   19264:	f91ff06f          	j	191f4 <_vfiprintf_r+0x148>
			} else
#endif
				flags |= LONGINT;
			goto rflag;
		case 'q': /* extension */
			flags |= QUADINT;
   19268:	010beb93          	ori	s7,s7,16
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   1926c:	000d8493          	mv	s1,s11
   19270:	fc1ff06f          	j	19230 <_vfiprintf_r+0x184>
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   19274:	000d0593          	mv	a1,s10
   19278:	000a8513          	mv	a0,s5
   1927c:	e59fa0ef          	jal	140d4 <__swsetup_r>
   19280:	48051ae3          	bnez	a0,19f14 <_vfiprintf_r+0xe68>
   19284:	00cd5783          	lhu	a5,12(s10)
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   19288:	00a00713          	li	a4,10
   1928c:	01a7f793          	andi	a5,a5,26
   19290:	ece794e3          	bne	a5,a4,19158 <_vfiprintf_r+0xac>
   19294:	00ed1783          	lh	a5,14(s10)
   19298:	ec07c0e3          	bltz	a5,19158 <_vfiprintf_r+0xac>
	    fp->_file >= 0) {
		_newlib_flockfile_exit (fp);
		return (__sbprintf (data, fp, fmt0, ap));
   1929c:	01012683          	lw	a3,16(sp)
   192a0:	00048613          	mv	a2,s1
   192a4:	000d0593          	mv	a1,s10
   192a8:	000a8513          	mv	a0,s5
   192ac:	629000ef          	jal	1a0d4 <__sbprintf>
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
	/* NOTREACHED */
}
   192b0:	0ec12083          	lw	ra,236(sp)
   192b4:	0e812403          	lw	s0,232(sp)
   192b8:	0e412483          	lw	s1,228(sp)
   192bc:	0e012903          	lw	s2,224(sp)
   192c0:	0dc12983          	lw	s3,220(sp)
   192c4:	0d812a03          	lw	s4,216(sp)
   192c8:	0d412a83          	lw	s5,212(sp)
   192cc:	0d012b03          	lw	s6,208(sp)
   192d0:	0cc12b83          	lw	s7,204(sp)
   192d4:	0c812c03          	lw	s8,200(sp)
   192d8:	0c412c83          	lw	s9,196(sp)
   192dc:	0c012d03          	lw	s10,192(sp)
   192e0:	0bc12d83          	lw	s11,188(sp)
   192e4:	0f010113          	addi	sp,sp,240
   192e8:	00008067          	ret
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
   192ec:	d71fc0ef          	jal	1605c <__sinit>
   192f0:	e11ff06f          	j	19100 <_vfiprintf_r+0x54>
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   192f4:	01012783          	lw	a5,16(sp)
   192f8:	0007a903          	lw	s2,0(a5)
   192fc:	00478793          	addi	a5,a5,4
   19300:	00f12823          	sw	a5,16(sp)
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
   19304:	f60954e3          	bgez	s2,1926c <_vfiprintf_r+0x1c0>
				goto rflag;
			width = -width;
   19308:	41200933          	neg	s2,s2
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
   1930c:	004beb93          	ori	s7,s7,4
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   19310:	000d8493          	mv	s1,s11
   19314:	f1dff06f          	j	19230 <_vfiprintf_r+0x184>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   19318:	01012883          	lw	a7,16(sp)
			base = HEX;
			xdigs = "0123456789abcdef";
			flags |= HEXPREFIX;
			ox[0] = '0';
   1931c:	03000593          	li	a1,48
   19320:	02b10c23          	sb	a1,56(sp)
			ox[1] = ch = 'x';
   19324:	07800593          	li	a1,120
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   19328:	00488613          	addi	a2,a7,4
   1932c:	0008a783          	lw	a5,0(a7)
			base = HEX;
			xdigs = "0123456789abcdef";
			flags |= HEXPREFIX;
   19330:	002be513          	ori	a0,s7,2
			ox[0] = '0';
			ox[1] = ch = 'x';
   19334:	02b10ca3          	sb	a1,57(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   19338:	02010ba3          	sb	zero,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   1933c:	2e074ae3          	bltz	a4,19e30 <_vfiprintf_r+0xd84>
   19340:	f7fbf293          	andi	t0,s7,-129
				flags &= ~ZEROPAD;
   19344:	0022eb93          	ori	s7,t0,2
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   19348:	00c12823          	sw	a2,16(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   1934c:	300798e3          	bnez	a5,19e5c <_vfiprintf_r+0xdb0>
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   19350:	0001d7b7          	lui	a5,0x1d
   19354:	c0878793          	addi	a5,a5,-1016 # 1cc08 <__thenan_sf+0x38>
   19358:	00f12e23          	sw	a5,28(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   1935c:	00000593          	li	a1,0
   19360:	20071ae3          	bnez	a4,19d74 <_vfiprintf_r+0xcc8>
   19364:	00000713          	li	a4,0
   19368:	00000a13          	li	s4,0
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   1936c:	000c8413          	mv	s0,s9
		 * If flags&FPT, ch must be in [aAeEfg].
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
   19370:	00070993          	mv	s3,a4
   19374:	01475463          	ble	s4,a4,1937c <_vfiprintf_r+0x2d0>
   19378:	000a0993          	mv	s3,s4
		if (sign)
			realsz++;
   1937c:	00b035b3          	snez	a1,a1
   19380:	00b989b3          	add	s3,s3,a1
		if (flags & HEXPREFIX)
   19384:	002bfe13          	andi	t3,s7,2
   19388:	000e0463          	beqz	t3,19390 <_vfiprintf_r+0x2e4>
			realsz+= 2;
   1938c:	00298993          	addi	s3,s3,2

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   19390:	084bf393          	andi	t2,s7,132
   19394:	5c039263          	bnez	t2,19958 <_vfiprintf_r+0x8ac>
			PAD (width - realsz, blanks);
   19398:	413904b3          	sub	s1,s2,s3
   1939c:	5a905e63          	blez	s1,19958 <_vfiprintf_r+0x8ac>
   193a0:	01000813          	li	a6,16
   193a4:	04412783          	lw	a5,68(sp)
   193a8:	3e9850e3          	ble	s1,a6,19f88 <_vfiprintf_r+0xedc>
   193ac:	02812023          	sw	s0,32(sp)
   193b0:	04012503          	lw	a0,64(sp)
   193b4:	00048413          	mv	s0,s1
   193b8:	01612c23          	sw	s6,24(sp)
   193bc:	00700e93          	li	t4,7
   193c0:	02e12423          	sw	a4,40(sp)
   193c4:	03c12623          	sw	t3,44(sp)
   193c8:	00038493          	mv	s1,t2
   193cc:	0180006f          	j	193e4 <_vfiprintf_r+0x338>
   193d0:	00250613          	addi	a2,a0,2
   193d4:	00868693          	addi	a3,a3,8
   193d8:	00070513          	mv	a0,a4
   193dc:	ff040413          	addi	s0,s0,-16
   193e0:	02885c63          	ble	s0,a6,19418 <_vfiprintf_r+0x36c>
   193e4:	01078793          	addi	a5,a5,16
   193e8:	00150713          	addi	a4,a0,1
   193ec:	0166a023          	sw	s6,0(a3)
   193f0:	0106a223          	sw	a6,4(a3)
   193f4:	04f12223          	sw	a5,68(sp)
   193f8:	04e12023          	sw	a4,64(sp)
   193fc:	fceedae3          	ble	a4,t4,193d0 <_vfiprintf_r+0x324>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   19400:	52079063          	bnez	a5,19920 <_vfiprintf_r+0x874>
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   19404:	ff040413          	addi	s0,s0,-16
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   19408:	00000513          	li	a0,0
   1940c:	00100613          	li	a2,1
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   19410:	000c8693          	mv	a3,s9
   19414:	fc8848e3          	blt	a6,s0,193e4 <_vfiprintf_r+0x338>
   19418:	00048393          	mv	t2,s1
   1941c:	02812703          	lw	a4,40(sp)
   19420:	00040493          	mv	s1,s0
   19424:	02c12e03          	lw	t3,44(sp)
   19428:	02012403          	lw	s0,32(sp)
   1942c:	01812883          	lw	a7,24(sp)
   19430:	00f487b3          	add	a5,s1,a5
   19434:	00700593          	li	a1,7
   19438:	0116a023          	sw	a7,0(a3)
   1943c:	0096a223          	sw	s1,4(a3)
   19440:	04f12223          	sw	a5,68(sp)
   19444:	04c12023          	sw	a2,64(sp)
   19448:	7cc5c863          	blt	a1,a2,19c18 <_vfiprintf_r+0xb6c>

		/* prefix */
		if (sign)
   1944c:	03714503          	lbu	a0,55(sp)
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   19450:	00868693          	addi	a3,a3,8
   19454:	00160593          	addi	a1,a2,1

		/* prefix */
		if (sign)
   19458:	50051a63          	bnez	a0,1996c <_vfiprintf_r+0x8c0>
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
   1945c:	540e0463          	beqz	t3,199a4 <_vfiprintf_r+0x8f8>
			PRINT (ox, 2);
   19460:	03810613          	addi	a2,sp,56
   19464:	00c6a023          	sw	a2,0(a3)
   19468:	00200613          	li	a2,2
   1946c:	00278793          	addi	a5,a5,2
   19470:	00c6a223          	sw	a2,4(a3)
   19474:	00700613          	li	a2,7
   19478:	04f12223          	sw	a5,68(sp)
   1947c:	04b12023          	sw	a1,64(sp)
   19480:	7eb65463          	ble	a1,a2,19c68 <_vfiprintf_r+0xbbc>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   19484:	12079ce3          	bnez	a5,19dbc <_vfiprintf_r+0xd10>
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   19488:	08000513          	li	a0,128
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   1948c:	00100593          	li	a1,1
   19490:	00000613          	li	a2,0

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
			PRINT (ox, 2);
   19494:	000c8693          	mv	a3,s9

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   19498:	50a39a63          	bne	t2,a0,199ac <_vfiprintf_r+0x900>
			PAD (width - realsz, zeroes);
   1949c:	413904b3          	sub	s1,s2,s3
   194a0:	50905663          	blez	s1,199ac <_vfiprintf_r+0x900>
   194a4:	01000813          	li	a6,16
   194a8:	369858e3          	ble	s1,a6,1a018 <_vfiprintf_r+0xf6c>
   194ac:	02812023          	sw	s0,32(sp)
   194b0:	01812c23          	sw	s8,24(sp)
   194b4:	00048413          	mv	s0,s1
   194b8:	00700393          	li	t2,7
   194bc:	00070493          	mv	s1,a4
   194c0:	0180006f          	j	194d8 <_vfiprintf_r+0x42c>
   194c4:	00260513          	addi	a0,a2,2
   194c8:	00868693          	addi	a3,a3,8
   194cc:	00070613          	mv	a2,a4
   194d0:	ff040413          	addi	s0,s0,-16
   194d4:	02885c63          	ble	s0,a6,1950c <_vfiprintf_r+0x460>
   194d8:	01078793          	addi	a5,a5,16
   194dc:	00160713          	addi	a4,a2,1
   194e0:	0186a023          	sw	s8,0(a3)
   194e4:	0106a223          	sw	a6,4(a3)
   194e8:	04f12223          	sw	a5,68(sp)
   194ec:	04e12023          	sw	a4,64(sp)
   194f0:	fce3dae3          	ble	a4,t2,194c4 <_vfiprintf_r+0x418>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   194f4:	6e079663          	bnez	a5,19be0 <_vfiprintf_r+0xb34>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   194f8:	ff040413          	addi	s0,s0,-16
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   194fc:	00100513          	li	a0,1
   19500:	00000613          	li	a2,0
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   19504:	000c8693          	mv	a3,s9
   19508:	fc8848e3          	blt	a6,s0,194d8 <_vfiprintf_r+0x42c>
   1950c:	00048713          	mv	a4,s1
   19510:	00040493          	mv	s1,s0
   19514:	02012403          	lw	s0,32(sp)
   19518:	01812883          	lw	a7,24(sp)
   1951c:	009787b3          	add	a5,a5,s1
   19520:	00700613          	li	a2,7
   19524:	0116a023          	sw	a7,0(a3)
   19528:	0096a223          	sw	s1,4(a3)
   1952c:	04f12223          	sw	a5,68(sp)
   19530:	04a12023          	sw	a0,64(sp)
   19534:	0ca640e3          	blt	a2,a0,19df4 <_vfiprintf_r+0xd48>

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   19538:	414704b3          	sub	s1,a4,s4
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   1953c:	00868693          	addi	a3,a3,8
   19540:	00150593          	addi	a1,a0,1
   19544:	00050613          	mv	a2,a0

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   19548:	46904663          	bgtz	s1,199b4 <_vfiprintf_r+0x908>
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   1954c:	00fa07b3          	add	a5,s4,a5
   19550:	00700713          	li	a4,7
   19554:	0086a023          	sw	s0,0(a3)
   19558:	0146a223          	sw	s4,4(a3)
   1955c:	04f12223          	sw	a5,68(sp)
   19560:	04b12023          	sw	a1,64(sp)
   19564:	54b75e63          	ble	a1,a4,19ac0 <_vfiprintf_r+0xa14>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   19568:	7a079a63          	bnez	a5,19d1c <_vfiprintf_r+0xc70>
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   1956c:	004bf293          	andi	t0,s7,4
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   19570:	04012023          	sw	zero,64(sp)
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   19574:	5e028263          	beqz	t0,19b58 <_vfiprintf_r+0xaac>
			PAD (width - realsz, blanks);
   19578:	413904b3          	sub	s1,s2,s3
   1957c:	1a9048e3          	bgtz	s1,19f2c <_vfiprintf_r+0xe80>

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   19580:	01395463          	ble	s3,s2,19588 <_vfiprintf_r+0x4dc>
   19584:	00098913          	mv	s2,s3
   19588:	01412783          	lw	a5,20(sp)
   1958c:	012787b3          	add	a5,a5,s2
   19590:	00f12a23          	sw	a5,20(sp)

		FLUSH ();	/* copy out the I/O vectors */
   19594:	04012023          	sw	zero,64(sp)
   19598:	000c8693          	mv	a3,s9
   1959c:	bfdff06f          	j	19198 <_vfiprintf_r+0xec>
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   195a0:	00100813          	li	a6,1
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
			goto rflag;
		case '+':
			sign = '+';
   195a4:	02b00313          	li	t1,43
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   195a8:	000d8493          	mv	s1,s11
   195ac:	c85ff06f          	j	19230 <_vfiprintf_r+0x184>
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
   195b0:	080beb93          	ori	s7,s7,128
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   195b4:	000d8493          	mv	s1,s11
   195b8:	c79ff06f          	j	19230 <_vfiprintf_r+0x184>
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   195bc:	00000913          	li	s2,0
   195c0:	fd060793          	addi	a5,a2,-48
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
   195c4:	001d8d93          	addi	s11,s11,1
   195c8:	fffdc603          	lbu	a2,-1(s11)
			goto rflag;
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
   195cc:	00191893          	slli	a7,s2,0x1
   195d0:	00391913          	slli	s2,s2,0x3
   195d4:	01288933          	add	s2,a7,s2
   195d8:	01278933          	add	s2,a5,s2
				ch = *fmt++;
			} while (is_digit (ch));
   195dc:	fd060793          	addi	a5,a2,-48
   195e0:	fef572e3          	bleu	a5,a0,195c4 <_vfiprintf_r+0x518>
   195e4:	c55ff06f          	j	19238 <_vfiprintf_r+0x18c>
   195e8:	2c0814e3          	bnez	a6,1a0b0 <_vfiprintf_r+0x1004>
				size = 1;
			}
			sign = '\0';
			break;
		case 'D':  /* extension */
			flags |= LONGINT;
   195ec:	010beb93          	ori	s7,s7,16
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   195f0:	010bf793          	andi	a5,s7,16
   195f4:	74078463          	beqz	a5,19d3c <_vfiprintf_r+0xc90>
   195f8:	01012883          	lw	a7,16(sp)
   195fc:	0008a783          	lw	a5,0(a7)
   19600:	00488893          	addi	a7,a7,4
   19604:	01112823          	sw	a7,16(sp)
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
#else
			if ((long) _uquad < 0)
   19608:	0807c8e3          	bltz	a5,19e98 <_vfiprintf_r+0xdec>
   1960c:	03714583          	lbu	a1,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   19610:	68074263          	bltz	a4,19c94 <_vfiprintf_r+0xbe8>
				flags &= ~ZEROPAD;
   19614:	f7fbfb93          	andi	s7,s7,-129
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   19618:	12078263          	beqz	a5,1973c <_vfiprintf_r+0x690>
						*--cp = '0';
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   1961c:	00900613          	li	a2,9
   19620:	000c8413          	mv	s0,s9
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   19624:	00a00513          	li	a0,10
						*--cp = '0';
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   19628:	10f67e63          	bleu	a5,a2,19744 <_vfiprintf_r+0x698>
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   1962c:	02a7f633          	remu	a2,a5,a0
   19630:	fff40413          	addi	s0,s0,-1
					       next cases. */
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
   19634:	02a7d7b3          	divu	a5,a5,a0
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   19638:	03060613          	addi	a2,a2,48
   1963c:	00c40023          	sb	a2,0(s0)
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
					} while (_uquad != 0);
   19640:	fe0796e3          	bnez	a5,1962c <_vfiprintf_r+0x580>
   19644:	408c8a33          	sub	s4,s9,s0
   19648:	d29ff06f          	j	19370 <_vfiprintf_r+0x2c4>
   1964c:	24081ee3          	bnez	a6,1a0a8 <_vfiprintf_r+0xffc>
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
   19650:	010beb93          	ori	s7,s7,16
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   19654:	010bf793          	andi	a5,s7,16
   19658:	64079e63          	bnez	a5,19cb4 <_vfiprintf_r+0xc08>
   1965c:	040bf793          	andi	a5,s7,64
   19660:	64078a63          	beqz	a5,19cb4 <_vfiprintf_r+0xc08>
   19664:	01012883          	lw	a7,16(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   19668:	02010ba3          	sb	zero,55(sp)
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   1966c:	00488613          	addi	a2,a7,4
   19670:	0008d783          	lhu	a5,0(a7)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   19674:	64074a63          	bltz	a4,19cc8 <_vfiprintf_r+0xc1c>
				flags &= ~ZEROPAD;
   19678:	f7fbfb93          	andi	s7,s7,-129
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   1967c:	00c12823          	sw	a2,16(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   19680:	64079a63          	bnez	a5,19cd4 <_vfiprintf_r+0xc28>
   19684:	00000593          	li	a1,0
   19688:	00000793          	li	a5,0
   1968c:	1e0700e3          	beqz	a4,1a06c <_vfiprintf_r+0xfc0>
   19690:	000c8413          	mv	s0,s9
				 * a variable; hence this switch.
				 */
				switch (base) {
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   19694:	0077f613          	andi	a2,a5,7
   19698:	fff40413          	addi	s0,s0,-1
   1969c:	03060613          	addi	a2,a2,48
						_uquad >>= 3;
   196a0:	0037d793          	srli	a5,a5,0x3
				 * a variable; hence this switch.
				 */
				switch (base) {
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   196a4:	00c40023          	sb	a2,0(s0)
						_uquad >>= 3;
					} while (_uquad);
   196a8:	fe0796e3          	bnez	a5,19694 <_vfiprintf_r+0x5e8>
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
   196ac:	001bf793          	andi	a5,s7,1
   196b0:	f8078ae3          	beqz	a5,19644 <_vfiprintf_r+0x598>
   196b4:	03000793          	li	a5,48
   196b8:	f8f606e3          	beq	a2,a5,19644 <_vfiprintf_r+0x598>
						*--cp = '0';
   196bc:	fff40613          	addi	a2,s0,-1
   196c0:	fef40fa3          	sb	a5,-1(s0)
   196c4:	40cc8a33          	sub	s4,s9,a2
   196c8:	00060413          	mv	s0,a2
   196cc:	ca5ff06f          	j	19370 <_vfiprintf_r+0x2c4>
   196d0:	18081ae3          	bnez	a6,1a064 <_vfiprintf_r+0xfb8>
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
				*GET_ARG (N, ap, quad_ptr_t) = ret;
			else
#endif
			if (flags & LONGINT)
   196d4:	010bf793          	andi	a5,s7,16
   196d8:	22079663          	bnez	a5,19904 <_vfiprintf_r+0x858>
				*GET_ARG (N, ap, long_ptr_t) = ret;
			else if (flags & SHORTINT)
   196dc:	040bf293          	andi	t0,s7,64
   196e0:	22028263          	beqz	t0,19904 <_vfiprintf_r+0x858>
				*GET_ARG (N, ap, short_ptr_t) = ret;
   196e4:	01012703          	lw	a4,16(sp)
   196e8:	01412883          	lw	a7,20(sp)
   196ec:	00072783          	lw	a5,0(a4)
   196f0:	00470713          	addi	a4,a4,4
   196f4:	00e12823          	sw	a4,16(sp)
   196f8:	01179023          	sh	a7,0(a5)
   196fc:	a9dff06f          	j	19198 <_vfiprintf_r+0xec>
   19700:	18081ce3          	bnez	a6,1a098 <_vfiprintf_r+0xfec>
			} else
				size = strlen (cp);

			break;
		case 'U': /* extension */
			flags |= LONGINT;
   19704:	010beb93          	ori	s7,s7,16
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   19708:	010bf793          	andi	a5,s7,16
   1970c:	56079663          	bnez	a5,19c78 <_vfiprintf_r+0xbcc>
   19710:	040bf793          	andi	a5,s7,64
   19714:	56078263          	beqz	a5,19c78 <_vfiprintf_r+0xbcc>
   19718:	01012783          	lw	a5,16(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   1971c:	02010ba3          	sb	zero,55(sp)
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   19720:	00478613          	addi	a2,a5,4
   19724:	0007d783          	lhu	a5,0(a5)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   19728:	56074263          	bltz	a4,19c8c <_vfiprintf_r+0xbe0>
				flags &= ~ZEROPAD;
   1972c:	f7fbfb93          	andi	s7,s7,-129
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   19730:	00c12823          	sw	a2,16(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   19734:	00000593          	li	a1,0
   19738:	ee0792e3          	bnez	a5,1961c <_vfiprintf_r+0x570>
   1973c:	c20704e3          	beqz	a4,19364 <_vfiprintf_r+0x2b8>
   19740:	00000793          	li	a5,0
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
						*--cp = to_char(_uquad);
   19744:	03078793          	addi	a5,a5,48
   19748:	06f107a3          	sb	a5,111(sp)
   1974c:	02412a03          	lw	s4,36(sp)
   19750:	06f10413          	addi	s0,sp,111
						break;
   19754:	c1dff06f          	j	19370 <_vfiprintf_r+0x2c4>
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
   19758:	b0031ae3          	bnez	t1,1926c <_vfiprintf_r+0x1c0>
   1975c:	00100813          	li	a6,1
				sign = ' ';
   19760:	02000313          	li	t1,32
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   19764:	000d8493          	mv	s1,s11
   19768:	ac9ff06f          	j	19230 <_vfiprintf_r+0x184>
			 */
			if (!sign)
				sign = ' ';
			goto rflag;
		case '#':
			flags |= ALT;
   1976c:	001beb93          	ori	s7,s7,1
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   19770:	000d8493          	mv	s1,s11
   19774:	abdff06f          	j	19230 <_vfiprintf_r+0x184>
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   19778:	01012783          	lw	a5,16(sp)
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
   1977c:	02010ba3          	sb	zero,55(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   19780:	0007a403          	lw	s0,0(a5)
   19784:	00478493          	addi	s1,a5,4
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
   19788:	040400e3          	beqz	s0,19fc8 <_vfiprintf_r+0xf1c>
				}
				cp[size] = '\0';
			}
			else
#endif /* _MB_CAPABLE */
			if (prec >= 0) {
   1978c:	7a074463          	bltz	a4,19f34 <_vfiprintf_r+0xe88>
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);
   19790:	00070613          	mv	a2,a4
   19794:	00000593          	li	a1,0
   19798:	00040513          	mv	a0,s0
   1979c:	00d12423          	sw	a3,8(sp)
   197a0:	00e12223          	sw	a4,4(sp)
   197a4:	cadfd0ef          	jal	17450 <memchr>

				if (p != NULL)
   197a8:	00812683          	lw	a3,8(sp)
   197ac:	00412703          	lw	a4,4(sp)
   197b0:	04050ae3          	beqz	a0,1a004 <_vfiprintf_r+0xf58>
					size = p - cp;
   197b4:	40850a33          	sub	s4,a0,s0
   197b8:	03714583          	lbu	a1,55(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   197bc:	00912823          	sw	s1,16(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   197c0:	00000713          	li	a4,0
   197c4:	badff06f          	j	19370 <_vfiprintf_r+0x2c4>
   197c8:	f40800e3          	beqz	a6,19708 <_vfiprintf_r+0x65c>
   197cc:	02610ba3          	sb	t1,55(sp)
   197d0:	f39ff06f          	j	19708 <_vfiprintf_r+0x65c>
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   197d4:	01012703          	lw	a4,16(sp)
				size = 1;
			}
			sign = '\0';
			break;
   197d8:	00100993          	li	s3,1
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
				size = 1;
			}
			sign = '\0';
   197dc:	02010ba3          	sb	zero,55(sp)
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   197e0:	00072783          	lw	a5,0(a4)
   197e4:	00470713          	addi	a4,a4,4
   197e8:	00e12823          	sw	a4,16(sp)
   197ec:	04f10423          	sb	a5,72(sp)
				size = 1;
   197f0:	00098a13          	mv	s4,s3
		    flags |= QUADINT;
		  goto rflag;
		case 'C':
#endif /* _WANT_IO_C99_FORMATS */
		case 'c':
			cp = buf;
   197f4:	04810413          	addi	s0,sp,72
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   197f8:	00000713          	li	a4,0
   197fc:	b89ff06f          	j	19384 <_vfiprintf_r+0x2d8>
   19800:	de0808e3          	beqz	a6,195f0 <_vfiprintf_r+0x544>
   19804:	02610ba3          	sb	t1,55(sp)
   19808:	de9ff06f          	j	195f0 <_vfiprintf_r+0x544>
   1980c:	0a0816e3          	bnez	a6,1a0b8 <_vfiprintf_r+0x100c>
		case 'u':
			_uquad = UARG ();
			base = DEC;
			goto nosign;
		case 'X':
			xdigs = "0123456789ABCDEF";
   19810:	0001d7b7          	lui	a5,0x1d
   19814:	bf478793          	addi	a5,a5,-1036 # 1cbf4 <__thenan_sf+0x24>
   19818:	00f12e23          	sw	a5,28(sp)
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
   1981c:	010bf793          	andi	a5,s7,16
   19820:	06078063          	beqz	a5,19880 <_vfiprintf_r+0x7d4>
   19824:	01012883          	lw	a7,16(sp)
   19828:	0008a783          	lw	a5,0(a7)
   1982c:	00488893          	addi	a7,a7,4
   19830:	01112823          	sw	a7,16(sp)
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
   19834:	001bf593          	andi	a1,s7,1
   19838:	4a058263          	beqz	a1,19cdc <_vfiprintf_r+0xc30>
   1983c:	62079a63          	bnez	a5,19e70 <_vfiprintf_r+0xdc4>

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   19840:	02010ba3          	sb	zero,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   19844:	60074263          	bltz	a4,19e48 <_vfiprintf_r+0xd9c>
				flags &= ~ZEROPAD;
   19848:	f7fbfb93          	andi	s7,s7,-129
   1984c:	b11ff06f          	j	1935c <_vfiprintf_r+0x2b0>
   19850:	e00802e3          	beqz	a6,19654 <_vfiprintf_r+0x5a8>
   19854:	02610ba3          	sb	t1,55(sp)
   19858:	dfdff06f          	j	19654 <_vfiprintf_r+0x5a8>
			if (*fmt == 'h') {
				fmt++;
				flags |= CHARINT;
			} else
#endif
				flags |= SHORTINT;
   1985c:	040beb93          	ori	s7,s7,64
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   19860:	000d8493          	mv	s1,s11
   19864:	9cdff06f          	j	19230 <_vfiprintf_r+0x184>
   19868:	7e081a63          	bnez	a6,1a05c <_vfiprintf_r+0xfb0>
			goto nosign;
		case 'X':
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
   1986c:	0001d7b7          	lui	a5,0x1d
   19870:	c0878793          	addi	a5,a5,-1016 # 1cc08 <__thenan_sf+0x38>
   19874:	00f12e23          	sw	a5,28(sp)
hex:			_uquad = UARG ();
   19878:	010bf793          	andi	a5,s7,16
   1987c:	fa0794e3          	bnez	a5,19824 <_vfiprintf_r+0x778>
   19880:	040bf793          	andi	a5,s7,64
   19884:	01012883          	lw	a7,16(sp)
   19888:	62078663          	beqz	a5,19eb4 <_vfiprintf_r+0xe08>
   1988c:	0008d783          	lhu	a5,0(a7)
   19890:	00488893          	addi	a7,a7,4
   19894:	01112823          	sw	a7,16(sp)
   19898:	f9dff06f          	j	19834 <_vfiprintf_r+0x788>
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
   1989c:	000dc603          	lbu	a2,0(s11)
   198a0:	001d8d93          	addi	s11,s11,1
   198a4:	78760c63          	beq	a2,t2,1a03c <_vfiprintf_r+0xf90>
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   198a8:	fd060793          	addi	a5,a2,-48
   198ac:	00000713          	li	a4,0
   198b0:	98f564e3          	bltu	a0,a5,19238 <_vfiprintf_r+0x18c>
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
   198b4:	001d8d93          	addi	s11,s11,1
   198b8:	fffdc603          	lbu	a2,-1(s11)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
				n = 10 * n + to_digit (ch);
   198bc:	00171893          	slli	a7,a4,0x1
   198c0:	00371713          	slli	a4,a4,0x3
   198c4:	00e88733          	add	a4,a7,a4
   198c8:	00f70733          	add	a4,a4,a5
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   198cc:	fd060793          	addi	a5,a2,-48
   198d0:	fef572e3          	bleu	a5,a0,198b4 <_vfiprintf_r+0x808>
   198d4:	960752e3          	bgez	a4,19238 <_vfiprintf_r+0x18c>
   198d8:	fff00713          	li	a4,-1
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			}
			prec = n < 0 ? -1 : n;
			goto reswitch;
   198dc:	95dff06f          	j	19238 <_vfiprintf_r+0x18c>
   198e0:	7c081063          	bnez	a6,1a0a0 <_vfiprintf_r+0xff4>

			size = buf + BUF - cp;
		skipsize:
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
   198e4:	18060863          	beqz	a2,19a74 <_vfiprintf_r+0x9c8>
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
   198e8:	00100993          	li	s3,1
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
   198ec:	04c10423          	sb	a2,72(sp)
			size = 1;
			sign = '\0';
   198f0:	02010ba3          	sb	zero,55(sp)
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
   198f4:	00098a13          	mv	s4,s3
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
   198f8:	04810413          	addi	s0,sp,72
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   198fc:	00000713          	li	a4,0
   19900:	a85ff06f          	j	19384 <_vfiprintf_r+0x2d8>
#ifdef _WANT_IO_C99_FORMATS
			else if (flags & CHARINT)
				*GET_ARG (N, ap, char_ptr_t) = ret;
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
   19904:	01012703          	lw	a4,16(sp)
   19908:	01412883          	lw	a7,20(sp)
   1990c:	00072783          	lw	a5,0(a4)
   19910:	00470713          	addi	a4,a4,4
   19914:	00e12823          	sw	a4,16(sp)
   19918:	0117a023          	sw	a7,0(a5)
   1991c:	87dff06f          	j	19198 <_vfiprintf_r+0xec>
   19920:	03c10613          	addi	a2,sp,60
   19924:	000d0593          	mv	a1,s10
   19928:	000a8513          	mv	a0,s5
   1992c:	01012223          	sw	a6,4(sp)
   19930:	01d12423          	sw	t4,8(sp)
   19934:	e78ff0ef          	jal	18fac <__sprint_r.part.0>
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   19938:	00412803          	lw	a6,4(sp)
   1993c:	00812e83          	lw	t4,8(sp)
   19940:	14051663          	bnez	a0,19a8c <_vfiprintf_r+0x9e0>
   19944:	04012503          	lw	a0,64(sp)
   19948:	04412783          	lw	a5,68(sp)
   1994c:	000c8693          	mv	a3,s9
   19950:	00150613          	addi	a2,a0,1
   19954:	a89ff06f          	j	193dc <_vfiprintf_r+0x330>
   19958:	04012603          	lw	a2,64(sp)
   1995c:	04412783          	lw	a5,68(sp)
   19960:	00160593          	addi	a1,a2,1

		/* prefix */
		if (sign)
   19964:	03714503          	lbu	a0,55(sp)
   19968:	ae050ae3          	beqz	a0,1945c <_vfiprintf_r+0x3b0>
			PRINT (&sign, 1);
   1996c:	00100513          	li	a0,1
   19970:	03710613          	addi	a2,sp,55
   19974:	00a787b3          	add	a5,a5,a0
   19978:	00c6a023          	sw	a2,0(a3)
   1997c:	00700613          	li	a2,7
   19980:	00a6a223          	sw	a0,4(a3)
   19984:	04f12223          	sw	a5,68(sp)
   19988:	04b12023          	sw	a1,64(sp)
   1998c:	2ab65863          	ble	a1,a2,19c3c <_vfiprintf_r+0xb90>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   19990:	3e079663          	bnez	a5,19d7c <_vfiprintf_r+0xcd0>
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
   19994:	2a0e1e63          	bnez	t3,19c50 <_vfiprintf_r+0xba4>
   19998:	00000613          	li	a2,0
   1999c:	00050593          	mv	a1,a0
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
   199a0:	000c8693          	mv	a3,s9
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   199a4:	08000513          	li	a0,128
   199a8:	aea38ae3          	beq	t2,a0,1949c <_vfiprintf_r+0x3f0>
			PAD (width - realsz, zeroes);

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   199ac:	414704b3          	sub	s1,a4,s4
   199b0:	b8905ee3          	blez	s1,1954c <_vfiprintf_r+0x4a0>
   199b4:	01000813          	li	a6,16
   199b8:	01812c23          	sw	s8,24(sp)
   199bc:	04985a63          	ble	s1,a6,19a10 <_vfiprintf_r+0x964>
   199c0:	00700393          	li	t2,7
   199c4:	0180006f          	j	199dc <_vfiprintf_r+0x930>
   199c8:	00260593          	addi	a1,a2,2
   199cc:	00868693          	addi	a3,a3,8
   199d0:	00070613          	mv	a2,a4
   199d4:	ff048493          	addi	s1,s1,-16
   199d8:	02985c63          	ble	s1,a6,19a10 <_vfiprintf_r+0x964>
   199dc:	01078793          	addi	a5,a5,16
   199e0:	00160713          	addi	a4,a2,1
   199e4:	0186a023          	sw	s8,0(a3)
   199e8:	0106a223          	sw	a6,4(a3)
   199ec:	04f12223          	sw	a5,68(sp)
   199f0:	04e12023          	sw	a4,64(sp)
   199f4:	fce3dae3          	ble	a4,t2,199c8 <_vfiprintf_r+0x91c>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   199f8:	04079263          	bnez	a5,19a3c <_vfiprintf_r+0x990>
		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   199fc:	ff048493          	addi	s1,s1,-16
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   19a00:	00100593          	li	a1,1
   19a04:	00000613          	li	a2,0
		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   19a08:	000c8693          	mv	a3,s9
   19a0c:	fc9848e3          	blt	a6,s1,199dc <_vfiprintf_r+0x930>
   19a10:	01812703          	lw	a4,24(sp)
   19a14:	009787b3          	add	a5,a5,s1
   19a18:	0096a223          	sw	s1,4(a3)
   19a1c:	00e6a023          	sw	a4,0(a3)
   19a20:	00700713          	li	a4,7
   19a24:	04f12223          	sw	a5,68(sp)
   19a28:	04b12023          	sw	a1,64(sp)
   19a2c:	06b74a63          	blt	a4,a1,19aa0 <_vfiprintf_r+0x9f4>
   19a30:	00868693          	addi	a3,a3,8
   19a34:	00158593          	addi	a1,a1,1
   19a38:	b15ff06f          	j	1954c <_vfiprintf_r+0x4a0>
   19a3c:	03c10613          	addi	a2,sp,60
   19a40:	000d0593          	mv	a1,s10
   19a44:	000a8513          	mv	a0,s5
   19a48:	00712023          	sw	t2,0(sp)
   19a4c:	01012223          	sw	a6,4(sp)
   19a50:	d5cff0ef          	jal	18fac <__sprint_r.part.0>
   19a54:	00012383          	lw	t2,0(sp)
   19a58:	00412803          	lw	a6,4(sp)
   19a5c:	02051863          	bnez	a0,19a8c <_vfiprintf_r+0x9e0>
   19a60:	04012603          	lw	a2,64(sp)
   19a64:	04412783          	lw	a5,68(sp)
   19a68:	000c8693          	mv	a3,s9
   19a6c:	00160593          	addi	a1,a2,1
   19a70:	f65ff06f          	j	199d4 <_vfiprintf_r+0x928>
			_free_r (data, malloc_buf);
			malloc_buf = NULL;
		}
	}
done:
	FLUSH ();
   19a74:	04412783          	lw	a5,68(sp)
   19a78:	00078a63          	beqz	a5,19a8c <_vfiprintf_r+0x9e0>
   19a7c:	03c10613          	addi	a2,sp,60
   19a80:	000d0593          	mv	a1,s10
   19a84:	000a8513          	mv	a0,s5
   19a88:	d24ff0ef          	jal	18fac <__sprint_r.part.0>
	if (malloc_buf != NULL)
		_free_r (data, malloc_buf);
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
   19a8c:	00cd5783          	lhu	a5,12(s10)
   19a90:	0407f793          	andi	a5,a5,64
   19a94:	48079063          	bnez	a5,19f14 <_vfiprintf_r+0xe68>
   19a98:	01412503          	lw	a0,20(sp)
   19a9c:	815ff06f          	j	192b0 <_vfiprintf_r+0x204>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   19aa0:	36079463          	bnez	a5,19e08 <_vfiprintf_r+0xd5c>
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   19aa4:	00100713          	li	a4,1
   19aa8:	000a0793          	mv	a5,s4
   19aac:	06812823          	sw	s0,112(sp)
   19ab0:	07412a23          	sw	s4,116(sp)
   19ab4:	05412223          	sw	s4,68(sp)
   19ab8:	04e12023          	sw	a4,64(sp)
   19abc:	000c8693          	mv	a3,s9
   19ac0:	00868693          	addi	a3,a3,8
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   19ac4:	004bf293          	andi	t0,s7,4
   19ac8:	0e028463          	beqz	t0,19bb0 <_vfiprintf_r+0xb04>
			PAD (width - realsz, blanks);
   19acc:	413904b3          	sub	s1,s2,s3
   19ad0:	0e905063          	blez	s1,19bb0 <_vfiprintf_r+0xb04>
   19ad4:	01000a13          	li	s4,16
   19ad8:	509a5e63          	ble	s1,s4,19ff4 <_vfiprintf_r+0xf48>
   19adc:	04012603          	lw	a2,64(sp)
   19ae0:	01612c23          	sw	s6,24(sp)
   19ae4:	00700413          	li	s0,7
   19ae8:	0180006f          	j	19b00 <_vfiprintf_r+0xa54>
   19aec:	00260593          	addi	a1,a2,2
   19af0:	00868693          	addi	a3,a3,8
   19af4:	00070613          	mv	a2,a4
   19af8:	ff048493          	addi	s1,s1,-16
   19afc:	029a5c63          	ble	s1,s4,19b34 <_vfiprintf_r+0xa88>
   19b00:	01078793          	addi	a5,a5,16
   19b04:	00160713          	addi	a4,a2,1
   19b08:	0166a023          	sw	s6,0(a3)
   19b0c:	0146a223          	sw	s4,4(a3)
   19b10:	04f12223          	sw	a5,68(sp)
   19b14:	04e12023          	sw	a4,64(sp)
   19b18:	fce45ae3          	ble	a4,s0,19aec <_vfiprintf_r+0xa40>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   19b1c:	04079a63          	bnez	a5,19b70 <_vfiprintf_r+0xac4>
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
			PAD (width - realsz, blanks);
   19b20:	ff048493          	addi	s1,s1,-16
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   19b24:	00100593          	li	a1,1
   19b28:	00000613          	li	a2,0
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
			PAD (width - realsz, blanks);
   19b2c:	000c8693          	mv	a3,s9
   19b30:	fc9a48e3          	blt	s4,s1,19b00 <_vfiprintf_r+0xa54>
   19b34:	01812883          	lw	a7,24(sp)
   19b38:	009787b3          	add	a5,a5,s1
   19b3c:	00700713          	li	a4,7
   19b40:	0116a023          	sw	a7,0(a3)
   19b44:	0096a223          	sw	s1,4(a3)
   19b48:	04f12223          	sw	a5,68(sp)
   19b4c:	04b12023          	sw	a1,64(sp)
   19b50:	06b75063          	ble	a1,a4,19bb0 <_vfiprintf_r+0xb04>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   19b54:	04079263          	bnez	a5,19b98 <_vfiprintf_r+0xaec>
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
			PAD (width - realsz, blanks);

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   19b58:	01395463          	ble	s3,s2,19b60 <_vfiprintf_r+0xab4>
   19b5c:	00098913          	mv	s2,s3
   19b60:	01412703          	lw	a4,20(sp)
   19b64:	01270733          	add	a4,a4,s2
   19b68:	00e12a23          	sw	a4,20(sp)
   19b6c:	a29ff06f          	j	19594 <_vfiprintf_r+0x4e8>
   19b70:	03c10613          	addi	a2,sp,60
   19b74:	000d0593          	mv	a1,s10
   19b78:	000a8513          	mv	a0,s5
   19b7c:	c30ff0ef          	jal	18fac <__sprint_r.part.0>
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
			PAD (width - realsz, blanks);
   19b80:	f00516e3          	bnez	a0,19a8c <_vfiprintf_r+0x9e0>
   19b84:	04012603          	lw	a2,64(sp)
   19b88:	04412783          	lw	a5,68(sp)
   19b8c:	000c8693          	mv	a3,s9
   19b90:	00160593          	addi	a1,a2,1
   19b94:	f65ff06f          	j	19af8 <_vfiprintf_r+0xa4c>
   19b98:	03c10613          	addi	a2,sp,60
   19b9c:	000d0593          	mv	a1,s10
   19ba0:	000a8513          	mv	a0,s5
   19ba4:	c08ff0ef          	jal	18fac <__sprint_r.part.0>
   19ba8:	ee0512e3          	bnez	a0,19a8c <_vfiprintf_r+0x9e0>
   19bac:	04412783          	lw	a5,68(sp)

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   19bb0:	01395463          	ble	s3,s2,19bb8 <_vfiprintf_r+0xb0c>
   19bb4:	00098913          	mv	s2,s3
   19bb8:	01412883          	lw	a7,20(sp)
   19bbc:	012888b3          	add	a7,a7,s2
   19bc0:	01112a23          	sw	a7,20(sp)

		FLUSH ();	/* copy out the I/O vectors */
   19bc4:	9c0788e3          	beqz	a5,19594 <_vfiprintf_r+0x4e8>
   19bc8:	03c10613          	addi	a2,sp,60
   19bcc:	000d0593          	mv	a1,s10
   19bd0:	000a8513          	mv	a0,s5
   19bd4:	bd8ff0ef          	jal	18fac <__sprint_r.part.0>
   19bd8:	9a050ee3          	beqz	a0,19594 <_vfiprintf_r+0x4e8>
   19bdc:	eb1ff06f          	j	19a8c <_vfiprintf_r+0x9e0>
   19be0:	03c10613          	addi	a2,sp,60
   19be4:	000d0593          	mv	a1,s10
   19be8:	000a8513          	mv	a0,s5
   19bec:	00712023          	sw	t2,0(sp)
   19bf0:	01012223          	sw	a6,4(sp)
   19bf4:	bb8ff0ef          	jal	18fac <__sprint_r.part.0>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   19bf8:	00012383          	lw	t2,0(sp)
   19bfc:	00412803          	lw	a6,4(sp)
   19c00:	e80516e3          	bnez	a0,19a8c <_vfiprintf_r+0x9e0>
   19c04:	04012603          	lw	a2,64(sp)
   19c08:	04412783          	lw	a5,68(sp)
   19c0c:	000c8693          	mv	a3,s9
   19c10:	00160513          	addi	a0,a2,1
   19c14:	8bdff06f          	j	194d0 <_vfiprintf_r+0x424>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   19c18:	2a079e63          	bnez	a5,19ed4 <_vfiprintf_r+0xe28>
		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
   19c1c:	03714683          	lbu	a3,55(sp)
   19c20:	02068663          	beqz	a3,19c4c <_vfiprintf_r+0xba0>
			PRINT (&sign, 1);
   19c24:	00100793          	li	a5,1
   19c28:	03710693          	addi	a3,sp,55
   19c2c:	06d12823          	sw	a3,112(sp)
   19c30:	00078593          	mv	a1,a5
   19c34:	06f12a23          	sw	a5,116(sp)
   19c38:	000c8693          	mv	a3,s9
   19c3c:	00058613          	mv	a2,a1
   19c40:	00868693          	addi	a3,a3,8
   19c44:	00158593          	addi	a1,a1,1
   19c48:	815ff06f          	j	1945c <_vfiprintf_r+0x3b0>
		if (flags & HEXPREFIX)
   19c4c:	2c0e0863          	beqz	t3,19f1c <_vfiprintf_r+0xe70>
			PRINT (ox, 2);
   19c50:	03810693          	addi	a3,sp,56
   19c54:	00200793          	li	a5,2
   19c58:	06d12823          	sw	a3,112(sp)
   19c5c:	06f12a23          	sw	a5,116(sp)
   19c60:	00100593          	li	a1,1
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   19c64:	000c8693          	mv	a3,s9

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
			PRINT (ox, 2);
   19c68:	00058613          	mv	a2,a1
   19c6c:	00868693          	addi	a3,a3,8
   19c70:	00158593          	addi	a1,a1,1
   19c74:	d31ff06f          	j	199a4 <_vfiprintf_r+0x8f8>
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   19c78:	01012883          	lw	a7,16(sp)
   19c7c:	0008a783          	lw	a5,0(a7)
   19c80:	00488613          	addi	a2,a7,4

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   19c84:	02010ba3          	sb	zero,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   19c88:	aa0752e3          	bgez	a4,1972c <_vfiprintf_r+0x680>
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   19c8c:	00c12823          	sw	a2,16(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   19c90:	00000593          	li	a1,0
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   19c94:	980794e3          	bnez	a5,1961c <_vfiprintf_r+0x570>
   19c98:	00100793          	li	a5,1
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   19c9c:	00100613          	li	a2,1
   19ca0:	aac780e3          	beq	a5,a2,19740 <_vfiprintf_r+0x694>
   19ca4:	00200613          	li	a2,2
   19ca8:	0cc78663          	beq	a5,a2,19d74 <_vfiprintf_r+0xcc8>
   19cac:	00000793          	li	a5,0
   19cb0:	9e1ff06f          	j	19690 <_vfiprintf_r+0x5e4>
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   19cb4:	01012783          	lw	a5,16(sp)
   19cb8:	00478613          	addi	a2,a5,4
   19cbc:	0007a783          	lw	a5,0(a5)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   19cc0:	02010ba3          	sb	zero,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   19cc4:	9a075ae3          	bgez	a4,19678 <_vfiprintf_r+0x5cc>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   19cc8:	00c12823          	sw	a2,16(sp)
   19ccc:	00000593          	li	a1,0
   19cd0:	fc0786e3          	beqz	a5,19c9c <_vfiprintf_r+0xbf0>
   19cd4:	00000593          	li	a1,0
   19cd8:	9b9ff06f          	j	19690 <_vfiprintf_r+0x5e4>

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   19cdc:	02010ba3          	sb	zero,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   19ce0:	16074263          	bltz	a4,19e44 <_vfiprintf_r+0xd98>
				flags &= ~ZEROPAD;
   19ce4:	f7fbfb93          	andi	s7,s7,-129
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   19ce8:	e6078a63          	beqz	a5,1935c <_vfiprintf_r+0x2b0>
   19cec:	00000593          	li	a1,0
   19cf0:	01c12503          	lw	a0,28(sp)
   19cf4:	000c8413          	mv	s0,s9
					} while (_uquad != 0);
					break;

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   19cf8:	00f7f613          	andi	a2,a5,15
   19cfc:	00c50633          	add	a2,a0,a2
   19d00:	00064603          	lbu	a2,0(a2)
   19d04:	fff40413          	addi	s0,s0,-1
						_uquad >>= 4;
   19d08:	0047d793          	srli	a5,a5,0x4
					} while (_uquad != 0);
					break;

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   19d0c:	00c40023          	sb	a2,0(s0)
						_uquad >>= 4;
					} while (_uquad);
   19d10:	fe0794e3          	bnez	a5,19cf8 <_vfiprintf_r+0xc4c>
   19d14:	408c8a33          	sub	s4,s9,s0
   19d18:	e58ff06f          	j	19370 <_vfiprintf_r+0x2c4>
   19d1c:	03c10613          	addi	a2,sp,60
   19d20:	000d0593          	mv	a1,s10
   19d24:	000a8513          	mv	a0,s5
   19d28:	a84ff0ef          	jal	18fac <__sprint_r.part.0>
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   19d2c:	d60510e3          	bnez	a0,19a8c <_vfiprintf_r+0x9e0>
   19d30:	04412783          	lw	a5,68(sp)
   19d34:	000c8693          	mv	a3,s9
   19d38:	d8dff06f          	j	19ac4 <_vfiprintf_r+0xa18>
		case 'D':  /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   19d3c:	040bf793          	andi	a5,s7,64
   19d40:	01012883          	lw	a7,16(sp)
   19d44:	18078063          	beqz	a5,19ec4 <_vfiprintf_r+0xe18>
   19d48:	00089783          	lh	a5,0(a7)
   19d4c:	00488893          	addi	a7,a7,4
   19d50:	01112823          	sw	a7,16(sp)
   19d54:	8b5ff06f          	j	19608 <_vfiprintf_r+0x55c>
   19d58:	03c10613          	addi	a2,sp,60
   19d5c:	000d0593          	mv	a1,s10
   19d60:	000a8513          	mv	a0,s5
   19d64:	a48ff0ef          	jal	18fac <__sprint_r.part.0>
#else
                while (*fmt != '\0' && *fmt != '%')
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
			PRINT (cp, m);
   19d68:	d20512e3          	bnez	a0,19a8c <_vfiprintf_r+0x9e0>
   19d6c:	000c8693          	mv	a3,s9
   19d70:	c84ff06f          	j	191f4 <_vfiprintf_r+0x148>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   19d74:	00000793          	li	a5,0
   19d78:	f79ff06f          	j	19cf0 <_vfiprintf_r+0xc44>
   19d7c:	03c10613          	addi	a2,sp,60
   19d80:	000d0593          	mv	a1,s10
   19d84:	000a8513          	mv	a0,s5
   19d88:	00712023          	sw	t2,0(sp)
   19d8c:	00e12223          	sw	a4,4(sp)
   19d90:	01c12423          	sw	t3,8(sp)
   19d94:	a18ff0ef          	jal	18fac <__sprint_r.part.0>
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
   19d98:	00012383          	lw	t2,0(sp)
   19d9c:	00412703          	lw	a4,4(sp)
   19da0:	00812e03          	lw	t3,8(sp)
   19da4:	ce0514e3          	bnez	a0,19a8c <_vfiprintf_r+0x9e0>
   19da8:	04012603          	lw	a2,64(sp)
   19dac:	04412783          	lw	a5,68(sp)
   19db0:	000c8693          	mv	a3,s9
   19db4:	00160593          	addi	a1,a2,1
   19db8:	ea4ff06f          	j	1945c <_vfiprintf_r+0x3b0>
   19dbc:	03c10613          	addi	a2,sp,60
   19dc0:	000d0593          	mv	a1,s10
   19dc4:	000a8513          	mv	a0,s5
   19dc8:	00712023          	sw	t2,0(sp)
   19dcc:	00e12223          	sw	a4,4(sp)
   19dd0:	9dcff0ef          	jal	18fac <__sprint_r.part.0>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);
   19dd4:	00012383          	lw	t2,0(sp)
   19dd8:	00412703          	lw	a4,4(sp)
   19ddc:	ca0518e3          	bnez	a0,19a8c <_vfiprintf_r+0x9e0>
   19de0:	04012603          	lw	a2,64(sp)
   19de4:	04412783          	lw	a5,68(sp)
   19de8:	000c8693          	mv	a3,s9
   19dec:	00160593          	addi	a1,a2,1
   19df0:	bb5ff06f          	j	199a4 <_vfiprintf_r+0x8f8>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   19df4:	16079263          	bnez	a5,19f58 <_vfiprintf_r+0xeac>
		uio->uio_iovcnt = 0;
   19df8:	00100593          	li	a1,1
   19dfc:	00000613          	li	a2,0
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   19e00:	000c8693          	mv	a3,s9
   19e04:	ba9ff06f          	j	199ac <_vfiprintf_r+0x900>
   19e08:	03c10613          	addi	a2,sp,60
   19e0c:	000d0593          	mv	a1,s10
   19e10:	000a8513          	mv	a0,s5
   19e14:	998ff0ef          	jal	18fac <__sprint_r.part.0>

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   19e18:	c6051ae3          	bnez	a0,19a8c <_vfiprintf_r+0x9e0>
   19e1c:	04012583          	lw	a1,64(sp)
   19e20:	04412783          	lw	a5,68(sp)
   19e24:	000c8693          	mv	a3,s9
   19e28:	00158593          	addi	a1,a1,1
   19e2c:	f20ff06f          	j	1954c <_vfiprintf_r+0x4a0>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   19e30:	00c12823          	sw	a2,16(sp)
			base = HEX;
			xdigs = "0123456789abcdef";
   19e34:	0001d637          	lui	a2,0x1d
   19e38:	c0860613          	addi	a2,a2,-1016 # 1cc08 <__thenan_sf+0x38>
			flags |= HEXPREFIX;
   19e3c:	00050b93          	mv	s7,a0
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   19e40:	00c12e23          	sw	a2,28(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   19e44:	ea0794e3          	bnez	a5,19cec <_vfiprintf_r+0xc40>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   19e48:	00000593          	li	a1,0
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
   19e4c:	00200793          	li	a5,2
   19e50:	e4dff06f          	j	19c9c <_vfiprintf_r+0xbf0>
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   19e54:	000d8913          	mv	s2,s11
   19e58:	ba8ff06f          	j	19200 <_vfiprintf_r+0x154>
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   19e5c:	0001d637          	lui	a2,0x1d
   19e60:	c0860613          	addi	a2,a2,-1016 # 1cc08 <__thenan_sf+0x38>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   19e64:	00000593          	li	a1,0
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   19e68:	00c12e23          	sw	a2,28(sp)
   19e6c:	e85ff06f          	j	19cf0 <_vfiprintf_r+0xc44>
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
				ox[0] = '0';
   19e70:	03000593          	li	a1,48
				ox[1] = ch;
   19e74:	02c10ca3          	sb	a2,57(sp)
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
				ox[0] = '0';
   19e78:	02b10c23          	sb	a1,56(sp)
				ox[1] = ch;
				flags |= HEXPREFIX;
   19e7c:	002be613          	ori	a2,s7,2

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   19e80:	02010ba3          	sb	zero,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   19e84:	10074a63          	bltz	a4,19f98 <_vfiprintf_r+0xeec>
   19e88:	f7fbf293          	andi	t0,s7,-129
				flags &= ~ZEROPAD;
   19e8c:	0022eb93          	ori	s7,t0,2
   19e90:	00000593          	li	a1,0
   19e94:	e5dff06f          	j	19cf0 <_vfiprintf_r+0xc44>
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
				sign = '-';
   19e98:	02d00613          	li	a2,45
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
   19e9c:	40f007b3          	neg	a5,a5
				sign = '-';
   19ea0:	02c10ba3          	sb	a2,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   19ea4:	10074a63          	bltz	a4,19fb8 <_vfiprintf_r+0xf0c>
				flags &= ~ZEROPAD;
   19ea8:	f7fbfb93          	andi	s7,s7,-129
   19eac:	02d00593          	li	a1,45
   19eb0:	f6cff06f          	j	1961c <_vfiprintf_r+0x570>
		case 'X':
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
   19eb4:	0008a783          	lw	a5,0(a7)
   19eb8:	00488893          	addi	a7,a7,4
   19ebc:	01112823          	sw	a7,16(sp)
   19ec0:	975ff06f          	j	19834 <_vfiprintf_r+0x788>
		case 'D':  /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   19ec4:	0008a783          	lw	a5,0(a7)
   19ec8:	00488893          	addi	a7,a7,4
   19ecc:	01112823          	sw	a7,16(sp)
   19ed0:	f38ff06f          	j	19608 <_vfiprintf_r+0x55c>
   19ed4:	03c10613          	addi	a2,sp,60
   19ed8:	000d0593          	mv	a1,s10
   19edc:	000a8513          	mv	a0,s5
   19ee0:	00712023          	sw	t2,0(sp)
   19ee4:	00e12223          	sw	a4,4(sp)
   19ee8:	01c12423          	sw	t3,8(sp)
   19eec:	8c0ff0ef          	jal	18fac <__sprint_r.part.0>
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   19ef0:	00012383          	lw	t2,0(sp)
   19ef4:	00412703          	lw	a4,4(sp)
   19ef8:	00812e03          	lw	t3,8(sp)
   19efc:	b80518e3          	bnez	a0,19a8c <_vfiprintf_r+0x9e0>
   19f00:	04012603          	lw	a2,64(sp)
   19f04:	04412783          	lw	a5,68(sp)
   19f08:	000c8693          	mv	a3,s9
   19f0c:	00160593          	addi	a1,a2,1
   19f10:	a55ff06f          	j	19964 <_vfiprintf_r+0x8b8>
	ORIENT(fp, -1);

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
		_newlib_flockfile_exit (fp);
		return (EOF);
   19f14:	fff00513          	li	a0,-1
   19f18:	b98ff06f          	j	192b0 <_vfiprintf_r+0x204>
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
   19f1c:	00000613          	li	a2,0
   19f20:	00100593          	li	a1,1
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   19f24:	000c8693          	mv	a3,s9
   19f28:	a7dff06f          	j	199a4 <_vfiprintf_r+0x8f8>
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   19f2c:	000c8693          	mv	a3,s9
   19f30:	ba5ff06f          	j	19ad4 <_vfiprintf_r+0xa28>
				if (p != NULL)
					size = p - cp;
				else
					size = prec;
			} else
				size = strlen (cp);
   19f34:	00040513          	mv	a0,s0
   19f38:	00d12423          	sw	a3,8(sp)
   19f3c:	b08f80ef          	jal	12244 <strlen>
   19f40:	00050a13          	mv	s4,a0
   19f44:	03714583          	lbu	a1,55(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   19f48:	00912823          	sw	s1,16(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   19f4c:	00000713          	li	a4,0
   19f50:	00812683          	lw	a3,8(sp)
   19f54:	c1cff06f          	j	19370 <_vfiprintf_r+0x2c4>
   19f58:	03c10613          	addi	a2,sp,60
   19f5c:	000d0593          	mv	a1,s10
   19f60:	000a8513          	mv	a0,s5
   19f64:	00e12223          	sw	a4,4(sp)
   19f68:	844ff0ef          	jal	18fac <__sprint_r.part.0>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   19f6c:	00412703          	lw	a4,4(sp)
   19f70:	b0051ee3          	bnez	a0,19a8c <_vfiprintf_r+0x9e0>
   19f74:	04012603          	lw	a2,64(sp)
   19f78:	04412783          	lw	a5,68(sp)
   19f7c:	000c8693          	mv	a3,s9
   19f80:	00160593          	addi	a1,a2,1
   19f84:	a29ff06f          	j	199ac <_vfiprintf_r+0x900>
   19f88:	04012603          	lw	a2,64(sp)
   19f8c:	01612c23          	sw	s6,24(sp)
   19f90:	00160613          	addi	a2,a2,1
   19f94:	c98ff06f          	j	1942c <_vfiprintf_r+0x380>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   19f98:	00000593          	li	a1,0
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
   19f9c:	00200513          	li	a0,2
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   19fa0:	00100813          	li	a6,1
   19fa4:	09050063          	beq	a0,a6,1a024 <_vfiprintf_r+0xf78>
   19fa8:	00200813          	li	a6,2
   19fac:	09051063          	bne	a0,a6,1a02c <_vfiprintf_r+0xf80>
   19fb0:	00060b93          	mv	s7,a2
   19fb4:	d3dff06f          	j	19cf0 <_vfiprintf_r+0xc44>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   19fb8:	000b8613          	mv	a2,s7
   19fbc:	02d00593          	li	a1,45
			{

				_uquad = -_uquad;
				sign = '-';
			}
			base = DEC;
   19fc0:	00100513          	li	a0,1
   19fc4:	fddff06f          	j	19fa0 <_vfiprintf_r+0xef4>
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
				size = ((unsigned) prec > 6U) ? 6 : prec;
   19fc8:	00600793          	li	a5,6
   19fcc:	00e7f463          	bleu	a4,a5,19fd4 <_vfiprintf_r+0xf28>
   19fd0:	00078713          	mv	a4,a5
   19fd4:	00070a13          	mv	s4,a4
   19fd8:	00070993          	mv	s3,a4
   19fdc:	04074c63          	bltz	a4,1a034 <_vfiprintf_r+0xf88>
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
   19fe0:	0001d337          	lui	t1,0x1d
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   19fe4:	00912823          	sw	s1,16(sp)
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
   19fe8:	c1c30413          	addi	s0,t1,-996 # 1cc1c <__thenan_sf+0x4c>
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   19fec:	00000713          	li	a4,0
   19ff0:	b94ff06f          	j	19384 <_vfiprintf_r+0x2d8>
   19ff4:	04012583          	lw	a1,64(sp)
   19ff8:	01612c23          	sw	s6,24(sp)
   19ffc:	00158593          	addi	a1,a1,1
   1a000:	b35ff06f          	j	19b34 <_vfiprintf_r+0xa88>
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);

				if (p != NULL)
   1a004:	00070a13          	mv	s4,a4
   1a008:	03714583          	lbu	a1,55(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   1a00c:	00912823          	sw	s1,16(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   1a010:	00000713          	li	a4,0
   1a014:	b5cff06f          	j	19370 <_vfiprintf_r+0x2c4>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   1a018:	00058513          	mv	a0,a1
   1a01c:	01812c23          	sw	s8,24(sp)
   1a020:	cf8ff06f          	j	19518 <_vfiprintf_r+0x46c>
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   1a024:	00060b93          	mv	s7,a2
   1a028:	df4ff06f          	j	1961c <_vfiprintf_r+0x570>
   1a02c:	00060b93          	mv	s7,a2
   1a030:	e60ff06f          	j	19690 <_vfiprintf_r+0x5e4>
   1a034:	00000993          	li	s3,0
   1a038:	fa9ff06f          	j	19fe0 <_vfiprintf_r+0xf34>
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
   1a03c:	01012883          	lw	a7,16(sp)
   1a040:	0008a703          	lw	a4,0(a7)
   1a044:	00488793          	addi	a5,a7,4
   1a048:	00f12823          	sw	a5,16(sp)
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
   1a04c:	a2075063          	bgez	a4,1926c <_vfiprintf_r+0x1c0>
					prec = -1;
   1a050:	fff00713          	li	a4,-1
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   1a054:	000d8493          	mv	s1,s11
   1a058:	9d8ff06f          	j	19230 <_vfiprintf_r+0x184>
   1a05c:	02610ba3          	sb	t1,55(sp)
   1a060:	80dff06f          	j	1986c <_vfiprintf_r+0x7c0>
   1a064:	02610ba3          	sb	t1,55(sp)
   1a068:	e6cff06f          	j	196d4 <_vfiprintf_r+0x628>
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   1a06c:	001bf793          	andi	a5,s7,1
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   1a070:	00070593          	mv	a1,a4
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   1a074:	00078c63          	beqz	a5,1a08c <_vfiprintf_r+0xfe0>
                         *--cp = '0';
   1a078:	03000793          	li	a5,48
   1a07c:	06f107a3          	sb	a5,111(sp)
   1a080:	02412a03          	lw	s4,36(sp)
   1a084:	06f10413          	addi	s0,sp,111
   1a088:	ae8ff06f          	j	19370 <_vfiprintf_r+0x2c4>
   1a08c:	00000a13          	li	s4,0
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   1a090:	000c8413          	mv	s0,s9
   1a094:	adcff06f          	j	19370 <_vfiprintf_r+0x2c4>
   1a098:	02610ba3          	sb	t1,55(sp)
   1a09c:	e68ff06f          	j	19704 <_vfiprintf_r+0x658>
   1a0a0:	02610ba3          	sb	t1,55(sp)
   1a0a4:	841ff06f          	j	198e4 <_vfiprintf_r+0x838>
   1a0a8:	02610ba3          	sb	t1,55(sp)
   1a0ac:	da4ff06f          	j	19650 <_vfiprintf_r+0x5a4>
   1a0b0:	02610ba3          	sb	t1,55(sp)
   1a0b4:	d38ff06f          	j	195ec <_vfiprintf_r+0x540>
   1a0b8:	02610ba3          	sb	t1,55(sp)
   1a0bc:	f54ff06f          	j	19810 <_vfiprintf_r+0x764>

0001a0c0 <vfiprintf>:
       FILE * fp         _AND
       _CONST char *fmt0 _AND
       va_list ap)
{
  int result;
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
   1a0c0:	00060693          	mv	a3,a2
   1a0c4:	00058613          	mv	a2,a1
   1a0c8:	00050593          	mv	a1,a0
   1a0cc:	8101a503          	lw	a0,-2032(gp) # 1ece0 <_impure_ptr>
   1a0d0:	fddfe06f          	j	190ac <_vfiprintf_r>

0001a0d4 <__sbprintf>:
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   1a0d4:	00c5d783          	lhu	a5,12(a1)
	fake._flags2 = fp->_flags2;
   1a0d8:	0685a303          	lw	t1,104(a1)
	fake._file = fp->_file;
   1a0dc:	00e5d283          	lhu	t0,14(a1)
	fake._cookie = fp->_cookie;
   1a0e0:	01c5a883          	lw	a7,28(a1)
	fake._write = fp->_write;
   1a0e4:	0245a803          	lw	a6,36(a1)
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   1a0e8:	b8010113          	addi	sp,sp,-1152
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   1a0ec:	ffd7f793          	andi	a5,a5,-3
	fake._cookie = fp->_cookie;
	fake._write = fp->_write;

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
	fake._bf._size = fake._w = sizeof (buf);
   1a0f0:	40000713          	li	a4,1024
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   1a0f4:	46812c23          	sw	s0,1144(sp)
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   1a0f8:	00f11623          	sh	a5,12(sp)
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   1a0fc:	00058413          	mv	s0,a1
	fake._file = fp->_file;
	fake._cookie = fp->_cookie;
	fake._write = fp->_write;

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
   1a100:	07010793          	addi	a5,sp,112
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   1a104:	00010593          	mv	a1,sp
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   1a108:	46912a23          	sw	s1,1140(sp)
   1a10c:	47212823          	sw	s2,1136(sp)
   1a110:	46112e23          	sw	ra,1148(sp)
   1a114:	00050913          	mv	s2,a0
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
	fake._flags2 = fp->_flags2;
   1a118:	06612423          	sw	t1,104(sp)
	fake._file = fp->_file;
   1a11c:	00511723          	sh	t0,14(sp)
	fake._cookie = fp->_cookie;
   1a120:	01112e23          	sw	a7,28(sp)
	fake._write = fp->_write;
   1a124:	03012223          	sw	a6,36(sp)

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
   1a128:	00f12023          	sw	a5,0(sp)
   1a12c:	00f12823          	sw	a5,16(sp)
	fake._bf._size = fake._w = sizeof (buf);
   1a130:	00e12423          	sw	a4,8(sp)
   1a134:	00e12a23          	sw	a4,20(sp)
	fake._lbfsize = 0;	/* not actually used, but Just In Case */
   1a138:	00012c23          	sw	zero,24(sp)
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   1a13c:	f71fe0ef          	jal	190ac <_vfiprintf_r>
   1a140:	00050493          	mv	s1,a0
	if (ret >= 0 && _fflush_r (rptr, &fake))
   1a144:	00054a63          	bltz	a0,1a158 <__sbprintf+0x84>
   1a148:	00010593          	mv	a1,sp
   1a14c:	00090513          	mv	a0,s2
   1a150:	b5dfb0ef          	jal	15cac <_fflush_r>
   1a154:	02051c63          	bnez	a0,1a18c <__sbprintf+0xb8>
		ret = EOF;
	if (fake._flags & __SERR)
   1a158:	00c15783          	lhu	a5,12(sp)
   1a15c:	0407f793          	andi	a5,a5,64
   1a160:	00078863          	beqz	a5,1a170 <__sbprintf+0x9c>
		fp->_flags |= __SERR;
   1a164:	00c45783          	lhu	a5,12(s0)
   1a168:	0407e793          	ori	a5,a5,64
   1a16c:	00f41623          	sh	a5,12(s0)

#ifndef __SINGLE_THREAD__
	__lock_close_recursive (fake._lock);
#endif
	return (ret);
}
   1a170:	47c12083          	lw	ra,1148(sp)
   1a174:	00048513          	mv	a0,s1
   1a178:	47812403          	lw	s0,1144(sp)
   1a17c:	47412483          	lw	s1,1140(sp)
   1a180:	47012903          	lw	s2,1136(sp)
   1a184:	48010113          	addi	sp,sp,1152
   1a188:	00008067          	ret
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
	if (ret >= 0 && _fflush_r (rptr, &fake))
		ret = EOF;
   1a18c:	fff00493          	li	s1,-1
   1a190:	fc9ff06f          	j	1a158 <__sbprintf+0x84>

0001a194 <_calloc_r>:
  MALLOC_LOCK;
  oldtop = top;
  oldtopsize = chunksize(top);
#endif

  mem = mALLOc (RCALL sz);
   1a194:	02c585b3          	mul	a1,a1,a2
#if __STD_C
Void_t* cALLOc(RARG size_t n, size_t elem_size)
#else
Void_t* cALLOc(RARG n, elem_size) RDECL size_t n; size_t elem_size;
#endif
{
   1a198:	ff010113          	addi	sp,sp,-16
   1a19c:	00112623          	sw	ra,12(sp)
   1a1a0:	00812423          	sw	s0,8(sp)
  MALLOC_LOCK;
  oldtop = top;
  oldtopsize = chunksize(top);
#endif

  mem = mALLOc (RCALL sz);
   1a1a4:	b35fc0ef          	jal	16cd8 <_malloc_r>

  if (mem == 0) 
   1a1a8:	08050c63          	beqz	a0,1a240 <_calloc_r+0xac>
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
   1a1ac:	ffc52603          	lw	a2,-4(a0)
   1a1b0:	02400713          	li	a4,36
   1a1b4:	00050413          	mv	s0,a0
   1a1b8:	ffc67613          	andi	a2,a2,-4
   1a1bc:	ffc60613          	addi	a2,a2,-4
   1a1c0:	04c76e63          	bltu	a4,a2,1a21c <_calloc_r+0x88>
   1a1c4:	01300693          	li	a3,19
   1a1c8:	00050793          	mv	a5,a0
   1a1cc:	02c6f863          	bleu	a2,a3,1a1fc <_calloc_r+0x68>
   1a1d0:	01b00793          	li	a5,27
   1a1d4:	00052023          	sw	zero,0(a0)
   1a1d8:	00052223          	sw	zero,4(a0)
   1a1dc:	04c7fe63          	bleu	a2,a5,1a238 <_calloc_r+0xa4>
   1a1e0:	00052423          	sw	zero,8(a0)
   1a1e4:	00052623          	sw	zero,12(a0)
   1a1e8:	01050793          	addi	a5,a0,16
   1a1ec:	00e61863          	bne	a2,a4,1a1fc <_calloc_r+0x68>
   1a1f0:	00052823          	sw	zero,16(a0)
   1a1f4:	01850793          	addi	a5,a0,24
   1a1f8:	00052a23          	sw	zero,20(a0)
   1a1fc:	0007a023          	sw	zero,0(a5)
   1a200:	0007a223          	sw	zero,4(a5)
   1a204:	0007a423          	sw	zero,8(a5)
   1a208:	00040513          	mv	a0,s0
    return mem;
  }
}
   1a20c:	00c12083          	lw	ra,12(sp)
   1a210:	00812403          	lw	s0,8(sp)
   1a214:	01010113          	addi	sp,sp,16
   1a218:	00008067          	ret
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
   1a21c:	00000593          	li	a1,0
   1a220:	c24fd0ef          	jal	17644 <memset>
    return mem;
  }
}
   1a224:	00c12083          	lw	ra,12(sp)
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
   1a228:	00040513          	mv	a0,s0
    return mem;
  }
}
   1a22c:	00812403          	lw	s0,8(sp)
   1a230:	01010113          	addi	sp,sp,16
   1a234:	00008067          	ret
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
   1a238:	00850793          	addi	a5,a0,8
   1a23c:	fc1ff06f          	j	1a1fc <_calloc_r+0x68>
  if (mem == 0) 
  {
#if MORECORE_CLEARS
    MALLOC_UNLOCK;
#endif
    return 0;
   1a240:	00000513          	li	a0,0
   1a244:	fc9ff06f          	j	1a20c <_calloc_r+0x78>

0001a248 <_fclose_r>:
      struct _reent *rptr _AND
      register FILE * fp)
{
  int r;

  if (fp == NULL)
   1a248:	0e058463          	beqz	a1,1a330 <_fclose_r+0xe8>

int
_DEFUN(_fclose_r, (rptr, fp),
      struct _reent *rptr _AND
      register FILE * fp)
{
   1a24c:	ff010113          	addi	sp,sp,-16
   1a250:	00812423          	sw	s0,8(sp)
   1a254:	00912223          	sw	s1,4(sp)
   1a258:	00112623          	sw	ra,12(sp)
   1a25c:	01212023          	sw	s2,0(sp)
   1a260:	00050493          	mv	s1,a0
   1a264:	00058413          	mv	s0,a1
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */

  CHECK_INIT (rptr, fp);
   1a268:	00050663          	beqz	a0,1a274 <_fclose_r+0x2c>
   1a26c:	03852783          	lw	a5,56(a0)
   1a270:	0a078063          	beqz	a5,1a310 <_fclose_r+0xc8>
  int __oldcancel;
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  _flockfile (fp);

  if (fp->_flags == 0)		/* not open! */
   1a274:	00c41783          	lh	a5,12(s0)
      register FILE * fp)
{
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */
   1a278:	00000513          	li	a0,0
  int __oldcancel;
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  _flockfile (fp);

  if (fp->_flags == 0)		/* not open! */
   1a27c:	00079e63          	bnez	a5,1a298 <_fclose_r+0x50>
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
}
   1a280:	00c12083          	lw	ra,12(sp)
   1a284:	00812403          	lw	s0,8(sp)
   1a288:	00412483          	lw	s1,4(sp)
   1a28c:	00012903          	lw	s2,0(sp)
   1a290:	01010113          	addi	sp,sp,16
   1a294:	00008067          	ret
  r = (fp->_flags & __SWR) ? __sflush_r (rptr, fp) : 0;
#else
  /* Follow POSIX semantics exactly.  Unconditionally flush to allow
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
   1a298:	00040593          	mv	a1,s0
   1a29c:	00048513          	mv	a0,s1
   1a2a0:	f7cfb0ef          	jal	15a1c <__sflush_r>
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
   1a2a4:	02c42783          	lw	a5,44(s0)
  r = (fp->_flags & __SWR) ? __sflush_r (rptr, fp) : 0;
#else
  /* Follow POSIX semantics exactly.  Unconditionally flush to allow
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
   1a2a8:	00050913          	mv	s2,a0
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
   1a2ac:	00078a63          	beqz	a5,1a2c0 <_fclose_r+0x78>
   1a2b0:	01c42583          	lw	a1,28(s0)
   1a2b4:	00048513          	mv	a0,s1
   1a2b8:	000780e7          	jalr	a5
   1a2bc:	04054e63          	bltz	a0,1a318 <_fclose_r+0xd0>
    r = EOF;
  if (fp->_flags & __SMBF)
   1a2c0:	00c45783          	lhu	a5,12(s0)
   1a2c4:	0807f793          	andi	a5,a5,128
   1a2c8:	04079c63          	bnez	a5,1a320 <_fclose_r+0xd8>
    _free_r (rptr, (char *) fp->_bf._base);
  if (HASUB (fp))
   1a2cc:	03042583          	lw	a1,48(s0)
   1a2d0:	00058c63          	beqz	a1,1a2e8 <_fclose_r+0xa0>
    FREEUB (rptr, fp);
   1a2d4:	04040793          	addi	a5,s0,64
   1a2d8:	00f58663          	beq	a1,a5,1a2e4 <_fclose_r+0x9c>
   1a2dc:	00048513          	mv	a0,s1
   1a2e0:	ebdfb0ef          	jal	1619c <_free_r>
   1a2e4:	02042823          	sw	zero,48(s0)
  if (HASLB (fp))
   1a2e8:	04442583          	lw	a1,68(s0)
   1a2ec:	00058863          	beqz	a1,1a2fc <_fclose_r+0xb4>
    FREELB (rptr, fp);
   1a2f0:	00048513          	mv	a0,s1
   1a2f4:	ea9fb0ef          	jal	1619c <_free_r>
   1a2f8:	04042223          	sw	zero,68(s0)
  __sfp_lock_acquire ();
   1a2fc:	d71fb0ef          	jal	1606c <__sfp_lock_acquire>
  fp->_flags = 0;		/* release this FILE for reuse */
   1a300:	00041623          	sh	zero,12(s0)
  _funlockfile (fp);
#ifndef __SINGLE_THREAD__
  __lock_close_recursive (fp->_lock);
#endif

  __sfp_lock_release ();
   1a304:	d6dfb0ef          	jal	16070 <__sfp_lock_release>
   1a308:	00090513          	mv	a0,s2
   1a30c:	f75ff06f          	j	1a280 <_fclose_r+0x38>
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */

  CHECK_INIT (rptr, fp);
   1a310:	d4dfb0ef          	jal	1605c <__sinit>
   1a314:	f61ff06f          	j	1a274 <_fclose_r+0x2c>
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
    r = EOF;
   1a318:	fff00913          	li	s2,-1
   1a31c:	fa5ff06f          	j	1a2c0 <_fclose_r+0x78>
  if (fp->_flags & __SMBF)
    _free_r (rptr, (char *) fp->_bf._base);
   1a320:	01042583          	lw	a1,16(s0)
   1a324:	00048513          	mv	a0,s1
   1a328:	e75fb0ef          	jal	1619c <_free_r>
   1a32c:	fa1ff06f          	j	1a2cc <_fclose_r+0x84>
      register FILE * fp)
{
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */
   1a330:	00000513          	li	a0,0
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
}
   1a334:	00008067          	ret

0001a338 <fclose>:

int
_DEFUN(fclose, (fp),
       register FILE * fp)
{
  return _fclose_r(_REENT, fp);
   1a338:	00050593          	mv	a1,a0
   1a33c:	8101a503          	lw	a0,-2032(gp) # 1ece0 <_impure_ptr>
   1a340:	f09ff06f          	j	1a248 <_fclose_r>

0001a344 <__fputwc>:
wint_t
_DEFUN(__fputwc, (ptr, wc, fp),
	struct _reent *ptr _AND
	wchar_t wc _AND
	FILE *fp)
{
   1a344:	fd010113          	addi	sp,sp,-48
   1a348:	02812423          	sw	s0,40(sp)
   1a34c:	01412c23          	sw	s4,24(sp)
   1a350:	01512a23          	sw	s5,20(sp)
   1a354:	02112623          	sw	ra,44(sp)
   1a358:	02912223          	sw	s1,36(sp)
   1a35c:	03212023          	sw	s2,32(sp)
   1a360:	01312e23          	sw	s3,28(sp)
   1a364:	01612823          	sw	s6,16(sp)
   1a368:	00050a93          	mv	s5,a0
   1a36c:	00058a13          	mv	s4,a1
   1a370:	00060413          	mv	s0,a2
  char buf[MB_LEN_MAX];
  size_t i, len;

  if (MB_CUR_MAX == 1 && wc > 0 && wc <= UCHAR_MAX)
   1a374:	f90fc0ef          	jal	16b04 <__locale_mb_cur_max>
   1a378:	00100793          	li	a5,1
   1a37c:	10f50063          	beq	a0,a5,1a47c <__fputwc+0x138>
      *buf = (unsigned char)wc;
      len = 1;
    }
  else
    {
      if ((len = _wcrtomb_r (ptr, buf, wc, &fp->_mbstate)) == (size_t) -1)
   1a380:	00c10493          	addi	s1,sp,12
   1a384:	06040693          	addi	a3,s0,96
   1a388:	000a0613          	mv	a2,s4
   1a38c:	00048593          	mv	a1,s1
   1a390:	000a8513          	mv	a0,s5
   1a394:	324000ef          	jal	1a6b8 <_wcrtomb_r>
   1a398:	fff00793          	li	a5,-1
   1a39c:	00050993          	mv	s3,a0
   1a3a0:	08f50863          	beq	a0,a5,1a430 <__fputwc+0xec>
	  fp->_flags |= __SERR;
	  return WEOF;
	}
    }

  for (i = 0; i < len; i++)
   1a3a4:	0e050c63          	beqz	a0,1a49c <__fputwc+0x158>
   1a3a8:	00c14583          	lbu	a1,12(sp)
       * Assume single-byte locale with no special encoding.
       * A more careful test would be to check
       * _CurrentRuneLocale->encoding.
       */
      *buf = (unsigned char)wc;
      len = 1;
   1a3ac:	00000913          	li	s2,0
	  return WEOF;
	}
    }

  for (i = 0; i < len; i++)
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
   1a3b0:	00a00b13          	li	s6,10
   1a3b4:	0280006f          	j	1a3dc <__fputwc+0x98>
   1a3b8:	00042783          	lw	a5,0(s0)
   1a3bc:	00b78023          	sb	a1,0(a5)
   1a3c0:	00042783          	lw	a5,0(s0)
   1a3c4:	00178793          	addi	a5,a5,1
   1a3c8:	00f42023          	sw	a5,0(s0)
	  fp->_flags |= __SERR;
	  return WEOF;
	}
    }

  for (i = 0; i < len; i++)
   1a3cc:	00190913          	addi	s2,s2,1
   1a3d0:	00148493          	addi	s1,s1,1
   1a3d4:	0d397463          	bleu	s3,s2,1a49c <__fputwc+0x158>
   1a3d8:	0004c583          	lbu	a1,0(s1)
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
   1a3dc:	00842783          	lw	a5,8(s0)
   1a3e0:	fff78793          	addi	a5,a5,-1
   1a3e4:	00f42423          	sw	a5,8(s0)
   1a3e8:	fc07d8e3          	bgez	a5,1a3b8 <__fputwc+0x74>
   1a3ec:	01842703          	lw	a4,24(s0)
   1a3f0:	06e7ca63          	blt	a5,a4,1a464 <__fputwc+0x120>
   1a3f4:	00042783          	lw	a5,0(s0)
   1a3f8:	00b78023          	sb	a1,0(a5)
   1a3fc:	00042783          	lw	a5,0(s0)
   1a400:	0007c703          	lbu	a4,0(a5)
   1a404:	00178793          	addi	a5,a5,1
   1a408:	fd6710e3          	bne	a4,s6,1a3c8 <__fputwc+0x84>
   1a40c:	00040613          	mv	a2,s0
   1a410:	000b0593          	mv	a1,s6
   1a414:	000a8513          	mv	a0,s5
   1a418:	130000ef          	jal	1a548 <__swbuf_r>
   1a41c:	00150513          	addi	a0,a0,1
   1a420:	00153513          	seqz	a0,a0
   1a424:	fa0504e3          	beqz	a0,1a3cc <__fputwc+0x88>
      return WEOF;
   1a428:	fff00513          	li	a0,-1
   1a42c:	0100006f          	j	1a43c <__fputwc+0xf8>
    }
  else
    {
      if ((len = _wcrtomb_r (ptr, buf, wc, &fp->_mbstate)) == (size_t) -1)
	{
	  fp->_flags |= __SERR;
   1a430:	00c45783          	lhu	a5,12(s0)
   1a434:	0407e793          	ori	a5,a5,64
   1a438:	00f41623          	sh	a5,12(s0)
  for (i = 0; i < len; i++)
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
      return WEOF;

  return (wint_t) wc;
}
   1a43c:	02c12083          	lw	ra,44(sp)
   1a440:	02812403          	lw	s0,40(sp)
   1a444:	02412483          	lw	s1,36(sp)
   1a448:	02012903          	lw	s2,32(sp)
   1a44c:	01c12983          	lw	s3,28(sp)
   1a450:	01812a03          	lw	s4,24(sp)
   1a454:	01412a83          	lw	s5,20(sp)
   1a458:	01012b03          	lw	s6,16(sp)
   1a45c:	03010113          	addi	sp,sp,48
   1a460:	00008067          	ret
	  return WEOF;
	}
    }

  for (i = 0; i < len; i++)
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
   1a464:	00040613          	mv	a2,s0
   1a468:	000a8513          	mv	a0,s5
   1a46c:	0dc000ef          	jal	1a548 <__swbuf_r>
   1a470:	00150513          	addi	a0,a0,1
   1a474:	00153513          	seqz	a0,a0
   1a478:	fadff06f          	j	1a424 <__fputwc+0xe0>
	FILE *fp)
{
  char buf[MB_LEN_MAX];
  size_t i, len;

  if (MB_CUR_MAX == 1 && wc > 0 && wc <= UCHAR_MAX)
   1a47c:	fffa0793          	addi	a5,s4,-1
   1a480:	0fe00713          	li	a4,254
   1a484:	eef76ee3          	bltu	a4,a5,1a380 <__fputwc+0x3c>
      /*
       * Assume single-byte locale with no special encoding.
       * A more careful test would be to check
       * _CurrentRuneLocale->encoding.
       */
      *buf = (unsigned char)wc;
   1a488:	0ffa7593          	andi	a1,s4,255
   1a48c:	00b10623          	sb	a1,12(sp)
      len = 1;
   1a490:	00050993          	mv	s3,a0
   1a494:	00c10493          	addi	s1,sp,12
   1a498:	f15ff06f          	j	1a3ac <__fputwc+0x68>

  for (i = 0; i < len; i++)
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
      return WEOF;

  return (wint_t) wc;
   1a49c:	000a0513          	mv	a0,s4
   1a4a0:	f9dff06f          	j	1a43c <__fputwc+0xf8>

0001a4a4 <_fputwc_r>:
	FILE *fp)
{
  wint_t r;

  _newlib_flockfile_start (fp);
  ORIENT(fp, 1);
   1a4a4:	00c61783          	lh	a5,12(a2)
   1a4a8:	00002737          	lui	a4,0x2
   1a4ac:	01279693          	slli	a3,a5,0x12
   1a4b0:	0006cc63          	bltz	a3,1a4c8 <_fputwc_r+0x24>
	wchar_t wc _AND
	FILE *fp)
{
  wint_t r;

  _newlib_flockfile_start (fp);
   1a4b4:	06862683          	lw	a3,104(a2)
  ORIENT(fp, 1);
   1a4b8:	00e7e7b3          	or	a5,a5,a4
   1a4bc:	00f61623          	sh	a5,12(a2)
   1a4c0:	00e6e733          	or	a4,a3,a4
   1a4c4:	06e62423          	sw	a4,104(a2)
  r = __fputwc(ptr, wc, fp);
   1a4c8:	e7dff06f          	j	1a344 <__fputwc>

0001a4cc <fputwc>:

wint_t
_DEFUN(fputwc, (wc, fp),
	wchar_t wc _AND
	FILE *fp)
{
   1a4cc:	fe010113          	addi	sp,sp,-32
   1a4d0:	00812c23          	sw	s0,24(sp)
  struct _reent *reent = _REENT;
   1a4d4:	8101a403          	lw	s0,-2032(gp) # 1ece0 <_impure_ptr>

wint_t
_DEFUN(fputwc, (wc, fp),
	wchar_t wc _AND
	FILE *fp)
{
   1a4d8:	00912a23          	sw	s1,20(sp)
   1a4dc:	00112e23          	sw	ra,28(sp)
   1a4e0:	00050493          	mv	s1,a0
   1a4e4:	00058613          	mv	a2,a1
  struct _reent *reent = _REENT;

  CHECK_INIT(reent, fp);
   1a4e8:	00040663          	beqz	s0,1a4f4 <fputwc+0x28>
   1a4ec:	03842783          	lw	a5,56(s0)
   1a4f0:	04078263          	beqz	a5,1a534 <fputwc+0x68>
	FILE *fp)
{
  wint_t r;

  _newlib_flockfile_start (fp);
  ORIENT(fp, 1);
   1a4f4:	00c61783          	lh	a5,12(a2)
   1a4f8:	00002737          	lui	a4,0x2
   1a4fc:	01279693          	slli	a3,a5,0x12
   1a500:	0006cc63          	bltz	a3,1a518 <fputwc+0x4c>
	wchar_t wc _AND
	FILE *fp)
{
  wint_t r;

  _newlib_flockfile_start (fp);
   1a504:	06862683          	lw	a3,104(a2)
  ORIENT(fp, 1);
   1a508:	00e7e7b3          	or	a5,a5,a4
   1a50c:	00f61623          	sh	a5,12(a2)
   1a510:	00e6e733          	or	a4,a3,a4
   1a514:	06e62423          	sw	a4,104(a2)
  r = __fputwc(ptr, wc, fp);
   1a518:	00048593          	mv	a1,s1
   1a51c:	00040513          	mv	a0,s0
{
  struct _reent *reent = _REENT;

  CHECK_INIT(reent, fp);
  return _fputwc_r (reent, wc, fp);
}
   1a520:	01c12083          	lw	ra,28(sp)
   1a524:	01812403          	lw	s0,24(sp)
   1a528:	01412483          	lw	s1,20(sp)
   1a52c:	02010113          	addi	sp,sp,32
{
  wint_t r;

  _newlib_flockfile_start (fp);
  ORIENT(fp, 1);
  r = __fputwc(ptr, wc, fp);
   1a530:	e15ff06f          	j	1a344 <__fputwc>
	wchar_t wc _AND
	FILE *fp)
{
  struct _reent *reent = _REENT;

  CHECK_INIT(reent, fp);
   1a534:	00040513          	mv	a0,s0
   1a538:	00b12623          	sw	a1,12(sp)
   1a53c:	b21fb0ef          	jal	1605c <__sinit>
   1a540:	00c12603          	lw	a2,12(sp)
   1a544:	fb1ff06f          	j	1a4f4 <fputwc+0x28>

0001a548 <__swbuf_r>:
int
_DEFUN(__swbuf_r, (ptr, c, fp),
       struct _reent *ptr _AND
       register int c _AND
       register FILE *fp)
{
   1a548:	fe010113          	addi	sp,sp,-32
   1a54c:	00812c23          	sw	s0,24(sp)
   1a550:	00912a23          	sw	s1,20(sp)
   1a554:	01312623          	sw	s3,12(sp)
   1a558:	00112e23          	sw	ra,28(sp)
   1a55c:	01212823          	sw	s2,16(sp)
   1a560:	00050493          	mv	s1,a0
   1a564:	00058993          	mv	s3,a1
   1a568:	00060413          	mv	s0,a2
  register int n;

  /* Ensure stdio has been initialized.  */

  CHECK_INIT (ptr, fp);
   1a56c:	00050663          	beqz	a0,1a578 <__swbuf_r+0x30>
   1a570:	03852783          	lw	a5,56(a0)
   1a574:	12078263          	beqz	a5,1a698 <__swbuf_r+0x150>
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
   1a578:	00c41683          	lh	a3,12(s0)
   * (if line buffered) so that we will get called again.
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
   1a57c:	01842603          	lw	a2,24(s0)
  if (cantwrite (ptr, fp))
   1a580:	01069713          	slli	a4,a3,0x10
   1a584:	01075713          	srli	a4,a4,0x10
   1a588:	00877793          	andi	a5,a4,8
   * (if line buffered) so that we will get called again.
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
   1a58c:	00c42423          	sw	a2,8(s0)
  if (cantwrite (ptr, fp))
   1a590:	0e078263          	beqz	a5,1a674 <__swbuf_r+0x12c>
   1a594:	01042783          	lw	a5,16(s0)
   1a598:	0c078e63          	beqz	a5,1a674 <__swbuf_r+0x12c>
    return EOF;
  c = (unsigned char) c;

  ORIENT (fp, -1);
   1a59c:	01271613          	slli	a2,a4,0x12
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
  c = (unsigned char) c;
   1a5a0:	0ff9f913          	andi	s2,s3,255

  ORIENT (fp, -1);
   1a5a4:	06065663          	bgez	a2,1a610 <__swbuf_r+0xc8>
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
   1a5a8:	00042703          	lw	a4,0(s0)
  if (n >= fp->_bf._size)
   1a5ac:	01442683          	lw	a3,20(s0)
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
   1a5b0:	40f707b3          	sub	a5,a4,a5
  if (n >= fp->_bf._size)
   1a5b4:	08d7d663          	ble	a3,a5,1a640 <__swbuf_r+0xf8>
   1a5b8:	00178793          	addi	a5,a5,1
    {
      if (_fflush_r (ptr, fp))
	return EOF;
      n = 0;
    }
  fp->_w--;
   1a5bc:	00842683          	lw	a3,8(s0)
  *fp->_p++ = c;
   1a5c0:	00170613          	addi	a2,a4,1 # 2001 <_reset+0x1e01>
   1a5c4:	00c42023          	sw	a2,0(s0)
    {
      if (_fflush_r (ptr, fp))
	return EOF;
      n = 0;
    }
  fp->_w--;
   1a5c8:	fff68693          	addi	a3,a3,-1
   1a5cc:	00d42423          	sw	a3,8(s0)
  *fp->_p++ = c;
   1a5d0:	01370023          	sb	s3,0(a4)
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
   1a5d4:	01442703          	lw	a4,20(s0)
   1a5d8:	08f70263          	beq	a4,a5,1a65c <__swbuf_r+0x114>
   1a5dc:	00c45783          	lhu	a5,12(s0)
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
  c = (unsigned char) c;
   1a5e0:	00090513          	mv	a0,s2
	return EOF;
      n = 0;
    }
  fp->_w--;
  *fp->_p++ = c;
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
   1a5e4:	0017f793          	andi	a5,a5,1
   1a5e8:	00078663          	beqz	a5,1a5f4 <__swbuf_r+0xac>
   1a5ec:	00a00793          	li	a5,10
   1a5f0:	06f90663          	beq	s2,a5,1a65c <__swbuf_r+0x114>
    if (_fflush_r (ptr, fp))
      return EOF;
  return c;
}
   1a5f4:	01c12083          	lw	ra,28(sp)
   1a5f8:	01812403          	lw	s0,24(sp)
   1a5fc:	01412483          	lw	s1,20(sp)
   1a600:	01012903          	lw	s2,16(sp)
   1a604:	00c12983          	lw	s3,12(sp)
   1a608:	02010113          	addi	sp,sp,32
   1a60c:	00008067          	ret
  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
  c = (unsigned char) c;

  ORIENT (fp, -1);
   1a610:	06842583          	lw	a1,104(s0)
   1a614:	ffffe737          	lui	a4,0xffffe
   1a618:	fff70713          	addi	a4,a4,-1 # ffffdfff <_gp+0xfffdeb2f>
   1a61c:	00e5f733          	and	a4,a1,a4
   1a620:	00002637          	lui	a2,0x2
   1a624:	00c6e6b3          	or	a3,a3,a2
   1a628:	06e42423          	sw	a4,104(s0)
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
   1a62c:	00042703          	lw	a4,0(s0)
  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
  c = (unsigned char) c;

  ORIENT (fp, -1);
   1a630:	00d41623          	sh	a3,12(s0)
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
  if (n >= fp->_bf._size)
   1a634:	01442683          	lw	a3,20(s0)
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
   1a638:	40f707b3          	sub	a5,a4,a5
  if (n >= fp->_bf._size)
   1a63c:	f6d7cee3          	blt	a5,a3,1a5b8 <__swbuf_r+0x70>
    {
      if (_fflush_r (ptr, fp))
   1a640:	00040593          	mv	a1,s0
   1a644:	00048513          	mv	a0,s1
   1a648:	e64fb0ef          	jal	15cac <_fflush_r>
   1a64c:	04051a63          	bnez	a0,1a6a0 <__swbuf_r+0x158>
   1a650:	00042703          	lw	a4,0(s0)
   1a654:	00100793          	li	a5,1
   1a658:	f65ff06f          	j	1a5bc <__swbuf_r+0x74>
      n = 0;
    }
  fp->_w--;
  *fp->_p++ = c;
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
    if (_fflush_r (ptr, fp))
   1a65c:	00040593          	mv	a1,s0
   1a660:	00048513          	mv	a0,s1
   1a664:	e48fb0ef          	jal	15cac <_fflush_r>
   1a668:	02051c63          	bnez	a0,1a6a0 <__swbuf_r+0x158>
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
  c = (unsigned char) c;
   1a66c:	00090513          	mv	a0,s2
   1a670:	f85ff06f          	j	1a5f4 <__swbuf_r+0xac>
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
   1a674:	00040593          	mv	a1,s0
   1a678:	00048513          	mv	a0,s1
   1a67c:	a59f90ef          	jal	140d4 <__swsetup_r>
   1a680:	02051063          	bnez	a0,1a6a0 <__swbuf_r+0x158>
   1a684:	00c41683          	lh	a3,12(s0)
   1a688:	01042783          	lw	a5,16(s0)
   1a68c:	01069713          	slli	a4,a3,0x10
   1a690:	01075713          	srli	a4,a4,0x10
   1a694:	f09ff06f          	j	1a59c <__swbuf_r+0x54>
{
  register int n;

  /* Ensure stdio has been initialized.  */

  CHECK_INIT (ptr, fp);
   1a698:	9c5fb0ef          	jal	1605c <__sinit>
   1a69c:	eddff06f          	j	1a578 <__swbuf_r+0x30>
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
   1a6a0:	fff00513          	li	a0,-1
   1a6a4:	f51ff06f          	j	1a5f4 <__swbuf_r+0xac>

0001a6a8 <__swbuf>:
int
_DEFUN(__swbuf, (c, fp),
       register int c _AND
       register FILE *fp)
{
  return __swbuf_r (_REENT, c, fp);
   1a6a8:	00058613          	mv	a2,a1
   1a6ac:	00050593          	mv	a1,a0
   1a6b0:	8101a503          	lw	a0,-2032(gp) # 1ece0 <_impure_ptr>
   1a6b4:	e95ff06f          	j	1a548 <__swbuf_r>

0001a6b8 <_wcrtomb_r>:
_DEFUN (_wcrtomb_r, (ptr, s, wc, ps),
	struct _reent *ptr _AND
	char *s _AND
	wchar_t wc _AND
	mbstate_t *ps)
{
   1a6b8:	fd010113          	addi	sp,sp,-48
   1a6bc:	02812423          	sw	s0,40(sp)
   1a6c0:	02912223          	sw	s1,36(sp)
   1a6c4:	03212023          	sw	s2,32(sp)
   1a6c8:	02112623          	sw	ra,44(sp)
   1a6cc:	00050413          	mv	s0,a0
   1a6d0:	00068493          	mv	s1,a3
      ps = &(_REENT_WCRTOMB_STATE(ptr));
    }
#endif

  if (s == NULL)
    retval = __wctomb (ptr, buf, L'\0', __locale_charset (), ps);
   1a6d4:	8201a903          	lw	s2,-2016(gp) # 1ecf0 <__wctomb>
      _REENT_CHECK_MISC(ptr);
      ps = &(_REENT_WCRTOMB_STATE(ptr));
    }
#endif

  if (s == NULL)
   1a6d8:	04058a63          	beqz	a1,1a72c <_wcrtomb_r+0x74>
    retval = __wctomb (ptr, buf, L'\0', __locale_charset (), ps);
  else
    retval = __wctomb (ptr, s, wc, __locale_charset (), ps);
   1a6dc:	00b12623          	sw	a1,12(sp)
   1a6e0:	00c12423          	sw	a2,8(sp)
   1a6e4:	c14fc0ef          	jal	16af8 <__locale_charset>
   1a6e8:	00812603          	lw	a2,8(sp)
   1a6ec:	00c12583          	lw	a1,12(sp)
   1a6f0:	00050693          	mv	a3,a0
   1a6f4:	00048713          	mv	a4,s1
   1a6f8:	00040513          	mv	a0,s0
   1a6fc:	000900e7          	jalr	s2

  if (retval == -1)
   1a700:	fff00793          	li	a5,-1
   1a704:	00f51863          	bne	a0,a5,1a714 <_wcrtomb_r+0x5c>
    {
      ps->__count = 0;
      ptr->_errno = EILSEQ;
   1a708:	08a00793          	li	a5,138
  else
    retval = __wctomb (ptr, s, wc, __locale_charset (), ps);

  if (retval == -1)
    {
      ps->__count = 0;
   1a70c:	0004a023          	sw	zero,0(s1)
      ptr->_errno = EILSEQ;
   1a710:	00f42023          	sw	a5,0(s0)
      return (size_t)(-1);
    }
  else
    return (size_t)retval;
}
   1a714:	02c12083          	lw	ra,44(sp)
   1a718:	02812403          	lw	s0,40(sp)
   1a71c:	02412483          	lw	s1,36(sp)
   1a720:	02012903          	lw	s2,32(sp)
   1a724:	03010113          	addi	sp,sp,48
   1a728:	00008067          	ret
      ps = &(_REENT_WCRTOMB_STATE(ptr));
    }
#endif

  if (s == NULL)
    retval = __wctomb (ptr, buf, L'\0', __locale_charset (), ps);
   1a72c:	bccfc0ef          	jal	16af8 <__locale_charset>
   1a730:	00050693          	mv	a3,a0
   1a734:	00048713          	mv	a4,s1
   1a738:	00000613          	li	a2,0
   1a73c:	01410593          	addi	a1,sp,20
   1a740:	00040513          	mv	a0,s0
   1a744:	000900e7          	jalr	s2
   1a748:	fb9ff06f          	j	1a700 <_wcrtomb_r+0x48>

0001a74c <wcrtomb>:
size_t
_DEFUN (wcrtomb, (s, wc, ps),
	char *__restrict s _AND
	wchar_t wc _AND
	mbstate_t *__restrict ps)
{
   1a74c:	fd010113          	addi	sp,sp,-48
   1a750:	02912223          	sw	s1,36(sp)
   1a754:	03212023          	sw	s2,32(sp)
   1a758:	02112623          	sw	ra,44(sp)
   1a75c:	02812423          	sw	s0,40(sp)
   1a760:	01312e23          	sw	s3,28(sp)
   1a764:	01412c23          	sw	s4,24(sp)
   1a768:	00060913          	mv	s2,a2
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  return _wcrtomb_r (_REENT, s, wc, ps);
#else
  int retval = 0;
  struct _reent *reent = _REENT;
   1a76c:	8101a483          	lw	s1,-2032(gp) # 1ece0 <_impure_ptr>
      _REENT_CHECK_MISC(reent);
      ps = &(_REENT_WCRTOMB_STATE(reent));
    }
#endif

  if (s == NULL)
   1a770:	06050063          	beqz	a0,1a7d0 <wcrtomb+0x84>
    retval = __wctomb (reent, buf, L'\0', __locale_charset (), ps);
  else
    retval = __wctomb (reent, s, wc, __locale_charset (), ps);
   1a774:	8201aa03          	lw	s4,-2016(gp) # 1ecf0 <__wctomb>
   1a778:	00058993          	mv	s3,a1
   1a77c:	00050413          	mv	s0,a0
   1a780:	b78fc0ef          	jal	16af8 <__locale_charset>
   1a784:	00050693          	mv	a3,a0
   1a788:	00090713          	mv	a4,s2
   1a78c:	00098613          	mv	a2,s3
   1a790:	00040593          	mv	a1,s0
   1a794:	00048513          	mv	a0,s1
   1a798:	000a00e7          	jalr	s4

  if (retval == -1)
   1a79c:	fff00793          	li	a5,-1
   1a7a0:	00f51863          	bne	a0,a5,1a7b0 <wcrtomb+0x64>
    {
      ps->__count = 0;
      reent->_errno = EILSEQ;
   1a7a4:	08a00793          	li	a5,138
  else
    retval = __wctomb (reent, s, wc, __locale_charset (), ps);

  if (retval == -1)
    {
      ps->__count = 0;
   1a7a8:	00092023          	sw	zero,0(s2)
      reent->_errno = EILSEQ;
   1a7ac:	00f4a023          	sw	a5,0(s1)
      return (size_t)(-1);
    }
  else
    return (size_t)retval;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   1a7b0:	02c12083          	lw	ra,44(sp)
   1a7b4:	02812403          	lw	s0,40(sp)
   1a7b8:	02412483          	lw	s1,36(sp)
   1a7bc:	02012903          	lw	s2,32(sp)
   1a7c0:	01c12983          	lw	s3,28(sp)
   1a7c4:	01812a03          	lw	s4,24(sp)
   1a7c8:	03010113          	addi	sp,sp,48
   1a7cc:	00008067          	ret
      ps = &(_REENT_WCRTOMB_STATE(reent));
    }
#endif

  if (s == NULL)
    retval = __wctomb (reent, buf, L'\0', __locale_charset (), ps);
   1a7d0:	8201a403          	lw	s0,-2016(gp) # 1ecf0 <__wctomb>
   1a7d4:	b24fc0ef          	jal	16af8 <__locale_charset>
   1a7d8:	00050693          	mv	a3,a0
   1a7dc:	00090713          	mv	a4,s2
   1a7e0:	00000613          	li	a2,0
   1a7e4:	00410593          	addi	a1,sp,4
   1a7e8:	00048513          	mv	a0,s1
   1a7ec:	000400e7          	jalr	s0
   1a7f0:	fadff06f          	j	1a79c <wcrtomb+0x50>

0001a7f4 <__ascii_wctomb>:
  /* Avoids compiler warnings about comparisons that are always false
     due to limited range when sizeof(wchar_t) is 2 but sizeof(wint_t)
     is 4, as is the case on cygwin.  */
  wint_t wchar = _wchar;

  if (s == NULL)
   1a7f4:	00058c63          	beqz	a1,1a80c <__ascii_wctomb+0x18>
    return 0;
 
#ifdef __CYGWIN__
  if ((size_t)wchar >= 0x80)
#else
  if ((size_t)wchar >= 0x100)
   1a7f8:	0ff00793          	li	a5,255
   1a7fc:	00c7ec63          	bltu	a5,a2,1a814 <__ascii_wctomb+0x20>
    {
      r->_errno = EILSEQ;
      return -1;
    }

  *s = (char) wchar;
   1a800:	00c58023          	sb	a2,0(a1)
  return 1;
   1a804:	00100513          	li	a0,1
   1a808:	00008067          	ret
     due to limited range when sizeof(wchar_t) is 2 but sizeof(wint_t)
     is 4, as is the case on cygwin.  */
  wint_t wchar = _wchar;

  if (s == NULL)
    return 0;
   1a80c:	00000513          	li	a0,0
      return -1;
    }

  *s = (char) wchar;
  return 1;
}
   1a810:	00008067          	ret
  if ((size_t)wchar >= 0x80)
#else
  if ((size_t)wchar >= 0x100)
#endif
    {
      r->_errno = EILSEQ;
   1a814:	08a00793          	li	a5,138
   1a818:	00f52023          	sw	a5,0(a0)
      return -1;
   1a81c:	fff00513          	li	a0,-1
   1a820:	00008067          	ret

0001a824 <_wctomb_r>:
_DEFUN (_wctomb_r, (r, s, wchar, state),
        struct _reent *r     _AND 
        char          *s     _AND
        wchar_t        _wchar _AND
        mbstate_t     *state)
{
   1a824:	fe010113          	addi	sp,sp,-32
   1a828:	00812c23          	sw	s0,24(sp)
  return __wctomb (r, s, _wchar, __locale_charset (), state);
   1a82c:	8201a403          	lw	s0,-2016(gp) # 1ecf0 <__wctomb>
_DEFUN (_wctomb_r, (r, s, wchar, state),
        struct _reent *r     _AND 
        char          *s     _AND
        wchar_t        _wchar _AND
        mbstate_t     *state)
{
   1a830:	00112e23          	sw	ra,28(sp)
   1a834:	00912a23          	sw	s1,20(sp)
   1a838:	01212823          	sw	s2,16(sp)
   1a83c:	00050493          	mv	s1,a0
   1a840:	00068913          	mv	s2,a3
  return __wctomb (r, s, _wchar, __locale_charset (), state);
   1a844:	00b12623          	sw	a1,12(sp)
   1a848:	00c12423          	sw	a2,8(sp)
   1a84c:	aacfc0ef          	jal	16af8 <__locale_charset>
   1a850:	00050693          	mv	a3,a0
   1a854:	00090713          	mv	a4,s2
   1a858:	00812603          	lw	a2,8(sp)
   1a85c:	00c12583          	lw	a1,12(sp)
   1a860:	00048513          	mv	a0,s1
   1a864:	00040313          	mv	t1,s0
}
   1a868:	01c12083          	lw	ra,28(sp)
   1a86c:	01812403          	lw	s0,24(sp)
   1a870:	01412483          	lw	s1,20(sp)
   1a874:	01012903          	lw	s2,16(sp)
   1a878:	02010113          	addi	sp,sp,32
        struct _reent *r     _AND 
        char          *s     _AND
        wchar_t        _wchar _AND
        mbstate_t     *state)
{
  return __wctomb (r, s, _wchar, __locale_charset (), state);
   1a87c:	00030067          	jr	t1

0001a880 <_fpadd_parts>:
#if defined(L_addsub_sf) || defined(L_addsub_df) || defined(L_addsub_tf)
static const fp_number_type *
_fpadd_parts (fp_number_type * a,
	      fp_number_type * b,
	      fp_number_type * tmp)
{
   1a880:	00052783          	lw	a5,0(a0)
  int a_normal_exp;
  int b_normal_exp;
  fractype a_fraction;
  fractype b_fraction;

  if (isnan (a))
   1a884:	00100693          	li	a3,1
   1a888:	12f6f263          	bleu	a5,a3,1a9ac <_fpadd_parts+0x12c>
   1a88c:	0005a703          	lw	a4,0(a1)
    {
      return a;
    }
  if (isnan (b))
   1a890:	10e6fc63          	bleu	a4,a3,1a9a8 <_fpadd_parts+0x128>
    {
      return b;
    }
  if (isinf (a))
   1a894:	00400693          	li	a3,4
   1a898:	24d78063          	beq	a5,a3,1aad8 <_fpadd_parts+0x258>
      /* Adding infinities with opposite signs yields a NaN.  */
      if (isinf (b) && a->sign != b->sign)
	return makenan ();
      return a;
    }
  if (isinf (b))
   1a89c:	10d70663          	beq	a4,a3,1a9a8 <_fpadd_parts+0x128>
    {
      return b;
    }
  if (iszero (b))
   1a8a0:	00200693          	li	a3,2
   1a8a4:	1cd70263          	beq	a4,a3,1aa68 <_fpadd_parts+0x1e8>
	  tmp->sign = a->sign & b->sign;
	  return tmp;
	}
      return a;
    }
  if (iszero (a))
   1a8a8:	10d78063          	beq	a5,a3,1a9a8 <_fpadd_parts+0x128>
     they're the same */
  {
    int diff;
    int sdiff;

    a_normal_exp = a->normal_exp;
   1a8ac:	00852303          	lw	t1,8(a0)
    b_normal_exp = b->normal_exp;
   1a8b0:	0085a683          	lw	a3,8(a1)
    a_fraction = a->fraction.ll;
   1a8b4:	01052883          	lw	a7,16(a0)
   1a8b8:	01452e03          	lw	t3,20(a0)
    b_fraction = b->fraction.ll;

    diff = a_normal_exp - b_normal_exp;
   1a8bc:	40d30833          	sub	a6,t1,a3
   1a8c0:	41f85793          	srai	a5,a6,0x1f
   1a8c4:	0107c733          	xor	a4,a5,a6
   1a8c8:	40f70733          	sub	a4,a4,a5
    sdiff = diff;

    if (diff < 0)
      diff = -diff;
    if (diff < FRAC_NBITS)
   1a8cc:	03f00793          	li	a5,63
    int sdiff;

    a_normal_exp = a->normal_exp;
    b_normal_exp = b->normal_exp;
    a_fraction = a->fraction.ll;
    b_fraction = b->fraction.ll;
   1a8d0:	0105a283          	lw	t0,16(a1)
   1a8d4:	0145a383          	lw	t2,20(a1)
    diff = a_normal_exp - b_normal_exp;
    sdiff = diff;

    if (diff < 0)
      diff = -diff;
    if (diff < FRAC_NBITS)
   1a8d8:	0ce7dc63          	ble	a4,a5,1a9b0 <_fpadd_parts+0x130>
	  }
      }
    else
      {
	/* Somethings's up.. choose the biggest */
	if (a_normal_exp > b_normal_exp)
   1a8dc:	1e66c863          	blt	a3,t1,1aacc <_fpadd_parts+0x24c>
   1a8e0:	00068313          	mv	t1,a3
	    b_fraction = 0;
	  }
	else
	  {
	    a_normal_exp = b_normal_exp;
	    a_fraction = 0;
   1a8e4:	00000893          	li	a7,0
   1a8e8:	00000e13          	li	t3,0
	  }
      }
  }

  if (a->sign != b->sign)
   1a8ec:	00452503          	lw	a0,4(a0)
   1a8f0:	0045a783          	lw	a5,4(a1)
   1a8f4:	10f50863          	beq	a0,a5,1aa04 <_fpadd_parts+0x184>
    {
      if (a->sign)
   1a8f8:	1c050063          	beqz	a0,1aab8 <_fpadd_parts+0x238>
	{
	  tfraction = -a_fraction + b_fraction;
   1a8fc:	411287b3          	sub	a5,t0,a7
   1a900:	00f2b6b3          	sltu	a3,t0,a5
   1a904:	41c38733          	sub	a4,t2,t3
   1a908:	40d706b3          	sub	a3,a4,a3
	}
      else
	{
	  tfraction = a_fraction - b_fraction;
	}
      if (tfraction >= 0)
   1a90c:	1e06c463          	bltz	a3,1aaf4 <_fpadd_parts+0x274>
	{
	  tmp->sign = 0;
   1a910:	00062223          	sw	zero,4(a2) # 2004 <_reset+0x1e04>
	  tmp->normal_exp = a_normal_exp;
   1a914:	00662423          	sw	t1,8(a2)
	  tmp->fraction.ll = tfraction;
   1a918:	00f62823          	sw	a5,16(a2)
   1a91c:	00d62a23          	sw	a3,20(a2)
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1a920:	fff78513          	addi	a0,a5,-1
   1a924:	fff68593          	addi	a1,a3,-1
   1a928:	00f53733          	sltu	a4,a0,a5
   1a92c:	00b70733          	add	a4,a4,a1
   1a930:	100005b7          	lui	a1,0x10000
   1a934:	0eb77863          	bleu	a1,a4,1aa24 <_fpadd_parts+0x1a4>
   1a938:	fff58593          	addi	a1,a1,-1 # fffffff <_gp+0xffe0b2f>
   1a93c:	24b70e63          	beq	a4,a1,1ab98 <_fpadd_parts+0x318>
   1a940:	00862503          	lw	a0,8(a2)
   1a944:	100002b7          	lui	t0,0x10000
   1a948:	fff28313          	addi	t1,t0,-1 # fffffff <_gp+0xffe0b2f>
   1a94c:	fff50513          	addi	a0,a0,-1
   1a950:	ffe00393          	li	t2,-2
   1a954:	0080006f          	j	1a95c <_fpadd_parts+0xdc>
   1a958:	14670c63          	beq	a4,t1,1aab0 <_fpadd_parts+0x230>
	{
	  tmp->fraction.ll <<= 1;
   1a95c:	01f7d713          	srli	a4,a5,0x1f
   1a960:	00169593          	slli	a1,a3,0x1
   1a964:	00179793          	slli	a5,a5,0x1
   1a968:	00b765b3          	or	a1,a4,a1
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1a96c:	fff78813          	addi	a6,a5,-1
   1a970:	fff58893          	addi	a7,a1,-1
   1a974:	00f83733          	sltu	a4,a6,a5
   1a978:	01170733          	add	a4,a4,a7
	{
	  tmp->fraction.ll <<= 1;
   1a97c:	00058693          	mv	a3,a1
	  tmp->normal_exp--;
   1a980:	00050893          	mv	a7,a0
   1a984:	fff50513          	addi	a0,a0,-1
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1a988:	fc5768e3          	bltu	a4,t0,1a958 <_fpadd_parts+0xd8>
   1a98c:	00f62823          	sw	a5,16(a2)
    {
      tmp->sign = a->sign;
      tmp->normal_exp = a_normal_exp;
      tmp->fraction.ll = a_fraction + b_fraction;
    }
  tmp->class = CLASS_NUMBER;
   1a990:	00300793          	li	a5,3
   1a994:	00b62a23          	sw	a1,20(a2)
   1a998:	01162423          	sw	a7,8(a2)
   1a99c:	00f62023          	sw	a5,0(a2)
   1a9a0:	00060513          	mv	a0,a2
   1a9a4:	00008067          	ret
   1a9a8:	00058513          	mv	a0,a1
    {
      LSHIFT (tmp->fraction.ll, 1);
      tmp->normal_exp++;
    }
  return tmp;
}
   1a9ac:	00008067          	ret

    if (diff < 0)
      diff = -diff;
    if (diff < FRAC_NBITS)
      {
	if (sdiff > 0)
   1a9b0:	19005a63          	blez	a6,1ab44 <_fpadd_parts+0x2c4>
	  {
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
   1a9b4:	02077793          	andi	a5,a4,32
   1a9b8:	16078263          	beqz	a5,1ab1c <_fpadd_parts+0x29c>
   1a9bc:	00100793          	li	a5,1
   1a9c0:	00e3deb3          	srl	t4,t2,a4
   1a9c4:	00e797b3          	sll	a5,a5,a4
   1a9c8:	00000f13          	li	t5,0
   1a9cc:	00000713          	li	a4,0
   1a9d0:	fff70693          	addi	a3,a4,-1
   1a9d4:	fff78793          	addi	a5,a5,-1
   1a9d8:	00e6b733          	sltu	a4,a3,a4
   1a9dc:	00f70733          	add	a4,a4,a5
   1a9e0:	00777733          	and	a4,a4,t2
   1a9e4:	0056f7b3          	and	a5,a3,t0
   1a9e8:	00e7e7b3          	or	a5,a5,a4
   1a9ec:	00f037b3          	snez	a5,a5
   1a9f0:	00fee2b3          	or	t0,t4,a5
	    a_fraction = 0;
	  }
      }
  }

  if (a->sign != b->sign)
   1a9f4:	00452503          	lw	a0,4(a0)
   1a9f8:	0045a783          	lw	a5,4(a1)
    if (diff < FRAC_NBITS)
      {
	if (sdiff > 0)
	  {
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
   1a9fc:	000f0393          	mv	t2,t5
	    a_fraction = 0;
	  }
      }
  }

  if (a->sign != b->sign)
   1aa00:	eef51ce3          	bne	a0,a5,1a8f8 <_fpadd_parts+0x78>
    }
  else
    {
      tmp->sign = a->sign;
      tmp->normal_exp = a_normal_exp;
      tmp->fraction.ll = a_fraction + b_fraction;
   1aa04:	005887b3          	add	a5,a7,t0
   1aa08:	0117b8b3          	sltu	a7,a5,a7
   1aa0c:	007e0733          	add	a4,t3,t2
   1aa10:	00e886b3          	add	a3,a7,a4
	  tmp->normal_exp--;
	}
    }
  else
    {
      tmp->sign = a->sign;
   1aa14:	00a62223          	sw	a0,4(a2)
      tmp->normal_exp = a_normal_exp;
   1aa18:	00662423          	sw	t1,8(a2)
      tmp->fraction.ll = a_fraction + b_fraction;
   1aa1c:	00f62823          	sw	a5,16(a2)
   1aa20:	00d62a23          	sw	a3,20(a2)
    }
  tmp->class = CLASS_NUMBER;
   1aa24:	00300713          	li	a4,3
   1aa28:	00e62023          	sw	a4,0(a2)
  /* Now the fraction is added, we have to shift down to renormalize the
     number */

  if (tmp->fraction.ll >= IMPLICIT_2)
   1aa2c:	20000737          	lui	a4,0x20000
   1aa30:	02e6e863          	bltu	a3,a4,1aa60 <_fpadd_parts+0x1e0>
    {
      LSHIFT (tmp->fraction.ll, 1);
      tmp->normal_exp++;
   1aa34:	00862703          	lw	a4,8(a2)
  /* Now the fraction is added, we have to shift down to renormalize the
     number */

  if (tmp->fraction.ll >= IMPLICIT_2)
    {
      LSHIFT (tmp->fraction.ll, 1);
   1aa38:	01f69513          	slli	a0,a3,0x1f
   1aa3c:	0017d593          	srli	a1,a5,0x1
   1aa40:	00b565b3          	or	a1,a0,a1
   1aa44:	0017f793          	andi	a5,a5,1
   1aa48:	0016d693          	srli	a3,a3,0x1
   1aa4c:	00f5e7b3          	or	a5,a1,a5
      tmp->normal_exp++;
   1aa50:	00170713          	addi	a4,a4,1 # 20000001 <_gp+0x1ffe0b31>
  /* Now the fraction is added, we have to shift down to renormalize the
     number */

  if (tmp->fraction.ll >= IMPLICIT_2)
    {
      LSHIFT (tmp->fraction.ll, 1);
   1aa54:	00f62823          	sw	a5,16(a2)
   1aa58:	00d62a23          	sw	a3,20(a2)
      tmp->normal_exp++;
   1aa5c:	00e62423          	sw	a4,8(a2)
   1aa60:	00060513          	mv	a0,a2
   1aa64:	00008067          	ret
    {
      return b;
    }
  if (iszero (b))
    {
      if (iszero (a))
   1aa68:	f4e792e3          	bne	a5,a4,1a9ac <_fpadd_parts+0x12c>
	{
	  *tmp = *a;
   1aa6c:	00f62023          	sw	a5,0(a2)
   1aa70:	00452783          	lw	a5,4(a0)
   1aa74:	00f62223          	sw	a5,4(a2)
   1aa78:	00852703          	lw	a4,8(a0)
	  tmp->sign = a->sign & b->sign;
   1aa7c:	00452683          	lw	a3,4(a0)
   1aa80:	0045a783          	lw	a5,4(a1)
    }
  if (iszero (b))
    {
      if (iszero (a))
	{
	  *tmp = *a;
   1aa84:	00e62423          	sw	a4,8(a2)
   1aa88:	00c52703          	lw	a4,12(a0)
	  tmp->sign = a->sign & b->sign;
   1aa8c:	00f6f7b3          	and	a5,a3,a5
    }
  if (iszero (b))
    {
      if (iszero (a))
	{
	  *tmp = *a;
   1aa90:	00e62623          	sw	a4,12(a2)
   1aa94:	01052703          	lw	a4,16(a0)
   1aa98:	00e62823          	sw	a4,16(a2)
   1aa9c:	01452703          	lw	a4,20(a0)
	  tmp->sign = a->sign & b->sign;
   1aaa0:	00f62223          	sw	a5,4(a2)
	  return tmp;
   1aaa4:	00060513          	mv	a0,a2
    }
  if (iszero (b))
    {
      if (iszero (a))
	{
	  *tmp = *a;
   1aaa8:	00e62a23          	sw	a4,20(a2)
	  tmp->sign = a->sign & b->sign;
	  return tmp;
   1aaac:	00008067          	ret
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1aab0:	eb03f6e3          	bleu	a6,t2,1a95c <_fpadd_parts+0xdc>
   1aab4:	ed9ff06f          	j	1a98c <_fpadd_parts+0x10c>
	{
	  tfraction = -a_fraction + b_fraction;
	}
      else
	{
	  tfraction = a_fraction - b_fraction;
   1aab8:	405887b3          	sub	a5,a7,t0
   1aabc:	00f8b6b3          	sltu	a3,a7,a5
   1aac0:	407e0733          	sub	a4,t3,t2
   1aac4:	40d706b3          	sub	a3,a4,a3
   1aac8:	e45ff06f          	j	1a90c <_fpadd_parts+0x8c>
      {
	/* Somethings's up.. choose the biggest */
	if (a_normal_exp > b_normal_exp)
	  {
	    b_normal_exp = a_normal_exp;
	    b_fraction = 0;
   1aacc:	00000293          	li	t0,0
   1aad0:	00000393          	li	t2,0
   1aad4:	e19ff06f          	j	1a8ec <_fpadd_parts+0x6c>
      return b;
    }
  if (isinf (a))
    {
      /* Adding infinities with opposite signs yields a NaN.  */
      if (isinf (b) && a->sign != b->sign)
   1aad8:	ecf71ae3          	bne	a4,a5,1a9ac <_fpadd_parts+0x12c>
   1aadc:	00452703          	lw	a4,4(a0)
   1aae0:	0045a783          	lw	a5,4(a1)
   1aae4:	ecf704e3          	beq	a4,a5,1a9ac <_fpadd_parts+0x12c>
	return makenan ();
   1aae8:	0001d537          	lui	a0,0x1d
   1aaec:	bb850513          	addi	a0,a0,-1096 # 1cbb8 <__thenan_df>
   1aaf0:	00008067          	ret
	}
      else
	{
	  tmp->sign = 1;
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
   1aaf4:	40f007b3          	neg	a5,a5
   1aaf8:	00f03733          	snez	a4,a5
   1aafc:	40d006b3          	neg	a3,a3
   1ab00:	40e686b3          	sub	a3,a3,a4
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = tfraction;
	}
      else
	{
	  tmp->sign = 1;
   1ab04:	00100713          	li	a4,1
   1ab08:	00e62223          	sw	a4,4(a2)
	  tmp->normal_exp = a_normal_exp;
   1ab0c:	00662423          	sw	t1,8(a2)
	  tmp->fraction.ll = -tfraction;
   1ab10:	00f62823          	sw	a5,16(a2)
   1ab14:	00d62a23          	sw	a3,20(a2)
   1ab18:	e09ff06f          	j	1a920 <_fpadd_parts+0xa0>
    if (diff < FRAC_NBITS)
      {
	if (sdiff > 0)
	  {
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
   1ab1c:	fff74693          	not	a3,a4
   1ab20:	00139793          	slli	a5,t2,0x1
   1ab24:	00d797b3          	sll	a5,a5,a3
   1ab28:	00e2deb3          	srl	t4,t0,a4
   1ab2c:	00100813          	li	a6,1
   1ab30:	01d7eeb3          	or	t4,a5,t4
   1ab34:	00e3df33          	srl	t5,t2,a4
   1ab38:	00000793          	li	a5,0
   1ab3c:	00e81733          	sll	a4,a6,a4
   1ab40:	e91ff06f          	j	1a9d0 <_fpadd_parts+0x150>
	  }
	else if (sdiff < 0)
   1ab44:	da0804e3          	beqz	a6,1a8ec <_fpadd_parts+0x6c>
	  {
	    a_normal_exp += diff;
	    LSHIFT (a_fraction, diff);
   1ab48:	02077793          	andi	a5,a4,32
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
	  }
	else if (sdiff < 0)
	  {
	    a_normal_exp += diff;
   1ab4c:	00e30333          	add	t1,t1,a4
	    LSHIFT (a_fraction, diff);
   1ab50:	06078263          	beqz	a5,1abb4 <_fpadd_parts+0x334>
   1ab54:	00ee5833          	srl	a6,t3,a4
   1ab58:	00000e93          	li	t4,0
   1ab5c:	04079463          	bnez	a5,1aba4 <_fpadd_parts+0x324>
   1ab60:	00100793          	li	a5,1
   1ab64:	00000693          	li	a3,0
   1ab68:	00e79733          	sll	a4,a5,a4
   1ab6c:	fff70793          	addi	a5,a4,-1
   1ab70:	00e7b733          	sltu	a4,a5,a4
   1ab74:	fff68693          	addi	a3,a3,-1
   1ab78:	00d70733          	add	a4,a4,a3
   1ab7c:	0117f7b3          	and	a5,a5,a7
   1ab80:	01c77733          	and	a4,a4,t3
   1ab84:	00e7e7b3          	or	a5,a5,a4
   1ab88:	00f037b3          	snez	a5,a5
   1ab8c:	00f868b3          	or	a7,a6,a5
   1ab90:	000e8e13          	mv	t3,t4
   1ab94:	d59ff06f          	j	1a8ec <_fpadd_parts+0x6c>
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1ab98:	ffe00713          	li	a4,-2
   1ab9c:	daa772e3          	bleu	a0,a4,1a940 <_fpadd_parts+0xc0>
   1aba0:	e85ff06f          	j	1aa24 <_fpadd_parts+0x1a4>
	    LSHIFT (b_fraction, diff);
	  }
	else if (sdiff < 0)
	  {
	    a_normal_exp += diff;
	    LSHIFT (a_fraction, diff);
   1aba4:	00100693          	li	a3,1
   1aba8:	00e696b3          	sll	a3,a3,a4
   1abac:	00000713          	li	a4,0
   1abb0:	fbdff06f          	j	1ab6c <_fpadd_parts+0x2ec>
   1abb4:	001e1793          	slli	a5,t3,0x1
   1abb8:	fff74693          	not	a3,a4
   1abbc:	00d797b3          	sll	a5,a5,a3
   1abc0:	00e8d833          	srl	a6,a7,a4
   1abc4:	0107e833          	or	a6,a5,a6
   1abc8:	00ee5eb3          	srl	t4,t3,a4
   1abcc:	f95ff06f          	j	1ab60 <_fpadd_parts+0x2e0>

0001abd0 <__pack_d>:
extern FLO_type pack_d (const fp_number_type * );

#if defined(L_pack_df) || defined(L_pack_sf) || defined(L_pack_tf)
FLO_type
pack_d (const fp_number_type *src)
{
   1abd0:	00052783          	lw	a5,0(a0)
  FLO_union_type dst;
  fractype fraction = src->fraction.ll;	/* wasn't unsigned before? */
  int sign = src->sign;
  int exp = 0;

  if (isnan (src))
   1abd4:	00100593          	li	a1,1
#if defined(L_pack_df) || defined(L_pack_sf) || defined(L_pack_tf)
FLO_type
pack_d (const fp_number_type *src)
{
  FLO_union_type dst;
  fractype fraction = src->fraction.ll;	/* wasn't unsigned before? */
   1abd8:	01052603          	lw	a2,16(a0)
   1abdc:	01452683          	lw	a3,20(a0)
  int sign = src->sign;
   1abe0:	00452803          	lw	a6,4(a0)
  int exp = 0;

  if (isnan (src))
   1abe4:	0ef5fa63          	bleu	a5,a1,1acd8 <__pack_d+0x108>
	  /* Set the quiet/signaling bit.  */
	  fraction |= QUIET_NAN;
#endif
	}
    }
  else if (isinf (src))
   1abe8:	00400713          	li	a4,4
   1abec:	0ce78e63          	beq	a5,a4,1acc8 <__pack_d+0xf8>
    {
      exp = EXPMAX;
      fraction = 0;
    }
  else if (iszero (src))
   1abf0:	00200713          	li	a4,2
   1abf4:	06e78263          	beq	a5,a4,1ac58 <__pack_d+0x88>
    {
      exp = 0;
      fraction = 0;
    }
  else if (fraction == 0)
   1abf8:	00d667b3          	or	a5,a2,a3
   1abfc:	04078e63          	beqz	a5,1ac58 <__pack_d+0x88>
    {
      exp = 0;
    }
  else
    {
      if (__builtin_expect (src->normal_exp < NORMAL_EXPMIN, 0))
   1ac00:	00852783          	lw	a5,8(a0)
   1ac04:	c0200713          	li	a4,-1022
   1ac08:	12e7c063          	blt	a5,a4,1ad28 <__pack_d+0x158>
	      exp += 1;
	    }
	  fraction >>= NGARDS;
#endif /* NO_DENORMALS */
	}
      else if (__builtin_expect (src->normal_exp > EXPBIAS, 0))
   1ac0c:	3ff00713          	li	a4,1023
   1ac10:	0af74c63          	blt	a4,a5,1acc8 <__pack_d+0xf8>
	{
	  exp = src->normal_exp + EXPBIAS;
	  /* IF the gard bits are the all zero, but the first, then we're
	     half way between two numbers, choose the one which makes the
	     lsb of the answer 0.  */
	  if ((fraction & GARDMASK) == GARDMSB)
   1ac14:	0ff67713          	andi	a4,a2,255
   1ac18:	08000593          	li	a1,128
   1ac1c:	0eb70863          	beq	a4,a1,1ad0c <__pack_d+0x13c>
		fraction += GARDROUND + 1;
	    }
	  else
	    {
	      /* Add a one to the guards to round up */
	      fraction += GARDROUND;
   1ac20:	07f60713          	addi	a4,a2,127
   1ac24:	00c73633          	sltu	a2,a4,a2
   1ac28:	00d606b3          	add	a3,a2,a3
   1ac2c:	00070613          	mv	a2,a4
	    }
	  if (fraction >= IMPLICIT_2)
   1ac30:	20000737          	lui	a4,0x20000
   1ac34:	06e6fe63          	bleu	a4,a3,1acb0 <__pack_d+0xe0>
	  exp = EXPMAX;
	  fraction = 0;
	}
      else
	{
	  exp = src->normal_exp + EXPBIAS;
   1ac38:	3ff78793          	addi	a5,a5,1023
   1ac3c:	01869713          	slli	a4,a3,0x18
   1ac40:	00865613          	srli	a2,a2,0x8
   1ac44:	00469693          	slli	a3,a3,0x4
   1ac48:	00c76633          	or	a2,a4,a2
   1ac4c:	00c6d693          	srli	a3,a3,0xc
   1ac50:	7ff7f793          	andi	a5,a5,2047
   1ac54:	0100006f          	j	1ac64 <__pack_d+0x94>
   1ac58:	00000793          	li	a5,0
   1ac5c:	00000613          	li	a2,0
   1ac60:	00000693          	li	a3,0

  /* We previously used bitfields to store the number, but this doesn't
     handle little/big endian systems conveniently, so use shifts and
     masks */
#ifdef FLOAT_BIT_ORDER_MISMATCH
  dst.bits.fraction = fraction;
   1ac64:	00100737          	lui	a4,0x100
   1ac68:	00000593          	li	a1,0
   1ac6c:	00060513          	mv	a0,a2
   1ac70:	fff70713          	addi	a4,a4,-1 # fffff <_gp+0xe0b2f>
   1ac74:	fff00637          	lui	a2,0xfff00
   1ac78:	00b67633          	and	a2,a2,a1
   1ac7c:	00e6f6b3          	and	a3,a3,a4
  dst.bits.exp = exp;
   1ac80:	01479713          	slli	a4,a5,0x14
   1ac84:	801007b7          	lui	a5,0x80100

  /* We previously used bitfields to store the number, but this doesn't
     handle little/big endian systems conveniently, so use shifts and
     masks */
#ifdef FLOAT_BIT_ORDER_MISMATCH
  dst.bits.fraction = fraction;
   1ac88:	00d666b3          	or	a3,a2,a3
  dst.bits.exp = exp;
   1ac8c:	fff78793          	addi	a5,a5,-1 # 800fffff <_gp+0x800e0b2f>
   1ac90:	00f6f7b3          	and	a5,a3,a5
   1ac94:	00e7e7b3          	or	a5,a5,a4
  dst.bits.sign = sign;
   1ac98:	80000737          	lui	a4,0x80000
   1ac9c:	fff74713          	not	a4,a4
   1aca0:	01f81813          	slli	a6,a6,0x1f
   1aca4:	00e7f7b3          	and	a5,a5,a4
   1aca8:	0107e5b3          	or	a1,a5,a6
  }
#endif
#endif

  return dst.value;
}
   1acac:	00008067          	ret
	      /* Add a one to the guards to round up */
	      fraction += GARDROUND;
	    }
	  if (fraction >= IMPLICIT_2)
	    {
	      fraction >>= 1;
   1acb0:	01f69713          	slli	a4,a3,0x1f
   1acb4:	00165613          	srli	a2,a2,0x1
   1acb8:	00c76633          	or	a2,a4,a2
   1acbc:	0016d693          	srli	a3,a3,0x1
	      exp += 1;
   1acc0:	40078793          	addi	a5,a5,1024
   1acc4:	f79ff06f          	j	1ac3c <__pack_d+0x6c>
   1acc8:	7ff00793          	li	a5,2047
   1accc:	00000613          	li	a2,0
   1acd0:	00000693          	li	a3,0
   1acd4:	f91ff06f          	j	1ac64 <__pack_d+0x94>
  if (isnan (src))
    {
      exp = EXPMAX;
      /* Restore the NaN's payload.  */
      fraction >>= NGARDS;
      fraction &= QUIET_NAN - 1;
   1acd8:	00080737          	lui	a4,0x80

  if (isnan (src))
    {
      exp = EXPMAX;
      /* Restore the NaN's payload.  */
      fraction >>= NGARDS;
   1acdc:	0086d593          	srli	a1,a3,0x8
      fraction &= QUIET_NAN - 1;
   1ace0:	fff70793          	addi	a5,a4,-1 # 7ffff <_gp+0x60b2f>
   1ace4:	00f5f7b3          	and	a5,a1,a5

  if (isnan (src))
    {
      exp = EXPMAX;
      /* Restore the NaN's payload.  */
      fraction >>= NGARDS;
   1ace8:	01869593          	slli	a1,a3,0x18
   1acec:	00e7e6b3          	or	a3,a5,a4
   1acf0:	001007b7          	lui	a5,0x100
   1acf4:	fff78793          	addi	a5,a5,-1 # fffff <_gp+0xe0b2f>
   1acf8:	00865613          	srli	a2,a2,0x8
   1acfc:	00f6f6b3          	and	a3,a3,a5
   1ad00:	00c5e633          	or	a2,a1,a2
	  /* Make sure the fraction has a non-zero value.  */
	  if (fraction == 0)
	    fraction |= QUIET_NAN - 1;
#else
	  /* Set the quiet/signaling bit.  */
	  fraction |= QUIET_NAN;
   1ad04:	7ff00793          	li	a5,2047
   1ad08:	f5dff06f          	j	1ac64 <__pack_d+0x94>
	  /* IF the gard bits are the all zero, but the first, then we're
	     half way between two numbers, choose the one which makes the
	     lsb of the answer 0.  */
	  if ((fraction & GARDMASK) == GARDMSB)
	    {
	      if (fraction & (1 << NGARDS))
   1ad0c:	10067713          	andi	a4,a2,256
   1ad10:	f20700e3          	beqz	a4,1ac30 <__pack_d+0x60>
		fraction += GARDROUND + 1;
   1ad14:	00b60733          	add	a4,a2,a1
   1ad18:	00c73633          	sltu	a2,a4,a2
   1ad1c:	00d606b3          	add	a3,a2,a3
   1ad20:	00070613          	mv	a2,a4
   1ad24:	f0dff06f          	j	1ac30 <__pack_d+0x60>
#else /* NO_DENORMALS */
	  /* This number's exponent is too low to fit into the bits
	     available in the number, so we'll store 0 in the exponent and
	     shift the fraction to the right to make up for it.  */

	  int shift = NORMAL_EXPMIN - src->normal_exp;
   1ad28:	40f707b3          	sub	a5,a4,a5

	  exp = 0;

	  if (shift > FRAC_NBITS - NGARDS)
   1ad2c:	03800713          	li	a4,56
   1ad30:	f2f744e3          	blt	a4,a5,1ac58 <__pack_d+0x88>
	      fraction = 0;
	    }
	  else
	    {
	      int lowbit = (fraction & (((fractype)1 << shift) - 1)) ? 1 : 0;
	      fraction = (fraction >> shift) | lowbit;
   1ad34:	0207f713          	andi	a4,a5,32
   1ad38:	0a070663          	beqz	a4,1ade4 <__pack_d+0x214>
   1ad3c:	00f6d8b3          	srl	a7,a3,a5
   1ad40:	00f595b3          	sll	a1,a1,a5
   1ad44:	00000713          	li	a4,0
   1ad48:	00000793          	li	a5,0
   1ad4c:	fff78513          	addi	a0,a5,-1
   1ad50:	00f537b3          	sltu	a5,a0,a5
   1ad54:	fff58593          	addi	a1,a1,-1
   1ad58:	00b785b3          	add	a1,a5,a1
   1ad5c:	00d5f6b3          	and	a3,a1,a3
   1ad60:	00c577b3          	and	a5,a0,a2
   1ad64:	00d7e7b3          	or	a5,a5,a3
   1ad68:	00f037b3          	snez	a5,a5
   1ad6c:	00f8e633          	or	a2,a7,a5
	    }
	  if ((fraction & GARDMASK) == GARDMSB)
   1ad70:	0ff67693          	andi	a3,a2,255
   1ad74:	08000793          	li	a5,128
   1ad78:	02f69a63          	bne	a3,a5,1adac <__pack_d+0x1dc>
	    {
	      if ((fraction & (1 << NGARDS)))
   1ad7c:	10067793          	andi	a5,a2,256
   1ad80:	08079663          	bnez	a5,1ae0c <__pack_d+0x23c>
   1ad84:	01871793          	slli	a5,a4,0x18
   1ad88:	00865613          	srli	a2,a2,0x8
   1ad8c:	00471693          	slli	a3,a4,0x4
   1ad90:	100005b7          	lui	a1,0x10000
   1ad94:	00c7e633          	or	a2,a5,a2
   1ad98:	00c6d693          	srli	a3,a3,0xc
   1ad9c:	00100793          	li	a5,1
   1ada0:	02b76c63          	bltu	a4,a1,1add8 <__pack_d+0x208>
   1ada4:	0017f793          	andi	a5,a5,1
   1ada8:	ebdff06f          	j	1ac64 <__pack_d+0x94>
   1adac:	07f60793          	addi	a5,a2,127 # fff0007f <_gp+0xffee0baf>
		fraction += GARDROUND + 1;
   1adb0:	00c7b633          	sltu	a2,a5,a2
   1adb4:	00e60733          	add	a4,a2,a4
   1adb8:	01871593          	slli	a1,a4,0x18
   1adbc:	0087d613          	srli	a2,a5,0x8
   1adc0:	00471693          	slli	a3,a4,0x4
   1adc4:	00c5e633          	or	a2,a1,a2
   1adc8:	100005b7          	lui	a1,0x10000
   1adcc:	00c6d693          	srli	a3,a3,0xc
   1add0:	00100793          	li	a5,1
   1add4:	fcb778e3          	bleu	a1,a4,1ada4 <__pack_d+0x1d4>
   1add8:	00000793          	li	a5,0
   1addc:	0017f793          	andi	a5,a5,1
   1ade0:	e85ff06f          	j	1ac64 <__pack_d+0x94>
	      fraction = 0;
	    }
	  else
	    {
	      int lowbit = (fraction & (((fractype)1 << shift) - 1)) ? 1 : 0;
	      fraction = (fraction >> shift) | lowbit;
   1ade4:	fff7c593          	not	a1,a5
   1ade8:	00169713          	slli	a4,a3,0x1
   1adec:	00b71733          	sll	a4,a4,a1
   1adf0:	00f658b3          	srl	a7,a2,a5
   1adf4:	00100513          	li	a0,1
   1adf8:	011768b3          	or	a7,a4,a7
   1adfc:	00000593          	li	a1,0
   1ae00:	00f6d733          	srl	a4,a3,a5
   1ae04:	00f517b3          	sll	a5,a0,a5
   1ae08:	f45ff06f          	j	1ad4c <__pack_d+0x17c>
	    }
	  if ((fraction & GARDMASK) == GARDMSB)
	    {
	      if ((fraction & (1 << NGARDS)))
		fraction += GARDROUND + 1;
   1ae0c:	08060793          	addi	a5,a2,128
   1ae10:	fa1ff06f          	j	1adb0 <__pack_d+0x1e0>

0001ae14 <__unpack_d>:
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
  exp = src->bits.exp;
   1ae14:	00655683          	lhu	a3,6(a0)
  sign = src->bits.sign;
   1ae18:	00754703          	lbu	a4,7(a0)
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1ae1c:	00452803          	lw	a6,4(a0)
  exp = src->bits.exp;
   1ae20:	0046d693          	srli	a3,a3,0x4
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1ae24:	001007b7          	lui	a5,0x100
  exp = ((int)(src->value_raw >> FRACBITS)) & ((1 << EXPBITS) - 1);
  sign = ((int)(src->value_raw >> (FRACBITS + EXPBITS))) & 1;
# endif
#endif

  dst->sign = sign;
   1ae28:	00775613          	srli	a2,a4,0x7
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1ae2c:	fff78793          	addi	a5,a5,-1 # fffff <_gp+0xe0b2f>
  exp = src->bits.exp;
   1ae30:	7ff6f693          	andi	a3,a3,2047
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1ae34:	00052703          	lw	a4,0(a0)
   1ae38:	00f877b3          	and	a5,a6,a5
  exp = ((int)(src->value_raw >> FRACBITS)) & ((1 << EXPBITS) - 1);
  sign = ((int)(src->value_raw >> (FRACBITS + EXPBITS))) & 1;
# endif
#endif

  dst->sign = sign;
   1ae3c:	00c5a223          	sw	a2,4(a1) # 10000004 <_gp+0xffe0b34>
  if (exp == 0)
   1ae40:	04069c63          	bnez	a3,1ae98 <__unpack_d+0x84>
    {
      /* Hmm.  Looks like 0 */
      if (fraction == 0
   1ae44:	00f766b3          	or	a3,a4,a5
   1ae48:	08068663          	beqz	a3,1aed4 <__unpack_d+0xc0>
	{
	  /* Zero exponent with nonzero fraction - it's denormalized,
	     so there isn't a leading implicit one - we'll shift it so
	     it gets one.  */
	  dst->normal_exp = exp - EXPBIAS + 1;
	  fraction <<= NGARDS;
   1ae4c:	01875693          	srli	a3,a4,0x18
   1ae50:	00879793          	slli	a5,a5,0x8
   1ae54:	00f6e7b3          	or	a5,a3,a5

	  dst->class = CLASS_NUMBER;
   1ae58:	00300693          	li	a3,3
   1ae5c:	00d5a023          	sw	a3,0(a1)
	{
	  /* Zero exponent with nonzero fraction - it's denormalized,
	     so there isn't a leading implicit one - we'll shift it so
	     it gets one.  */
	  dst->normal_exp = exp - EXPBIAS + 1;
	  fraction <<= NGARDS;
   1ae60:	00871713          	slli	a4,a4,0x8

	  dst->class = CLASS_NUMBER;
   1ae64:	c0100693          	li	a3,-1023
#if 1
	  while (fraction < IMPLICIT_1)
   1ae68:	10000537          	lui	a0,0x10000
	    {
	      fraction <<= 1;
   1ae6c:	01f75613          	srli	a2,a4,0x1f
   1ae70:	00179793          	slli	a5,a5,0x1
   1ae74:	00f667b3          	or	a5,a2,a5
   1ae78:	00171713          	slli	a4,a4,0x1
	      dst->normal_exp--;
   1ae7c:	00068613          	mv	a2,a3
   1ae80:	fff68693          	addi	a3,a3,-1
	  dst->normal_exp = exp - EXPBIAS + 1;
	  fraction <<= NGARDS;

	  dst->class = CLASS_NUMBER;
#if 1
	  while (fraction < IMPLICIT_1)
   1ae84:	fea7e4e3          	bltu	a5,a0,1ae6c <__unpack_d+0x58>
   1ae88:	00c5a423          	sw	a2,8(a1)
	    {
	      fraction <<= 1;
	      dst->normal_exp--;
	    }
#endif
	  dst->fraction.ll = fraction;
   1ae8c:	00e5a823          	sw	a4,16(a1)
   1ae90:	00f5aa23          	sw	a5,20(a1)
   1ae94:	00008067          	ret
	}
    }
  else if (__builtin_expect (exp == EXPMAX, 0))
   1ae98:	7ff00613          	li	a2,2047
   1ae9c:	04c68263          	beq	a3,a2,1aee0 <__unpack_d+0xcc>
  else
    {
      /* Nothing strange about this number */
      dst->normal_exp = exp - EXPBIAS;
      dst->class = CLASS_NUMBER;
      dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;
   1aea0:	01875613          	srli	a2,a4,0x18
   1aea4:	00879793          	slli	a5,a5,0x8
   1aea8:	00f667b3          	or	a5,a2,a5
	}
    }
  else
    {
      /* Nothing strange about this number */
      dst->normal_exp = exp - EXPBIAS;
   1aeac:	c0168693          	addi	a3,a3,-1023
      dst->class = CLASS_NUMBER;
      dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;
   1aeb0:	10000637          	lui	a2,0x10000
   1aeb4:	00871713          	slli	a4,a4,0x8
   1aeb8:	00c7e7b3          	or	a5,a5,a2
	}
    }
  else
    {
      /* Nothing strange about this number */
      dst->normal_exp = exp - EXPBIAS;
   1aebc:	00d5a423          	sw	a3,8(a1)
      dst->class = CLASS_NUMBER;
   1aec0:	00300693          	li	a3,3
   1aec4:	00d5a023          	sw	a3,0(a1)
      dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;
   1aec8:	00e5a823          	sw	a4,16(a1)
   1aecc:	00f5aa23          	sw	a5,20(a1)
   1aed0:	00008067          	ret
	  || 1
#endif
	  )
	{
	  /* tastes like zero */
	  dst->class = CLASS_ZERO;
   1aed4:	00200793          	li	a5,2
   1aed8:	00f5a023          	sw	a5,0(a1)
   1aedc:	00008067          	ret
	}
    }
  else if (__builtin_expect (exp == EXPMAX, 0))
    {
      /* Huge exponent*/
      if (fraction == 0)
   1aee0:	00f766b3          	or	a3,a4,a5
   1aee4:	02068e63          	beqz	a3,1af20 <__unpack_d+0x10c>
	{
	  /* Nonzero fraction, means nan */
#ifdef QUIET_NAN_NEGATED
	  if ((fraction & QUIET_NAN) == 0)
#else
	  if (fraction & QUIET_NAN)
   1aee8:	00c79693          	slli	a3,a5,0xc
   1aeec:	0406d063          	bgez	a3,1af2c <__unpack_d+0x118>
#endif
	    {
	      dst->class = CLASS_QNAN;
   1aef0:	00100693          	li	a3,1
   1aef4:	00d5a023          	sw	a3,0(a1)
	      dst->class = CLASS_SNAN;
	    }
	  /* Now that we know which kind of NaN we got, discard the
	     quiet/signaling bit, but do preserve the NaN payload.  */
	  fraction &= ~QUIET_NAN;
	  dst->fraction.ll = fraction << NGARDS;
   1aef8:	fff806b7          	lui	a3,0xfff80
   1aefc:	fff68693          	addi	a3,a3,-1 # fff7ffff <_gp+0xfff60b2f>
   1af00:	00d7f7b3          	and	a5,a5,a3
   1af04:	00879793          	slli	a5,a5,0x8
   1af08:	01875693          	srli	a3,a4,0x18
   1af0c:	00d7e7b3          	or	a5,a5,a3
   1af10:	00871713          	slli	a4,a4,0x8
   1af14:	00f5aa23          	sw	a5,20(a1)
   1af18:	00e5a823          	sw	a4,16(a1)
   1af1c:	00008067          	ret
    {
      /* Huge exponent*/
      if (fraction == 0)
	{
	  /* Attached to a zero fraction - means infinity */
	  dst->class = CLASS_INFINITY;
   1af20:	00400793          	li	a5,4
   1af24:	00f5a023          	sw	a5,0(a1)
   1af28:	00008067          	ret
	    {
	      dst->class = CLASS_QNAN;
	    }
	  else
	    {
	      dst->class = CLASS_SNAN;
   1af2c:	0005a023          	sw	zero,0(a1)
   1af30:	fc9ff06f          	j	1aef8 <__unpack_d+0xe4>

0001af34 <__adddf3>:
  return tmp;
}

FLO_type
add (FLO_type arg_a, FLO_type arg_b)
{
   1af34:	f9010113          	addi	sp,sp,-112
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1af38:	00a12423          	sw	a0,8(sp)
   1af3c:	00b12623          	sw	a1,12(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1af40:	00810513          	addi	a0,sp,8
   1af44:	01810593          	addi	a1,sp,24
  return tmp;
}

FLO_type
add (FLO_type arg_a, FLO_type arg_b)
{
   1af48:	06112623          	sw	ra,108(sp)
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1af4c:	00d12a23          	sw	a3,20(sp)
   1af50:	00c12823          	sw	a2,16(sp)

  unpack_d (&au, &a);
   1af54:	ec1ff0ef          	jal	1ae14 <__unpack_d>
  unpack_d (&bu, &b);
   1af58:	03010593          	addi	a1,sp,48
   1af5c:	01010513          	addi	a0,sp,16
   1af60:	eb5ff0ef          	jal	1ae14 <__unpack_d>

  res = _fpadd_parts (&a, &b, &tmp);
   1af64:	04810613          	addi	a2,sp,72
   1af68:	03010593          	addi	a1,sp,48
   1af6c:	01810513          	addi	a0,sp,24
   1af70:	911ff0ef          	jal	1a880 <_fpadd_parts>

  return pack_d (res);
   1af74:	c5dff0ef          	jal	1abd0 <__pack_d>
}
   1af78:	06c12083          	lw	ra,108(sp)
   1af7c:	07010113          	addi	sp,sp,112
   1af80:	00008067          	ret

0001af84 <__subdf3>:

FLO_type
sub (FLO_type arg_a, FLO_type arg_b)
{
   1af84:	f9010113          	addi	sp,sp,-112
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1af88:	00a12423          	sw	a0,8(sp)
   1af8c:	00b12623          	sw	a1,12(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1af90:	00810513          	addi	a0,sp,8
   1af94:	01810593          	addi	a1,sp,24
  return pack_d (res);
}

FLO_type
sub (FLO_type arg_a, FLO_type arg_b)
{
   1af98:	06112623          	sw	ra,108(sp)
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1af9c:	00d12a23          	sw	a3,20(sp)
   1afa0:	00c12823          	sw	a2,16(sp)

  unpack_d (&au, &a);
   1afa4:	e71ff0ef          	jal	1ae14 <__unpack_d>
  unpack_d (&bu, &b);
   1afa8:	03010593          	addi	a1,sp,48
   1afac:	01010513          	addi	a0,sp,16
   1afb0:	e65ff0ef          	jal	1ae14 <__unpack_d>

  b.sign ^= 1;
   1afb4:	03412783          	lw	a5,52(sp)

  res = _fpadd_parts (&a, &b, &tmp);
   1afb8:	04810613          	addi	a2,sp,72
   1afbc:	03010593          	addi	a1,sp,48
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  b.sign ^= 1;
   1afc0:	0017c793          	xori	a5,a5,1

  res = _fpadd_parts (&a, &b, &tmp);
   1afc4:	01810513          	addi	a0,sp,24
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  b.sign ^= 1;
   1afc8:	02f12a23          	sw	a5,52(sp)

  res = _fpadd_parts (&a, &b, &tmp);
   1afcc:	8b5ff0ef          	jal	1a880 <_fpadd_parts>

  return pack_d (res);
   1afd0:	c01ff0ef          	jal	1abd0 <__pack_d>
}
   1afd4:	06c12083          	lw	ra,108(sp)
   1afd8:	07010113          	addi	sp,sp,112
   1afdc:	00008067          	ret

0001afe0 <__muldf3>:
  return tmp;
}

FLO_type
multiply (FLO_type arg_a, FLO_type arg_b)
{
   1afe0:	f9010113          	addi	sp,sp,-112
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1afe4:	00a12423          	sw	a0,8(sp)
   1afe8:	00b12623          	sw	a1,12(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1afec:	00810513          	addi	a0,sp,8
   1aff0:	01810593          	addi	a1,sp,24
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1aff4:	00d12a23          	sw	a3,20(sp)
  return tmp;
}

FLO_type
multiply (FLO_type arg_a, FLO_type arg_b)
{
   1aff8:	06112623          	sw	ra,108(sp)
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1affc:	00c12823          	sw	a2,16(sp)

  unpack_d (&au, &a);
   1b000:	e15ff0ef          	jal	1ae14 <__unpack_d>
  unpack_d (&bu, &b);
   1b004:	03010593          	addi	a1,sp,48
   1b008:	01010513          	addi	a0,sp,16
   1b00c:	e09ff0ef          	jal	1ae14 <__unpack_d>
   1b010:	01812783          	lw	a5,24(sp)
	       fp_number_type * tmp)
{
  fractype low = 0;
  fractype high = 0;

  if (isnan (a))
   1b014:	00100693          	li	a3,1
   1b018:	16f6fc63          	bleu	a5,a3,1b190 <__muldf3+0x1b0>
   1b01c:	03012703          	lw	a4,48(sp)
    {
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isnan (b))
   1b020:	14e6f063          	bleu	a4,a3,1b160 <__muldf3+0x180>
    {
      b->sign = a->sign != b->sign;
      return b;
    }
  if (isinf (a))
   1b024:	00400693          	li	a3,4
   1b028:	16d78063          	beq	a5,a3,1b188 <__muldf3+0x1a8>
      if (iszero (b))
	return makenan ();
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isinf (b))
   1b02c:	12d70663          	beq	a4,a3,1b158 <__muldf3+0x178>
	  return makenan ();
	}
      b->sign = a->sign != b->sign;
      return b;
    }
  if (iszero (a))
   1b030:	00200693          	li	a3,2
   1b034:	14d78e63          	beq	a5,a3,1b190 <__muldf3+0x1b0>
    {
      a->sign = a->sign != b->sign;
      return a;
    }
  if (iszero (b))
   1b038:	12d70463          	beq	a4,a3,1b160 <__muldf3+0x180>
#else
    /* fractype is DImode, but we need the result to be twice as wide.
       Assuming a widening multiply from DImode to TImode is not
       available, build one by hand.  */
    {
      USItype nl = a->fraction.ll;
   1b03c:	02812503          	lw	a0,40(sp)
   1b040:	02c12703          	lw	a4,44(sp)
      USItype nh = a->fraction.ll >> BITS_PER_SI;
      USItype ml = b->fraction.ll;
   1b044:	04012783          	lw	a5,64(sp)
   1b048:	04412803          	lw	a6,68(sp)
      UDItype pp_hl = (UDItype) mh * nl;
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
      UDItype res2 = 0;
      UDItype res0 = 0;
      UDItype ps_hh__ = pp_hl + pp_lh;
   1b04c:	02f70633          	mul	a2,a4,a5
      USItype nl = a->fraction.ll;
      USItype nh = a->fraction.ll >> BITS_PER_SI;
      USItype ml = b->fraction.ll;
      USItype mh = b->fraction.ll >> BITS_PER_SI;
      UDItype pp_ll = (UDItype) ml * nl;
      UDItype pp_hl = (UDItype) mh * nl;
   1b050:	02a803b3          	mul	t2,a6,a0
   1b054:	02a832b3          	mulhu	t0,a6,a0
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
      UDItype res2 = 0;
      UDItype res0 = 0;
      UDItype ps_hh__ = pp_hl + pp_lh;
   1b058:	00760333          	add	t1,a2,t2
   1b05c:	00c33633          	sltu	a2,t1,a2
   1b060:	02f735b3          	mulhu	a1,a4,a5
   1b064:	005585b3          	add	a1,a1,t0
   1b068:	00b60633          	add	a2,a2,a1
      USItype ml = b->fraction.ll;
      USItype mh = b->fraction.ll >> BITS_PER_SI;
      UDItype pp_ll = (UDItype) ml * nl;
      UDItype pp_hl = (UDItype) mh * nl;
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
   1b06c:	030708b3          	mul	a7,a4,a6
    {
      USItype nl = a->fraction.ll;
      USItype nh = a->fraction.ll >> BITS_PER_SI;
      USItype ml = b->fraction.ll;
      USItype mh = b->fraction.ll >> BITS_PER_SI;
      UDItype pp_ll = (UDItype) ml * nl;
   1b070:	02a785b3          	mul	a1,a5,a0
      UDItype pp_hl = (UDItype) mh * nl;
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
   1b074:	03073833          	mulhu	a6,a4,a6
    {
      USItype nl = a->fraction.ll;
      USItype nh = a->fraction.ll >> BITS_PER_SI;
      USItype ml = b->fraction.ll;
      USItype mh = b->fraction.ll >> BITS_PER_SI;
      UDItype pp_ll = (UDItype) ml * nl;
   1b078:	02a7b533          	mulhu	a0,a5,a0
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
      UDItype res2 = 0;
      UDItype res0 = 0;
      UDItype ps_hh__ = pp_hl + pp_lh;
      if (ps_hh__ < pp_hl)
   1b07c:	14566063          	bltu	a2,t0,1b1bc <__muldf3+0x1dc>
   1b080:	12c28c63          	beq	t0,a2,1b1b8 <__muldf3+0x1d8>
      USItype mh = b->fraction.ll >> BITS_PER_SI;
      UDItype pp_ll = (UDItype) ml * nl;
      UDItype pp_hl = (UDItype) mh * nl;
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
      UDItype res2 = 0;
   1b084:	00000793          	li	a5,0
   1b088:	00000713          	li	a4,0
      UDItype res0 = 0;
      UDItype ps_hh__ = pp_hl + pp_lh;
      if (ps_hh__ < pp_hl)
	res2 += (UDItype)1 << BITS_PER_SI;
      pp_hl = (UDItype)(USItype)ps_hh__ << BITS_PER_SI;
      res0 = pp_ll + pp_hl;
   1b08c:	00a306b3          	add	a3,t1,a0
      if (res0 < pp_ll)
   1b090:	00a6f463          	bleu	a0,a3,1b098 <__muldf3+0xb8>
	res2++;
   1b094:	00100793          	li	a5,1
      res2 += (ps_hh__ >> BITS_PER_SI) + pp_hh;
   1b098:	011608b3          	add	a7,a2,a7
   1b09c:	00c8b533          	sltu	a0,a7,a2
   1b0a0:	01050833          	add	a6,a0,a6
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1b0a4:	02012603          	lw	a2,32(sp)
   1b0a8:	03812503          	lw	a0,56(sp)
	res2 += (UDItype)1 << BITS_PER_SI;
      pp_hl = (UDItype)(USItype)ps_hh__ << BITS_PER_SI;
      res0 = pp_ll + pp_hl;
      if (res0 < pp_ll)
	res2++;
      res2 += (ps_hh__ >> BITS_PER_SI) + pp_hh;
   1b0ac:	00f887b3          	add	a5,a7,a5
   1b0b0:	0117b8b3          	sltu	a7,a5,a7
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1b0b4:	00a60533          	add	a0,a2,a0
	res2 += (UDItype)1 << BITS_PER_SI;
      pp_hl = (UDItype)(USItype)ps_hh__ << BITS_PER_SI;
      res0 = pp_ll + pp_hl;
      if (res0 < pp_ll)
	res2++;
      res2 += (ps_hh__ >> BITS_PER_SI) + pp_hh;
   1b0b8:	00e80633          	add	a2,a6,a4
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
   1b0bc:	01c12703          	lw	a4,28(sp)
   1b0c0:	03412803          	lw	a6,52(sp)
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1b0c4:	00450293          	addi	t0,a0,4 # 10000004 <_gp+0xffe0b34>
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
  while (high >= IMPLICIT_2)
   1b0c8:	200003b7          	lui	t2,0x20000
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
   1b0cc:	41070833          	sub	a6,a4,a6
   1b0d0:	01003833          	snez	a6,a6
	res2 += (UDItype)1 << BITS_PER_SI;
      pp_hl = (UDItype)(USItype)ps_hh__ << BITS_PER_SI;
      res0 = pp_ll + pp_hl;
      if (res0 < pp_ll)
	res2++;
      res2 += (ps_hh__ >> BITS_PER_SI) + pp_hh;
   1b0d4:	00c88733          	add	a4,a7,a2
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1b0d8:	04512823          	sw	t0,80(sp)
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
   1b0dc:	05012623          	sw	a6,76(sp)
   1b0e0:	00550613          	addi	a2,a0,5
    {
      tmp->normal_exp++;
      if (high & 1)
	{
	  low >>= 1;
	  low |= FRACHIGH;
   1b0e4:	80000eb7          	lui	t4,0x80000
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
  while (high >= IMPLICIT_2)
   1b0e8:	10776863          	bltu	a4,t2,1b1f8 <__muldf3+0x218>
    {
      tmp->normal_exp++;
      if (high & 1)
   1b0ec:	0017f813          	andi	a6,a5,1
	{
	  low >>= 1;
	  low |= FRACHIGH;
	}
      high >>= 1;
   1b0f0:	01f71513          	slli	a0,a4,0x1f
   1b0f4:	0017d793          	srli	a5,a5,0x1
   1b0f8:	00175713          	srli	a4,a4,0x1
  while (high >= IMPLICIT_2)
    {
      tmp->normal_exp++;
      if (high & 1)
	{
	  low >>= 1;
   1b0fc:	01f69313          	slli	t1,a3,0x1f
   1b100:	0015d293          	srli	t0,a1,0x1
   1b104:	0016d893          	srli	a7,a3,0x1
  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
  while (high >= IMPLICIT_2)
    {
      tmp->normal_exp++;
   1b108:	00060e13          	mv	t3,a2
      if (high & 1)
   1b10c:	00080663          	beqz	a6,1b118 <__muldf3+0x138>
	{
	  low >>= 1;
	  low |= FRACHIGH;
   1b110:	005365b3          	or	a1,t1,t0
   1b114:	01d8e6b3          	or	a3,a7,t4
	}
      high >>= 1;
   1b118:	00f567b3          	or	a5,a0,a5
   1b11c:	00160613          	addi	a2,a2,1 # 10000001 <_gp+0xffe0b31>
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
  while (high >= IMPLICIT_2)
   1b120:	fc7776e3          	bleu	t2,a4,1b0ec <__muldf3+0x10c>
   1b124:	05c12823          	sw	t3,80(sp)
      if (low & FRACHIGH)
	high |= 1;
      low <<= 1;
    }

  if ((high & GARDMASK) == GARDMSB)
   1b128:	0ff7f613          	andi	a2,a5,255
   1b12c:	08000513          	li	a0,128
   1b130:	08a60c63          	beq	a2,a0,1b1c8 <__muldf3+0x1e8>

	  /* Avoid further rounding in pack_d.  */
	  high &= ~(fractype) GARDMASK;
	}
    }
  tmp->fraction.ll = high;
   1b134:	04f12c23          	sw	a5,88(sp)
  tmp->class = CLASS_NUMBER;
   1b138:	00300793          	li	a5,3

	  /* Avoid further rounding in pack_d.  */
	  high &= ~(fractype) GARDMASK;
	}
    }
  tmp->fraction.ll = high;
   1b13c:	04e12e23          	sw	a4,92(sp)
  tmp->class = CLASS_NUMBER;
   1b140:	04f12423          	sw	a5,72(sp)
  return tmp;
   1b144:	04810513          	addi	a0,sp,72
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
   1b148:	a89ff0ef          	jal	1abd0 <__pack_d>
}
   1b14c:	06c12083          	lw	ra,108(sp)
   1b150:	07010113          	addi	sp,sp,112
   1b154:	00008067          	ret
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isinf (b))
    {
      if (iszero (a))
   1b158:	00200713          	li	a4,2
   1b15c:	08e78863          	beq	a5,a4,1b1ec <__muldf3+0x20c>
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isnan (b))
    {
      b->sign = a->sign != b->sign;
   1b160:	03412703          	lw	a4,52(sp)
   1b164:	01c12783          	lw	a5,28(sp)
      return b;
   1b168:	03010513          	addi	a0,sp,48
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isnan (b))
    {
      b->sign = a->sign != b->sign;
   1b16c:	40e787b3          	sub	a5,a5,a4
   1b170:	00f037b3          	snez	a5,a5
   1b174:	02f12a23          	sw	a5,52(sp)
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
   1b178:	a59ff0ef          	jal	1abd0 <__pack_d>
}
   1b17c:	06c12083          	lw	ra,108(sp)
   1b180:	07010113          	addi	sp,sp,112
   1b184:	00008067          	ret
      b->sign = a->sign != b->sign;
      return b;
    }
  if (isinf (a))
    {
      if (iszero (b))
   1b188:	00200793          	li	a5,2
   1b18c:	06f70063          	beq	a4,a5,1b1ec <__muldf3+0x20c>
  fractype low = 0;
  fractype high = 0;

  if (isnan (a))
    {
      a->sign = a->sign != b->sign;
   1b190:	03412703          	lw	a4,52(sp)
   1b194:	01c12783          	lw	a5,28(sp)
      return a;
   1b198:	01810513          	addi	a0,sp,24
  fractype low = 0;
  fractype high = 0;

  if (isnan (a))
    {
      a->sign = a->sign != b->sign;
   1b19c:	40e787b3          	sub	a5,a5,a4
   1b1a0:	00f037b3          	snez	a5,a5
   1b1a4:	00f12e23          	sw	a5,28(sp)
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
   1b1a8:	a29ff0ef          	jal	1abd0 <__pack_d>
}
   1b1ac:	06c12083          	lw	ra,108(sp)
   1b1b0:	07010113          	addi	sp,sp,112
   1b1b4:	00008067          	ret
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
      UDItype res2 = 0;
      UDItype res0 = 0;
      UDItype ps_hh__ = pp_hl + pp_lh;
      if (ps_hh__ < pp_hl)
   1b1b8:	ec7376e3          	bleu	t2,t1,1b084 <__muldf3+0xa4>
	res2 += (UDItype)1 << BITS_PER_SI;
   1b1bc:	00000793          	li	a5,0
   1b1c0:	00100713          	li	a4,1
   1b1c4:	ec9ff06f          	j	1b08c <__muldf3+0xac>
      low <<= 1;
    }

  if ((high & GARDMASK) == GARDMSB)
    {
      if (high & (1 << NGARDS))
   1b1c8:	1007f613          	andi	a2,a5,256
   1b1cc:	f60614e3          	bnez	a2,1b134 <__muldf3+0x154>
	     function, and rounding twice will lose precision and cause
	     the result to be too far off.  Example: 32-bit floats with
	     bit patterns 0xfff * 0x3f800400 ~= 0xfff (less than 0.5ulp
	     off), not 0x1000 (more than 0.5ulp off).  */
	}
      else if (low)
   1b1d0:	00d5e6b3          	or	a3,a1,a3
   1b1d4:	f60680e3          	beqz	a3,1b134 <__muldf3+0x154>
	{
	  /* We're a further than half way by a small amount corresponding
	     to the bits set in "low".  Knowing that, we round here and
	     not in pack_d, because there we don't have "low" available
	     anymore.  */
	  high += GARDROUND + 1;
   1b1d8:	00a786b3          	add	a3,a5,a0
   1b1dc:	00f6b7b3          	sltu	a5,a3,a5

	  /* Avoid further rounding in pack_d.  */
	  high &= ~(fractype) GARDMASK;
   1b1e0:	00e78733          	add	a4,a5,a4
   1b1e4:	f006f793          	andi	a5,a3,-256
   1b1e8:	f4dff06f          	j	1b134 <__muldf3+0x154>
      return b;
    }
  if (isinf (a))
    {
      if (iszero (b))
	return makenan ();
   1b1ec:	0001d537          	lui	a0,0x1d
   1b1f0:	bb850513          	addi	a0,a0,-1096 # 1cbb8 <__thenan_df>
   1b1f4:	f55ff06f          	j	1b148 <__muldf3+0x168>
	  low >>= 1;
	  low |= FRACHIGH;
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
   1b1f8:	10000337          	lui	t1,0x10000
   1b1fc:	00350513          	addi	a0,a0,3
   1b200:	f26774e3          	bleu	t1,a4,1b128 <__muldf3+0x148>
    {
      tmp->normal_exp--;

      high <<= 1;
   1b204:	01f7d813          	srli	a6,a5,0x1f
   1b208:	00171613          	slli	a2,a4,0x1
   1b20c:	00c86633          	or	a2,a6,a2
      if (low & FRACHIGH)
	high |= 1;
      low <<= 1;
   1b210:	01f5d893          	srli	a7,a1,0x1f
   1b214:	00169813          	slli	a6,a3,0x1
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
    {
      tmp->normal_exp--;
   1b218:	00050293          	mv	t0,a0

      high <<= 1;
   1b21c:	00179793          	slli	a5,a5,0x1
   1b220:	00060713          	mv	a4,a2
      if (low & FRACHIGH)
   1b224:	0006d463          	bgez	a3,1b22c <__muldf3+0x24c>
	high |= 1;
   1b228:	0017e793          	ori	a5,a5,1
      low <<= 1;
   1b22c:	00159593          	slli	a1,a1,0x1
   1b230:	0108e6b3          	or	a3,a7,a6
   1b234:	fff50513          	addi	a0,a0,-1
	  low >>= 1;
	  low |= FRACHIGH;
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
   1b238:	fc6666e3          	bltu	a2,t1,1b204 <__muldf3+0x224>
   1b23c:	04512823          	sw	t0,80(sp)
   1b240:	ee9ff06f          	j	1b128 <__muldf3+0x148>

0001b244 <__divdf3>:
  }
}

FLO_type
divide (FLO_type arg_a, FLO_type arg_b)
{
   1b244:	fb010113          	addi	sp,sp,-80
  fp_number_type a;
  fp_number_type b;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1b248:	00a12023          	sw	a0,0(sp)
   1b24c:	00b12223          	sw	a1,4(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1b250:	00010513          	mv	a0,sp
   1b254:	01010593          	addi	a1,sp,16
  fp_number_type b;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1b258:	00c12423          	sw	a2,8(sp)
  }
}

FLO_type
divide (FLO_type arg_a, FLO_type arg_b)
{
   1b25c:	04112623          	sw	ra,76(sp)
  fp_number_type b;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1b260:	00d12623          	sw	a3,12(sp)

  unpack_d (&au, &a);
   1b264:	bb1ff0ef          	jal	1ae14 <__unpack_d>
  unpack_d (&bu, &b);
   1b268:	02810593          	addi	a1,sp,40
   1b26c:	00810513          	addi	a0,sp,8
   1b270:	ba5ff0ef          	jal	1ae14 <__unpack_d>
   1b274:	01012603          	lw	a2,16(sp)
  fractype bit;
  fractype numerator;
  fractype denominator;
  fractype quotient;

  if (isnan (a))
   1b278:	00100793          	li	a5,1
   1b27c:	0ec7fa63          	bleu	a2,a5,1b370 <__divdf3+0x12c>
   1b280:	02812683          	lw	a3,40(sp)
    {
      return a;
    }
  if (isnan (b))
   1b284:	14d7fe63          	bleu	a3,a5,1b3e0 <__divdf3+0x19c>
    {
      return b;
    }

  a->sign = a->sign ^ b->sign;
   1b288:	01412583          	lw	a1,20(sp)
   1b28c:	02c12703          	lw	a4,44(sp)

  if (isinf (a) || iszero (a))
   1b290:	ffe60793          	addi	a5,a2,-2
   1b294:	ffd7f793          	andi	a5,a5,-3
  if (isnan (b))
    {
      return b;
    }

  a->sign = a->sign ^ b->sign;
   1b298:	00e5c733          	xor	a4,a1,a4
   1b29c:	00e12a23          	sw	a4,20(sp)

  if (isinf (a) || iszero (a))
   1b2a0:	0e078263          	beqz	a5,1b384 <__divdf3+0x140>
      if (a->class == b->class)
	return makenan ();
      return a;
    }

  if (isinf (b))
   1b2a4:	00400793          	li	a5,4
   1b2a8:	0ef68663          	beq	a3,a5,1b394 <__divdf3+0x150>
    {
      a->fraction.ll = 0;
      a->normal_exp = 0;
      return a;
    }
  if (iszero (b))
   1b2ac:	00200713          	li	a4,2
   1b2b0:	12e68263          	beq	a3,a4,1b3d4 <__divdf3+0x190>
  {
    /* quotient =
       ( numerator / denominator) * 2^(numerator exponent -  denominator exponent)
     */

    a->normal_exp = a->normal_exp - b->normal_exp;
   1b2b4:	01812703          	lw	a4,24(sp)
   1b2b8:	03012603          	lw	a2,48(sp)
    numerator = a->fraction.ll;
   1b2bc:	02412783          	lw	a5,36(sp)
    denominator = b->fraction.ll;
   1b2c0:	03c12883          	lw	a7,60(sp)
  {
    /* quotient =
       ( numerator / denominator) * 2^(numerator exponent -  denominator exponent)
     */

    a->normal_exp = a->normal_exp - b->normal_exp;
   1b2c4:	40c70633          	sub	a2,a4,a2
   1b2c8:	00c12c23          	sw	a2,24(sp)
    numerator = a->fraction.ll;
   1b2cc:	02012683          	lw	a3,32(sp)
    denominator = b->fraction.ll;
   1b2d0:	03812f03          	lw	t5,56(sp)

    if (numerator < denominator)
   1b2d4:	0117e663          	bltu	a5,a7,1b2e0 <__divdf3+0x9c>
   1b2d8:	02f89063          	bne	a7,a5,1b2f8 <__divdf3+0xb4>
   1b2dc:	01e6fe63          	bleu	t5,a3,1b2f8 <__divdf3+0xb4>
      {
	/* Fraction will be less than 1.0 */
	numerator *= 2;
   1b2e0:	01f6d593          	srli	a1,a3,0x1f
   1b2e4:	00179713          	slli	a4,a5,0x1
	a->normal_exp--;
   1b2e8:	fff60613          	addi	a2,a2,-1
    denominator = b->fraction.ll;

    if (numerator < denominator)
      {
	/* Fraction will be less than 1.0 */
	numerator *= 2;
   1b2ec:	00e5e7b3          	or	a5,a1,a4
   1b2f0:	00169693          	slli	a3,a3,0x1
	a->normal_exp--;
   1b2f4:	00c12c23          	sw	a2,24(sp)
  }
}

FLO_type
divide (FLO_type arg_a, FLO_type arg_b)
{
   1b2f8:	03d00513          	li	a0,61
	/* Fraction will be less than 1.0 */
	numerator *= 2;
	a->normal_exp--;
      }
    bit = IMPLICIT_1;
    quotient = 0;
   1b2fc:	00000393          	li	t2,0
   1b300:	00000e13          	li	t3,0
      {
	/* Fraction will be less than 1.0 */
	numerator *= 2;
	a->normal_exp--;
      }
    bit = IMPLICIT_1;
   1b304:	00000813          	li	a6,0
   1b308:	100005b7          	lui	a1,0x10000
	if (numerator >= denominator)
	  {
	    quotient |= bit;
	    numerator -= denominator;
	  }
	bit >>= 1;
   1b30c:	01f59313          	slli	t1,a1,0x1f
   1b310:	00185293          	srli	t0,a6,0x1
   1b314:	fff50513          	addi	a0,a0,-1
    bit = IMPLICIT_1;
    quotient = 0;
    /* ??? Does divide one bit at a time.  Optimize.  */
    while (bit)
      {
	if (numerator >= denominator)
   1b318:	0317e463          	bltu	a5,a7,1b340 <__divdf3+0xfc>
	  {
	    quotient |= bit;
	    numerator -= denominator;
   1b31c:	41e68733          	sub	a4,a3,t5
   1b320:	00e6b633          	sltu	a2,a3,a4
   1b324:	41178eb3          	sub	t4,a5,a7
    bit = IMPLICIT_1;
    quotient = 0;
    /* ??? Does divide one bit at a time.  Optimize.  */
    while (bit)
      {
	if (numerator >= denominator)
   1b328:	00f89463          	bne	a7,a5,1b330 <__divdf3+0xec>
   1b32c:	01e6ea63          	bltu	a3,t5,1b340 <__divdf3+0xfc>
	  {
	    quotient |= bit;
	    numerator -= denominator;
   1b330:	00070693          	mv	a3,a4
   1b334:	40ce87b3          	sub	a5,t4,a2
    /* ??? Does divide one bit at a time.  Optimize.  */
    while (bit)
      {
	if (numerator >= denominator)
	  {
	    quotient |= bit;
   1b338:	0103e3b3          	or	t2,t2,a6
   1b33c:	00be6e33          	or	t3,t3,a1
	    numerator -= denominator;
	  }
	bit >>= 1;
	numerator *= 2;
   1b340:	01f6d613          	srli	a2,a3,0x1f
   1b344:	00179713          	slli	a4,a5,0x1
	if (numerator >= denominator)
	  {
	    quotient |= bit;
	    numerator -= denominator;
	  }
	bit >>= 1;
   1b348:	00536833          	or	a6,t1,t0
   1b34c:	0015d593          	srli	a1,a1,0x1
	numerator *= 2;
   1b350:	00e667b3          	or	a5,a2,a4
   1b354:	00169693          	slli	a3,a3,0x1
	a->normal_exp--;
      }
    bit = IMPLICIT_1;
    quotient = 0;
    /* ??? Does divide one bit at a time.  Optimize.  */
    while (bit)
   1b358:	fa051ae3          	bnez	a0,1b30c <__divdf3+0xc8>
	  }
	bit >>= 1;
	numerator *= 2;
      }

    if ((quotient & GARDMASK) == GARDMSB)
   1b35c:	0ff3f713          	andi	a4,t2,255
   1b360:	08000613          	li	a2,128
   1b364:	04c70663          	beq	a4,a2,1b3b0 <__divdf3+0x16c>
	    /* Avoid further rounding in pack_d.  */
	    quotient &= ~(fractype) GARDMASK;
	  }
      }

    a->fraction.ll = quotient;
   1b368:	02712023          	sw	t2,32(sp)
   1b36c:	03c12223          	sw	t3,36(sp)
    return (a);
   1b370:	01010513          	addi	a0,sp,16
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpdiv_parts (&a, &b);

  return pack_d (res);
   1b374:	85dff0ef          	jal	1abd0 <__pack_d>
}
   1b378:	04c12083          	lw	ra,76(sp)
   1b37c:	05010113          	addi	sp,sp,80
   1b380:	00008067          	ret

  a->sign = a->sign ^ b->sign;

  if (isinf (a) || iszero (a))
    {
      if (a->class == b->class)
   1b384:	fed616e3          	bne	a2,a3,1b370 <__divdf3+0x12c>
	return makenan ();
   1b388:	0001d537          	lui	a0,0x1d
   1b38c:	bb850513          	addi	a0,a0,-1096 # 1cbb8 <__thenan_df>
   1b390:	fe5ff06f          	j	1b374 <__divdf3+0x130>
      return a;
    }

  if (isinf (b))
    {
      a->fraction.ll = 0;
   1b394:	00000713          	li	a4,0
   1b398:	00000793          	li	a5,0
   1b39c:	02e12023          	sw	a4,32(sp)
   1b3a0:	02f12223          	sw	a5,36(sp)
      a->normal_exp = 0;
   1b3a4:	00012c23          	sw	zero,24(sp)
      return a;
   1b3a8:	01010513          	addi	a0,sp,16
   1b3ac:	fc9ff06f          	j	1b374 <__divdf3+0x130>
	numerator *= 2;
      }

    if ((quotient & GARDMASK) == GARDMSB)
      {
	if (quotient & (1 << NGARDS))
   1b3b0:	1003f713          	andi	a4,t2,256
   1b3b4:	fa071ae3          	bnez	a4,1b368 <__divdf3+0x124>
	    /* Because we're half way, we would round to even by adding
	       GARDROUND + 1, except that's also done in the packing
	       function, and rounding twice will lose precision and cause
	       the result to be too far off.  */
	  }
	else if (numerator)
   1b3b8:	00f6e7b3          	or	a5,a3,a5
   1b3bc:	fa0786e3          	beqz	a5,1b368 <__divdf3+0x124>
	  {
	    /* We're a further than half way by the small amount
	       corresponding to the bits set in "numerator".  Knowing
	       that, we round here and not in pack_d, because there we
	       don't have "numerator" available anymore.  */
	    quotient += GARDROUND + 1;
   1b3c0:	00c387b3          	add	a5,t2,a2
   1b3c4:	0077b3b3          	sltu	t2,a5,t2

	    /* Avoid further rounding in pack_d.  */
	    quotient &= ~(fractype) GARDMASK;
   1b3c8:	01c38e33          	add	t3,t2,t3
   1b3cc:	f007f393          	andi	t2,a5,-256
   1b3d0:	f99ff06f          	j	1b368 <__divdf3+0x124>
      a->normal_exp = 0;
      return a;
    }
  if (iszero (b))
    {
      a->class = CLASS_INFINITY;
   1b3d4:	00f12823          	sw	a5,16(sp)
      return a;
   1b3d8:	01010513          	addi	a0,sp,16
   1b3dc:	f99ff06f          	j	1b374 <__divdf3+0x130>
    {
      return a;
    }
  if (isnan (b))
    {
      return b;
   1b3e0:	02810513          	addi	a0,sp,40
   1b3e4:	f91ff06f          	j	1b374 <__divdf3+0x130>

0001b3e8 <__fpcmp_parts_d>:
   a>b -> +1
 */

int
__fpcmp_parts (fp_number_type * a, fp_number_type * b)
{
   1b3e8:	00052703          	lw	a4,0(a0)
    {
      return 1;			/* still unordered! */
    }
#endif

  if (isnan (a) || isnan (b))
   1b3ec:	00100793          	li	a5,1
   a>b -> +1
 */

int
__fpcmp_parts (fp_number_type * a, fp_number_type * b)
{
   1b3f0:	00050613          	mv	a2,a0
    {
      return 1;			/* still unordered! */
    }
#endif

  if (isnan (a) || isnan (b))
   1b3f4:	08e7f263          	bleu	a4,a5,1b478 <__fpcmp_parts_d+0x90>
   1b3f8:	0005a683          	lw	a3,0(a1) # 10000000 <_gp+0xffe0b30>
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1b3fc:	00078513          	mv	a0,a5
    {
      return 1;			/* still unordered! */
    }
#endif

  if (isnan (a) || isnan (b))
   1b400:	04d7f263          	bleu	a3,a5,1b444 <__fpcmp_parts_d+0x5c>
    {
      return 1;			/* how to indicate unordered compare? */
    }
  if (isinf (a) && isinf (b))
   1b404:	00400793          	li	a5,4
   1b408:	04f70c63          	beq	a4,a5,1b460 <__fpcmp_parts_d+0x78>
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
    }
  if (isinf (b))
   1b40c:	04f68063          	beq	a3,a5,1b44c <__fpcmp_parts_d+0x64>
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (a) && iszero (b))
   1b410:	00200793          	li	a5,2
   1b414:	02f70a63          	beq	a4,a5,1b448 <__fpcmp_parts_d+0x60>
    }
  if (iszero (a))
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (b))
   1b418:	04f68663          	beq	a3,a5,1b464 <__fpcmp_parts_d+0x7c>
    {
      return a->sign ? -1 : 1;
    }
  /* now both are "normal".  */
  if (a->sign != b->sign)
   1b41c:	00462783          	lw	a5,4(a2)
   1b420:	0045a703          	lw	a4,4(a1)
   1b424:	04e78e63          	beq	a5,a4,1b480 <__fpcmp_parts_d+0x98>
    {
      return a->sign ? -1 : 1;
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
   1b428:	00f03533          	snez	a0,a5
   1b42c:	40a00533          	neg	a0,a0
   1b430:	00156513          	ori	a0,a0,1
   1b434:	00008067          	ret
  /* same exponents; check size.  */
  if (a->fraction.ll > b->fraction.ll)
    {
      return a->sign ? -1 : 1;
    }
  if (a->fraction.ll < b->fraction.ll)
   1b438:	00e69463          	bne	a3,a4,1b440 <__fpcmp_parts_d+0x58>
   1b43c:	06b66a63          	bltu	a2,a1,1b4b0 <__fpcmp_parts_d+0xc8>
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (a) && iszero (b))
    {
      return 0;
   1b440:	00000513          	li	a0,0
    {
      return a->sign ? 1 : -1;
    }
  /* after all that, they're equal.  */
  return 0;
}
   1b444:	00008067          	ret
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (a) && iszero (b))
   1b448:	fee68ce3          	beq	a3,a4,1b440 <__fpcmp_parts_d+0x58>
    {
      return a->sign ? -1 : 1;
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
   1b44c:	0045a503          	lw	a0,4(a1)
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1b450:	00153513          	seqz	a0,a0
   1b454:	40a00533          	neg	a0,a0
   1b458:	00156513          	ori	a0,a0,1
   1b45c:	00008067          	ret

  if (isnan (a) || isnan (b))
    {
      return 1;			/* how to indicate unordered compare? */
    }
  if (isinf (a) && isinf (b))
   1b460:	06e68063          	beq	a3,a4,1b4c0 <__fpcmp_parts_d+0xd8>
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1b464:	00462503          	lw	a0,4(a2)
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
   1b468:	00a03533          	snez	a0,a0
   1b46c:	40a00533          	neg	a0,a0
   1b470:	00156513          	ori	a0,a0,1
   1b474:	00008067          	ret
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1b478:	00078513          	mv	a0,a5
   1b47c:	00008067          	ret
    {
      /* opposite signs */
      return a->sign ? -1 : 1;
    }
  /* same sign; exponents? */
  if (a->normal_exp > b->normal_exp)
   1b480:	00862683          	lw	a3,8(a2)
   1b484:	0085a703          	lw	a4,8(a1)
   1b488:	fad740e3          	blt	a4,a3,1b428 <__fpcmp_parts_d+0x40>
    {
      return a->sign ? -1 : 1;
    }
  if (a->normal_exp < b->normal_exp)
   1b48c:	02e6c263          	blt	a3,a4,1b4b0 <__fpcmp_parts_d+0xc8>
    {
      return a->sign ? 1 : -1;
    }
  /* same exponents; check size.  */
  if (a->fraction.ll > b->fraction.ll)
   1b490:	01462703          	lw	a4,20(a2)
   1b494:	0145a683          	lw	a3,20(a1)
   1b498:	01062603          	lw	a2,16(a2)
   1b49c:	0105a583          	lw	a1,16(a1)
   1b4a0:	f8e6e4e3          	bltu	a3,a4,1b428 <__fpcmp_parts_d+0x40>
   1b4a4:	00d71463          	bne	a4,a3,1b4ac <__fpcmp_parts_d+0xc4>
   1b4a8:	f8c5e0e3          	bltu	a1,a2,1b428 <__fpcmp_parts_d+0x40>
    {
      return a->sign ? -1 : 1;
    }
  if (a->fraction.ll < b->fraction.ll)
   1b4ac:	f8d776e3          	bleu	a3,a4,1b438 <__fpcmp_parts_d+0x50>
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1b4b0:	0017b513          	seqz	a0,a5
   1b4b4:	40a00533          	neg	a0,a0
   1b4b8:	00156513          	ori	a0,a0,1
   1b4bc:	00008067          	ret
       -------+--------+--------
       -inf(1)| a>b(1) | a==b(0)
       -------+--------+--------
       So since unordered must be nonzero, just line up the columns...
       */
      return b->sign - a->sign;
   1b4c0:	0045a783          	lw	a5,4(a1)
   1b4c4:	00462503          	lw	a0,4(a2)
   1b4c8:	40a78533          	sub	a0,a5,a0
   1b4cc:	00008067          	ret

0001b4d0 <__cmpdf2>:
#endif

#if defined(L_compare_sf) || defined(L_compare_df) || defined(L_compoare_tf)
CMPtype
compare (FLO_type arg_a, FLO_type arg_b)
{
   1b4d0:	fb010113          	addi	sp,sp,-80
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1b4d4:	00a12023          	sw	a0,0(sp)
   1b4d8:	00b12223          	sw	a1,4(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1b4dc:	00010513          	mv	a0,sp
   1b4e0:	01010593          	addi	a1,sp,16
#endif

#if defined(L_compare_sf) || defined(L_compare_df) || defined(L_compoare_tf)
CMPtype
compare (FLO_type arg_a, FLO_type arg_b)
{
   1b4e4:	04112623          	sw	ra,76(sp)
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1b4e8:	00c12423          	sw	a2,8(sp)
   1b4ec:	00d12623          	sw	a3,12(sp)

  unpack_d (&au, &a);
   1b4f0:	925ff0ef          	jal	1ae14 <__unpack_d>
  unpack_d (&bu, &b);
   1b4f4:	02810593          	addi	a1,sp,40
   1b4f8:	00810513          	addi	a0,sp,8
   1b4fc:	919ff0ef          	jal	1ae14 <__unpack_d>

  return __fpcmp_parts (&a, &b);
   1b500:	02810593          	addi	a1,sp,40
   1b504:	01010513          	addi	a0,sp,16
   1b508:	ee1ff0ef          	jal	1b3e8 <__fpcmp_parts_d>
}
   1b50c:	04c12083          	lw	ra,76(sp)
   1b510:	05010113          	addi	sp,sp,80
   1b514:	00008067          	ret

0001b518 <__gedf2>:
#endif /* L_gt_sf || L_gt_df */

#if defined(L_ge_sf) || defined(L_ge_df) || defined(L_ge_tf)
CMPtype
_ge_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1b518:	fb010113          	addi	sp,sp,-80
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1b51c:	00a12023          	sw	a0,0(sp)
   1b520:	00b12223          	sw	a1,4(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1b524:	00010513          	mv	a0,sp
   1b528:	01010593          	addi	a1,sp,16
#endif /* L_gt_sf || L_gt_df */

#if defined(L_ge_sf) || defined(L_ge_df) || defined(L_ge_tf)
CMPtype
_ge_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1b52c:	04112623          	sw	ra,76(sp)
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1b530:	00c12423          	sw	a2,8(sp)
   1b534:	00d12623          	sw	a3,12(sp)

  unpack_d (&au, &a);
   1b538:	8ddff0ef          	jal	1ae14 <__unpack_d>
  unpack_d (&bu, &b);
   1b53c:	00810513          	addi	a0,sp,8
   1b540:	02810593          	addi	a1,sp,40
   1b544:	8d1ff0ef          	jal	1ae14 <__unpack_d>

  if (isnan (&a) || isnan (&b))
   1b548:	01012703          	lw	a4,16(sp)
   1b54c:	00100793          	li	a5,1
    return -1;			/* false, truth >= 0 */
   1b550:	fff00513          	li	a0,-1
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  if (isnan (&a) || isnan (&b))
   1b554:	00e7fc63          	bleu	a4,a5,1b56c <__gedf2+0x54>
   1b558:	02812703          	lw	a4,40(sp)
   1b55c:	00e7f863          	bleu	a4,a5,1b56c <__gedf2+0x54>
    return -1;			/* false, truth >= 0 */
  return __fpcmp_parts (&a, &b) ;
   1b560:	02810593          	addi	a1,sp,40
   1b564:	01010513          	addi	a0,sp,16
   1b568:	e81ff0ef          	jal	1b3e8 <__fpcmp_parts_d>
}
   1b56c:	04c12083          	lw	ra,76(sp)
   1b570:	05010113          	addi	sp,sp,80
   1b574:	00008067          	ret

0001b578 <__gtdf2>:
   1b578:	fa1ff06f          	j	1b518 <__gedf2>

0001b57c <__ledf2>:
#endif /* L_lt_sf || L_lt_df */

#if defined(L_le_sf) || defined(L_le_df) || defined(L_le_tf)
CMPtype
_le_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1b57c:	fb010113          	addi	sp,sp,-80
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1b580:	00a12023          	sw	a0,0(sp)
   1b584:	00b12223          	sw	a1,4(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1b588:	00010513          	mv	a0,sp
   1b58c:	01010593          	addi	a1,sp,16
#endif /* L_lt_sf || L_lt_df */

#if defined(L_le_sf) || defined(L_le_df) || defined(L_le_tf)
CMPtype
_le_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1b590:	04112623          	sw	ra,76(sp)
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1b594:	00c12423          	sw	a2,8(sp)
   1b598:	00d12623          	sw	a3,12(sp)

  unpack_d (&au, &a);
   1b59c:	879ff0ef          	jal	1ae14 <__unpack_d>
  unpack_d (&bu, &b);
   1b5a0:	00810513          	addi	a0,sp,8
   1b5a4:	02810593          	addi	a1,sp,40
   1b5a8:	86dff0ef          	jal	1ae14 <__unpack_d>

  if (isnan (&a) || isnan (&b))
   1b5ac:	01012783          	lw	a5,16(sp)
   1b5b0:	00100513          	li	a0,1
   1b5b4:	00f57c63          	bleu	a5,a0,1b5cc <__ledf2+0x50>
   1b5b8:	02812783          	lw	a5,40(sp)
   1b5bc:	00f57863          	bleu	a5,a0,1b5cc <__ledf2+0x50>
    return 1;			/* false, truth <= 0 */

  return __fpcmp_parts (&a, &b) ;
   1b5c0:	02810593          	addi	a1,sp,40
   1b5c4:	01010513          	addi	a0,sp,16
   1b5c8:	e21ff0ef          	jal	1b3e8 <__fpcmp_parts_d>
}
   1b5cc:	04c12083          	lw	ra,76(sp)
   1b5d0:	05010113          	addi	sp,sp,80
   1b5d4:	00008067          	ret

0001b5d8 <__ltdf2>:
   1b5d8:	fa5ff06f          	j	1b57c <__ledf2>

0001b5dc <__nedf2>:
   1b5dc:	fa1ff06f          	j	1b57c <__ledf2>

0001b5e0 <__eqdf2>:
   1b5e0:	f9dff06f          	j	1b57c <__ledf2>

0001b5e4 <__unorddf2>:
#endif /* L_le_sf || L_le_df */

#if defined(L_unord_sf) || defined(L_unord_df) || defined(L_unord_tf)
CMPtype
_unord_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1b5e4:	fb010113          	addi	sp,sp,-80
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1b5e8:	00a12023          	sw	a0,0(sp)
   1b5ec:	00b12223          	sw	a1,4(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1b5f0:	00010513          	mv	a0,sp
   1b5f4:	01010593          	addi	a1,sp,16
#endif /* L_le_sf || L_le_df */

#if defined(L_unord_sf) || defined(L_unord_df) || defined(L_unord_tf)
CMPtype
_unord_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1b5f8:	04112623          	sw	ra,76(sp)
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1b5fc:	00c12423          	sw	a2,8(sp)
   1b600:	00d12623          	sw	a3,12(sp)

  unpack_d (&au, &a);
   1b604:	811ff0ef          	jal	1ae14 <__unpack_d>
  unpack_d (&bu, &b);
   1b608:	00810513          	addi	a0,sp,8
   1b60c:	02810593          	addi	a1,sp,40
   1b610:	805ff0ef          	jal	1ae14 <__unpack_d>

  return (isnan (&a) || isnan (&b));
   1b614:	01012783          	lw	a5,16(sp)
   1b618:	00100513          	li	a0,1
   1b61c:	00f57663          	bleu	a5,a0,1b628 <__unorddf2+0x44>
   1b620:	02812503          	lw	a0,40(sp)
   1b624:	00253513          	sltiu	a0,a0,2
}
   1b628:	04c12083          	lw	ra,76(sp)
   1b62c:	05010113          	addi	sp,sp,80
   1b630:	00008067          	ret

0001b634 <__floatsidf>:
#endif /* L_unord_sf || L_unord_df */

#if defined(L_si_to_sf) || defined(L_si_to_df) || defined(L_si_to_tf)
FLO_type
si_to_float (SItype arg_a)
{
   1b634:	fd010113          	addi	sp,sp,-48
  fp_number_type in;

  in.class = CLASS_NUMBER;
  in.sign = arg_a < 0;
   1b638:	01f55793          	srli	a5,a0,0x1f
FLO_type
si_to_float (SItype arg_a)
{
  fp_number_type in;

  in.class = CLASS_NUMBER;
   1b63c:	00300713          	li	a4,3
#endif /* L_unord_sf || L_unord_df */

#if defined(L_si_to_sf) || defined(L_si_to_df) || defined(L_si_to_tf)
FLO_type
si_to_float (SItype arg_a)
{
   1b640:	02112623          	sw	ra,44(sp)
   1b644:	02812423          	sw	s0,40(sp)
  fp_number_type in;

  in.class = CLASS_NUMBER;
   1b648:	00e12423          	sw	a4,8(sp)
  in.sign = arg_a < 0;
   1b64c:	00f12623          	sw	a5,12(sp)
  if (!arg_a)
   1b650:	02051263          	bnez	a0,1b674 <__floatsidf+0x40>
    {
      in.class = CLASS_ZERO;
   1b654:	00200793          	li	a5,2
   1b658:	00f12423          	sw	a5,8(sp)
	{
	  in.fraction.ll <<= shift;
	  in.normal_exp -= shift;
	}
    }
  return pack_d (&in);
   1b65c:	00810513          	addi	a0,sp,8
   1b660:	d70ff0ef          	jal	1abd0 <__pack_d>
}
   1b664:	02c12083          	lw	ra,44(sp)
   1b668:	02812403          	lw	s0,40(sp)
   1b66c:	03010113          	addi	sp,sp,48
   1b670:	00008067          	ret
  else
    {
      USItype uarg;
      int shift;
      in.normal_exp = FRACBITS + NGARDS;
      if (in.sign) 
   1b674:	02054c63          	bltz	a0,1b6ac <__floatsidf+0x78>
	      return (FLO_type)(- MAX_SI_INT - 1);
	    }
	  uarg = (-arg_a);
	}
      else
	uarg = arg_a;
   1b678:	00050413          	mv	s0,a0
static int
clzusi (USItype n)
{
  extern int __clzsi2 (USItype);
  if (sizeof (USItype) == sizeof (unsigned int))
    return __builtin_clz (n);
   1b67c:	00040513          	mv	a0,s0
   1b680:	27c000ef          	jal	1b8fc <__clzsi2>
	}
      else
	uarg = arg_a;

      in.fraction.ll = uarg;
      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
   1b684:	01d50513          	addi	a0,a0,29
      if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1b688:	02057793          	andi	a5,a0,32
   1b68c:	04078063          	beqz	a5,1b6cc <__floatsidf+0x98>
   1b690:	00a41433          	sll	s0,s0,a0
   1b694:	00812e23          	sw	s0,28(sp)
   1b698:	00012c23          	sw	zero,24(sp)
	  in.normal_exp -= shift;
   1b69c:	03c00793          	li	a5,60
   1b6a0:	40a78533          	sub	a0,a5,a0
   1b6a4:	00a12823          	sw	a0,16(sp)
   1b6a8:	fb5ff06f          	j	1b65c <__floatsidf+0x28>
      in.normal_exp = FRACBITS + NGARDS;
      if (in.sign) 
	{
	  /* Special case for minint, since there is no +ve integer
	     representation for it */
	  if (arg_a == (- MAX_SI_INT - 1))
   1b6ac:	800007b7          	lui	a5,0x80000
   1b6b0:	02f50c63          	beq	a0,a5,1b6e8 <__floatsidf+0xb4>
	    {
	      return (FLO_type)(- MAX_SI_INT - 1);
	    }
	  uarg = (-arg_a);
   1b6b4:	40a00433          	neg	s0,a0
static int
clzusi (USItype n)
{
  extern int __clzsi2 (USItype);
  if (sizeof (USItype) == sizeof (unsigned int))
    return __builtin_clz (n);
   1b6b8:	00040513          	mv	a0,s0
   1b6bc:	240000ef          	jal	1b8fc <__clzsi2>
	}
      else
	uarg = arg_a;

      in.fraction.ll = uarg;
      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
   1b6c0:	01d50513          	addi	a0,a0,29
      if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1b6c4:	02057793          	andi	a5,a0,32
   1b6c8:	fc0794e3          	bnez	a5,1b690 <__floatsidf+0x5c>
   1b6cc:	00145793          	srli	a5,s0,0x1
   1b6d0:	fff54713          	not	a4,a0
   1b6d4:	00e7d7b3          	srl	a5,a5,a4
   1b6d8:	00a41433          	sll	s0,s0,a0
   1b6dc:	00f12e23          	sw	a5,28(sp)
   1b6e0:	00812c23          	sw	s0,24(sp)
   1b6e4:	fb9ff06f          	j	1b69c <__floatsidf+0x68>
	{
	  /* Special case for minint, since there is no +ve integer
	     representation for it */
	  if (arg_a == (- MAX_SI_INT - 1))
	    {
	      return (FLO_type)(- MAX_SI_INT - 1);
   1b6e8:	8701a503          	lw	a0,-1936(gp) # 1ed40 <__wctomb+0x50>
   1b6ec:	8741a583          	lw	a1,-1932(gp) # 1ed44 <__wctomb+0x54>
   1b6f0:	f75ff06f          	j	1b664 <__floatsidf+0x30>

0001b6f4 <__floatunsidf>:
#endif /* L_si_to_sf || L_si_to_df */

#if defined(L_usi_to_sf) || defined(L_usi_to_df) || defined(L_usi_to_tf)
FLO_type
usi_to_float (USItype arg_a)
{
   1b6f4:	fd010113          	addi	sp,sp,-48
   1b6f8:	02112623          	sw	ra,44(sp)
   1b6fc:	02812423          	sw	s0,40(sp)
  fp_number_type in;

  in.sign = 0;
   1b700:	00012623          	sw	zero,12(sp)
  if (!arg_a)
   1b704:	06050663          	beqz	a0,1b770 <__floatunsidf+0x7c>
      in.class = CLASS_ZERO;
    }
  else
    {
      int shift;
      in.class = CLASS_NUMBER;
   1b708:	00300793          	li	a5,3
   1b70c:	00f12423          	sw	a5,8(sp)
   1b710:	00050413          	mv	s0,a0
static int
clzusi (USItype n)
{
  extern int __clzsi2 (USItype);
  if (sizeof (USItype) == sizeof (unsigned int))
    return __builtin_clz (n);
   1b714:	1e8000ef          	jal	1b8fc <__clzsi2>
      int shift;
      in.class = CLASS_NUMBER;
      in.normal_exp = FRACBITS + NGARDS;
      in.fraction.ll = arg_a;

      shift = clzusi (arg_a) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
   1b718:	01d50513          	addi	a0,a0,29
	  in.fraction.ll |= (guard != 0);
	  in.normal_exp -= shift;
	}
      else if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1b71c:	02057793          	andi	a5,a0,32
   1b720:	02078a63          	beqz	a5,1b754 <__floatunsidf+0x60>
   1b724:	00a41433          	sll	s0,s0,a0
   1b728:	00812e23          	sw	s0,28(sp)
   1b72c:	00012c23          	sw	zero,24(sp)
	  in.normal_exp -= shift;
   1b730:	03c00793          	li	a5,60
   1b734:	40a78533          	sub	a0,a5,a0
   1b738:	00a12823          	sw	a0,16(sp)
	}
    }
  return pack_d (&in);
   1b73c:	00810513          	addi	a0,sp,8
   1b740:	c90ff0ef          	jal	1abd0 <__pack_d>
}
   1b744:	02c12083          	lw	ra,44(sp)
   1b748:	02812403          	lw	s0,40(sp)
   1b74c:	03010113          	addi	sp,sp,48
   1b750:	00008067          	ret
	  in.fraction.ll |= (guard != 0);
	  in.normal_exp -= shift;
	}
      else if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1b754:	00145793          	srli	a5,s0,0x1
   1b758:	fff54713          	not	a4,a0
   1b75c:	00e7d7b3          	srl	a5,a5,a4
   1b760:	00a41433          	sll	s0,s0,a0
   1b764:	00f12e23          	sw	a5,28(sp)
   1b768:	00812c23          	sw	s0,24(sp)
   1b76c:	fc5ff06f          	j	1b730 <__floatunsidf+0x3c>
  fp_number_type in;

  in.sign = 0;
  if (!arg_a)
    {
      in.class = CLASS_ZERO;
   1b770:	00200793          	li	a5,2
   1b774:	00f12423          	sw	a5,8(sp)
   1b778:	fc5ff06f          	j	1b73c <__floatunsidf+0x48>

0001b77c <__fixdfsi>:
#endif

#if defined(L_sf_to_si) || defined(L_df_to_si) || defined(L_tf_to_si)
SItype
float_to_si (FLO_type arg_a)
{
   1b77c:	fd010113          	addi	sp,sp,-48
  fp_number_type a;
  SItype tmp;
  FLO_union_type au;

  au.value = arg_a;
   1b780:	00a12023          	sw	a0,0(sp)
   1b784:	00b12223          	sw	a1,4(sp)
  unpack_d (&au, &a);
   1b788:	00010513          	mv	a0,sp
   1b78c:	00810593          	addi	a1,sp,8
#endif

#if defined(L_sf_to_si) || defined(L_df_to_si) || defined(L_tf_to_si)
SItype
float_to_si (FLO_type arg_a)
{
   1b790:	02112623          	sw	ra,44(sp)
  fp_number_type a;
  SItype tmp;
  FLO_union_type au;

  au.value = arg_a;
  unpack_d (&au, &a);
   1b794:	e80ff0ef          	jal	1ae14 <__unpack_d>
   1b798:	00812783          	lw	a5,8(sp)

  if (iszero (&a))
    return 0;
  if (isnan (&a))
   1b79c:	00200713          	li	a4,2
   1b7a0:	06f77463          	bleu	a5,a4,1b808 <__fixdfsi+0x8c>
    return 0;
  /* get reasonable MAX_SI_INT...  */
  if (isinf (&a))
   1b7a4:	00400713          	li	a4,4
   1b7a8:	00e78a63          	beq	a5,a4,1b7bc <__fixdfsi+0x40>
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  /* it is a number, but a small one */
  if (a.normal_exp < 0)
   1b7ac:	01012503          	lw	a0,16(sp)
   1b7b0:	04054c63          	bltz	a0,1b808 <__fixdfsi+0x8c>
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
   1b7b4:	01e00793          	li	a5,30
   1b7b8:	02a7d063          	ble	a0,a5,1b7d8 <__fixdfsi+0x5c>
    return 0;
  if (isnan (&a))
    return 0;
  /* get reasonable MAX_SI_INT...  */
  if (isinf (&a))
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
   1b7bc:	00c12783          	lw	a5,12(sp)
   1b7c0:	80000537          	lui	a0,0x80000
   1b7c4:	00079463          	bnez	a5,1b7cc <__fixdfsi+0x50>
   1b7c8:	fff54513          	not	a0,a0
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
  return a.sign ? (-tmp) : (tmp);
}
   1b7cc:	02c12083          	lw	ra,44(sp)
   1b7d0:	03010113          	addi	sp,sp,48
   1b7d4:	00008067          	ret
  /* it is a number, but a small one */
  if (a.normal_exp < 0)
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
   1b7d8:	03c00793          	li	a5,60
   1b7dc:	40a78533          	sub	a0,a5,a0
   1b7e0:	02057793          	andi	a5,a0,32
   1b7e4:	02078a63          	beqz	a5,1b818 <__fixdfsi+0x9c>
   1b7e8:	01c12783          	lw	a5,28(sp)
   1b7ec:	00a7d533          	srl	a0,a5,a0
  return a.sign ? (-tmp) : (tmp);
   1b7f0:	00c12783          	lw	a5,12(sp)
   1b7f4:	fc078ce3          	beqz	a5,1b7cc <__fixdfsi+0x50>
}
   1b7f8:	02c12083          	lw	ra,44(sp)
  if (a.normal_exp < 0)
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
  return a.sign ? (-tmp) : (tmp);
   1b7fc:	40a00533          	neg	a0,a0
}
   1b800:	03010113          	addi	sp,sp,48
   1b804:	00008067          	ret
   1b808:	02c12083          	lw	ra,44(sp)
  unpack_d (&au, &a);

  if (iszero (&a))
    return 0;
  if (isnan (&a))
    return 0;
   1b80c:	00000513          	li	a0,0
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
  return a.sign ? (-tmp) : (tmp);
}
   1b810:	03010113          	addi	sp,sp,48
   1b814:	00008067          	ret
  /* it is a number, but a small one */
  if (a.normal_exp < 0)
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
   1b818:	01c12783          	lw	a5,28(sp)
   1b81c:	fff54713          	not	a4,a0
   1b820:	00179793          	slli	a5,a5,0x1
   1b824:	00e797b3          	sll	a5,a5,a4
   1b828:	01812703          	lw	a4,24(sp)
   1b82c:	00a75533          	srl	a0,a4,a0
   1b830:	00a7e533          	or	a0,a5,a0
   1b834:	fbdff06f          	j	1b7f0 <__fixdfsi+0x74>

0001b838 <__negdf2>:
#endif /* L_tf_to_usi */

#if defined(L_negate_sf) || defined(L_negate_df) || defined(L_negate_tf)
FLO_type
negate (FLO_type arg_a)
{
   1b838:	fd010113          	addi	sp,sp,-48
  fp_number_type a;
  FLO_union_type au;

  au.value = arg_a;
   1b83c:	00a12023          	sw	a0,0(sp)
   1b840:	00b12223          	sw	a1,4(sp)
  unpack_d (&au, &a);
   1b844:	00010513          	mv	a0,sp
   1b848:	00810593          	addi	a1,sp,8
#endif /* L_tf_to_usi */

#if defined(L_negate_sf) || defined(L_negate_df) || defined(L_negate_tf)
FLO_type
negate (FLO_type arg_a)
{
   1b84c:	02112623          	sw	ra,44(sp)
  fp_number_type a;
  FLO_union_type au;

  au.value = arg_a;
  unpack_d (&au, &a);
   1b850:	dc4ff0ef          	jal	1ae14 <__unpack_d>

INLINE 
static void
flip_sign ( fp_number_type *  x)
{
  x->sign = !x->sign;
   1b854:	00c12783          	lw	a5,12(sp)

  au.value = arg_a;
  unpack_d (&au, &a);

  flip_sign (&a);
  return pack_d (&a);
   1b858:	00810513          	addi	a0,sp,8

INLINE 
static void
flip_sign ( fp_number_type *  x)
{
  x->sign = !x->sign;
   1b85c:	0017b793          	seqz	a5,a5
   1b860:	00f12623          	sw	a5,12(sp)

  au.value = arg_a;
  unpack_d (&au, &a);

  flip_sign (&a);
  return pack_d (&a);
   1b864:	b6cff0ef          	jal	1abd0 <__pack_d>
}
   1b868:	02c12083          	lw	ra,44(sp)
   1b86c:	03010113          	addi	sp,sp,48
   1b870:	00008067          	ret

0001b874 <__make_dp>:
extern SFtype __make_fp (fp_class_type, unsigned int, int, USItype);

#if defined(L_make_df)
DFtype
__make_dp (fp_class_type class, unsigned int sign, int exp, UDItype frac)
{
   1b874:	fd010113          	addi	sp,sp,-48
  fp_number_type in;

  in.class = class;
   1b878:	00a12423          	sw	a0,8(sp)
  in.sign = sign;
  in.normal_exp = exp;
  in.fraction.ll = frac;
  return pack_d (&in);
   1b87c:	00810513          	addi	a0,sp,8
extern SFtype __make_fp (fp_class_type, unsigned int, int, USItype);

#if defined(L_make_df)
DFtype
__make_dp (fp_class_type class, unsigned int sign, int exp, UDItype frac)
{
   1b880:	02112623          	sw	ra,44(sp)
  fp_number_type in;

  in.class = class;
  in.sign = sign;
   1b884:	00b12623          	sw	a1,12(sp)
  in.normal_exp = exp;
   1b888:	00c12823          	sw	a2,16(sp)
  in.fraction.ll = frac;
   1b88c:	00e12c23          	sw	a4,24(sp)
   1b890:	00f12e23          	sw	a5,28(sp)
  return pack_d (&in);
   1b894:	b3cff0ef          	jal	1abd0 <__pack_d>
}
   1b898:	02c12083          	lw	ra,44(sp)
   1b89c:	03010113          	addi	sp,sp,48
   1b8a0:	00008067          	ret

0001b8a4 <__truncdfsf2>:
#endif /* L_make_df */

#if defined(L_df_to_sf)
SFtype
df_to_sf (DFtype arg_a)
{
   1b8a4:	fd010113          	addi	sp,sp,-48
  fp_number_type in;
  USItype sffrac;
  FLO_union_type au;

  au.value = arg_a;
   1b8a8:	00a12023          	sw	a0,0(sp)
   1b8ac:	00b12223          	sw	a1,4(sp)
  unpack_d (&au, &in);
   1b8b0:	00010513          	mv	a0,sp
   1b8b4:	00810593          	addi	a1,sp,8
#endif /* L_make_df */

#if defined(L_df_to_sf)
SFtype
df_to_sf (DFtype arg_a)
{
   1b8b8:	02112623          	sw	ra,44(sp)
  fp_number_type in;
  USItype sffrac;
  FLO_union_type au;

  au.value = arg_a;
  unpack_d (&au, &in);
   1b8bc:	d58ff0ef          	jal	1ae14 <__unpack_d>

  sffrac = in.fraction.ll >> F_D_BITOFF;
   1b8c0:	01812703          	lw	a4,24(sp)
   1b8c4:	01c12683          	lw	a3,28(sp)
   1b8c8:	01e75793          	srli	a5,a4,0x1e
   1b8cc:	00269693          	slli	a3,a3,0x2
   1b8d0:	00f6e6b3          	or	a3,a3,a5

  /* We set the lowest guard bit in SFFRAC if we discarded any non
     zero bits.  */
  if ((in.fraction.ll & (((USItype) 1 << F_D_BITOFF) - 1)) != 0)
   1b8d4:	00271793          	slli	a5,a4,0x2
   1b8d8:	00078463          	beqz	a5,1b8e0 <__truncdfsf2+0x3c>
    sffrac |= 1;
   1b8dc:	0016e693          	ori	a3,a3,1

  return __make_fp (in.class, in.sign, in.normal_exp, sffrac);
   1b8e0:	01012603          	lw	a2,16(sp)
   1b8e4:	00c12583          	lw	a1,12(sp)
   1b8e8:	00812503          	lw	a0,8(sp)
   1b8ec:	401000ef          	jal	1c4ec <__make_fp>
}
   1b8f0:	02c12083          	lw	ra,44(sp)
   1b8f4:	03010113          	addi	sp,sp,48
   1b8f8:	00008067          	ret

0001b8fc <__clzsi2>:
int
__clzSI2 (UWtype x)
{
  Wtype ret;

  count_leading_zeros (ret, x);
   1b8fc:	000107b7          	lui	a5,0x10
   1b900:	02f57c63          	bleu	a5,a0,1b938 <__clzsi2+0x3c>
   1b904:	0ff00693          	li	a3,255
   1b908:	01800713          	li	a4,24
   1b90c:	00800793          	li	a5,8
   1b910:	00a6e663          	bltu	a3,a0,1b91c <__clzsi2+0x20>
   1b914:	02000713          	li	a4,32
   1b918:	00000793          	li	a5,0
   1b91c:	00f55533          	srl	a0,a0,a5
   1b920:	0001c7b7          	lui	a5,0x1c
   1b924:	68078793          	addi	a5,a5,1664 # 1c680 <__clz_tab>
   1b928:	00f507b3          	add	a5,a0,a5

  return ret;
   1b92c:	0007c503          	lbu	a0,0(a5)
}
   1b930:	40a70533          	sub	a0,a4,a0
   1b934:	00008067          	ret
int
__clzSI2 (UWtype x)
{
  Wtype ret;

  count_leading_zeros (ret, x);
   1b938:	010006b7          	lui	a3,0x1000
   1b93c:	00800713          	li	a4,8
   1b940:	01800793          	li	a5,24
   1b944:	fcd57ce3          	bleu	a3,a0,1b91c <__clzsi2+0x20>
   1b948:	01000713          	li	a4,16
   1b94c:	00070793          	mv	a5,a4
   1b950:	00f55533          	srl	a0,a0,a5
   1b954:	0001c7b7          	lui	a5,0x1c
   1b958:	68078793          	addi	a5,a5,1664 # 1c680 <__clz_tab>
   1b95c:	00f507b3          	add	a5,a0,a5

  return ret;
   1b960:	0007c503          	lbu	a0,0(a5)
}
   1b964:	40a70533          	sub	a0,a4,a0
   1b968:	00008067          	ret

0001b96c <_fpadd_parts>:
#if defined(L_addsub_sf) || defined(L_addsub_df) || defined(L_addsub_tf)
static const fp_number_type *
_fpadd_parts (fp_number_type * a,
	      fp_number_type * b,
	      fp_number_type * tmp)
{
   1b96c:	00052783          	lw	a5,0(a0) # 80000000 <_gp+0x7ffe0b30>
  int a_normal_exp;
  int b_normal_exp;
  fractype a_fraction;
  fractype b_fraction;

  if (isnan (a))
   1b970:	00100713          	li	a4,1
   1b974:	0ef77463          	bleu	a5,a4,1ba5c <_fpadd_parts+0xf0>
   1b978:	0005a683          	lw	a3,0(a1)
    {
      return a;
    }
  if (isnan (b))
   1b97c:	0cd77e63          	bleu	a3,a4,1ba58 <_fpadd_parts+0xec>
    {
      return b;
    }
  if (isinf (a))
   1b980:	00400813          	li	a6,4
   1b984:	15078c63          	beq	a5,a6,1badc <_fpadd_parts+0x170>
      /* Adding infinities with opposite signs yields a NaN.  */
      if (isinf (b) && a->sign != b->sign)
	return makenan ();
      return a;
    }
  if (isinf (b))
   1b988:	0d068863          	beq	a3,a6,1ba58 <_fpadd_parts+0xec>
    {
      return b;
    }
  if (iszero (b))
   1b98c:	00200813          	li	a6,2
   1b990:	11068663          	beq	a3,a6,1ba9c <_fpadd_parts+0x130>
	  tmp->sign = a->sign & b->sign;
	  return tmp;
	}
      return a;
    }
  if (iszero (a))
   1b994:	0d078263          	beq	a5,a6,1ba58 <_fpadd_parts+0xec>
     they're the same */
  {
    int diff;
    int sdiff;

    a_normal_exp = a->normal_exp;
   1b998:	00852303          	lw	t1,8(a0)
    b_normal_exp = b->normal_exp;
   1b99c:	0085a783          	lw	a5,8(a1)
    diff = a_normal_exp - b_normal_exp;
    sdiff = diff;

    if (diff < 0)
      diff = -diff;
    if (diff < FRAC_NBITS)
   1b9a0:	01f00693          	li	a3,31
    int diff;
    int sdiff;

    a_normal_exp = a->normal_exp;
    b_normal_exp = b->normal_exp;
    a_fraction = a->fraction.ll;
   1b9a4:	00c52383          	lw	t2,12(a0)
    b_fraction = b->fraction.ll;

    diff = a_normal_exp - b_normal_exp;
   1b9a8:	40f30833          	sub	a6,t1,a5
   1b9ac:	41f85293          	srai	t0,a6,0x1f
   1b9b0:	0102c8b3          	xor	a7,t0,a6
   1b9b4:	405888b3          	sub	a7,a7,t0
    int sdiff;

    a_normal_exp = a->normal_exp;
    b_normal_exp = b->normal_exp;
    a_fraction = a->fraction.ll;
    b_fraction = b->fraction.ll;
   1b9b8:	00c5a283          	lw	t0,12(a1)
    diff = a_normal_exp - b_normal_exp;
    sdiff = diff;

    if (diff < 0)
      diff = -diff;
    if (diff < FRAC_NBITS)
   1b9bc:	0b16d263          	ble	a7,a3,1ba60 <_fpadd_parts+0xf4>
	  }
      }
    else
      {
	/* Somethings's up.. choose the biggest */
	if (a_normal_exp > b_normal_exp)
   1b9c0:	1067ca63          	blt	a5,t1,1bad4 <_fpadd_parts+0x168>
   1b9c4:	00078313          	mv	t1,a5
	    b_fraction = 0;
	  }
	else
	  {
	    a_normal_exp = b_normal_exp;
	    a_fraction = 0;
   1b9c8:	00000393          	li	t2,0
	  }
      }
  }

  if (a->sign != b->sign)
   1b9cc:	00452703          	lw	a4,4(a0)
   1b9d0:	0045a783          	lw	a5,4(a1)
   1b9d4:	0af70a63          	beq	a4,a5,1ba88 <_fpadd_parts+0x11c>
	{
	  tfraction = -a_fraction + b_fraction;
	}
      else
	{
	  tfraction = a_fraction - b_fraction;
   1b9d8:	405387b3          	sub	a5,t2,t0
      }
  }

  if (a->sign != b->sign)
    {
      if (a->sign)
   1b9dc:	00070463          	beqz	a4,1b9e4 <_fpadd_parts+0x78>
	{
	  tfraction = -a_fraction + b_fraction;
   1b9e0:	407287b3          	sub	a5,t0,t2
	}
      else
	{
	  tfraction = a_fraction - b_fraction;
	}
      if (tfraction >= 0)
   1b9e4:	1007ca63          	bltz	a5,1baf8 <_fpadd_parts+0x18c>
	{
	  tmp->sign = 0;
   1b9e8:	00062223          	sw	zero,4(a2)
	  tmp->normal_exp = a_normal_exp;
   1b9ec:	00662423          	sw	t1,8(a2)
	  tmp->fraction.ll = tfraction;
   1b9f0:	00f62623          	sw	a5,12(a2)
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1b9f4:	400005b7          	lui	a1,0x40000
   1b9f8:	fff78713          	addi	a4,a5,-1
   1b9fc:	ffe58593          	addi	a1,a1,-2 # 3ffffffe <_gp+0x3ffe0b2e>
   1ba00:	02e5e463          	bltu	a1,a4,1ba28 <_fpadd_parts+0xbc>
   1ba04:	00862703          	lw	a4,8(a2)
   1ba08:	fff70713          	addi	a4,a4,-1
	{
	  tmp->fraction.ll <<= 1;
   1ba0c:	00179793          	slli	a5,a5,0x1
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1ba10:	fff78693          	addi	a3,a5,-1
	{
	  tmp->fraction.ll <<= 1;
	  tmp->normal_exp--;
   1ba14:	00070513          	mv	a0,a4
   1ba18:	fff70713          	addi	a4,a4,-1
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1ba1c:	fed5f8e3          	bleu	a3,a1,1ba0c <_fpadd_parts+0xa0>
   1ba20:	00f62623          	sw	a5,12(a2)
   1ba24:	00a62423          	sw	a0,8(a2)
    {
      tmp->sign = a->sign;
      tmp->normal_exp = a_normal_exp;
      tmp->fraction.ll = a_fraction + b_fraction;
    }
  tmp->class = CLASS_NUMBER;
   1ba28:	00300713          	li	a4,3
   1ba2c:	00e62023          	sw	a4,0(a2)
   1ba30:	00060513          	mv	a0,a2
  /* Now the fraction is added, we have to shift down to renormalize the
     number */

  if (tmp->fraction.ll >= IMPLICIT_2)
   1ba34:	0207d463          	bgez	a5,1ba5c <_fpadd_parts+0xf0>
    {
      LSHIFT (tmp->fraction.ll, 1);
      tmp->normal_exp++;
   1ba38:	00862703          	lw	a4,8(a2)
  /* Now the fraction is added, we have to shift down to renormalize the
     number */

  if (tmp->fraction.ll >= IMPLICIT_2)
    {
      LSHIFT (tmp->fraction.ll, 1);
   1ba3c:	0017d693          	srli	a3,a5,0x1
   1ba40:	0017f793          	andi	a5,a5,1
   1ba44:	00f6e7b3          	or	a5,a3,a5
      tmp->normal_exp++;
   1ba48:	00170713          	addi	a4,a4,1
  /* Now the fraction is added, we have to shift down to renormalize the
     number */

  if (tmp->fraction.ll >= IMPLICIT_2)
    {
      LSHIFT (tmp->fraction.ll, 1);
   1ba4c:	00f62623          	sw	a5,12(a2)
      tmp->normal_exp++;
   1ba50:	00e62423          	sw	a4,8(a2)
   1ba54:	00008067          	ret
   1ba58:	00058513          	mv	a0,a1
    }
  return tmp;
}
   1ba5c:	00008067          	ret

    if (diff < 0)
      diff = -diff;
    if (diff < FRAC_NBITS)
      {
	if (sdiff > 0)
   1ba60:	0b005863          	blez	a6,1bb10 <_fpadd_parts+0x1a4>
	  {
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
   1ba64:	011716b3          	sll	a3,a4,a7
   1ba68:	fff68693          	addi	a3,a3,-1 # ffffff <_gp+0xfe0b2f>
   1ba6c:	0056f6b3          	and	a3,a3,t0
   1ba70:	00d03733          	snez	a4,a3
   1ba74:	0112d2b3          	srl	t0,t0,a7
   1ba78:	00e2e2b3          	or	t0,t0,a4
	    a_fraction = 0;
	  }
      }
  }

  if (a->sign != b->sign)
   1ba7c:	0045a783          	lw	a5,4(a1)
   1ba80:	00452703          	lw	a4,4(a0)
   1ba84:	f4f71ae3          	bne	a4,a5,1b9d8 <_fpadd_parts+0x6c>
    }
  else
    {
      tmp->sign = a->sign;
      tmp->normal_exp = a_normal_exp;
      tmp->fraction.ll = a_fraction + b_fraction;
   1ba88:	005387b3          	add	a5,t2,t0
	  tmp->normal_exp--;
	}
    }
  else
    {
      tmp->sign = a->sign;
   1ba8c:	00e62223          	sw	a4,4(a2)
      tmp->normal_exp = a_normal_exp;
   1ba90:	00662423          	sw	t1,8(a2)
      tmp->fraction.ll = a_fraction + b_fraction;
   1ba94:	00f62623          	sw	a5,12(a2)
   1ba98:	f91ff06f          	j	1ba28 <_fpadd_parts+0xbc>
    {
      return b;
    }
  if (iszero (b))
    {
      if (iszero (a))
   1ba9c:	fcd790e3          	bne	a5,a3,1ba5c <_fpadd_parts+0xf0>
	{
	  *tmp = *a;
   1baa0:	00f62023          	sw	a5,0(a2)
   1baa4:	00452783          	lw	a5,4(a0)
   1baa8:	00f62223          	sw	a5,4(a2)
   1baac:	00852703          	lw	a4,8(a0)
	  tmp->sign = a->sign & b->sign;
   1bab0:	00452683          	lw	a3,4(a0)
   1bab4:	0045a783          	lw	a5,4(a1)
    }
  if (iszero (b))
    {
      if (iszero (a))
	{
	  *tmp = *a;
   1bab8:	00e62423          	sw	a4,8(a2)
   1babc:	00c52703          	lw	a4,12(a0)
	  tmp->sign = a->sign & b->sign;
   1bac0:	00f6f7b3          	and	a5,a3,a5
   1bac4:	00f62223          	sw	a5,4(a2)
    }
  if (iszero (b))
    {
      if (iszero (a))
	{
	  *tmp = *a;
   1bac8:	00e62623          	sw	a4,12(a2)
	  tmp->sign = a->sign & b->sign;
	  return tmp;
   1bacc:	00060513          	mv	a0,a2
   1bad0:	00008067          	ret
      {
	/* Somethings's up.. choose the biggest */
	if (a_normal_exp > b_normal_exp)
	  {
	    b_normal_exp = a_normal_exp;
	    b_fraction = 0;
   1bad4:	00000293          	li	t0,0
   1bad8:	ef5ff06f          	j	1b9cc <_fpadd_parts+0x60>
      return b;
    }
  if (isinf (a))
    {
      /* Adding infinities with opposite signs yields a NaN.  */
      if (isinf (b) && a->sign != b->sign)
   1badc:	f8f690e3          	bne	a3,a5,1ba5c <_fpadd_parts+0xf0>
   1bae0:	00452703          	lw	a4,4(a0)
   1bae4:	0045a783          	lw	a5,4(a1)
   1bae8:	f6f70ae3          	beq	a4,a5,1ba5c <_fpadd_parts+0xf0>
	return makenan ();
   1baec:	0001d537          	lui	a0,0x1d
   1baf0:	bd050513          	addi	a0,a0,-1072 # 1cbd0 <__thenan_sf>
   1baf4:	00008067          	ret
	}
      else
	{
	  tmp->sign = 1;
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
   1baf8:	40f007b3          	neg	a5,a5
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = tfraction;
	}
      else
	{
	  tmp->sign = 1;
   1bafc:	00100713          	li	a4,1
   1bb00:	00e62223          	sw	a4,4(a2)
	  tmp->normal_exp = a_normal_exp;
   1bb04:	00662423          	sw	t1,8(a2)
	  tmp->fraction.ll = -tfraction;
   1bb08:	00f62623          	sw	a5,12(a2)
   1bb0c:	ee9ff06f          	j	1b9f4 <_fpadd_parts+0x88>
	if (sdiff > 0)
	  {
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
	  }
	else if (sdiff < 0)
   1bb10:	ea080ee3          	beqz	a6,1b9cc <_fpadd_parts+0x60>
	  {
	    a_normal_exp += diff;
	    LSHIFT (a_fraction, diff);
   1bb14:	01171833          	sll	a6,a4,a7
   1bb18:	fff80813          	addi	a6,a6,-1
   1bb1c:	00787833          	and	a6,a6,t2
   1bb20:	0113d7b3          	srl	a5,t2,a7
   1bb24:	010036b3          	snez	a3,a6
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
	  }
	else if (sdiff < 0)
	  {
	    a_normal_exp += diff;
   1bb28:	01130333          	add	t1,t1,a7
	    LSHIFT (a_fraction, diff);
   1bb2c:	00d7e3b3          	or	t2,a5,a3
   1bb30:	e9dff06f          	j	1b9cc <_fpadd_parts+0x60>

0001bb34 <__pack_f>:
extern FLO_type pack_d (const fp_number_type * );

#if defined(L_pack_df) || defined(L_pack_sf) || defined(L_pack_tf)
FLO_type
pack_d (const fp_number_type *src)
{
   1bb34:	00052783          	lw	a5,0(a0)
  FLO_union_type dst;
  fractype fraction = src->fraction.ll;	/* wasn't unsigned before? */
  int sign = src->sign;
  int exp = 0;

  if (isnan (src))
   1bb38:	00100613          	li	a2,1
#if defined(L_pack_df) || defined(L_pack_sf) || defined(L_pack_tf)
FLO_type
pack_d (const fp_number_type *src)
{
  FLO_union_type dst;
  fractype fraction = src->fraction.ll;	/* wasn't unsigned before? */
   1bb3c:	00c52683          	lw	a3,12(a0)
  int sign = src->sign;
   1bb40:	00452583          	lw	a1,4(a0)
  int exp = 0;

  if (isnan (src))
   1bb44:	08f67a63          	bleu	a5,a2,1bbd8 <__pack_f+0xa4>
	  /* Set the quiet/signaling bit.  */
	  fraction |= QUIET_NAN;
#endif
	}
    }
  else if (isinf (src))
   1bb48:	00400713          	li	a4,4
   1bb4c:	08e78063          	beq	a5,a4,1bbcc <__pack_f+0x98>
    {
      exp = EXPMAX;
      fraction = 0;
    }
  else if (iszero (src))
   1bb50:	00200713          	li	a4,2
   1bb54:	04e78263          	beq	a5,a4,1bb98 <__pack_f+0x64>
    {
      exp = 0;
      fraction = 0;
    }
  else if (fraction == 0)
   1bb58:	04068063          	beqz	a3,1bb98 <__pack_f+0x64>
    {
      exp = 0;
    }
  else
    {
      if (__builtin_expect (src->normal_exp < NORMAL_EXPMIN, 0))
   1bb5c:	00852703          	lw	a4,8(a0)
   1bb60:	f8200793          	li	a5,-126
   1bb64:	0af74c63          	blt	a4,a5,1bc1c <__pack_f+0xe8>
	      exp += 1;
	    }
	  fraction >>= NGARDS;
#endif /* NO_DENORMALS */
	}
      else if (__builtin_expect (src->normal_exp > EXPBIAS, 0))
   1bb68:	07f00793          	li	a5,127
   1bb6c:	06e7c063          	blt	a5,a4,1bbcc <__pack_f+0x98>
	{
	  exp = src->normal_exp + EXPBIAS;
	  /* IF the gard bits are the all zero, but the first, then we're
	     half way between two numbers, choose the one which makes the
	     lsb of the answer 0.  */
	  if ((fraction & GARDMASK) == GARDMSB)
   1bb70:	00f6f7b3          	and	a5,a3,a5
   1bb74:	04000613          	li	a2,64
   1bb78:	08c78463          	beq	a5,a2,1bc00 <__pack_f+0xcc>
		fraction += GARDROUND + 1;
	    }
	  else
	    {
	      /* Add a one to the guards to round up */
	      fraction += GARDROUND;
   1bb7c:	03f68693          	addi	a3,a3,63
	    }
	  if (fraction >= IMPLICIT_2)
   1bb80:	0806c863          	bltz	a3,1bc10 <__pack_f+0xdc>
	  exp = EXPMAX;
	  fraction = 0;
	}
      else
	{
	  exp = src->normal_exp + EXPBIAS;
   1bb84:	07f70713          	addi	a4,a4,127
   1bb88:	00269693          	slli	a3,a3,0x2
   1bb8c:	0096d693          	srli	a3,a3,0x9
   1bb90:	0ff77713          	andi	a4,a4,255
   1bb94:	00c0006f          	j	1bba0 <__pack_f+0x6c>
   1bb98:	00000713          	li	a4,0
   1bb9c:	00000693          	li	a3,0

  /* We previously used bitfields to store the number, but this doesn't
     handle little/big endian systems conveniently, so use shifts and
     masks */
#ifdef FLOAT_BIT_ORDER_MISMATCH
  dst.bits.fraction = fraction;
   1bba0:	008007b7          	lui	a5,0x800
   1bba4:	fff78793          	addi	a5,a5,-1 # 7fffff <_gp+0x7e0b2f>
  dst.bits.exp = exp;
   1bba8:	80800637          	lui	a2,0x80800

  /* We previously used bitfields to store the number, but this doesn't
     handle little/big endian systems conveniently, so use shifts and
     masks */
#ifdef FLOAT_BIT_ORDER_MISMATCH
  dst.bits.fraction = fraction;
   1bbac:	00f6f7b3          	and	a5,a3,a5
  dst.bits.exp = exp;
   1bbb0:	fff60613          	addi	a2,a2,-1 # 807fffff <_gp+0x807e0b2f>
   1bbb4:	01771713          	slli	a4,a4,0x17
   1bbb8:	00c7f7b3          	and	a5,a5,a2
  dst.bits.sign = sign;
   1bbbc:	01f59513          	slli	a0,a1,0x1f
   1bbc0:	00e7e7b3          	or	a5,a5,a4
    dst.words[1] = tmp;
  }
#endif
#endif

  return dst.value;
   1bbc4:	00a7e533          	or	a0,a5,a0
}
   1bbc8:	00008067          	ret
   1bbcc:	0ff00713          	li	a4,255
   1bbd0:	00000693          	li	a3,0
   1bbd4:	fcdff06f          	j	1bba0 <__pack_f+0x6c>
  if (isnan (src))
    {
      exp = EXPMAX;
      /* Restore the NaN's payload.  */
      fraction >>= NGARDS;
      fraction &= QUIET_NAN - 1;
   1bbd8:	004007b7          	lui	a5,0x400

  if (isnan (src))
    {
      exp = EXPMAX;
      /* Restore the NaN's payload.  */
      fraction >>= NGARDS;
   1bbdc:	0076d713          	srli	a4,a3,0x7
      fraction &= QUIET_NAN - 1;
   1bbe0:	fff78693          	addi	a3,a5,-1 # 3fffff <_gp+0x3e0b2f>
   1bbe4:	00d776b3          	and	a3,a4,a3
   1bbe8:	00f6e6b3          	or	a3,a3,a5
   1bbec:	008007b7          	lui	a5,0x800
   1bbf0:	fff78793          	addi	a5,a5,-1 # 7fffff <_gp+0x7e0b2f>
   1bbf4:	00f6f6b3          	and	a3,a3,a5
	  /* Make sure the fraction has a non-zero value.  */
	  if (fraction == 0)
	    fraction |= QUIET_NAN - 1;
#else
	  /* Set the quiet/signaling bit.  */
	  fraction |= QUIET_NAN;
   1bbf8:	0ff00713          	li	a4,255
   1bbfc:	fa5ff06f          	j	1bba0 <__pack_f+0x6c>
	  /* IF the gard bits are the all zero, but the first, then we're
	     half way between two numbers, choose the one which makes the
	     lsb of the answer 0.  */
	  if ((fraction & GARDMASK) == GARDMSB)
	    {
	      if (fraction & (1 << NGARDS))
   1bc00:	0806f793          	andi	a5,a3,128
   1bc04:	f6078ee3          	beqz	a5,1bb80 <__pack_f+0x4c>
		fraction += GARDROUND + 1;
   1bc08:	00c686b3          	add	a3,a3,a2
   1bc0c:	f75ff06f          	j	1bb80 <__pack_f+0x4c>
	      /* Add a one to the guards to round up */
	      fraction += GARDROUND;
	    }
	  if (fraction >= IMPLICIT_2)
	    {
	      fraction >>= 1;
   1bc10:	0016d693          	srli	a3,a3,0x1
	      exp += 1;
   1bc14:	08070713          	addi	a4,a4,128
   1bc18:	f71ff06f          	j	1bb88 <__pack_f+0x54>
#else /* NO_DENORMALS */
	  /* This number's exponent is too low to fit into the bits
	     available in the number, so we'll store 0 in the exponent and
	     shift the fraction to the right to make up for it.  */

	  int shift = NORMAL_EXPMIN - src->normal_exp;
   1bc1c:	40e78733          	sub	a4,a5,a4

	  exp = 0;

	  if (shift > FRAC_NBITS - NGARDS)
   1bc20:	01900793          	li	a5,25
   1bc24:	f6e7cae3          	blt	a5,a4,1bb98 <__pack_f+0x64>
	      fraction = 0;
	    }
	  else
	    {
	      int lowbit = (fraction & (((fractype)1 << shift) - 1)) ? 1 : 0;
	      fraction = (fraction >> shift) | lowbit;
   1bc28:	00e617b3          	sll	a5,a2,a4
   1bc2c:	fff78793          	addi	a5,a5,-1
   1bc30:	00d7f7b3          	and	a5,a5,a3
   1bc34:	00e6d6b3          	srl	a3,a3,a4
   1bc38:	00f03733          	snez	a4,a5
   1bc3c:	00e6e6b3          	or	a3,a3,a4
	    }
	  if ((fraction & GARDMASK) == GARDMSB)
   1bc40:	07f6f713          	andi	a4,a3,127
   1bc44:	04000793          	li	a5,64
   1bc48:	02f71263          	bne	a4,a5,1bc6c <__pack_f+0x138>
	    {
	      if ((fraction & (1 << NGARDS)))
   1bc4c:	0806f793          	andi	a5,a3,128
   1bc50:	02079c63          	bnez	a5,1bc88 <__pack_f+0x154>
   1bc54:	40000737          	lui	a4,0x40000
   1bc58:	00e6b733          	sltu	a4,a3,a4
   1bc5c:	00269613          	slli	a2,a3,0x2
   1bc60:	00965693          	srli	a3,a2,0x9
   1bc64:	00174713          	xori	a4,a4,1
   1bc68:	f39ff06f          	j	1bba0 <__pack_f+0x6c>
   1bc6c:	03f68713          	addi	a4,a3,63
   1bc70:	400007b7          	lui	a5,0x40000
   1bc74:	00271693          	slli	a3,a4,0x2
   1bc78:	00f73733          	sltu	a4,a4,a5
   1bc7c:	0096d693          	srli	a3,a3,0x9
   1bc80:	00174713          	xori	a4,a4,1
   1bc84:	f1dff06f          	j	1bba0 <__pack_f+0x6c>
		fraction += GARDROUND + 1;
   1bc88:	04068713          	addi	a4,a3,64
   1bc8c:	fe5ff06f          	j	1bc70 <__pack_f+0x13c>

0001bc90 <__unpack_f>:
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
  exp = src->bits.exp;
   1bc90:	00255703          	lhu	a4,2(a0)
  sign = src->bits.sign;
   1bc94:	00354683          	lbu	a3,3(a0)
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1bc98:	00052603          	lw	a2,0(a0)
  exp = src->bits.exp;
   1bc9c:	00775713          	srli	a4,a4,0x7
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1bca0:	008007b7          	lui	a5,0x800
  exp = ((int)(src->value_raw >> FRACBITS)) & ((1 << EXPBITS) - 1);
  sign = ((int)(src->value_raw >> (FRACBITS + EXPBITS))) & 1;
# endif
#endif

  dst->sign = sign;
   1bca4:	0076d693          	srli	a3,a3,0x7
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1bca8:	fff78793          	addi	a5,a5,-1 # 7fffff <_gp+0x7e0b2f>
  exp = src->bits.exp;
   1bcac:	0ff77713          	andi	a4,a4,255
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1bcb0:	00f677b3          	and	a5,a2,a5
  exp = ((int)(src->value_raw >> FRACBITS)) & ((1 << EXPBITS) - 1);
  sign = ((int)(src->value_raw >> (FRACBITS + EXPBITS))) & 1;
# endif
#endif

  dst->sign = sign;
   1bcb4:	00d5a223          	sw	a3,4(a1)
  if (exp == 0)
   1bcb8:	02071c63          	bnez	a4,1bcf0 <__unpack_f+0x60>
    {
      /* Hmm.  Looks like 0 */
      if (fraction == 0
   1bcbc:	06078063          	beqz	a5,1bd1c <__unpack_f+0x8c>
	     so there isn't a leading implicit one - we'll shift it so
	     it gets one.  */
	  dst->normal_exp = exp - EXPBIAS + 1;
	  fraction <<= NGARDS;

	  dst->class = CLASS_NUMBER;
   1bcc0:	00300713          	li	a4,3
   1bcc4:	00e5a023          	sw	a4,0(a1)
	{
	  /* Zero exponent with nonzero fraction - it's denormalized,
	     so there isn't a leading implicit one - we'll shift it so
	     it gets one.  */
	  dst->normal_exp = exp - EXPBIAS + 1;
	  fraction <<= NGARDS;
   1bcc8:	00779793          	slli	a5,a5,0x7

	  dst->class = CLASS_NUMBER;
   1bccc:	f8100713          	li	a4,-127
#if 1
	  while (fraction < IMPLICIT_1)
   1bcd0:	40000637          	lui	a2,0x40000
	    {
	      fraction <<= 1;
   1bcd4:	00179793          	slli	a5,a5,0x1
	      dst->normal_exp--;
   1bcd8:	00070693          	mv	a3,a4
   1bcdc:	fff70713          	addi	a4,a4,-1 # 3fffffff <_gp+0x3ffe0b2f>
	  dst->normal_exp = exp - EXPBIAS + 1;
	  fraction <<= NGARDS;

	  dst->class = CLASS_NUMBER;
#if 1
	  while (fraction < IMPLICIT_1)
   1bce0:	fec7eae3          	bltu	a5,a2,1bcd4 <__unpack_f+0x44>
   1bce4:	00d5a423          	sw	a3,8(a1)
	    {
	      fraction <<= 1;
	      dst->normal_exp--;
	    }
#endif
	  dst->fraction.ll = fraction;
   1bce8:	00f5a623          	sw	a5,12(a1)
   1bcec:	00008067          	ret
	}
    }
  else if (__builtin_expect (exp == EXPMAX, 0))
   1bcf0:	0ff00693          	li	a3,255
   1bcf4:	02d70a63          	beq	a4,a3,1bd28 <__unpack_f+0x98>
	}
    }
  else
    {
      /* Nothing strange about this number */
      dst->normal_exp = exp - EXPBIAS;
   1bcf8:	f8170713          	addi	a4,a4,-127
      dst->class = CLASS_NUMBER;
      dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;
   1bcfc:	00779793          	slli	a5,a5,0x7
   1bd00:	400006b7          	lui	a3,0x40000
   1bd04:	00d7e7b3          	or	a5,a5,a3
	}
    }
  else
    {
      /* Nothing strange about this number */
      dst->normal_exp = exp - EXPBIAS;
   1bd08:	00e5a423          	sw	a4,8(a1)
      dst->class = CLASS_NUMBER;
   1bd0c:	00300713          	li	a4,3
   1bd10:	00e5a023          	sw	a4,0(a1)
      dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;
   1bd14:	00f5a623          	sw	a5,12(a1)
   1bd18:	00008067          	ret
	  || 1
#endif
	  )
	{
	  /* tastes like zero */
	  dst->class = CLASS_ZERO;
   1bd1c:	00200793          	li	a5,2
   1bd20:	00f5a023          	sw	a5,0(a1)
   1bd24:	00008067          	ret
	}
    }
  else if (__builtin_expect (exp == EXPMAX, 0))
    {
      /* Huge exponent*/
      if (fraction == 0)
   1bd28:	02078663          	beqz	a5,1bd54 <__unpack_f+0xc4>
	{
	  /* Nonzero fraction, means nan */
#ifdef QUIET_NAN_NEGATED
	  if ((fraction & QUIET_NAN) == 0)
#else
	  if (fraction & QUIET_NAN)
   1bd2c:	00979713          	slli	a4,a5,0x9
   1bd30:	02075863          	bgez	a4,1bd60 <__unpack_f+0xd0>
#endif
	    {
	      dst->class = CLASS_QNAN;
   1bd34:	00100713          	li	a4,1
   1bd38:	00e5a023          	sw	a4,0(a1)
	      dst->class = CLASS_SNAN;
	    }
	  /* Now that we know which kind of NaN we got, discard the
	     quiet/signaling bit, but do preserve the NaN payload.  */
	  fraction &= ~QUIET_NAN;
	  dst->fraction.ll = fraction << NGARDS;
   1bd3c:	ffc00737          	lui	a4,0xffc00
   1bd40:	fff70713          	addi	a4,a4,-1 # ffbfffff <_gp+0xffbe0b2f>
   1bd44:	00e7f7b3          	and	a5,a5,a4
   1bd48:	00779793          	slli	a5,a5,0x7
   1bd4c:	00f5a623          	sw	a5,12(a1)
   1bd50:	00008067          	ret
    {
      /* Huge exponent*/
      if (fraction == 0)
	{
	  /* Attached to a zero fraction - means infinity */
	  dst->class = CLASS_INFINITY;
   1bd54:	00400793          	li	a5,4
   1bd58:	00f5a023          	sw	a5,0(a1)
   1bd5c:	00008067          	ret
	    {
	      dst->class = CLASS_QNAN;
	    }
	  else
	    {
	      dst->class = CLASS_SNAN;
   1bd60:	0005a023          	sw	zero,0(a1)
   1bd64:	fd9ff06f          	j	1bd3c <__unpack_f+0xac>

0001bd68 <__addsf3>:
  return tmp;
}

FLO_type
add (FLO_type arg_a, FLO_type arg_b)
{
   1bd68:	fb010113          	addi	sp,sp,-80
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1bd6c:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1bd70:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1bd74:	00810513          	addi	a0,sp,8
   1bd78:	01010593          	addi	a1,sp,16
  return tmp;
}

FLO_type
add (FLO_type arg_a, FLO_type arg_b)
{
   1bd7c:	04112623          	sw	ra,76(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1bd80:	f11ff0ef          	jal	1bc90 <__unpack_f>
  unpack_d (&bu, &b);
   1bd84:	02010593          	addi	a1,sp,32
   1bd88:	00c10513          	addi	a0,sp,12
   1bd8c:	f05ff0ef          	jal	1bc90 <__unpack_f>

  res = _fpadd_parts (&a, &b, &tmp);
   1bd90:	03010613          	addi	a2,sp,48
   1bd94:	02010593          	addi	a1,sp,32
   1bd98:	01010513          	addi	a0,sp,16
   1bd9c:	bd1ff0ef          	jal	1b96c <_fpadd_parts>

  return pack_d (res);
   1bda0:	d95ff0ef          	jal	1bb34 <__pack_f>
}
   1bda4:	04c12083          	lw	ra,76(sp)
   1bda8:	05010113          	addi	sp,sp,80
   1bdac:	00008067          	ret

0001bdb0 <__subsf3>:

FLO_type
sub (FLO_type arg_a, FLO_type arg_b)
{
   1bdb0:	fb010113          	addi	sp,sp,-80
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1bdb4:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1bdb8:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1bdbc:	00810513          	addi	a0,sp,8
   1bdc0:	01010593          	addi	a1,sp,16
  return pack_d (res);
}

FLO_type
sub (FLO_type arg_a, FLO_type arg_b)
{
   1bdc4:	04112623          	sw	ra,76(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1bdc8:	ec9ff0ef          	jal	1bc90 <__unpack_f>
  unpack_d (&bu, &b);
   1bdcc:	02010593          	addi	a1,sp,32
   1bdd0:	00c10513          	addi	a0,sp,12
   1bdd4:	ebdff0ef          	jal	1bc90 <__unpack_f>

  b.sign ^= 1;
   1bdd8:	02412783          	lw	a5,36(sp)

  res = _fpadd_parts (&a, &b, &tmp);
   1bddc:	03010613          	addi	a2,sp,48
   1bde0:	02010593          	addi	a1,sp,32
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  b.sign ^= 1;
   1bde4:	0017c793          	xori	a5,a5,1

  res = _fpadd_parts (&a, &b, &tmp);
   1bde8:	01010513          	addi	a0,sp,16
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  b.sign ^= 1;
   1bdec:	02f12223          	sw	a5,36(sp)

  res = _fpadd_parts (&a, &b, &tmp);
   1bdf0:	b7dff0ef          	jal	1b96c <_fpadd_parts>

  return pack_d (res);
   1bdf4:	d41ff0ef          	jal	1bb34 <__pack_f>
}
   1bdf8:	04c12083          	lw	ra,76(sp)
   1bdfc:	05010113          	addi	sp,sp,80
   1be00:	00008067          	ret

0001be04 <__mulsf3>:
  return tmp;
}

FLO_type
multiply (FLO_type arg_a, FLO_type arg_b)
{
   1be04:	fb010113          	addi	sp,sp,-80
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1be08:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1be0c:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1be10:	00810513          	addi	a0,sp,8
   1be14:	01010593          	addi	a1,sp,16
  return tmp;
}

FLO_type
multiply (FLO_type arg_a, FLO_type arg_b)
{
   1be18:	04112623          	sw	ra,76(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1be1c:	e75ff0ef          	jal	1bc90 <__unpack_f>
  unpack_d (&bu, &b);
   1be20:	02010593          	addi	a1,sp,32
   1be24:	00c10513          	addi	a0,sp,12
   1be28:	e69ff0ef          	jal	1bc90 <__unpack_f>
   1be2c:	01012783          	lw	a5,16(sp)
	       fp_number_type * tmp)
{
  fractype low = 0;
  fractype high = 0;

  if (isnan (a))
   1be30:	00100693          	li	a3,1
   1be34:	0ef6f463          	bleu	a5,a3,1bf1c <__mulsf3+0x118>
   1be38:	02012703          	lw	a4,32(sp)
    {
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isnan (b))
   1be3c:	0ae6f863          	bleu	a4,a3,1beec <__mulsf3+0xe8>
    {
      b->sign = a->sign != b->sign;
      return b;
    }
  if (isinf (a))
   1be40:	00400693          	li	a3,4
   1be44:	0cd78863          	beq	a5,a3,1bf14 <__mulsf3+0x110>
      if (iszero (b))
	return makenan ();
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isinf (b))
   1be48:	08d70e63          	beq	a4,a3,1bee4 <__mulsf3+0xe0>
	  return makenan ();
	}
      b->sign = a->sign != b->sign;
      return b;
    }
  if (iszero (a))
   1be4c:	00200693          	li	a3,2
   1be50:	0cd78663          	beq	a5,a3,1bf1c <__mulsf3+0x118>
    {
      a->sign = a->sign != b->sign;
      return a;
    }
  if (iszero (b))
   1be54:	08d70c63          	beq	a4,a3,1beec <__mulsf3+0xe8>
	}
    }
#elif defined(FLOAT) 
    /* Multiplying two USIs to get a UDI, we're safe.  */
    {
      UDItype answer = (UDItype)a->fraction.ll * (UDItype)b->fraction.ll;
   1be58:	01c12703          	lw	a4,28(sp)
   1be5c:	02c12583          	lw	a1,44(sp)
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1be60:	02812683          	lw	a3,40(sp)
   1be64:	01812783          	lw	a5,24(sp)
	}
    }
#elif defined(FLOAT) 
    /* Multiplying two USIs to get a UDI, we're safe.  */
    {
      UDItype answer = (UDItype)a->fraction.ll * (UDItype)b->fraction.ll;
   1be68:	02b73633          	mulhu	a2,a4,a1
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
   1be6c:	02412803          	lw	a6,36(sp)
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1be70:	00d787b3          	add	a5,a5,a3
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
   1be74:	01412683          	lw	a3,20(sp)
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1be78:	00278513          	addi	a0,a5,2
   1be7c:	02a12c23          	sw	a0,56(sp)
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
   1be80:	410686b3          	sub	a3,a3,a6
   1be84:	00d036b3          	snez	a3,a3
   1be88:	02d12a23          	sw	a3,52(sp)
    /* Multiplying two USIs to get a UDI, we're safe.  */
    {
      UDItype answer = (UDItype)a->fraction.ll * (UDItype)b->fraction.ll;
      
      high = answer >> BITS_PER_SI;
      low = answer;
   1be8c:	02b70733          	mul	a4,a4,a1
#elif defined(FLOAT) 
    /* Multiplying two USIs to get a UDI, we're safe.  */
    {
      UDItype answer = (UDItype)a->fraction.ll * (UDItype)b->fraction.ll;
      
      high = answer >> BITS_PER_SI;
   1be90:	00060693          	mv	a3,a2
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
  while (high >= IMPLICIT_2)
   1be94:	0c065a63          	bgez	a2,1bf68 <__mulsf3+0x164>
    {
      tmp->normal_exp++;
      if (high & 1)
   1be98:	00167693          	andi	a3,a2,1
   1be9c:	00378793          	addi	a5,a5,3
   1bea0:	00068863          	beqz	a3,1beb0 <__mulsf3+0xac>
	{
	  low >>= 1;
   1bea4:	00175713          	srli	a4,a4,0x1
	  low |= FRACHIGH;
   1bea8:	800006b7          	lui	a3,0x80000
   1beac:	00d76733          	or	a4,a4,a3
	}
      high >>= 1;
   1beb0:	00165693          	srli	a3,a2,0x1
   1beb4:	02f12c23          	sw	a5,56(sp)
      if (low & FRACHIGH)
	high |= 1;
      low <<= 1;
    }

  if ((high & GARDMASK) == GARDMSB)
   1beb8:	07f6f793          	andi	a5,a3,127
   1bebc:	04000613          	li	a2,64
   1bec0:	08c78263          	beq	a5,a2,1bf44 <__mulsf3+0x140>
	  /* Avoid further rounding in pack_d.  */
	  high &= ~(fractype) GARDMASK;
	}
    }
  tmp->fraction.ll = high;
  tmp->class = CLASS_NUMBER;
   1bec4:	00300793          	li	a5,3

	  /* Avoid further rounding in pack_d.  */
	  high &= ~(fractype) GARDMASK;
	}
    }
  tmp->fraction.ll = high;
   1bec8:	02d12e23          	sw	a3,60(sp)
  tmp->class = CLASS_NUMBER;
   1becc:	02f12823          	sw	a5,48(sp)
  return tmp;
   1bed0:	03010513          	addi	a0,sp,48
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
   1bed4:	c61ff0ef          	jal	1bb34 <__pack_f>
}
   1bed8:	04c12083          	lw	ra,76(sp)
   1bedc:	05010113          	addi	sp,sp,80
   1bee0:	00008067          	ret
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isinf (b))
    {
      if (iszero (a))
   1bee4:	00200713          	li	a4,2
   1bee8:	06e78a63          	beq	a5,a4,1bf5c <__mulsf3+0x158>
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isnan (b))
    {
      b->sign = a->sign != b->sign;
   1beec:	02412703          	lw	a4,36(sp)
   1bef0:	01412783          	lw	a5,20(sp)
      return b;
   1bef4:	02010513          	addi	a0,sp,32
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isnan (b))
    {
      b->sign = a->sign != b->sign;
   1bef8:	40e787b3          	sub	a5,a5,a4
   1befc:	00f037b3          	snez	a5,a5
   1bf00:	02f12223          	sw	a5,36(sp)
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
   1bf04:	c31ff0ef          	jal	1bb34 <__pack_f>
}
   1bf08:	04c12083          	lw	ra,76(sp)
   1bf0c:	05010113          	addi	sp,sp,80
   1bf10:	00008067          	ret
      b->sign = a->sign != b->sign;
      return b;
    }
  if (isinf (a))
    {
      if (iszero (b))
   1bf14:	00200793          	li	a5,2
   1bf18:	04f70263          	beq	a4,a5,1bf5c <__mulsf3+0x158>
  fractype low = 0;
  fractype high = 0;

  if (isnan (a))
    {
      a->sign = a->sign != b->sign;
   1bf1c:	02412703          	lw	a4,36(sp)
   1bf20:	01412783          	lw	a5,20(sp)
      return a;
   1bf24:	01010513          	addi	a0,sp,16
  fractype low = 0;
  fractype high = 0;

  if (isnan (a))
    {
      a->sign = a->sign != b->sign;
   1bf28:	40e787b3          	sub	a5,a5,a4
   1bf2c:	00f037b3          	snez	a5,a5
   1bf30:	00f12a23          	sw	a5,20(sp)
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
   1bf34:	c01ff0ef          	jal	1bb34 <__pack_f>
}
   1bf38:	04c12083          	lw	ra,76(sp)
   1bf3c:	05010113          	addi	sp,sp,80
   1bf40:	00008067          	ret
      low <<= 1;
    }

  if ((high & GARDMASK) == GARDMSB)
    {
      if (high & (1 << NGARDS))
   1bf44:	0806f793          	andi	a5,a3,128
   1bf48:	f6079ee3          	bnez	a5,1bec4 <__mulsf3+0xc0>
	     function, and rounding twice will lose precision and cause
	     the result to be too far off.  Example: 32-bit floats with
	     bit patterns 0xfff * 0x3f800400 ~= 0xfff (less than 0.5ulp
	     off), not 0x1000 (more than 0.5ulp off).  */
	}
      else if (low)
   1bf4c:	f6070ce3          	beqz	a4,1bec4 <__mulsf3+0xc0>
	{
	  /* We're a further than half way by a small amount corresponding
	     to the bits set in "low".  Knowing that, we round here and
	     not in pack_d, because there we don't have "low" available
	     anymore.  */
	  high += GARDROUND + 1;
   1bf50:	00c686b3          	add	a3,a3,a2

	  /* Avoid further rounding in pack_d.  */
	  high &= ~(fractype) GARDMASK;
   1bf54:	f806f693          	andi	a3,a3,-128
   1bf58:	f6dff06f          	j	1bec4 <__mulsf3+0xc0>
      return b;
    }
  if (isinf (a))
    {
      if (iszero (b))
	return makenan ();
   1bf5c:	0001d537          	lui	a0,0x1d
   1bf60:	bd050513          	addi	a0,a0,-1072 # 1cbd0 <__thenan_sf>
   1bf64:	f71ff06f          	j	1bed4 <__mulsf3+0xd0>
	  low >>= 1;
	  low |= FRACHIGH;
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
   1bf68:	40000637          	lui	a2,0x40000
   1bf6c:	f4c6f6e3          	bleu	a2,a3,1beb8 <__mulsf3+0xb4>
   1bf70:	00178793          	addi	a5,a5,1
   1bf74:	0100006f          	j	1bf84 <__mulsf3+0x180>
      tmp->normal_exp--;

      high <<= 1;
      if (low & FRACHIGH)
	high |= 1;
      low <<= 1;
   1bf78:	00171713          	slli	a4,a4,0x1
   1bf7c:	fff78793          	addi	a5,a5,-1
	  low >>= 1;
	  low |= FRACHIGH;
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
   1bf80:	02c6f063          	bleu	a2,a3,1bfa0 <__mulsf3+0x19c>
    {
      tmp->normal_exp--;

      high <<= 1;
   1bf84:	00169693          	slli	a3,a3,0x1
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
    {
      tmp->normal_exp--;
   1bf88:	00078593          	mv	a1,a5

      high <<= 1;
      if (low & FRACHIGH)
   1bf8c:	fe0756e3          	bgez	a4,1bf78 <__mulsf3+0x174>
	high |= 1;
   1bf90:	0016e693          	ori	a3,a3,1
      low <<= 1;
   1bf94:	00171713          	slli	a4,a4,0x1
   1bf98:	fff78793          	addi	a5,a5,-1
	  low >>= 1;
	  low |= FRACHIGH;
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
   1bf9c:	fec6e4e3          	bltu	a3,a2,1bf84 <__mulsf3+0x180>
   1bfa0:	02b12c23          	sw	a1,56(sp)
   1bfa4:	f15ff06f          	j	1beb8 <__mulsf3+0xb4>

0001bfa8 <__divsf3>:
  }
}

FLO_type
divide (FLO_type arg_a, FLO_type arg_b)
{
   1bfa8:	fc010113          	addi	sp,sp,-64
  fp_number_type a;
  fp_number_type b;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1bfac:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1bfb0:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1bfb4:	00810513          	addi	a0,sp,8
   1bfb8:	01010593          	addi	a1,sp,16
  }
}

FLO_type
divide (FLO_type arg_a, FLO_type arg_b)
{
   1bfbc:	02112e23          	sw	ra,60(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1bfc0:	cd1ff0ef          	jal	1bc90 <__unpack_f>
  unpack_d (&bu, &b);
   1bfc4:	02010593          	addi	a1,sp,32
   1bfc8:	00c10513          	addi	a0,sp,12
   1bfcc:	cc5ff0ef          	jal	1bc90 <__unpack_f>
   1bfd0:	01012683          	lw	a3,16(sp)
  fractype bit;
  fractype numerator;
  fractype denominator;
  fractype quotient;

  if (isnan (a))
   1bfd4:	00100793          	li	a5,1
   1bfd8:	08d7f663          	bleu	a3,a5,1c064 <__divsf3+0xbc>
   1bfdc:	02012603          	lw	a2,32(sp)
    {
      return a;
    }
  if (isnan (b))
   1bfe0:	0ec7f663          	bleu	a2,a5,1c0cc <__divsf3+0x124>
    {
      return b;
    }

  a->sign = a->sign ^ b->sign;
   1bfe4:	01412583          	lw	a1,20(sp)
   1bfe8:	02412703          	lw	a4,36(sp)

  if (isinf (a) || iszero (a))
   1bfec:	ffe68793          	addi	a5,a3,-2 # 7ffffffe <_gp+0x7ffe0b2e>
   1bff0:	ffd7f793          	andi	a5,a5,-3
  if (isnan (b))
    {
      return b;
    }

  a->sign = a->sign ^ b->sign;
   1bff4:	00e5c733          	xor	a4,a1,a4
   1bff8:	00e12a23          	sw	a4,20(sp)

  if (isinf (a) || iszero (a))
   1bffc:	06078e63          	beqz	a5,1c078 <__divsf3+0xd0>
      if (a->class == b->class)
	return makenan ();
      return a;
    }

  if (isinf (b))
   1c000:	00400793          	li	a5,4
   1c004:	08f60a63          	beq	a2,a5,1c098 <__divsf3+0xf0>
    {
      a->fraction.ll = 0;
      a->normal_exp = 0;
      return a;
    }
  if (iszero (b))
   1c008:	00200713          	li	a4,2
   1c00c:	0ae60a63          	beq	a2,a4,1c0c0 <__divsf3+0x118>
  {
    /* quotient =
       ( numerator / denominator) * 2^(numerator exponent -  denominator exponent)
     */

    a->normal_exp = a->normal_exp - b->normal_exp;
   1c010:	01812703          	lw	a4,24(sp)
   1c014:	02812683          	lw	a3,40(sp)
    numerator = a->fraction.ll;
   1c018:	01c12783          	lw	a5,28(sp)
    denominator = b->fraction.ll;
   1c01c:	02c12603          	lw	a2,44(sp)
  {
    /* quotient =
       ( numerator / denominator) * 2^(numerator exponent -  denominator exponent)
     */

    a->normal_exp = a->normal_exp - b->normal_exp;
   1c020:	40d70733          	sub	a4,a4,a3
   1c024:	00e12c23          	sw	a4,24(sp)
    numerator = a->fraction.ll;
    denominator = b->fraction.ll;

    if (numerator < denominator)
   1c028:	06c7e063          	bltu	a5,a2,1c088 <__divsf3+0xe0>
  }
}

FLO_type
divide (FLO_type arg_a, FLO_type arg_b)
{
   1c02c:	01f00713          	li	a4,31
	/* Fraction will be less than 1.0 */
	numerator *= 2;
	a->normal_exp--;
      }
    bit = IMPLICIT_1;
    quotient = 0;
   1c030:	00000593          	li	a1,0
      {
	/* Fraction will be less than 1.0 */
	numerator *= 2;
	a->normal_exp--;
      }
    bit = IMPLICIT_1;
   1c034:	400006b7          	lui	a3,0x40000
   1c038:	fff70713          	addi	a4,a4,-1
    quotient = 0;
    /* ??? Does divide one bit at a time.  Optimize.  */
    while (bit)
      {
	if (numerator >= denominator)
   1c03c:	00c7e663          	bltu	a5,a2,1c048 <__divsf3+0xa0>
	  {
	    quotient |= bit;
   1c040:	00d5e5b3          	or	a1,a1,a3
	    numerator -= denominator;
   1c044:	40c787b3          	sub	a5,a5,a2
	  }
	bit >>= 1;
   1c048:	0016d693          	srli	a3,a3,0x1
	numerator *= 2;
   1c04c:	00179793          	slli	a5,a5,0x1
	a->normal_exp--;
      }
    bit = IMPLICIT_1;
    quotient = 0;
    /* ??? Does divide one bit at a time.  Optimize.  */
    while (bit)
   1c050:	fe0714e3          	bnez	a4,1c038 <__divsf3+0x90>
	  }
	bit >>= 1;
	numerator *= 2;
      }

    if ((quotient & GARDMASK) == GARDMSB)
   1c054:	07f5f713          	andi	a4,a1,127
   1c058:	04000693          	li	a3,64
   1c05c:	04d70663          	beq	a4,a3,1c0a8 <__divsf3+0x100>
	    /* Avoid further rounding in pack_d.  */
	    quotient &= ~(fractype) GARDMASK;
	  }
      }

    a->fraction.ll = quotient;
   1c060:	00b12e23          	sw	a1,28(sp)
    return (a);
   1c064:	01010513          	addi	a0,sp,16
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpdiv_parts (&a, &b);

  return pack_d (res);
   1c068:	acdff0ef          	jal	1bb34 <__pack_f>
}
   1c06c:	03c12083          	lw	ra,60(sp)
   1c070:	04010113          	addi	sp,sp,64
   1c074:	00008067          	ret

  a->sign = a->sign ^ b->sign;

  if (isinf (a) || iszero (a))
    {
      if (a->class == b->class)
   1c078:	fec696e3          	bne	a3,a2,1c064 <__divsf3+0xbc>
	return makenan ();
   1c07c:	0001d537          	lui	a0,0x1d
   1c080:	bd050513          	addi	a0,a0,-1072 # 1cbd0 <__thenan_sf>
   1c084:	fe5ff06f          	j	1c068 <__divsf3+0xc0>

    if (numerator < denominator)
      {
	/* Fraction will be less than 1.0 */
	numerator *= 2;
	a->normal_exp--;
   1c088:	fff70713          	addi	a4,a4,-1
    denominator = b->fraction.ll;

    if (numerator < denominator)
      {
	/* Fraction will be less than 1.0 */
	numerator *= 2;
   1c08c:	00179793          	slli	a5,a5,0x1
	a->normal_exp--;
   1c090:	00e12c23          	sw	a4,24(sp)
   1c094:	f99ff06f          	j	1c02c <__divsf3+0x84>
      return a;
    }

  if (isinf (b))
    {
      a->fraction.ll = 0;
   1c098:	00012e23          	sw	zero,28(sp)
      a->normal_exp = 0;
   1c09c:	00012c23          	sw	zero,24(sp)
      return a;
   1c0a0:	01010513          	addi	a0,sp,16
   1c0a4:	fc5ff06f          	j	1c068 <__divsf3+0xc0>
	numerator *= 2;
      }

    if ((quotient & GARDMASK) == GARDMSB)
      {
	if (quotient & (1 << NGARDS))
   1c0a8:	0805f713          	andi	a4,a1,128
   1c0ac:	fa071ae3          	bnez	a4,1c060 <__divsf3+0xb8>
	    /* Because we're half way, we would round to even by adding
	       GARDROUND + 1, except that's also done in the packing
	       function, and rounding twice will lose precision and cause
	       the result to be too far off.  */
	  }
	else if (numerator)
   1c0b0:	fa0788e3          	beqz	a5,1c060 <__divsf3+0xb8>
	  {
	    /* We're a further than half way by the small amount
	       corresponding to the bits set in "numerator".  Knowing
	       that, we round here and not in pack_d, because there we
	       don't have "numerator" available anymore.  */
	    quotient += GARDROUND + 1;
   1c0b4:	00d585b3          	add	a1,a1,a3

	    /* Avoid further rounding in pack_d.  */
	    quotient &= ~(fractype) GARDMASK;
   1c0b8:	f805f593          	andi	a1,a1,-128
   1c0bc:	fa5ff06f          	j	1c060 <__divsf3+0xb8>
      a->normal_exp = 0;
      return a;
    }
  if (iszero (b))
    {
      a->class = CLASS_INFINITY;
   1c0c0:	00f12823          	sw	a5,16(sp)
      return a;
   1c0c4:	01010513          	addi	a0,sp,16
   1c0c8:	fa1ff06f          	j	1c068 <__divsf3+0xc0>
    {
      return a;
    }
  if (isnan (b))
    {
      return b;
   1c0cc:	02010513          	addi	a0,sp,32
   1c0d0:	f99ff06f          	j	1c068 <__divsf3+0xc0>

0001c0d4 <__fpcmp_parts_f>:
   a>b -> +1
 */

int
__fpcmp_parts (fp_number_type * a, fp_number_type * b)
{
   1c0d4:	00052703          	lw	a4,0(a0)
    {
      return 1;			/* still unordered! */
    }
#endif

  if (isnan (a) || isnan (b))
   1c0d8:	00100793          	li	a5,1
   a>b -> +1
 */

int
__fpcmp_parts (fp_number_type * a, fp_number_type * b)
{
   1c0dc:	00050613          	mv	a2,a0
    {
      return 1;			/* still unordered! */
    }
#endif

  if (isnan (a) || isnan (b))
   1c0e0:	06e7fe63          	bleu	a4,a5,1c15c <__fpcmp_parts_f+0x88>
   1c0e4:	0005a683          	lw	a3,0(a1)
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1c0e8:	00078513          	mv	a0,a5
    {
      return 1;			/* still unordered! */
    }
#endif

  if (isnan (a) || isnan (b))
   1c0ec:	04d7f063          	bleu	a3,a5,1c12c <__fpcmp_parts_f+0x58>
    {
      return 1;			/* how to indicate unordered compare? */
    }
  if (isinf (a) && isinf (b))
   1c0f0:	00400793          	li	a5,4
   1c0f4:	04f70863          	beq	a4,a5,1c144 <__fpcmp_parts_f+0x70>
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
    }
  if (isinf (b))
   1c0f8:	02f68c63          	beq	a3,a5,1c130 <__fpcmp_parts_f+0x5c>
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (a) && iszero (b))
   1c0fc:	00200793          	li	a5,2
   1c100:	02f70263          	beq	a4,a5,1c124 <__fpcmp_parts_f+0x50>
    }
  if (iszero (a))
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (b))
   1c104:	04f68263          	beq	a3,a5,1c148 <__fpcmp_parts_f+0x74>
    {
      return a->sign ? -1 : 1;
    }
  /* now both are "normal".  */
  if (a->sign != b->sign)
   1c108:	00462783          	lw	a5,4(a2) # 40000004 <_gp+0x3ffe0b34>
   1c10c:	0045a703          	lw	a4,4(a1)
   1c110:	04e78a63          	beq	a5,a4,1c164 <__fpcmp_parts_f+0x90>
    {
      return a->sign ? -1 : 1;
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
   1c114:	00f03533          	snez	a0,a5
   1c118:	40a00533          	neg	a0,a0
   1c11c:	00156513          	ori	a0,a0,1
   1c120:	00008067          	ret
    }
  if (iszero (a) && iszero (b))
   1c124:	00e69663          	bne	a3,a4,1c130 <__fpcmp_parts_f+0x5c>
    {
      return 0;
   1c128:	00000513          	li	a0,0
    {
      return a->sign ? 1 : -1;
    }
  /* after all that, they're equal.  */
  return 0;
}
   1c12c:	00008067          	ret
    {
      return a->sign ? -1 : 1;
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
   1c130:	0045a503          	lw	a0,4(a1)
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1c134:	00153513          	seqz	a0,a0
   1c138:	40a00533          	neg	a0,a0
   1c13c:	00156513          	ori	a0,a0,1
   1c140:	00008067          	ret

  if (isnan (a) || isnan (b))
    {
      return 1;			/* how to indicate unordered compare? */
    }
  if (isinf (a) && isinf (b))
   1c144:	04e68a63          	beq	a3,a4,1c198 <__fpcmp_parts_f+0xc4>
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1c148:	00462503          	lw	a0,4(a2)
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
   1c14c:	00a03533          	snez	a0,a0
   1c150:	40a00533          	neg	a0,a0
   1c154:	00156513          	ori	a0,a0,1
   1c158:	00008067          	ret
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1c15c:	00078513          	mv	a0,a5
   1c160:	00008067          	ret
    {
      /* opposite signs */
      return a->sign ? -1 : 1;
    }
  /* same sign; exponents? */
  if (a->normal_exp > b->normal_exp)
   1c164:	00862683          	lw	a3,8(a2)
   1c168:	0085a703          	lw	a4,8(a1)
   1c16c:	fad744e3          	blt	a4,a3,1c114 <__fpcmp_parts_f+0x40>
    {
      return a->sign ? -1 : 1;
    }
  if (a->normal_exp < b->normal_exp)
   1c170:	00e6cc63          	blt	a3,a4,1c188 <__fpcmp_parts_f+0xb4>
    {
      return a->sign ? 1 : -1;
    }
  /* same exponents; check size.  */
  if (a->fraction.ll > b->fraction.ll)
   1c174:	00c62683          	lw	a3,12(a2)
   1c178:	00c5a703          	lw	a4,12(a1)
   1c17c:	f8d76ce3          	bltu	a4,a3,1c114 <__fpcmp_parts_f+0x40>
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (a) && iszero (b))
    {
      return 0;
   1c180:	00000513          	li	a0,0
  /* same exponents; check size.  */
  if (a->fraction.ll > b->fraction.ll)
    {
      return a->sign ? -1 : 1;
    }
  if (a->fraction.ll < b->fraction.ll)
   1c184:	fae6f4e3          	bleu	a4,a3,1c12c <__fpcmp_parts_f+0x58>
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1c188:	0017b513          	seqz	a0,a5
   1c18c:	40a00533          	neg	a0,a0
   1c190:	00156513          	ori	a0,a0,1
   1c194:	00008067          	ret
       -------+--------+--------
       -inf(1)| a>b(1) | a==b(0)
       -------+--------+--------
       So since unordered must be nonzero, just line up the columns...
       */
      return b->sign - a->sign;
   1c198:	0045a783          	lw	a5,4(a1)
   1c19c:	00462503          	lw	a0,4(a2)
   1c1a0:	40a78533          	sub	a0,a5,a0
   1c1a4:	00008067          	ret

0001c1a8 <__cmpsf2>:
#endif

#if defined(L_compare_sf) || defined(L_compare_df) || defined(L_compoare_tf)
CMPtype
compare (FLO_type arg_a, FLO_type arg_b)
{
   1c1a8:	fc010113          	addi	sp,sp,-64
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1c1ac:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1c1b0:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1c1b4:	00810513          	addi	a0,sp,8
   1c1b8:	01010593          	addi	a1,sp,16
#endif

#if defined(L_compare_sf) || defined(L_compare_df) || defined(L_compoare_tf)
CMPtype
compare (FLO_type arg_a, FLO_type arg_b)
{
   1c1bc:	02112e23          	sw	ra,60(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1c1c0:	ad1ff0ef          	jal	1bc90 <__unpack_f>
  unpack_d (&bu, &b);
   1c1c4:	02010593          	addi	a1,sp,32
   1c1c8:	00c10513          	addi	a0,sp,12
   1c1cc:	ac5ff0ef          	jal	1bc90 <__unpack_f>

  return __fpcmp_parts (&a, &b);
   1c1d0:	02010593          	addi	a1,sp,32
   1c1d4:	01010513          	addi	a0,sp,16
   1c1d8:	efdff0ef          	jal	1c0d4 <__fpcmp_parts_f>
}
   1c1dc:	03c12083          	lw	ra,60(sp)
   1c1e0:	04010113          	addi	sp,sp,64
   1c1e4:	00008067          	ret

0001c1e8 <__gesf2>:
#endif /* L_gt_sf || L_gt_df */

#if defined(L_ge_sf) || defined(L_ge_df) || defined(L_ge_tf)
CMPtype
_ge_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1c1e8:	fc010113          	addi	sp,sp,-64
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1c1ec:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1c1f0:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1c1f4:	00810513          	addi	a0,sp,8
   1c1f8:	01010593          	addi	a1,sp,16
#endif /* L_gt_sf || L_gt_df */

#if defined(L_ge_sf) || defined(L_ge_df) || defined(L_ge_tf)
CMPtype
_ge_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1c1fc:	02112e23          	sw	ra,60(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1c200:	a91ff0ef          	jal	1bc90 <__unpack_f>
  unpack_d (&bu, &b);
   1c204:	00c10513          	addi	a0,sp,12
   1c208:	02010593          	addi	a1,sp,32
   1c20c:	a85ff0ef          	jal	1bc90 <__unpack_f>

  if (isnan (&a) || isnan (&b))
   1c210:	01012703          	lw	a4,16(sp)
   1c214:	00100793          	li	a5,1
    return -1;			/* false, truth >= 0 */
   1c218:	fff00513          	li	a0,-1
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  if (isnan (&a) || isnan (&b))
   1c21c:	00e7fc63          	bleu	a4,a5,1c234 <__gesf2+0x4c>
   1c220:	02012703          	lw	a4,32(sp)
   1c224:	00e7f863          	bleu	a4,a5,1c234 <__gesf2+0x4c>
    return -1;			/* false, truth >= 0 */
  return __fpcmp_parts (&a, &b) ;
   1c228:	02010593          	addi	a1,sp,32
   1c22c:	01010513          	addi	a0,sp,16
   1c230:	ea5ff0ef          	jal	1c0d4 <__fpcmp_parts_f>
}
   1c234:	03c12083          	lw	ra,60(sp)
   1c238:	04010113          	addi	sp,sp,64
   1c23c:	00008067          	ret

0001c240 <__gtsf2>:
   1c240:	fa9ff06f          	j	1c1e8 <__gesf2>

0001c244 <__lesf2>:
#endif /* L_lt_sf || L_lt_df */

#if defined(L_le_sf) || defined(L_le_df) || defined(L_le_tf)
CMPtype
_le_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1c244:	fc010113          	addi	sp,sp,-64
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1c248:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1c24c:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1c250:	00810513          	addi	a0,sp,8
   1c254:	01010593          	addi	a1,sp,16
#endif /* L_lt_sf || L_lt_df */

#if defined(L_le_sf) || defined(L_le_df) || defined(L_le_tf)
CMPtype
_le_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1c258:	02112e23          	sw	ra,60(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1c25c:	a35ff0ef          	jal	1bc90 <__unpack_f>
  unpack_d (&bu, &b);
   1c260:	00c10513          	addi	a0,sp,12
   1c264:	02010593          	addi	a1,sp,32
   1c268:	a29ff0ef          	jal	1bc90 <__unpack_f>

  if (isnan (&a) || isnan (&b))
   1c26c:	01012783          	lw	a5,16(sp)
   1c270:	00100513          	li	a0,1
   1c274:	00f57c63          	bleu	a5,a0,1c28c <__lesf2+0x48>
   1c278:	02012783          	lw	a5,32(sp)
   1c27c:	00f57863          	bleu	a5,a0,1c28c <__lesf2+0x48>
    return 1;			/* false, truth <= 0 */

  return __fpcmp_parts (&a, &b) ;
   1c280:	02010593          	addi	a1,sp,32
   1c284:	01010513          	addi	a0,sp,16
   1c288:	e4dff0ef          	jal	1c0d4 <__fpcmp_parts_f>
}
   1c28c:	03c12083          	lw	ra,60(sp)
   1c290:	04010113          	addi	sp,sp,64
   1c294:	00008067          	ret

0001c298 <__ltsf2>:
   1c298:	fadff06f          	j	1c244 <__lesf2>

0001c29c <__nesf2>:
   1c29c:	fa9ff06f          	j	1c244 <__lesf2>

0001c2a0 <__eqsf2>:
   1c2a0:	fa5ff06f          	j	1c244 <__lesf2>

0001c2a4 <__unordsf2>:
#endif /* L_le_sf || L_le_df */

#if defined(L_unord_sf) || defined(L_unord_df) || defined(L_unord_tf)
CMPtype
_unord_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1c2a4:	fc010113          	addi	sp,sp,-64
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1c2a8:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1c2ac:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1c2b0:	00810513          	addi	a0,sp,8
   1c2b4:	01010593          	addi	a1,sp,16
#endif /* L_le_sf || L_le_df */

#if defined(L_unord_sf) || defined(L_unord_df) || defined(L_unord_tf)
CMPtype
_unord_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1c2b8:	02112e23          	sw	ra,60(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1c2bc:	9d5ff0ef          	jal	1bc90 <__unpack_f>
  unpack_d (&bu, &b);
   1c2c0:	00c10513          	addi	a0,sp,12
   1c2c4:	02010593          	addi	a1,sp,32
   1c2c8:	9c9ff0ef          	jal	1bc90 <__unpack_f>

  return (isnan (&a) || isnan (&b));
   1c2cc:	01012783          	lw	a5,16(sp)
   1c2d0:	00100513          	li	a0,1
   1c2d4:	00f57663          	bleu	a5,a0,1c2e0 <__unordsf2+0x3c>
   1c2d8:	02012503          	lw	a0,32(sp)
   1c2dc:	00253513          	sltiu	a0,a0,2
}
   1c2e0:	03c12083          	lw	ra,60(sp)
   1c2e4:	04010113          	addi	sp,sp,64
   1c2e8:	00008067          	ret

0001c2ec <__floatsisf>:
#endif /* L_unord_sf || L_unord_df */

#if defined(L_si_to_sf) || defined(L_si_to_df) || defined(L_si_to_tf)
FLO_type
si_to_float (SItype arg_a)
{
   1c2ec:	fe010113          	addi	sp,sp,-32
  fp_number_type in;

  in.class = CLASS_NUMBER;
  in.sign = arg_a < 0;
   1c2f0:	01f55793          	srli	a5,a0,0x1f
FLO_type
si_to_float (SItype arg_a)
{
  fp_number_type in;

  in.class = CLASS_NUMBER;
   1c2f4:	00300713          	li	a4,3
#endif /* L_unord_sf || L_unord_df */

#if defined(L_si_to_sf) || defined(L_si_to_df) || defined(L_si_to_tf)
FLO_type
si_to_float (SItype arg_a)
{
   1c2f8:	00112e23          	sw	ra,28(sp)
   1c2fc:	00812c23          	sw	s0,24(sp)
  fp_number_type in;

  in.class = CLASS_NUMBER;
   1c300:	00e12023          	sw	a4,0(sp)
  in.sign = arg_a < 0;
   1c304:	00f12223          	sw	a5,4(sp)
  if (!arg_a)
   1c308:	02051263          	bnez	a0,1c32c <__floatsisf+0x40>
    {
      in.class = CLASS_ZERO;
   1c30c:	00200793          	li	a5,2
   1c310:	00f12023          	sw	a5,0(sp)
	{
	  in.fraction.ll <<= shift;
	  in.normal_exp -= shift;
	}
    }
  return pack_d (&in);
   1c314:	00010513          	mv	a0,sp
   1c318:	81dff0ef          	jal	1bb34 <__pack_f>
}
   1c31c:	01c12083          	lw	ra,28(sp)
   1c320:	01812403          	lw	s0,24(sp)
   1c324:	02010113          	addi	sp,sp,32
   1c328:	00008067          	ret
    }
  else
    {
      USItype uarg;
      int shift;
      in.normal_exp = FRACBITS + NGARDS;
   1c32c:	01e00793          	li	a5,30
   1c330:	00f12423          	sw	a5,8(sp)
      if (in.sign) 
   1c334:	02054863          	bltz	a0,1c364 <__floatsisf+0x78>
	      return (FLO_type)(- MAX_SI_INT - 1);
	    }
	  uarg = (-arg_a);
	}
      else
	uarg = arg_a;
   1c338:	00050413          	mv	s0,a0
static int
clzusi (USItype n)
{
  extern int __clzsi2 (USItype);
  if (sizeof (USItype) == sizeof (unsigned int))
    return __builtin_clz (n);
   1c33c:	00040513          	mv	a0,s0
   1c340:	dbcff0ef          	jal	1b8fc <__clzsi2>
	}
      else
	uarg = arg_a;

      in.fraction.ll = uarg;
      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
   1c344:	fff50793          	addi	a5,a0,-1
      if (shift > 0)
   1c348:	02078c63          	beqz	a5,1c380 <__floatsisf+0x94>
	{
	  in.fraction.ll <<= shift;
	  in.normal_exp -= shift;
   1c34c:	01e00713          	li	a4,30

      in.fraction.ll = uarg;
      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
      if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1c350:	00f41533          	sll	a0,s0,a5
	  in.normal_exp -= shift;
   1c354:	40f707b3          	sub	a5,a4,a5

      in.fraction.ll = uarg;
      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
      if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1c358:	00a12623          	sw	a0,12(sp)
	  in.normal_exp -= shift;
   1c35c:	00f12423          	sw	a5,8(sp)
   1c360:	fb5ff06f          	j	1c314 <__floatsisf+0x28>
      in.normal_exp = FRACBITS + NGARDS;
      if (in.sign) 
	{
	  /* Special case for minint, since there is no +ve integer
	     representation for it */
	  if (arg_a == (- MAX_SI_INT - 1))
   1c364:	800007b7          	lui	a5,0x80000
   1c368:	02f50063          	beq	a0,a5,1c388 <__floatsisf+0x9c>
	    {
	      return (FLO_type)(- MAX_SI_INT - 1);
	    }
	  uarg = (-arg_a);
   1c36c:	40a00433          	neg	s0,a0
static int
clzusi (USItype n)
{
  extern int __clzsi2 (USItype);
  if (sizeof (USItype) == sizeof (unsigned int))
    return __builtin_clz (n);
   1c370:	00040513          	mv	a0,s0
   1c374:	d88ff0ef          	jal	1b8fc <__clzsi2>
	}
      else
	uarg = arg_a;

      in.fraction.ll = uarg;
      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
   1c378:	fff50793          	addi	a5,a0,-1
      if (shift > 0)
   1c37c:	fc0798e3          	bnez	a5,1c34c <__floatsisf+0x60>
	  uarg = (-arg_a);
	}
      else
	uarg = arg_a;

      in.fraction.ll = uarg;
   1c380:	00812623          	sw	s0,12(sp)
   1c384:	f91ff06f          	j	1c314 <__floatsisf+0x28>
	{
	  /* Special case for minint, since there is no +ve integer
	     representation for it */
	  if (arg_a == (- MAX_SI_INT - 1))
	    {
	      return (FLO_type)(- MAX_SI_INT - 1);
   1c388:	8781a503          	lw	a0,-1928(gp) # 1ed48 <__wctomb+0x58>
   1c38c:	f91ff06f          	j	1c31c <__floatsisf+0x30>

0001c390 <__floatunsisf>:
#endif /* L_si_to_sf || L_si_to_df */

#if defined(L_usi_to_sf) || defined(L_usi_to_df) || defined(L_usi_to_tf)
FLO_type
usi_to_float (USItype arg_a)
{
   1c390:	fe010113          	addi	sp,sp,-32
   1c394:	00112e23          	sw	ra,28(sp)
   1c398:	00812c23          	sw	s0,24(sp)
   1c39c:	00912a23          	sw	s1,20(sp)
  fp_number_type in;

  in.sign = 0;
   1c3a0:	00012223          	sw	zero,4(sp)
  if (!arg_a)
   1c3a4:	04050a63          	beqz	a0,1c3f8 <__floatunsisf+0x68>
      in.class = CLASS_ZERO;
    }
  else
    {
      int shift;
      in.class = CLASS_NUMBER;
   1c3a8:	00300793          	li	a5,3
      in.normal_exp = FRACBITS + NGARDS;
   1c3ac:	01e00493          	li	s1,30
      in.class = CLASS_ZERO;
    }
  else
    {
      int shift;
      in.class = CLASS_NUMBER;
   1c3b0:	00f12023          	sw	a5,0(sp)
   1c3b4:	00050413          	mv	s0,a0
      in.normal_exp = FRACBITS + NGARDS;
   1c3b8:	00912423          	sw	s1,8(sp)
static int
clzusi (USItype n)
{
  extern int __clzsi2 (USItype);
  if (sizeof (USItype) == sizeof (unsigned int))
    return __builtin_clz (n);
   1c3bc:	d40ff0ef          	jal	1b8fc <__clzsi2>
      in.class = CLASS_NUMBER;
      in.normal_exp = FRACBITS + NGARDS;
      in.fraction.ll = arg_a;

      shift = clzusi (arg_a) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
      if (shift < 0)
   1c3c0:	fff50793          	addi	a5,a0,-1
   1c3c4:	04050063          	beqz	a0,1c404 <__floatunsisf+0x74>
	  fractype guard = in.fraction.ll & (((fractype)1 << -shift) - 1);
	  in.fraction.ll >>= -shift;
	  in.fraction.ll |= (guard != 0);
	  in.normal_exp -= shift;
	}
      else if (shift > 0)
   1c3c8:	04078c63          	beqz	a5,1c420 <__floatunsisf+0x90>
	{
	  in.fraction.ll <<= shift;
   1c3cc:	00f41433          	sll	s0,s0,a5
	  in.normal_exp -= shift;
   1c3d0:	40f484b3          	sub	s1,s1,a5
	  in.fraction.ll |= (guard != 0);
	  in.normal_exp -= shift;
	}
      else if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1c3d4:	00812623          	sw	s0,12(sp)
	  in.normal_exp -= shift;
   1c3d8:	00912423          	sw	s1,8(sp)
	}
    }
  return pack_d (&in);
   1c3dc:	00010513          	mv	a0,sp
   1c3e0:	f54ff0ef          	jal	1bb34 <__pack_f>
}
   1c3e4:	01c12083          	lw	ra,28(sp)
   1c3e8:	01812403          	lw	s0,24(sp)
   1c3ec:	01412483          	lw	s1,20(sp)
   1c3f0:	02010113          	addi	sp,sp,32
   1c3f4:	00008067          	ret
  fp_number_type in;

  in.sign = 0;
  if (!arg_a)
    {
      in.class = CLASS_ZERO;
   1c3f8:	00200793          	li	a5,2
   1c3fc:	00f12023          	sw	a5,0(sp)
   1c400:	fddff06f          	j	1c3dc <__floatunsisf+0x4c>
      shift = clzusi (arg_a) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
      if (shift < 0)
	{
	  fractype guard = in.fraction.ll & (((fractype)1 << -shift) - 1);
	  in.fraction.ll >>= -shift;
	  in.fraction.ll |= (guard != 0);
   1c404:	00147793          	andi	a5,s0,1
   1c408:	00145413          	srli	s0,s0,0x1
   1c40c:	0087e433          	or	s0,a5,s0
	  in.normal_exp -= shift;
   1c410:	01f00793          	li	a5,31
      shift = clzusi (arg_a) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
      if (shift < 0)
	{
	  fractype guard = in.fraction.ll & (((fractype)1 << -shift) - 1);
	  in.fraction.ll >>= -shift;
	  in.fraction.ll |= (guard != 0);
   1c414:	00812623          	sw	s0,12(sp)
	  in.normal_exp -= shift;
   1c418:	00f12423          	sw	a5,8(sp)
   1c41c:	fc1ff06f          	j	1c3dc <__floatunsisf+0x4c>
  else
    {
      int shift;
      in.class = CLASS_NUMBER;
      in.normal_exp = FRACBITS + NGARDS;
      in.fraction.ll = arg_a;
   1c420:	00812623          	sw	s0,12(sp)
   1c424:	fb9ff06f          	j	1c3dc <__floatunsisf+0x4c>

0001c428 <__fixsfsi>:
#endif

#if defined(L_sf_to_si) || defined(L_df_to_si) || defined(L_tf_to_si)
SItype
float_to_si (FLO_type arg_a)
{
   1c428:	fd010113          	addi	sp,sp,-48
  fp_number_type a;
  SItype tmp;
  FLO_union_type au;

  au.value = arg_a;
   1c42c:	00a12623          	sw	a0,12(sp)
  unpack_d (&au, &a);
   1c430:	01010593          	addi	a1,sp,16
   1c434:	00c10513          	addi	a0,sp,12
#endif

#if defined(L_sf_to_si) || defined(L_df_to_si) || defined(L_tf_to_si)
SItype
float_to_si (FLO_type arg_a)
{
   1c438:	02112623          	sw	ra,44(sp)
  fp_number_type a;
  SItype tmp;
  FLO_union_type au;

  au.value = arg_a;
  unpack_d (&au, &a);
   1c43c:	855ff0ef          	jal	1bc90 <__unpack_f>
   1c440:	01012783          	lw	a5,16(sp)

  if (iszero (&a))
    return 0;
  if (isnan (&a))
   1c444:	00200713          	li	a4,2
   1c448:	04f77e63          	bleu	a5,a4,1c4a4 <__fixsfsi+0x7c>
    return 0;
  /* get reasonable MAX_SI_INT...  */
  if (isinf (&a))
   1c44c:	00400713          	li	a4,4
   1c450:	00e78a63          	beq	a5,a4,1c464 <__fixsfsi+0x3c>
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  /* it is a number, but a small one */
  if (a.normal_exp < 0)
   1c454:	01812783          	lw	a5,24(sp)
   1c458:	0407c663          	bltz	a5,1c4a4 <__fixsfsi+0x7c>
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
   1c45c:	01e00513          	li	a0,30
   1c460:	02f55063          	ble	a5,a0,1c480 <__fixsfsi+0x58>
    return 0;
  if (isnan (&a))
    return 0;
  /* get reasonable MAX_SI_INT...  */
  if (isinf (&a))
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
   1c464:	01412783          	lw	a5,20(sp)
   1c468:	80000537          	lui	a0,0x80000
   1c46c:	00079463          	bnez	a5,1c474 <__fixsfsi+0x4c>
   1c470:	fff54513          	not	a0,a0
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
  return a.sign ? (-tmp) : (tmp);
}
   1c474:	02c12083          	lw	ra,44(sp)
   1c478:	03010113          	addi	sp,sp,48
   1c47c:	00008067          	ret
  /* it is a number, but a small one */
  if (a.normal_exp < 0)
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
   1c480:	40f50533          	sub	a0,a0,a5
  return a.sign ? (-tmp) : (tmp);
   1c484:	01c12783          	lw	a5,28(sp)
   1c488:	00a7d533          	srl	a0,a5,a0
   1c48c:	01412783          	lw	a5,20(sp)
   1c490:	fe0782e3          	beqz	a5,1c474 <__fixsfsi+0x4c>
}
   1c494:	02c12083          	lw	ra,44(sp)
  if (a.normal_exp < 0)
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
  return a.sign ? (-tmp) : (tmp);
   1c498:	40a00533          	neg	a0,a0
}
   1c49c:	03010113          	addi	sp,sp,48
   1c4a0:	00008067          	ret
   1c4a4:	02c12083          	lw	ra,44(sp)
  unpack_d (&au, &a);

  if (iszero (&a))
    return 0;
  if (isnan (&a))
    return 0;
   1c4a8:	00000513          	li	a0,0
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
  return a.sign ? (-tmp) : (tmp);
}
   1c4ac:	03010113          	addi	sp,sp,48
   1c4b0:	00008067          	ret

0001c4b4 <__negsf2>:
#endif /* L_tf_to_usi */

#if defined(L_negate_sf) || defined(L_negate_df) || defined(L_negate_tf)
FLO_type
negate (FLO_type arg_a)
{
   1c4b4:	fd010113          	addi	sp,sp,-48
  fp_number_type a;
  FLO_union_type au;

  au.value = arg_a;
   1c4b8:	00a12623          	sw	a0,12(sp)
  unpack_d (&au, &a);
   1c4bc:	01010593          	addi	a1,sp,16
   1c4c0:	00c10513          	addi	a0,sp,12
#endif /* L_tf_to_usi */

#if defined(L_negate_sf) || defined(L_negate_df) || defined(L_negate_tf)
FLO_type
negate (FLO_type arg_a)
{
   1c4c4:	02112623          	sw	ra,44(sp)
  fp_number_type a;
  FLO_union_type au;

  au.value = arg_a;
  unpack_d (&au, &a);
   1c4c8:	fc8ff0ef          	jal	1bc90 <__unpack_f>

INLINE 
static void
flip_sign ( fp_number_type *  x)
{
  x->sign = !x->sign;
   1c4cc:	01412783          	lw	a5,20(sp)

  au.value = arg_a;
  unpack_d (&au, &a);

  flip_sign (&a);
  return pack_d (&a);
   1c4d0:	01010513          	addi	a0,sp,16

INLINE 
static void
flip_sign ( fp_number_type *  x)
{
  x->sign = !x->sign;
   1c4d4:	0017b793          	seqz	a5,a5
   1c4d8:	00f12a23          	sw	a5,20(sp)

  au.value = arg_a;
  unpack_d (&au, &a);

  flip_sign (&a);
  return pack_d (&a);
   1c4dc:	e58ff0ef          	jal	1bb34 <__pack_f>
}
   1c4e0:	02c12083          	lw	ra,44(sp)
   1c4e4:	03010113          	addi	sp,sp,48
   1c4e8:	00008067          	ret

0001c4ec <__make_fp>:
SFtype
__make_fp(fp_class_type class,
	     unsigned int sign,
	     int exp, 
	     USItype frac)
{
   1c4ec:	fe010113          	addi	sp,sp,-32
  fp_number_type in;

  in.class = class;
   1c4f0:	00a12023          	sw	a0,0(sp)
  in.sign = sign;
  in.normal_exp = exp;
  in.fraction.ll = frac;
  return pack_d (&in);
   1c4f4:	00010513          	mv	a0,sp
SFtype
__make_fp(fp_class_type class,
	     unsigned int sign,
	     int exp, 
	     USItype frac)
{
   1c4f8:	00112e23          	sw	ra,28(sp)
  fp_number_type in;

  in.class = class;
  in.sign = sign;
   1c4fc:	00b12223          	sw	a1,4(sp)
  in.normal_exp = exp;
   1c500:	00c12423          	sw	a2,8(sp)
  in.fraction.ll = frac;
   1c504:	00d12623          	sw	a3,12(sp)
  return pack_d (&in);
   1c508:	e2cff0ef          	jal	1bb34 <__pack_f>
}
   1c50c:	01c12083          	lw	ra,28(sp)
   1c510:	02010113          	addi	sp,sp,32
   1c514:	00008067          	ret

0001c518 <__extendsfdf2>:
   are 8-bytes in size, so we just don't support double for them at all.  */

#if defined(L_sf_to_df)
DFtype
sf_to_df (SFtype arg_a)
{
   1c518:	fd010113          	addi	sp,sp,-48
  fp_number_type in;
  FLO_union_type au;

  au.value = arg_a;
   1c51c:	00a12623          	sw	a0,12(sp)
  unpack_d (&au, &in);
   1c520:	01010593          	addi	a1,sp,16
   1c524:	00c10513          	addi	a0,sp,12
   are 8-bytes in size, so we just don't support double for them at all.  */

#if defined(L_sf_to_df)
DFtype
sf_to_df (SFtype arg_a)
{
   1c528:	02112623          	sw	ra,44(sp)
  fp_number_type in;
  FLO_union_type au;

  au.value = arg_a;
  unpack_d (&au, &in);
   1c52c:	f64ff0ef          	jal	1bc90 <__unpack_f>

  return __make_dp (in.class, in.sign, in.normal_exp,
   1c530:	01c12783          	lw	a5,28(sp)
   1c534:	01812603          	lw	a2,24(sp)
   1c538:	01412583          	lw	a1,20(sp)
   1c53c:	01012503          	lw	a0,16(sp)
   1c540:	01e79713          	slli	a4,a5,0x1e
   1c544:	0027d793          	srli	a5,a5,0x2
   1c548:	b2cff0ef          	jal	1b874 <__make_dp>
		    ((UDItype) in.fraction.ll) << F_D_BITOFF);
}
   1c54c:	02c12083          	lw	ra,44(sp)
   1c550:	03010113          	addi	sp,sp,48
   1c554:	00008067          	ret

Disassembly of section .startup:

00000000 <_reset-0x200>:
	...

00000200 <_reset>:
 200:	00100137          	lui	sp,0x100
 204:	00016113          	ori	sp,sp,0
 208:	00012023          	sw	zero,0(sp) # 100000 <_gp+0xe0b30>
 20c:	fe012e23          	sw	zero,-4(sp)
 210:	00003437          	lui	s0,0x3
 214:	00640413          	addi	s0,s0,6 # 3006 <_reset+0x2e06>
 218:	30041073          	csrw	mstatus,s0
 21c:	10000413          	li	s0,256
 220:	0c042023          	sw	zero,192(s0)
 224:	30141073          	csrw	mtvec,s0
 228:	5d90f06f          	j	10000 <_ftext>
