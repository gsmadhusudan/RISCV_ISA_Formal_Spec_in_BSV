
print:     file format elf32-littleriscv
print
architecture: riscv, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000200

Program Header:
    LOAD off    0x00001000 vaddr 0x00000000 paddr 0x00000000 align 2**12
         filesz 0x0000022c memsz 0x0000022c flags r-x
    LOAD off    0x00002000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x0000debc memsz 0x0000df28 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000bb78  00010000  00010000  00002000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000610  0001bb78  0001bb78  0000db78  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init_array   00000008  0001c188  0001c188  0000e188  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .fini_array   00000004  0001c190  0001c190  0000e190  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .eh_frame     000013dc  0001c194  0001c194  0000e194  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .jcr          00000004  0001d570  0001d570  0000f570  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         000008c0  0001d580  0001d580  0000f580  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  7 .sdata        0000007c  0001de40  0001de40  0000fe40  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  8 .sbss         0000001c  0001dec0  0001dec0  0000febc  2**2
                  ALLOC
  9 .bss          0000004c  0001dedc  0001dedc  0000febc  2**2
                  ALLOC
 10 .startup      0000022c  00000000  00000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .comment      00000011  00000000  00000000  0000febc  2**0
                  CONTENTS, READONLY
 12 .debug_info   0001864b  00000000  00000000  0000fecd  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 000053aa  00000000  00000000  00028518  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00000590  00000000  00000000  0002d8c2  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00011021  00000000  00000000  0002de52  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00002a40  00000000  00000000  0003ee73  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    000118a3  00000000  00000000  000418b3  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00000b50  00000000  00000000  00053156  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
0001bb78 l    d  .rodata	00000000 .rodata
0001c188 l    d  .init_array	00000000 .init_array
0001c190 l    d  .fini_array	00000000 .fini_array
0001c194 l    d  .eh_frame	00000000 .eh_frame
0001d570 l    d  .jcr	00000000 .jcr
0001d580 l    d  .data	00000000 .data
0001de40 l    d  .sdata	00000000 .sdata
0001dec0 l    d  .sbss	00000000 .sbss
0001dedc l    d  .bss	00000000 .bss
00000000 l    d  .startup	00000000 .startup
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 crtstuff.c
0001c194 l     O .eh_frame	00000000 __EH_FRAME_BEGIN__
0001d570 l     O .jcr	00000000 __JCR_LIST__
0001004c l     F .text	00000000 deregister_tm_clones
00010078 l     F .text	00000000 register_tm_clones
000100b0 l     F .text	00000000 __do_global_dtors_aux
0001dedc l     O .bss	00000001 completed.3082
0001c190 l     O .fini_array	00000000 __do_global_dtors_aux_fini_array_entry
000100f4 l     F .text	00000000 frame_dummy
0001dee0 l     O .bss	00000018 object.3087
0001c188 l     O .init_array	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 syscalls.c
0001def8 l     O .bss	00000004 heap_end.1982
00000000 l    df *ABS*	00000000 htif.c
000106e4 l     F .text	00000068 htif_tohost
0001074c l     F .text	00000044 htif_fromhost
00000000 l    df *ABS*	00000000 riscv_counters.c
00000000 l    df *ABS*	00000000 ns16550.c
0001de48 l     O .sdata	00000004 pio
000108d4 l     F .text	000000b0 ns16550_init
00000000 l    df *ABS*	00000000 print.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
00013514 l     F .text	000000bc __sbprintf
0001be28 l     O .rodata	00000010 blanks.4190
0001be38 l     O .rodata	00000010 zeroes.4191
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 dtoa.c
0001381c l     F .text	000001e8 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
00015228 l     F .text	00000008 __fp_unlock
0001523c l     F .text	0000018c __sinit.part.1
000153cc l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
0001d580 l     O .data	00000440 impure_data
00000000 l    df *ABS*	00000000 locale.c
0001d9c0 l     O .data	00000020 lc_ctype_charset
0001d9e0 l     O .data	00000020 lc_message_charset
0001da00 l     O .data	00000038 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 mprec.c
0001be48 l     O .rodata	0000000c p05.2565
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 vfprintf.c
000185cc l     F .text	000000e8 __sprint_r.part.0
000196f4 l     F .text	000000bc __sbprintf
0001c0d4 l     O .rodata	00000010 blanks.4133
0001c0e4 l     O .rodata	00000010 zeroes.4134
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 dp-bit.c
00019ea0 l     F .text	00000350 _fpadd_parts
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
0001af8c l     F .text	000001c8 _fpadd_parts
00000000 l    df *ABS*	00000000 crtstuff.c
0001d56c l     O .eh_frame	00000000 __FRAME_END__
0001d570 l     O .jcr	00000000 __JCR_END__
00000000 l    df *ABS*	00000000 
0001c194 l       .fini_array	00000000 __fini_array_end
0001c190 l       .fini_array	00000000 __fini_array_start
0001c190 l       .init_array	00000000 __init_array_end
0001c188 l       .init_array	00000000 __preinit_array_end
0001c188 l       .init_array	00000000 __init_array_start
0001c188 l       .init_array	00000000 __preinit_array_start
00017be8 g     F .text	00000078 _mprec_log10
00017cc8 g     F .text	00000084 __any_on
0001bf20 g     O .rodata	00000028 __mprec_tinytens
00011688 g     F .text	000000b0 _puts_r
0001aaf0 g     F .text	00000048 .hidden __cmpdf2
0001ac00 g     F .text	00000004 .hidden __eqdf2
00010b80 g     F .text	000004d0 .hidden __divdi3
00010a78 g     F .text	000000dc print
00011638 g     F .text	00000050 printf
0001d580 g       .data	00000000 _fdata
00019cd8 g     F .text	00000094 _wcrtomb_r
00018444 g     F .text	00000068 __sseek
0001555c g     F .text	00000010 __sinit
00019b68 g     F .text	00000160 __swbuf_r
00015f80 g     F .text	00000078 _setlocale_r
000153d4 g     F .text	00000070 __sfmoreglue
00016d44 g     F .text	00000004 __malloc_unlock
0001b5c8 g     F .text	0000012c .hidden __divsf3
00016b44 g     F .text	00000120 memmove
0001554c g     F .text	00000010 _cleanup
00016d48 g     F .text	000000a4 _Balloc
0001ba48 g     F .text	0000008c .hidden __fixsfsi
0001ab98 g     F .text	00000004 .hidden __gtdf2
00010838 g     F .text	00000034 read_cycle
00010464 g     F .text	00000024 times
0001df24 g     O .bss	00000004 errno
0001ae94 g     F .text	00000030 .hidden __make_dp
000183c4 g     F .text	00000008 __seofread
0001c188 g       .rodata	00000000 _etext
0001bb0c g     F .text	0000002c .hidden __make_fp
0001e640 g       *ABS*	00000000 _gp
0001b3d0 g     F .text	00000054 .hidden __subsf3
00010178 g     F .text	00000034 execve
00010208 g     F .text	00000020 getpid
00016a24 g     F .text	00000120 memcpy
0001de40 g     O .sdata	00000000 .hidden __TMC_END__
00015230 g     F .text	0000000c _cleanup_r
0001ac54 g     F .text	000000c0 .hidden __floatsidf
0001abf8 g     F .text	00000004 .hidden __ltdf2
00011738 g     F .text	0000000c puts
000182d4 g     F .text	00000074 __fpclassifyd
00017b3c g     F .text	000000ac __ratio
00010984 g     F .text	00000034 ns16550_rxready
00000000  w      *UND*	00000000 malloc
000115f4 g     F .text	00000044 _printf_r
00010228 g     F .text	00000024 isatty
0001be58 g     O .rodata	000000c8 __mprec_tens
00010644 g     F .text	000000a0 sleep
00015ff8 g     F .text	0000000c __locale_charset
0001b864 g     F .text	00000050 .hidden __lesf2
0001dedc g       .bss	00000000 _bss_start
0001ded8 g     O .sbss	00000004 __malloc_top_pad
000109f8 g     F .text	0000004c ns16550_txchar
0001de40 g     O .sdata	00000000 .hidden __dso_handle
0001de54 g     O .sdata	00000004 __mb_cur_max
00016020 g     F .text	0000000c _localeconv_r
00010790 g     F .text	00000040 htif_putc
00017150 g     F .text	00000034 __i2b
00015978 g     F .text	00000498 __sfvwrite_r
0001a434 g     F .text	00000120 .hidden __unpack_d
00019868 g     F .text	000000f0 _fclose_r
00015208 g     F .text	00000020 fflush
0001ded4 g     O .sbss	00000004 __malloc_max_sbrked_mem
0001bb38 g     F .text	00000040 .hidden __extendsfdf2
0001a554 g     F .text	00000050 .hidden __adddf3
0001b8bc g     F .text	00000004 .hidden __nesf2
000178c8 g     F .text	00000130 __b2d
000102ac g     F .text	0000002c lseek
0001de4c g     O .sdata	00000004 _global_impure_ptr
00017d4c g     F .text	00000588 _realloc_r
00011554 g     F .text	000000a0 __libc_init_array
00019ac4 g     F .text	00000028 _fputwc_r
0001bf48 g     O .rodata	00000028 __mprec_bigtens
00016f20 g     F .text	00000104 __s2b
0001ad14 g     F .text	00000088 .hidden __floatunsidf
000175fc g     F .text	00000060 __mcmp
0001557c g     F .text	00000010 __fp_lock_all
0001086c g     F .text	00000034 read_time
00010048 g       .text	00000000 _init
000114f4 g     F .text	00000060 __libc_fini_array
0001b2b0 g     F .text	000000d8 .hidden __unpack_f
00017024 g     F .text	0000007c __hi0bits
0001ad9c g     F .text	000000bc .hidden __fixdfsi
000104e0 g     F .text	0000006c write
0001b860 g     F .text	00000004 .hidden __gtsf2
0001de44 g     O .sdata	00000004 environ
000101d4 g     F .text	00000034 fstat
0001024c g     F .text	00000030 kill
0001ab9c g     F .text	00000058 .hidden __ledf2
00017374 g     F .text	00000138 __pow5mult
0001decc g     O .sbss	00000004 __nlocale_changed
00000000  w      *UND*	00000000 __deregister_frame_info
0001b154 g     F .text	0000015c .hidden __pack_f
00000000  w      *UND*	00000000 _ITM_registerTMCloneTable
0001af1c g     F .text	00000070 .hidden __clzsi2
0001556c g     F .text	00000000 __sfp_lock_acquire
00016950 g     F .text	000000d4 memchr
0001569c g     F .text	000002dc _free_r
000104b4 g     F .text	0000002c wait
00016004 g     F .text	00000008 __locale_mb_cur_max
0001dec8 g     O .sbss	00000004 __mlocale_changed
00010000 g       .text	00000000 _ftext
0001de58 g     O .sdata	00000004 __malloc_sbrk_base
00010000 g       .text	00000000 _start
000174ac g     F .text	00000150 __lshift
00010304 g     F .text	000000bc read
0001b90c g     F .text	000000a4 .hidden __floatsisf
00013728 g     F .text	000000f4 __register_exitproc
000108a0 g     F .text	00000034 read_instret
00017184 g     F .text	000001f0 __multiply
0001defc g     O .bss	00000028 __malloc_current_mallinfo
00010488 g     F .text	0000002c unlink
0001b8c0 g     F .text	00000004 .hidden __eqsf2
000179f8 g     F .text	00000144 __d2b
0001aa08 g     F .text	000000e8 .hidden __fpcmp_parts_d
0001ae58 g     F .text	0000003c .hidden __negdf2
000101ac g     F .text	00000028 fork
000135d4 g     F .text	00000154 __swsetup_r
0001a864 g     F .text	000001a4 .hidden __divdf3
0001bad4 g     F .text	00000038 .hidden __negsf2
00015444 g     F .text	00000108 __sfp
00017c60 g     F .text	00000068 __copybits
0001da38 g     O .data	00000408 __malloc_av_
00015578 g     F .text	00000004 __sinit_lock_release
0001a600 g     F .text	00000264 .hidden __muldf3
00018348 g     F .text	0000007c __sread
0001dec0 g     O .sbss	00000004 __env
0001c110 g     O .rodata	00000010 .hidden __thenan_sf
00016d40 g     F .text	00000004 __malloc_lock
00000000  w      *UND*	00000000 _ITM_deregisterTMCloneTable
000103c0 g     F .text	00000070 sbrk
000151ac g     F .text	0000005c _fflush_r
000197b4 g     F .text	000000b4 _calloc_r
0001b7c8 g     F .text	00000040 .hidden __cmpsf2
0001054c g     F .text	000000f8 gettimeofday
00016c64 g       .text	00000000 memset
00010b54 g     F .text	0000002c main
0001ded0 g     O .sbss	00000004 __malloc_max_total_mem
00019cc8 g     F .text	00000010 __swbuf
0001b8b8 g     F .text	00000004 .hidden __ltsf2
000184b0 g     F .text	00000008 __sclose
00019958 g     F .text	0000000c fclose
0001aec4 g     F .text	00000058 .hidden __truncdfsf2
00013a04 g     F .text	00001518 _dtoa_r
000161d8 g     F .text	00000778 _malloc_r
00019e14 g     F .text	00000030 __ascii_wctomb
00015e10 g     F .text	000000b0 _fwalk
0001c0f8 g     O .rodata	00000018 .hidden __thenan_df
0001559c g     F .text	00000100 _malloc_trim_r
0001b424 g     F .text	000001a4 .hidden __mulsf3
000184b8 g       .text	00000000 strcmp
000196e0 g     F .text	00000014 vfiprintf
0001abfc g     F .text	00000004 .hidden __nedf2
00010048 g       .text	00000000 _fini
0001bbc4 g     O .rodata	00000100 .hidden __clz_tab
0001dec4 g     O .sbss	00000004 _PathLocale
000114e0 g     F .text	00000014 atexit
0001b808 g     F .text	00000058 .hidden __gesf2
0001602c g     F .text	00000010 setlocale
0001de50 g     O .sdata	00000004 _impure_ptr
00014f1c g     F .text	00000290 __sflush_r
00016018 g     F .text	00000008 __locale_cjk_lang
0001784c g     F .text	0000007c __ulp
0001558c g     F .text	00000010 __fp_unlock_all
0001603c g     F .text	00000008 localeconv
00010430 g     F .text	00000034 stat
00000200 g       .startup	00000000 _reset
0001de40 g       .data	00000000 _edata
0001df28 g       .bss	00000000 _end
0001b8c4 g     F .text	00000044 .hidden __unordsf2
00019964 g     F .text	00000160 __fputwc
000183cc g     F .text	00000078 __swrite
0001de5c g     O .sdata	00000004 __malloc_trim_threshold
0001027c g     F .text	00000030 link
0001600c g     F .text	0000000c __locale_msgcharset
00010140 g     F .text	00000014 exit
000186cc g     F .text	00001014 _vfiprintf_r
000107d0 g     F .text	00000068 htif_getc
00015ec0 g     F .text	000000c0 _fwalk_reent
0001b9b0 g     F .text	00000098 .hidden __floatunsisf
0001765c g     F .text	000001f0 __mdiff
00015570 g     F .text	00000004 __sfp_lock_release
0001ac04 g     F .text	0000004c .hidden __unorddf2
00011050 g     F .text	00000490 .hidden __moddi3
0001b6f4 g     F .text	000000d4 .hidden __fpcmp_parts_f
00016048 g     F .text	00000190 __smakebuf_r
00011744 g     F .text	00000090 strlen
000102d8 g     F .text	0000002c open
0001ab38 g     F .text	00000060 .hidden __gedf2
0001de60 g     O .sdata	00000004 __wctomb
000186b4 g     F .text	00000018 __sprint_r
00010a44 g     F .text	00000034 ns16550_flush
000109b8 g     F .text	00000040 ns16550_rxchar
00019e44 g     F .text	0000005c _wctomb_r
00000000  w      *UND*	00000000 _Jv_RegisterClasses
0001a5a4 g     F .text	0000005c .hidden __subdf3
000117d4 g     F .text	00001d2c _vfprintf_r
000170a0 g     F .text	000000b0 __lo0bits
0001dec0 g       .sbss	00000000 _fbss
00000000  w      *UND*	00000000 __register_frame_info
00019d6c g     F .text	000000a8 wcrtomb
00010154 g     F .text	00000024 close
0001b388 g     F .text	00000048 .hidden __addsf3
0001a1f0 g     F .text	00000244 .hidden __pack_d
00013500 g     F .text	00000014 vfprintf
00019aec g     F .text	00000078 fputwc
00015574 g     F .text	00000004 __sinit_lock_acquire
00016e10 g     F .text	00000110 __multadd
00016dec g     F .text	00000024 _Bfree



Disassembly of section .text:

00010000 <_ftext>:
   10000:	0000e197          	auipc	gp,0xe
   10004:	64018193          	addi	gp,gp,1600 # 1e640 <_gp>
   10008:	0000e297          	auipc	t0,0xe
   1000c:	eb828293          	addi	t0,t0,-328 # 1dec0 <__env>
   10010:	0000e317          	auipc	t1,0xe
   10014:	f1830313          	addi	t1,t1,-232 # 1df28 <_end>
   10018:	0002a023          	sw	zero,0(t0)
   1001c:	00428293          	addi	t0,t0,4
   10020:	fe62ece3          	bltu	t0,t1,10018 <_ftext+0x18>
   10024:	00001517          	auipc	a0,0x1
   10028:	4d050513          	addi	a0,a0,1232 # 114f4 <__libc_fini_array>
   1002c:	4b4010ef          	jal	114e0 <atexit>
   10030:	524010ef          	jal	11554 <__libc_init_array>
   10034:	00012503          	lw	a0,0(sp)
   10038:	00410593          	addi	a1,sp,4
   1003c:	00000613          	li	a2,0
   10040:	315000ef          	jal	10b54 <main>
   10044:	0fc0006f          	j	10140 <exit>

00010048 <_fini>:
   10048:	00008067          	ret

0001004c <deregister_tm_clones>:
   1004c:	80018713          	addi	a4,gp,-2048 # 1de40 <_edata>
   10050:	80318793          	addi	a5,gp,-2045 # 1de43 <_edata+0x3>
   10054:	40e787b3          	sub	a5,a5,a4
   10058:	00600713          	li	a4,6
   1005c:	00f77c63          	bleu	a5,a4,10074 <deregister_tm_clones+0x28>
   10060:	00000293          	li	t0,0
   10064:	00028863          	beqz	t0,10074 <deregister_tm_clones+0x28>
   10068:	80018513          	addi	a0,gp,-2048 # 1de40 <_edata>
   1006c:	00028313          	mv	t1,t0
   10070:	00030067          	jr	t1
   10074:	00008067          	ret

00010078 <register_tm_clones>:
   10078:	80018593          	addi	a1,gp,-2048 # 1de40 <_edata>
   1007c:	80018793          	addi	a5,gp,-2048 # 1de40 <_edata>
   10080:	40b787b3          	sub	a5,a5,a1
   10084:	4027d793          	srai	a5,a5,0x2
   10088:	01f7d593          	srli	a1,a5,0x1f
   1008c:	00f585b3          	add	a1,a1,a5
   10090:	4015d593          	srai	a1,a1,0x1
   10094:	00058c63          	beqz	a1,100ac <register_tm_clones+0x34>
   10098:	00000293          	li	t0,0
   1009c:	00028863          	beqz	t0,100ac <register_tm_clones+0x34>
   100a0:	80018513          	addi	a0,gp,-2048 # 1de40 <_edata>
   100a4:	00028313          	mv	t1,t0
   100a8:	00030067          	jr	t1
   100ac:	00008067          	ret

000100b0 <__do_global_dtors_aux>:
   100b0:	ff010113          	addi	sp,sp,-16
   100b4:	00812423          	sw	s0,8(sp)
   100b8:	89c1c783          	lbu	a5,-1892(gp) # 1dedc <_bss_start>
   100bc:	00112623          	sw	ra,12(sp)
   100c0:	02079263          	bnez	a5,100e4 <__do_global_dtors_aux+0x34>
   100c4:	f89ff0ef          	jal	1004c <deregister_tm_clones>
   100c8:	00000793          	li	a5,0
   100cc:	00078863          	beqz	a5,100dc <__do_global_dtors_aux+0x2c>
   100d0:	0001c537          	lui	a0,0x1c
   100d4:	19450513          	addi	a0,a0,404 # 1c194 <__fini_array_end>
   100d8:	f29ef0ef          	jal	0 <_reset-0x200>
   100dc:	00100793          	li	a5,1
   100e0:	88f18e23          	sb	a5,-1892(gp) # 1dedc <_bss_start>
   100e4:	00c12083          	lw	ra,12(sp)
   100e8:	00812403          	lw	s0,8(sp)
   100ec:	01010113          	addi	sp,sp,16
   100f0:	00008067          	ret

000100f4 <frame_dummy>:
   100f4:	ff010113          	addi	sp,sp,-16
   100f8:	00000793          	li	a5,0
   100fc:	00112623          	sw	ra,12(sp)
   10100:	00078a63          	beqz	a5,10114 <frame_dummy+0x20>
   10104:	0001c537          	lui	a0,0x1c
   10108:	8a018593          	addi	a1,gp,-1888 # 1dee0 <object.3087>
   1010c:	19450513          	addi	a0,a0,404 # 1c194 <__fini_array_end>
   10110:	ef1ef0ef          	jal	0 <_reset-0x200>
   10114:	0001d537          	lui	a0,0x1d
   10118:	57050513          	addi	a0,a0,1392 # 1d570 <__JCR_END__>
   1011c:	00052783          	lw	a5,0(a0)
   10120:	00079863          	bnez	a5,10130 <frame_dummy+0x3c>
   10124:	00c12083          	lw	ra,12(sp)
   10128:	01010113          	addi	sp,sp,16
   1012c:	f4dff06f          	j	10078 <register_tm_clones>
   10130:	00000793          	li	a5,0
   10134:	fe0788e3          	beqz	a5,10124 <frame_dummy+0x30>
   10138:	000780e7          	jalr	a5
   1013c:	fe9ff06f          	j	10124 <frame_dummy+0x30>

00010140 <exit>:
register char * stack_ptr asm ("sp");

#undef errno
int errno;

void exit (int status) {
   10140:	fe010113          	addi	sp,sp,-32
   10144:	00812e23          	sw	s0,28(sp)
   10148:	02010413          	addi	s0,sp,32
   1014c:	fea42623          	sw	a0,-20(s0)
  while (1)
    ;
   10150:	0000006f          	j	10150 <exit+0x10>

00010154 <close>:
}

int close(int file) {
   10154:	fe010113          	addi	sp,sp,-32
   10158:	00812e23          	sw	s0,28(sp)
   1015c:	02010413          	addi	s0,sp,32
   10160:	fea42623          	sw	a0,-20(s0)
  return -1;
   10164:	fff00793          	li	a5,-1
}
   10168:	00078513          	mv	a0,a5
   1016c:	01c12403          	lw	s0,28(sp)
   10170:	02010113          	addi	sp,sp,32
   10174:	00008067          	ret

00010178 <execve>:

char *__env[1] = { 0 };
char **environ = __env;

int execve(char *name, char **argv, char **env) {
   10178:	fe010113          	addi	sp,sp,-32
   1017c:	00812e23          	sw	s0,28(sp)
   10180:	02010413          	addi	s0,sp,32
   10184:	fea42623          	sw	a0,-20(s0)
   10188:	feb42423          	sw	a1,-24(s0)
   1018c:	fec42223          	sw	a2,-28(s0)
  errno = ENOMEM;
   10190:	00c00713          	li	a4,12
   10194:	8ee1a223          	sw	a4,-1820(gp) # 1df24 <errno>
  return -1;
   10198:	fff00793          	li	a5,-1
}
   1019c:	00078513          	mv	a0,a5
   101a0:	01c12403          	lw	s0,28(sp)
   101a4:	02010113          	addi	sp,sp,32
   101a8:	00008067          	ret

000101ac <fork>:

int fork(void) {
   101ac:	ff010113          	addi	sp,sp,-16
   101b0:	00812623          	sw	s0,12(sp)
   101b4:	01010413          	addi	s0,sp,16
  errno = EAGAIN;
   101b8:	00b00713          	li	a4,11
   101bc:	8ee1a223          	sw	a4,-1820(gp) # 1df24 <errno>
  return -1;
   101c0:	fff00793          	li	a5,-1
}
   101c4:	00078513          	mv	a0,a5
   101c8:	00c12403          	lw	s0,12(sp)
   101cc:	01010113          	addi	sp,sp,16
   101d0:	00008067          	ret

000101d4 <fstat>:

int fstat(int file, struct stat *st) {
   101d4:	fe010113          	addi	sp,sp,-32
   101d8:	00812e23          	sw	s0,28(sp)
   101dc:	02010413          	addi	s0,sp,32
   101e0:	fea42623          	sw	a0,-20(s0)
   101e4:	feb42423          	sw	a1,-24(s0)
  st->st_mode = S_IFCHR;
   101e8:	fe842783          	lw	a5,-24(s0)
   101ec:	00002737          	lui	a4,0x2
   101f0:	00e7a823          	sw	a4,16(a5)
  return 0;
   101f4:	00000793          	li	a5,0
}
   101f8:	00078513          	mv	a0,a5
   101fc:	01c12403          	lw	s0,28(sp)
   10200:	02010113          	addi	sp,sp,32
   10204:	00008067          	ret

00010208 <getpid>:

int getpid(void) {
   10208:	ff010113          	addi	sp,sp,-16
   1020c:	00812623          	sw	s0,12(sp)
   10210:	01010413          	addi	s0,sp,16
  return 1;
   10214:	00100793          	li	a5,1
}
   10218:	00078513          	mv	a0,a5
   1021c:	00c12403          	lw	s0,12(sp)
   10220:	01010113          	addi	sp,sp,16
   10224:	00008067          	ret

00010228 <isatty>:

int isatty(int file) {
   10228:	fe010113          	addi	sp,sp,-32
   1022c:	00812e23          	sw	s0,28(sp)
   10230:	02010413          	addi	s0,sp,32
   10234:	fea42623          	sw	a0,-20(s0)
  return 1;
   10238:	00100793          	li	a5,1
}
   1023c:	00078513          	mv	a0,a5
   10240:	01c12403          	lw	s0,28(sp)
   10244:	02010113          	addi	sp,sp,32
   10248:	00008067          	ret

0001024c <kill>:

int kill(int pid, int sig) {
   1024c:	fe010113          	addi	sp,sp,-32
   10250:	00812e23          	sw	s0,28(sp)
   10254:	02010413          	addi	s0,sp,32
   10258:	fea42623          	sw	a0,-20(s0)
   1025c:	feb42423          	sw	a1,-24(s0)
  errno = EINVAL;
   10260:	01600713          	li	a4,22
   10264:	8ee1a223          	sw	a4,-1820(gp) # 1df24 <errno>
  return -1;
   10268:	fff00793          	li	a5,-1
}
   1026c:	00078513          	mv	a0,a5
   10270:	01c12403          	lw	s0,28(sp)
   10274:	02010113          	addi	sp,sp,32
   10278:	00008067          	ret

0001027c <link>:

int link(char *old, char *new) {
   1027c:	fe010113          	addi	sp,sp,-32
   10280:	00812e23          	sw	s0,28(sp)
   10284:	02010413          	addi	s0,sp,32
   10288:	fea42623          	sw	a0,-20(s0)
   1028c:	feb42423          	sw	a1,-24(s0)
  errno = EMLINK;
   10290:	01f00713          	li	a4,31
   10294:	8ee1a223          	sw	a4,-1820(gp) # 1df24 <errno>
  return -1;
   10298:	fff00793          	li	a5,-1
}
   1029c:	00078513          	mv	a0,a5
   102a0:	01c12403          	lw	s0,28(sp)
   102a4:	02010113          	addi	sp,sp,32
   102a8:	00008067          	ret

000102ac <lseek>:

int lseek(int file, int ptr, int dir) {
   102ac:	fe010113          	addi	sp,sp,-32
   102b0:	00812e23          	sw	s0,28(sp)
   102b4:	02010413          	addi	s0,sp,32
   102b8:	fea42623          	sw	a0,-20(s0)
   102bc:	feb42423          	sw	a1,-24(s0)
   102c0:	fec42223          	sw	a2,-28(s0)
  return 0;
   102c4:	00000793          	li	a5,0
}
   102c8:	00078513          	mv	a0,a5
   102cc:	01c12403          	lw	s0,28(sp)
   102d0:	02010113          	addi	sp,sp,32
   102d4:	00008067          	ret

000102d8 <open>:

int open(const char *name, int flags, int mode) {
   102d8:	fe010113          	addi	sp,sp,-32
   102dc:	00812e23          	sw	s0,28(sp)
   102e0:	02010413          	addi	s0,sp,32
   102e4:	fea42623          	sw	a0,-20(s0)
   102e8:	feb42423          	sw	a1,-24(s0)
   102ec:	fec42223          	sw	a2,-28(s0)
  return -1;
   102f0:	fff00793          	li	a5,-1
}
   102f4:	00078513          	mv	a0,a5
   102f8:	01c12403          	lw	s0,28(sp)
   102fc:	02010113          	addi	sp,sp,32
   10300:	00008067          	ret

00010304 <read>:

int read(int file, char *ptr, int len) {
   10304:	fd010113          	addi	sp,sp,-48
   10308:	02112623          	sw	ra,44(sp)
   1030c:	02812423          	sw	s0,40(sp)
   10310:	02912223          	sw	s1,36(sp)
   10314:	03010413          	addi	s0,sp,48
   10318:	fca42e23          	sw	a0,-36(s0)
   1031c:	fcb42c23          	sw	a1,-40(s0)
   10320:	fcc42a23          	sw	a2,-44(s0)
  int todo;
  if(len == 0)
   10324:	fd442783          	lw	a5,-44(s0)
   10328:	00079663          	bnez	a5,10334 <read+0x30>
    return 0;
   1032c:	00000793          	li	a5,0
   10330:	0780006f          	j	103a8 <read+0xa4>
    // note: this is always blocking
    *ptr++ = htif_getc();
  }
#endif
#ifdef CONSOLE_UART
  *ptr++ = ns16550_rxchar();
   10334:	fd842483          	lw	s1,-40(s0)
   10338:	00148793          	addi	a5,s1,1
   1033c:	fcf42c23          	sw	a5,-40(s0)
   10340:	678000ef          	jal	109b8 <ns16550_rxchar>
   10344:	00050793          	mv	a5,a0
   10348:	0ff7f793          	andi	a5,a5,255
   1034c:	00f48023          	sb	a5,0(s1)
  for(todo = 1; todo < len; todo++) {
   10350:	00100793          	li	a5,1
   10354:	fef42623          	sw	a5,-20(s0)
   10358:	0380006f          	j	10390 <read+0x8c>
    if (!ns16550_rxready())
   1035c:	628000ef          	jal	10984 <ns16550_rxready>
   10360:	00050793          	mv	a5,a0
   10364:	02078e63          	beqz	a5,103a0 <read+0x9c>
      break;
    *ptr++ = ns16550_rxchar();
   10368:	fd842483          	lw	s1,-40(s0)
   1036c:	00148793          	addi	a5,s1,1
   10370:	fcf42c23          	sw	a5,-40(s0)
   10374:	644000ef          	jal	109b8 <ns16550_rxchar>
   10378:	00050793          	mv	a5,a0
   1037c:	0ff7f793          	andi	a5,a5,255
   10380:	00f48023          	sb	a5,0(s1)
    *ptr++ = htif_getc();
  }
#endif
#ifdef CONSOLE_UART
  *ptr++ = ns16550_rxchar();
  for(todo = 1; todo < len; todo++) {
   10384:	fec42783          	lw	a5,-20(s0)
   10388:	00178793          	addi	a5,a5,1
   1038c:	fef42623          	sw	a5,-20(s0)
   10390:	fec42703          	lw	a4,-20(s0)
   10394:	fd442783          	lw	a5,-44(s0)
   10398:	fcf742e3          	blt	a4,a5,1035c <read+0x58>
   1039c:	0080006f          	j	103a4 <read+0xa0>
    if (!ns16550_rxready())
      break;
   103a0:	00000013          	nop
    *ptr++ = ns16550_rxchar();
  }
#endif
  return todo;
   103a4:	fec42783          	lw	a5,-20(s0)
}
   103a8:	00078513          	mv	a0,a5
   103ac:	02c12083          	lw	ra,44(sp)
   103b0:	02812403          	lw	s0,40(sp)
   103b4:	02412483          	lw	s1,36(sp)
   103b8:	03010113          	addi	sp,sp,48
   103bc:	00008067          	ret

000103c0 <sbrk>:

caddr_t sbrk(int incr) {
   103c0:	fd010113          	addi	sp,sp,-48
   103c4:	02812623          	sw	s0,44(sp)
   103c8:	03010413          	addi	s0,sp,48
   103cc:	fca42e23          	sw	a0,-36(s0)
  extern char _end;		/* Defined by the linker */
  static char *heap_end;
  char *prev_heap_end;

  if (heap_end == 0) {
   103d0:	8b81a783          	lw	a5,-1864(gp) # 1def8 <heap_end.1982>
   103d4:	00079663          	bnez	a5,103e0 <sbrk+0x20>
    heap_end = &_end;
   103d8:	8e818713          	addi	a4,gp,-1816 # 1df28 <_end>
   103dc:	8ae1ac23          	sw	a4,-1864(gp) # 1def8 <heap_end.1982>
  }
  prev_heap_end = heap_end;
   103e0:	8b81a783          	lw	a5,-1864(gp) # 1def8 <heap_end.1982>
   103e4:	fef42623          	sw	a5,-20(s0)
  if (heap_end + incr > stack_ptr) {
   103e8:	8b81a703          	lw	a4,-1864(gp) # 1def8 <heap_end.1982>
   103ec:	fdc42783          	lw	a5,-36(s0)
   103f0:	00f707b3          	add	a5,a4,a5
   103f4:	00010713          	mv	a4,sp
   103f8:	00f77a63          	bleu	a5,a4,1040c <sbrk+0x4c>
    errno = ENOMEM;
   103fc:	00c00713          	li	a4,12
   10400:	8ee1a223          	sw	a4,-1820(gp) # 1df24 <errno>
    return (caddr_t) -1;
   10404:	fff00793          	li	a5,-1
   10408:	0180006f          	j	10420 <sbrk+0x60>
  }

  heap_end += incr;
   1040c:	8b81a703          	lw	a4,-1864(gp) # 1def8 <heap_end.1982>
   10410:	fdc42783          	lw	a5,-36(s0)
   10414:	00f70733          	add	a4,a4,a5
   10418:	8ae1ac23          	sw	a4,-1864(gp) # 1def8 <heap_end.1982>
  return (caddr_t) prev_heap_end;
   1041c:	fec42783          	lw	a5,-20(s0)
}
   10420:	00078513          	mv	a0,a5
   10424:	02c12403          	lw	s0,44(sp)
   10428:	03010113          	addi	sp,sp,48
   1042c:	00008067          	ret

00010430 <stat>:

int stat(const char *file, struct stat *st) {
   10430:	fe010113          	addi	sp,sp,-32
   10434:	00812e23          	sw	s0,28(sp)
   10438:	02010413          	addi	s0,sp,32
   1043c:	fea42623          	sw	a0,-20(s0)
   10440:	feb42423          	sw	a1,-24(s0)
  st->st_mode = S_IFCHR;
   10444:	fe842783          	lw	a5,-24(s0)
   10448:	00002737          	lui	a4,0x2
   1044c:	00e7a823          	sw	a4,16(a5)
  return 0;
   10450:	00000793          	li	a5,0
}
   10454:	00078513          	mv	a0,a5
   10458:	01c12403          	lw	s0,28(sp)
   1045c:	02010113          	addi	sp,sp,32
   10460:	00008067          	ret

00010464 <times>:

clock_t times(struct tms *buf) {
   10464:	fe010113          	addi	sp,sp,-32
   10468:	00812e23          	sw	s0,28(sp)
   1046c:	02010413          	addi	s0,sp,32
   10470:	fea42623          	sw	a0,-20(s0)
  return -1;
   10474:	fff00793          	li	a5,-1
}
   10478:	00078513          	mv	a0,a5
   1047c:	01c12403          	lw	s0,28(sp)
   10480:	02010113          	addi	sp,sp,32
   10484:	00008067          	ret

00010488 <unlink>:

int unlink(char *name) {
   10488:	fe010113          	addi	sp,sp,-32
   1048c:	00812e23          	sw	s0,28(sp)
   10490:	02010413          	addi	s0,sp,32
   10494:	fea42623          	sw	a0,-20(s0)
  errno = ENOENT;
   10498:	00200713          	li	a4,2
   1049c:	8ee1a223          	sw	a4,-1820(gp) # 1df24 <errno>
  return -1;
   104a0:	fff00793          	li	a5,-1
}
   104a4:	00078513          	mv	a0,a5
   104a8:	01c12403          	lw	s0,28(sp)
   104ac:	02010113          	addi	sp,sp,32
   104b0:	00008067          	ret

000104b4 <wait>:

int wait(int *status) {
   104b4:	fe010113          	addi	sp,sp,-32
   104b8:	00812e23          	sw	s0,28(sp)
   104bc:	02010413          	addi	s0,sp,32
   104c0:	fea42623          	sw	a0,-20(s0)
  errno = ECHILD;
   104c4:	00a00713          	li	a4,10
   104c8:	8ee1a223          	sw	a4,-1820(gp) # 1df24 <errno>
  return -1;
   104cc:	fff00793          	li	a5,-1
}
   104d0:	00078513          	mv	a0,a5
   104d4:	01c12403          	lw	s0,28(sp)
   104d8:	02010113          	addi	sp,sp,32
   104dc:	00008067          	ret

000104e0 <write>:

int write(int file, char *ptr, int len) {
   104e0:	fd010113          	addi	sp,sp,-48
   104e4:	02112623          	sw	ra,44(sp)
   104e8:	02812423          	sw	s0,40(sp)
   104ec:	03010413          	addi	s0,sp,48
   104f0:	fca42e23          	sw	a0,-36(s0)
   104f4:	fcb42c23          	sw	a1,-40(s0)
   104f8:	fcc42a23          	sw	a2,-44(s0)
  for (todo = 0; todo < len; todo++) {
    htif_putc (*ptr++);
  }
#endif
#ifdef CONSOLE_UART
  for (todo = 0; todo < len; todo++) {
   104fc:	fe042623          	sw	zero,-20(s0)
   10500:	0280006f          	j	10528 <write+0x48>
    ns16550_txchar (*ptr++);
   10504:	fd842783          	lw	a5,-40(s0)
   10508:	00178713          	addi	a4,a5,1
   1050c:	fce42c23          	sw	a4,-40(s0)
   10510:	0007c783          	lbu	a5,0(a5)
   10514:	00078513          	mv	a0,a5
   10518:	4e0000ef          	jal	109f8 <ns16550_txchar>
  for (todo = 0; todo < len; todo++) {
    htif_putc (*ptr++);
  }
#endif
#ifdef CONSOLE_UART
  for (todo = 0; todo < len; todo++) {
   1051c:	fec42783          	lw	a5,-20(s0)
   10520:	00178793          	addi	a5,a5,1
   10524:	fef42623          	sw	a5,-20(s0)
   10528:	fec42703          	lw	a4,-20(s0)
   1052c:	fd442783          	lw	a5,-44(s0)
   10530:	fcf74ae3          	blt	a4,a5,10504 <write+0x24>
    ns16550_txchar (*ptr++);
  }
#endif
  return len;
   10534:	fd442783          	lw	a5,-44(s0)
}
   10538:	00078513          	mv	a0,a5
   1053c:	02c12083          	lw	ra,44(sp)
   10540:	02812403          	lw	s0,40(sp)
   10544:	03010113          	addi	sp,sp,48
   10548:	00008067          	ret

0001054c <gettimeofday>:

#define CLOCK_PERIOD  (10000000)

int gettimeofday(struct timeval *ptimeval, void *ptimezone)
{
   1054c:	fd010113          	addi	sp,sp,-48
   10550:	02112623          	sw	ra,44(sp)
   10554:	02812423          	sw	s0,40(sp)
   10558:	03010413          	addi	s0,sp,48
   1055c:	fca42e23          	sw	a0,-36(s0)
   10560:	fcb42c23          	sw	a1,-40(s0)
    if (ptimeval)
   10564:	fdc42583          	lw	a1,-36(s0)
   10568:	0c058263          	beqz	a1,1062c <gettimeofday+0xe0>
#ifdef __riscv64
	asm ("rdtime %0" : "=r" (tv));
#else
	unsigned int tvh;
	unsigned int tvl;
	asm ("rdtime %0;"
   1056c:	c0102573          	rdtime	a0
   10570:	c81025f3          	rdtimeh	a1
   10574:	fea42623          	sw	a0,-20(s0)
   10578:	feb42423          	sw	a1,-24(s0)
	    "rdtimeh %1 " : "=r" (tvl), "=r" (tvh));
	tv = ((long long)tvh) << 32 | tvl;
   1057c:	fe842583          	lw	a1,-24(s0)
   10580:	00058813          	mv	a6,a1
   10584:	00000893          	li	a7,0
   10588:	00081793          	slli	a5,a6,0x0
   1058c:	00000713          	li	a4,0
   10590:	fec42583          	lw	a1,-20(s0)
   10594:	00058613          	mv	a2,a1
   10598:	00000693          	li	a3,0
   1059c:	00c765b3          	or	a1,a4,a2
   105a0:	feb42023          	sw	a1,-32(s0)
   105a4:	00d7e7b3          	or	a5,a5,a3
   105a8:	fef42223          	sw	a5,-28(s0)
#endif
	ptimeval->tv_sec = tv / CLOCK_PERIOD;
   105ac:	fe042703          	lw	a4,-32(s0)
   105b0:	fe442783          	lw	a5,-28(s0)
   105b4:	00989637          	lui	a2,0x989
   105b8:	68060613          	addi	a2,a2,1664 # 989680 <_gp+0x96b040>
   105bc:	00000693          	li	a3,0
   105c0:	00070513          	mv	a0,a4
   105c4:	00078593          	mv	a1,a5
   105c8:	5b8000ef          	jal	10b80 <__divdi3>
   105cc:	00050713          	mv	a4,a0
   105d0:	00058793          	mv	a5,a1
   105d4:	fdc42683          	lw	a3,-36(s0)
   105d8:	00e6a023          	sw	a4,0(a3)
   105dc:	00f6a223          	sw	a5,4(a3)
	ptimeval->tv_usec = tv % CLOCK_PERIOD / (CLOCK_PERIOD / 1000000);
   105e0:	fe042703          	lw	a4,-32(s0)
   105e4:	fe442783          	lw	a5,-28(s0)
   105e8:	00989637          	lui	a2,0x989
   105ec:	68060613          	addi	a2,a2,1664 # 989680 <_gp+0x96b040>
   105f0:	00000693          	li	a3,0
   105f4:	00070513          	mv	a0,a4
   105f8:	00078593          	mv	a1,a5
   105fc:	255000ef          	jal	11050 <__moddi3>
   10600:	00050713          	mv	a4,a0
   10604:	00058793          	mv	a5,a1
   10608:	00a00613          	li	a2,10
   1060c:	00000693          	li	a3,0
   10610:	00070513          	mv	a0,a4
   10614:	00078593          	mv	a1,a5
   10618:	568000ef          	jal	10b80 <__divdi3>
   1061c:	00050713          	mv	a4,a0
   10620:	00058793          	mv	a5,a1
   10624:	fdc42783          	lw	a5,-36(s0)
   10628:	00e7a423          	sw	a4,8(a5)
    }

    return 0;
   1062c:	00000793          	li	a5,0
}
   10630:	00078513          	mv	a0,a5
   10634:	02c12083          	lw	ra,44(sp)
   10638:	02812403          	lw	s0,40(sp)
   1063c:	03010113          	addi	sp,sp,48
   10640:	00008067          	ret

00010644 <sleep>:

unsigned int sleep(unsigned int seconds)
{
   10644:	fd010113          	addi	sp,sp,-48
   10648:	02112623          	sw	ra,44(sp)
   1064c:	02812423          	sw	s0,40(sp)
   10650:	03212223          	sw	s2,36(sp)
   10654:	03312023          	sw	s3,32(sp)
   10658:	03010413          	addi	s0,sp,48
   1065c:	fca42e23          	sw	a0,-36(s0)
    struct timeval tv;
    gettimeofday(&tv, NULL);
   10660:	fe040793          	addi	a5,s0,-32
   10664:	00000593          	li	a1,0
   10668:	00078513          	mv	a0,a5
   1066c:	ee1ff0ef          	jal	1054c <gettimeofday>
    seconds += tv.tv_sec;
   10670:	fe042703          	lw	a4,-32(s0)
   10674:	fe442783          	lw	a5,-28(s0)
   10678:	fdc42783          	lw	a5,-36(s0)
   1067c:	00e787b3          	add	a5,a5,a4
   10680:	fcf42e23          	sw	a5,-36(s0)

    while (tv.tv_sec < seconds)
   10684:	0140006f          	j	10698 <sleep+0x54>
	gettimeofday(&tv, NULL);
   10688:	fe040793          	addi	a5,s0,-32
   1068c:	00000593          	li	a1,0
   10690:	00078513          	mv	a0,a5
   10694:	eb9ff0ef          	jal	1054c <gettimeofday>
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    seconds += tv.tv_sec;

    while (tv.tv_sec < seconds)
   10698:	fe042703          	lw	a4,-32(s0)
   1069c:	fe442783          	lw	a5,-28(s0)
   106a0:	fdc42683          	lw	a3,-36(s0)
   106a4:	00068913          	mv	s2,a3
   106a8:	00000993          	li	s3,0
   106ac:	00078693          	mv	a3,a5
   106b0:	fd36ece3          	bltu	a3,s3,10688 <sleep+0x44>
   106b4:	00078693          	mv	a3,a5
   106b8:	00d99663          	bne	s3,a3,106c4 <sleep+0x80>
   106bc:	00070793          	mv	a5,a4
   106c0:	fd27e4e3          	bltu	a5,s2,10688 <sleep+0x44>
	gettimeofday(&tv, NULL);

    return 0;
   106c4:	00000793          	li	a5,0
}
   106c8:	00078513          	mv	a0,a5
   106cc:	02c12083          	lw	ra,44(sp)
   106d0:	02812403          	lw	s0,40(sp)
   106d4:	02412903          	lw	s2,36(sp)
   106d8:	02012983          	lw	s3,32(sp)
   106dc:	03010113          	addi	sp,sp,48
   106e0:	00008067          	ret

000106e4 <htif_tohost>:
#define HTIF_CMD_WRITE      (0x01UL)
#define HTIF_CMD_IDENTITY   (0xFFUL)

static inline void htif_tohost(unsigned long dev,
	unsigned long cmd, unsigned long data)
{
   106e4:	fd010113          	addi	sp,sp,-48
   106e8:	02812623          	sw	s0,44(sp)
   106ec:	03010413          	addi	s0,sp,48
   106f0:	fca42e23          	sw	a0,-36(s0)
   106f4:	fcb42c23          	sw	a1,-40(s0)
   106f8:	fcc42a23          	sw	a2,-44(s0)
	unsigned long packet;
	packet = (dev << HTIF_DEV_SHIFT) | (cmd << HTIF_CMD_SHIFT) | data;
   106fc:	fdc42783          	lw	a5,-36(s0)
   10700:	01879713          	slli	a4,a5,0x18
   10704:	fd842783          	lw	a5,-40(s0)
   10708:	01079793          	slli	a5,a5,0x10
   1070c:	00f76733          	or	a4,a4,a5
   10710:	fd442783          	lw	a5,-44(s0)
   10714:	00f767b3          	or	a5,a4,a5
   10718:	fef42623          	sw	a5,-20(s0)
	while (csr_swap(mtohost, packet) != 0);
   1071c:	00000013          	nop
   10720:	fec42783          	lw	a5,-20(s0)
   10724:	fef42423          	sw	a5,-24(s0)
   10728:	fe842783          	lw	a5,-24(s0)
   1072c:	780797f3          	csrrw	a5,mtohost,a5
   10730:	fef42423          	sw	a5,-24(s0)
   10734:	fe842783          	lw	a5,-24(s0)
   10738:	fe0794e3          	bnez	a5,10720 <htif_tohost+0x3c>
}
   1073c:	00000013          	nop
   10740:	02c12403          	lw	s0,44(sp)
   10744:	03010113          	addi	sp,sp,48
   10748:	00008067          	ret

0001074c <htif_fromhost>:

static inline unsigned long htif_fromhost(void)
{
   1074c:	fe010113          	addi	sp,sp,-32
   10750:	00812e23          	sw	s0,28(sp)
   10754:	02010413          	addi	s0,sp,32
	unsigned long data;
	while ((data = csr_swap(mfromhost, 0)) == 0);
   10758:	00000013          	nop
   1075c:	fe042623          	sw	zero,-20(s0)
   10760:	fec42783          	lw	a5,-20(s0)
   10764:	781797f3          	csrrw	a5,mfromhost,a5
   10768:	fef42623          	sw	a5,-20(s0)
   1076c:	fec42783          	lw	a5,-20(s0)
   10770:	fef42423          	sw	a5,-24(s0)
   10774:	fe842783          	lw	a5,-24(s0)
   10778:	fe0782e3          	beqz	a5,1075c <htif_fromhost+0x10>
	return data;
   1077c:	fe842783          	lw	a5,-24(s0)
}
   10780:	00078513          	mv	a0,a5
   10784:	01c12403          	lw	s0,28(sp)
   10788:	02010113          	addi	sp,sp,32
   1078c:	00008067          	ret

00010790 <htif_putc>:

#define HTIF_DEV_CONSOLE        (1U)

void htif_putc(char c)
{
   10790:	fe010113          	addi	sp,sp,-32
   10794:	00112e23          	sw	ra,28(sp)
   10798:	00812c23          	sw	s0,24(sp)
   1079c:	02010413          	addi	s0,sp,32
   107a0:	00050793          	mv	a5,a0
   107a4:	fef407a3          	sb	a5,-17(s0)
    htif_tohost(HTIF_DEV_CONSOLE, HTIF_CMD_WRITE, c);
   107a8:	fef44783          	lbu	a5,-17(s0)
   107ac:	00078613          	mv	a2,a5
   107b0:	00100593          	li	a1,1
   107b4:	00100513          	li	a0,1
   107b8:	f2dff0ef          	jal	106e4 <htif_tohost>
}
   107bc:	00000013          	nop
   107c0:	01c12083          	lw	ra,28(sp)
   107c4:	01812403          	lw	s0,24(sp)
   107c8:	02010113          	addi	sp,sp,32
   107cc:	00008067          	ret

000107d0 <htif_getc>:

char htif_getc(void)
{
   107d0:	fe010113          	addi	sp,sp,-32
   107d4:	00112e23          	sw	ra,28(sp)
   107d8:	00812c23          	sw	s0,24(sp)
   107dc:	02010413          	addi	s0,sp,32
    htif_tohost(HTIF_DEV_CONSOLE, HTIF_CMD_READ, 0);
   107e0:	00000613          	li	a2,0
   107e4:	00000593          	li	a1,0
   107e8:	00100513          	li	a0,1
   107ec:	ef9ff0ef          	jal	106e4 <htif_tohost>

    // poll interrupt
    unsigned long mip = csr_read(mip);
   107f0:	344027f3          	csrr	a5,mip
   107f4:	00078093          	mv	ra,a5
   107f8:	00008793          	mv	a5,ra
   107fc:	fef42623          	sw	a5,-20(s0)
    while (!(mip & 0x40000000))
   10800:	00000013          	nop
   10804:	fec42703          	lw	a4,-20(s0)
   10808:	400007b7          	lui	a5,0x40000
   1080c:	00f777b3          	and	a5,a4,a5
   10810:	fe078ae3          	beqz	a5,10804 <htif_getc+0x34>
	;  // nothing

    unsigned long data = htif_fromhost();
   10814:	f39ff0ef          	jal	1074c <htif_fromhost>
   10818:	fea42423          	sw	a0,-24(s0)
    return data;
   1081c:	fe842783          	lw	a5,-24(s0)
   10820:	0ff7f793          	andi	a5,a5,255
}
   10824:	00078513          	mv	a0,a5
   10828:	01c12083          	lw	ra,28(sp)
   1082c:	01812403          	lw	s0,24(sp)
   10830:	02010113          	addi	sp,sp,32
   10834:	00008067          	ret

00010838 <read_cycle>:
// The following are interfaces to inline RISC-V assembly instructions
//     RDCYCLE, RDTIME, RDINSTRET
// For all of them, the result is left in v0 (= x2) per calling convention

uint64_t  read_cycle (void)
{
   10838:	fe010113          	addi	sp,sp,-32
   1083c:	00812e23          	sw	s0,28(sp)
   10840:	02010413          	addi	s0,sp,32
    uint64_t result;

    asm volatile ("RDCYCLE %0" : "=r" (result));
   10844:	c0002773          	rdcycle	a4
   10848:	fee42423          	sw	a4,-24(s0)
   1084c:	fef42623          	sw	a5,-20(s0)
    return result;
   10850:	fe842703          	lw	a4,-24(s0)
   10854:	fec42783          	lw	a5,-20(s0)
}
   10858:	00070513          	mv	a0,a4
   1085c:	00078593          	mv	a1,a5
   10860:	01c12403          	lw	s0,28(sp)
   10864:	02010113          	addi	sp,sp,32
   10868:	00008067          	ret

0001086c <read_time>:

uint64_t  read_time (void)
{
   1086c:	fe010113          	addi	sp,sp,-32
   10870:	00812e23          	sw	s0,28(sp)
   10874:	02010413          	addi	s0,sp,32
    uint64_t result;

    asm volatile ("RDTIME %0" : "=r" (result));
   10878:	c0102773          	rdtime	a4
   1087c:	fee42423          	sw	a4,-24(s0)
   10880:	fef42623          	sw	a5,-20(s0)
    return result;
   10884:	fe842703          	lw	a4,-24(s0)
   10888:	fec42783          	lw	a5,-20(s0)
}
   1088c:	00070513          	mv	a0,a4
   10890:	00078593          	mv	a1,a5
   10894:	01c12403          	lw	s0,28(sp)
   10898:	02010113          	addi	sp,sp,32
   1089c:	00008067          	ret

000108a0 <read_instret>:

uint64_t  read_instret (void)
{
   108a0:	fe010113          	addi	sp,sp,-32
   108a4:	00812e23          	sw	s0,28(sp)
   108a8:	02010413          	addi	s0,sp,32
    uint64_t result;

    asm volatile ("RDINSTRET %0" : "=r" (result));
   108ac:	c0202773          	rdinstret	a4
   108b0:	fee42423          	sw	a4,-24(s0)
   108b4:	fef42623          	sw	a5,-20(s0)
    return result;
   108b8:	fe842703          	lw	a4,-24(s0)
   108bc:	fec42783          	lw	a5,-20(s0)
}
   108c0:	00070513          	mv	a0,a4
   108c4:	00078593          	mv	a1,a5
   108c8:	01c12403          	lw	s0,28(sp)
   108cc:	02010113          	addi	sp,sp,32
   108d0:	00008067          	ret

000108d4 <ns16550_init>:
static struct ns16550_pio * pio = (void*)NS16550_BASE;

#ifdef CONSOLE_UART
__attribute__ ((constructor))
static int ns16550_init(void)
{
   108d4:	fe010113          	addi	sp,sp,-32
   108d8:	00812e23          	sw	s0,28(sp)
   108dc:	02010413          	addi	s0,sp,32
  uint32_t divisor;

  pio->ier = 0;
   108e0:	8081a783          	lw	a5,-2040(gp) # 1de48 <pio>
   108e4:	00078223          	sb	zero,4(a5) # 40000004 <_gp+0x3ffe19c4>

  divisor = NS16550_CLOCK_RATE / (16 * DEFAULT_BAUDRATE);
   108e8:	01a00793          	li	a5,26
   108ec:	fef42623          	sw	a5,-20(s0)
  pio->lcr |= LCR_DLAB;
   108f0:	8081a783          	lw	a5,-2040(gp) # 1de48 <pio>
   108f4:	8081a703          	lw	a4,-2040(gp) # 1de48 <pio>
   108f8:	00c74703          	lbu	a4,12(a4) # 200c <_reset+0x1e0c>
   108fc:	0ff77713          	andi	a4,a4,255
   10900:	f8076713          	ori	a4,a4,-128
   10904:	0ff77713          	andi	a4,a4,255
   10908:	00e78623          	sb	a4,12(a5)
  pio->dll = divisor & 0xff;
   1090c:	8081a783          	lw	a5,-2040(gp) # 1de48 <pio>
   10910:	fec42703          	lw	a4,-20(s0)
   10914:	0ff77713          	andi	a4,a4,255
   10918:	00e78023          	sb	a4,0(a5)
  pio->dlm = (divisor >> 8) & 0xff;
   1091c:	8081a783          	lw	a5,-2040(gp) # 1de48 <pio>
   10920:	fec42703          	lw	a4,-20(s0)
   10924:	00875713          	srli	a4,a4,0x8
   10928:	0ff77713          	andi	a4,a4,255
   1092c:	00e78223          	sb	a4,4(a5)
  pio->lcr &= ~LCR_DLAB;
   10930:	8081a783          	lw	a5,-2040(gp) # 1de48 <pio>
   10934:	8081a703          	lw	a4,-2040(gp) # 1de48 <pio>
   10938:	00c74703          	lbu	a4,12(a4)
   1093c:	0ff77713          	andi	a4,a4,255
   10940:	07f77713          	andi	a4,a4,127
   10944:	0ff77713          	andi	a4,a4,255
   10948:	00e78623          	sb	a4,12(a5)

  pio->lcr = LCR_WLS8;
   1094c:	8081a783          	lw	a5,-2040(gp) # 1de48 <pio>
   10950:	00300713          	li	a4,3
   10954:	00e78623          	sb	a4,12(a5)
  pio->fcr = FCR_FE;
   10958:	8081a783          	lw	a5,-2040(gp) # 1de48 <pio>
   1095c:	00100713          	li	a4,1
   10960:	00e78423          	sb	a4,8(a5)
  pio->mcr = MCR_RTS;
   10964:	8081a783          	lw	a5,-2040(gp) # 1de48 <pio>
   10968:	00200713          	li	a4,2
   1096c:	00e78823          	sb	a4,16(a5)

  return 0;
   10970:	00000793          	li	a5,0
}
   10974:	00078513          	mv	a0,a5
   10978:	01c12403          	lw	s0,28(sp)
   1097c:	02010113          	addi	sp,sp,32
   10980:	00008067          	ret

00010984 <ns16550_rxready>:
#endif


int ns16550_rxready(void)
{
   10984:	ff010113          	addi	sp,sp,-16
   10988:	00812623          	sw	s0,12(sp)
   1098c:	01010413          	addi	s0,sp,16
  return (pio->lsr & LSR_DR) != 0;
   10990:	8081a783          	lw	a5,-2040(gp) # 1de48 <pio>
   10994:	0147c783          	lbu	a5,20(a5)
   10998:	0ff7f793          	andi	a5,a5,255
   1099c:	0017f793          	andi	a5,a5,1
   109a0:	00f037b3          	snez	a5,a5
   109a4:	0ff7f793          	andi	a5,a5,255
}
   109a8:	00078513          	mv	a0,a5
   109ac:	00c12403          	lw	s0,12(sp)
   109b0:	01010113          	addi	sp,sp,16
   109b4:	00008067          	ret

000109b8 <ns16550_rxchar>:


int ns16550_rxchar(void)
{
   109b8:	ff010113          	addi	sp,sp,-16
   109bc:	00812623          	sw	s0,12(sp)
   109c0:	01010413          	addi	s0,sp,16
  while ((pio->lsr & LSR_DR) == 0)
   109c4:	00000013          	nop
   109c8:	8081a783          	lw	a5,-2040(gp) # 1de48 <pio>
   109cc:	0147c783          	lbu	a5,20(a5)
   109d0:	0ff7f793          	andi	a5,a5,255
   109d4:	0017f793          	andi	a5,a5,1
   109d8:	fe0788e3          	beqz	a5,109c8 <ns16550_rxchar+0x10>
    ;  // nothing

  return pio->rbr;
   109dc:	8081a783          	lw	a5,-2040(gp) # 1de48 <pio>
   109e0:	0007c783          	lbu	a5,0(a5)
   109e4:	0ff7f793          	andi	a5,a5,255
}
   109e8:	00078513          	mv	a0,a5
   109ec:	00c12403          	lw	s0,12(sp)
   109f0:	01010113          	addi	sp,sp,16
   109f4:	00008067          	ret

000109f8 <ns16550_txchar>:


int ns16550_txchar(int c)
{
   109f8:	fe010113          	addi	sp,sp,-32
   109fc:	00812e23          	sw	s0,28(sp)
   10a00:	02010413          	addi	s0,sp,32
   10a04:	fea42623          	sw	a0,-20(s0)
  while ((pio->lsr & LSR_THRE) == 0)
   10a08:	00000013          	nop
   10a0c:	8081a783          	lw	a5,-2040(gp) # 1de48 <pio>
   10a10:	0147c783          	lbu	a5,20(a5)
   10a14:	0ff7f793          	andi	a5,a5,255
   10a18:	0207f793          	andi	a5,a5,32
   10a1c:	fe0788e3          	beqz	a5,10a0c <ns16550_txchar+0x14>
    ;  // nothing

  pio->thr = c;
   10a20:	8081a783          	lw	a5,-2040(gp) # 1de48 <pio>
   10a24:	fec42703          	lw	a4,-20(s0)
   10a28:	0ff77713          	andi	a4,a4,255
   10a2c:	00e78023          	sb	a4,0(a5)

  return c;
   10a30:	fec42783          	lw	a5,-20(s0)
}
   10a34:	00078513          	mv	a0,a5
   10a38:	01c12403          	lw	s0,28(sp)
   10a3c:	02010113          	addi	sp,sp,32
   10a40:	00008067          	ret

00010a44 <ns16550_flush>:


void ns16550_flush(void)
{
   10a44:	ff010113          	addi	sp,sp,-16
   10a48:	00812623          	sw	s0,12(sp)
   10a4c:	01010413          	addi	s0,sp,16
  while ((pio->lsr & LSR_TEMT) == 0)
   10a50:	00000013          	nop
   10a54:	8081a783          	lw	a5,-2040(gp) # 1de48 <pio>
   10a58:	0147c783          	lbu	a5,20(a5)
   10a5c:	0ff7f793          	andi	a5,a5,255
   10a60:	0407f793          	andi	a5,a5,64
   10a64:	fe0788e3          	beqz	a5,10a54 <ns16550_flush+0x10>
    ;  // nothing
}
   10a68:	00000013          	nop
   10a6c:	00c12403          	lw	s0,12(sp)
   10a70:	01010113          	addi	sp,sp,16
   10a74:	00008067          	ret

00010a78 <print>:
#include <stdio.h>

// ----------------------------------------------------------------

void print()
{
   10a78:	fd010113          	addi	sp,sp,-48
   10a7c:	02112623          	sw	ra,44(sp)
   10a80:	02812423          	sw	s0,40(sp)
   10a84:	03010413          	addi	s0,sp,48
    int i;
    char *c = "Hello world!\n\n";
   10a88:	0001c7b7          	lui	a5,0x1c
   10a8c:	b7878793          	addi	a5,a5,-1160 # 1bb78 <__extendsfdf2+0x40>
   10a90:	fef42423          	sw	a5,-24(s0)
    char d[15];

    printf("1: %c\n", 'c');
   10a94:	06300593          	li	a1,99
   10a98:	0001c7b7          	lui	a5,0x1c
   10a9c:	b8878513          	addi	a0,a5,-1144 # 1bb88 <__extendsfdf2+0x50>
   10aa0:	399000ef          	jal	11638 <printf>
    printf("2: %s\n", c);
   10aa4:	fe842583          	lw	a1,-24(s0)
   10aa8:	0001c7b7          	lui	a5,0x1c
   10aac:	b9078513          	addi	a0,a5,-1136 # 1bb90 <__extendsfdf2+0x58>
   10ab0:	389000ef          	jal	11638 <printf>

    for(i = 0; i < 15; i++)
   10ab4:	fe042623          	sw	zero,-20(s0)
   10ab8:	0300006f          	j	10ae8 <print+0x70>
	d[i] = c[i];
   10abc:	fec42783          	lw	a5,-20(s0)
   10ac0:	fe842703          	lw	a4,-24(s0)
   10ac4:	00f707b3          	add	a5,a4,a5
   10ac8:	0007c703          	lbu	a4,0(a5)
   10acc:	fec42783          	lw	a5,-20(s0)
   10ad0:	ff040693          	addi	a3,s0,-16
   10ad4:	00f687b3          	add	a5,a3,a5
   10ad8:	fee78423          	sb	a4,-24(a5)
    char d[15];

    printf("1: %c\n", 'c');
    printf("2: %s\n", c);

    for(i = 0; i < 15; i++)
   10adc:	fec42783          	lw	a5,-20(s0)
   10ae0:	00178793          	addi	a5,a5,1
   10ae4:	fef42623          	sw	a5,-20(s0)
   10ae8:	fec42703          	lw	a4,-20(s0)
   10aec:	00e00793          	li	a5,14
   10af0:	fce7d6e3          	ble	a4,a5,10abc <print+0x44>
	d[i] = c[i];

    printf("3: %c\n", 'd');
   10af4:	06400593          	li	a1,100
   10af8:	0001c7b7          	lui	a5,0x1c
   10afc:	b9878513          	addi	a0,a5,-1128 # 1bb98 <__extendsfdf2+0x60>
   10b00:	339000ef          	jal	11638 <printf>
    printf("4: %s\n", d);
   10b04:	fd840793          	addi	a5,s0,-40
   10b08:	00078593          	mv	a1,a5
   10b0c:	0001c7b7          	lui	a5,0x1c
   10b10:	ba078513          	addi	a0,a5,-1120 # 1bba0 <__extendsfdf2+0x68>
   10b14:	325000ef          	jal	11638 <printf>
    printf("5: %0d\n", 25);
   10b18:	01900593          	li	a1,25
   10b1c:	0001c7b7          	lui	a5,0x1c
   10b20:	ba878513          	addi	a0,a5,-1112 # 1bba8 <__extendsfdf2+0x70>
   10b24:	315000ef          	jal	11638 <printf>
    printf("6: Done\n");
   10b28:	0001c7b7          	lui	a5,0x1c
   10b2c:	bb078513          	addi	a0,a5,-1104 # 1bbb0 <__extendsfdf2+0x78>
   10b30:	409000ef          	jal	11738 <puts>
    printf("7: 1234\n\n");
   10b34:	0001c7b7          	lui	a5,0x1c
   10b38:	bb878513          	addi	a0,a5,-1096 # 1bbb8 <__extendsfdf2+0x80>
   10b3c:	3fd000ef          	jal	11738 <puts>
}
   10b40:	00000013          	nop
   10b44:	02c12083          	lw	ra,44(sp)
   10b48:	02812403          	lw	s0,40(sp)
   10b4c:	03010113          	addi	sp,sp,48
   10b50:	00008067          	ret

00010b54 <main>:

int main()
{
   10b54:	ff010113          	addi	sp,sp,-16
   10b58:	00112623          	sw	ra,12(sp)
   10b5c:	00812423          	sw	s0,8(sp)
   10b60:	01010413          	addi	s0,sp,16
    print();
   10b64:	f15ff0ef          	jal	10a78 <print>
    return 0;
   10b68:	00000793          	li	a5,0
}
   10b6c:	00078513          	mv	a0,a5
   10b70:	00c12083          	lw	ra,12(sp)
   10b74:	00812403          	lw	s0,8(sp)
   10b78:	01010113          	addi	sp,sp,16
   10b7c:	00008067          	ret

00010b80 <__divdi3>:
  Wtype c = 0;
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
   10b80:	2605ce63          	bltz	a1,10dfc <__divdi3+0x27c>
   10b84:	00050313          	mv	t1,a0
   10b88:	00058793          	mv	a5,a1

#ifdef L_divdi3
DWtype
__divdi3 (DWtype u, DWtype v)
{
  Wtype c = 0;
   10b8c:	00000893          	li	a7,0
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
   10b90:	2406ca63          	bltz	a3,10de4 <__divdi3+0x264>
  DWunion rr;
  UWtype d0, d1, n0, n1, n2;
  UWtype q0, q1;
  UWtype b, bm;

  d0 = dd.s.low;
   10b94:	00060293          	mv	t0,a2
  d1 = dd.s.high;
  n0 = nn.s.low;
   10b98:	00030393          	mv	t2,t1
  n1 = nn.s.high;
   10b9c:	00078593          	mv	a1,a5
	}
    }

#else /* UDIV_NEEDS_NORMALIZATION */

  if (d1 == 0)
   10ba0:	0e069e63          	bnez	a3,10c9c <__divdi3+0x11c>
    {
      if (d0 > n1)
   10ba4:	16c7f263          	bleu	a2,a5,10d08 <__divdi3+0x188>
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   10ba8:	00010737          	lui	a4,0x10
   10bac:	26e66c63          	bltu	a2,a4,10e24 <__divdi3+0x2a4>
   10bb0:	01000737          	lui	a4,0x1000
   10bb4:	00e63733          	sltu	a4,a2,a4
   10bb8:	00174713          	xori	a4,a4,1
   10bbc:	40e00733          	neg	a4,a4
   10bc0:	00877713          	andi	a4,a4,8
   10bc4:	01070713          	addi	a4,a4,16 # 1000010 <_gp+0xfe19d0>
   10bc8:	0001c6b7          	lui	a3,0x1c
   10bcc:	00e65533          	srl	a0,a2,a4
   10bd0:	bc468693          	addi	a3,a3,-1084 # 1bbc4 <__clz_tab>
   10bd4:	00d506b3          	add	a3,a0,a3
   10bd8:	0006c683          	lbu	a3,0(a3)
   10bdc:	00e68733          	add	a4,a3,a4
   10be0:	02000693          	li	a3,32
   10be4:	40e686b3          	sub	a3,a3,a4

	  if (bm != 0)
   10be8:	00068c63          	beqz	a3,10c00 <__divdi3+0x80>
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   10bec:	00d797b3          	sll	a5,a5,a3
   10bf0:	00e35733          	srl	a4,t1,a4
	  if (bm != 0)
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
   10bf4:	00d612b3          	sll	t0,a2,a3
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   10bf8:	00f765b3          	or	a1,a4,a5
	      n0 = n0 << bm;
   10bfc:	00d313b3          	sll	t2,t1,a3
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   10c00:	0102d613          	srli	a2,t0,0x10
   10c04:	02c5d533          	divu	a0,a1,a2
   10c08:	01029693          	slli	a3,t0,0x10
   10c0c:	0106d693          	srli	a3,a3,0x10
   10c10:	0103d713          	srli	a4,t2,0x10
   10c14:	02c5f7b3          	remu	a5,a1,a2
   10c18:	02a68833          	mul	a6,a3,a0
   10c1c:	01079793          	slli	a5,a5,0x10
   10c20:	00f765b3          	or	a1,a4,a5
   10c24:	0105fc63          	bleu	a6,a1,10c3c <__divdi3+0xbc>
   10c28:	005585b3          	add	a1,a1,t0
   10c2c:	fff50793          	addi	a5,a0,-1
   10c30:	0055e463          	bltu	a1,t0,10c38 <__divdi3+0xb8>
   10c34:	4105e263          	bltu	a1,a6,11038 <__divdi3+0x4b8>
   10c38:	00078513          	mv	a0,a5
   10c3c:	410585b3          	sub	a1,a1,a6
   10c40:	02c5d7b3          	divu	a5,a1,a2
   10c44:	01039393          	slli	t2,t2,0x10
   10c48:	0103d393          	srli	t2,t2,0x10
   10c4c:	02c5f5b3          	remu	a1,a1,a2
   10c50:	02f686b3          	mul	a3,a3,a5
   10c54:	01059593          	slli	a1,a1,0x10
   10c58:	00b3e5b3          	or	a1,t2,a1
   10c5c:	00d5fe63          	bleu	a3,a1,10c78 <__divdi3+0xf8>
   10c60:	00b285b3          	add	a1,t0,a1
   10c64:	fff78713          	addi	a4,a5,-1
   10c68:	0055e663          	bltu	a1,t0,10c74 <__divdi3+0xf4>
   10c6c:	ffe78793          	addi	a5,a5,-2
   10c70:	00d5e463          	bltu	a1,a3,10c78 <__divdi3+0xf8>
   10c74:	00070793          	mv	a5,a4
   10c78:	01051513          	slli	a0,a0,0x10
   10c7c:	00f56533          	or	a0,a0,a5
   10c80:	00000593          	li	a1,0
  if (vv.s.high < 0)
    c = ~c,
    vv.ll = -vv.ll;

  w = __udivmoddi4 (uu.ll, vv.ll, (UDWtype *) 0);
  if (c)
   10c84:	00088a63          	beqz	a7,10c98 <__divdi3+0x118>
    w = -w;
   10c88:	40a00533          	neg	a0,a0
   10c8c:	00a037b3          	snez	a5,a0
   10c90:	40b005b3          	neg	a1,a1
   10c94:	40f585b3          	sub	a1,a1,a5

  return w;
}
   10c98:	00008067          	ret
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
   10c9c:	00d7f863          	bleu	a3,a5,10cac <__divdi3+0x12c>
   10ca0:	00000593          	li	a1,0
   10ca4:	00000513          	li	a0,0
   10ca8:	fddff06f          	j	10c84 <__divdi3+0x104>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   10cac:	00010737          	lui	a4,0x10
   10cb0:	18e6e263          	bltu	a3,a4,10e34 <__divdi3+0x2b4>
   10cb4:	01000737          	lui	a4,0x1000
   10cb8:	00e6b733          	sltu	a4,a3,a4
   10cbc:	00174713          	xori	a4,a4,1
   10cc0:	40e00733          	neg	a4,a4
   10cc4:	00877713          	andi	a4,a4,8
   10cc8:	01070713          	addi	a4,a4,16 # 1000010 <_gp+0xfe19d0>
   10ccc:	0001c5b7          	lui	a1,0x1c
   10cd0:	00e6d533          	srl	a0,a3,a4
   10cd4:	bc458593          	addi	a1,a1,-1084 # 1bbc4 <__clz_tab>
   10cd8:	00b505b3          	add	a1,a0,a1
   10cdc:	0005c803          	lbu	a6,0(a1)
   10ce0:	02000293          	li	t0,32
   10ce4:	00e80833          	add	a6,a6,a4
   10ce8:	410282b3          	sub	t0,t0,a6
	  if (bm == 0)
   10cec:	14029c63          	bnez	t0,10e44 <__divdi3+0x2c4>

		 This special case is necessary, not an optimization.  */

	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
   10cf0:	00000593          	li	a1,0
   10cf4:	00100513          	li	a0,1
   10cf8:	f8f6e6e3          	bltu	a3,a5,10c84 <__divdi3+0x104>
   10cfc:	00c33533          	sltu	a0,t1,a2
   10d00:	00154513          	xori	a0,a0,1
   10d04:	f81ff06f          	j	10c84 <__divdi3+0x104>
	}
      else
	{
	  /* qq = NN / 0d */

	  if (d0 == 0)
   10d08:	00061663          	bnez	a2,10d14 <__divdi3+0x194>
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
   10d0c:	00100293          	li	t0,1
   10d10:	02d2d2b3          	divu	t0,t0,a3

	  count_leading_zeros (bm, d0);
   10d14:	00010737          	lui	a4,0x10
   10d18:	0ee2ee63          	bltu	t0,a4,10e14 <__divdi3+0x294>
   10d1c:	01000737          	lui	a4,0x1000
   10d20:	00e2b733          	sltu	a4,t0,a4
   10d24:	00174713          	xori	a4,a4,1
   10d28:	40e00733          	neg	a4,a4
   10d2c:	00877713          	andi	a4,a4,8
   10d30:	01070713          	addi	a4,a4,16 # 1000010 <_gp+0xfe19d0>
   10d34:	0001c6b7          	lui	a3,0x1c
   10d38:	00e2d633          	srl	a2,t0,a4
   10d3c:	bc468693          	addi	a3,a3,-1084 # 1bbc4 <__clz_tab>
   10d40:	00d606b3          	add	a3,a2,a3
   10d44:	0006c503          	lbu	a0,0(a3)
   10d48:	02000e13          	li	t3,32
   10d4c:	00e50533          	add	a0,a0,a4
   10d50:	40ae0e33          	sub	t3,t3,a0

	  if (bm == 0)
   10d54:	1e0e1663          	bnez	t3,10f40 <__divdi3+0x3c0>
   10d58:	01029813          	slli	a6,t0,0x10
		 leading quotient digit q1 = 1).

		 This special case is necessary, not an optimization.
		 (Shifts counts of W_TYPE_SIZE are undefined.)  */

	      n1 -= d0;
   10d5c:	405786b3          	sub	a3,a5,t0
   10d60:	0102d613          	srli	a2,t0,0x10
   10d64:	01085813          	srli	a6,a6,0x10
   10d68:	00100593          	li	a1,1
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   10d6c:	0103d793          	srli	a5,t2,0x10
   10d70:	02c6d533          	divu	a0,a3,a2
   10d74:	02c6f6b3          	remu	a3,a3,a2
   10d78:	03050733          	mul	a4,a0,a6
   10d7c:	01069693          	slli	a3,a3,0x10
   10d80:	00d7e7b3          	or	a5,a5,a3
   10d84:	00e7fc63          	bleu	a4,a5,10d9c <__divdi3+0x21c>
   10d88:	005787b3          	add	a5,a5,t0
   10d8c:	fff50693          	addi	a3,a0,-1
   10d90:	0057e463          	bltu	a5,t0,10d98 <__divdi3+0x218>
   10d94:	2ae7e863          	bltu	a5,a4,11044 <__divdi3+0x4c4>
   10d98:	00068513          	mv	a0,a3
   10d9c:	40e78733          	sub	a4,a5,a4
   10da0:	02c757b3          	divu	a5,a4,a2
   10da4:	01039393          	slli	t2,t2,0x10
   10da8:	0103d393          	srli	t2,t2,0x10
   10dac:	02c77733          	remu	a4,a4,a2
   10db0:	03078833          	mul	a6,a5,a6
   10db4:	01071713          	slli	a4,a4,0x10
   10db8:	00e3e733          	or	a4,t2,a4
   10dbc:	01077e63          	bleu	a6,a4,10dd8 <__divdi3+0x258>
   10dc0:	00e28733          	add	a4,t0,a4
   10dc4:	fff78693          	addi	a3,a5,-1
   10dc8:	00576663          	bltu	a4,t0,10dd4 <__divdi3+0x254>
   10dcc:	ffe78793          	addi	a5,a5,-2
   10dd0:	01076463          	bltu	a4,a6,10dd8 <__divdi3+0x258>
   10dd4:	00068793          	mv	a5,a3
   10dd8:	01051513          	slli	a0,a0,0x10
   10ddc:	00f56533          	or	a0,a0,a5
   10de0:	ea5ff06f          	j	10c84 <__divdi3+0x104>
  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    c = ~c,
    vv.ll = -vv.ll;
   10de4:	40c00633          	neg	a2,a2
   10de8:	00c03733          	snez	a4,a2
   10dec:	40d006b3          	neg	a3,a3

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    c = ~c,
   10df0:	fff8c893          	not	a7,a7
    vv.ll = -vv.ll;
   10df4:	40e686b3          	sub	a3,a3,a4
   10df8:	d9dff06f          	j	10b94 <__divdi3+0x14>
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
   10dfc:	40a00333          	neg	t1,a0
   10e00:	00603733          	snez	a4,t1
   10e04:	40b007b3          	neg	a5,a1
   10e08:	40e787b3          	sub	a5,a5,a4
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
   10e0c:	fff00893          	li	a7,-1
   10e10:	d81ff06f          	j	10b90 <__divdi3+0x10>
	  /* qq = NN / 0d */

	  if (d0 == 0)
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */

	  count_leading_zeros (bm, d0);
   10e14:	0ff00713          	li	a4,255
   10e18:	00573733          	sltu	a4,a4,t0
   10e1c:	00371713          	slli	a4,a4,0x3
   10e20:	f15ff06f          	j	10d34 <__divdi3+0x1b4>
    {
      if (d0 > n1)
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   10e24:	0ff00713          	li	a4,255
   10e28:	00c73733          	sltu	a4,a4,a2
   10e2c:	00371713          	slli	a4,a4,0x3
   10e30:	d99ff06f          	j	10bc8 <__divdi3+0x48>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   10e34:	0ff00713          	li	a4,255
   10e38:	00d73733          	sltu	a4,a4,a3
   10e3c:	00371713          	slli	a4,a4,0x3
   10e40:	e8dff06f          	j	10ccc <__divdi3+0x14c>
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
   10e44:	01065733          	srl	a4,a2,a6
   10e48:	005696b3          	sll	a3,a3,t0
   10e4c:	00e6e6b3          	or	a3,a3,a4
	      d0 = d0 << bm;
	      n2 = n1 >> b;
   10e50:	0107d5b3          	srl	a1,a5,a6
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   10e54:	0106de93          	srli	t4,a3,0x10
   10e58:	03d5de33          	divu	t3,a1,t4
   10e5c:	01069393          	slli	t2,a3,0x10
   10e60:	0103d393          	srli	t2,t2,0x10
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   10e64:	005797b3          	sll	a5,a5,t0
   10e68:	01035833          	srl	a6,t1,a6
   10e6c:	00f867b3          	or	a5,a6,a5
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   10e70:	0107d713          	srli	a4,a5,0x10
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
   10e74:	00561633          	sll	a2,a2,t0
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   10e78:	03d5f5b3          	remu	a1,a1,t4
   10e7c:	03c38533          	mul	a0,t2,t3
   10e80:	01059593          	slli	a1,a1,0x10
   10e84:	00b76733          	or	a4,a4,a1
   10e88:	00a77e63          	bleu	a0,a4,10ea4 <__divdi3+0x324>
   10e8c:	00d70733          	add	a4,a4,a3
   10e90:	fffe0593          	addi	a1,t3,-1
   10e94:	18d76e63          	bltu	a4,a3,11030 <__divdi3+0x4b0>
   10e98:	18a77c63          	bleu	a0,a4,11030 <__divdi3+0x4b0>
   10e9c:	ffee0e13          	addi	t3,t3,-2
   10ea0:	00d70733          	add	a4,a4,a3
   10ea4:	40a70733          	sub	a4,a4,a0
   10ea8:	03d75833          	divu	a6,a4,t4
   10eac:	01079793          	slli	a5,a5,0x10
   10eb0:	0107d793          	srli	a5,a5,0x10
   10eb4:	03d77733          	remu	a4,a4,t4
   10eb8:	030385b3          	mul	a1,t2,a6
   10ebc:	01071713          	slli	a4,a4,0x10
   10ec0:	00e7e7b3          	or	a5,a5,a4
   10ec4:	00b7fe63          	bleu	a1,a5,10ee0 <__divdi3+0x360>
   10ec8:	00d787b3          	add	a5,a5,a3
   10ecc:	fff80713          	addi	a4,a6,-1
   10ed0:	14d7e863          	bltu	a5,a3,11020 <__divdi3+0x4a0>
   10ed4:	14b7f663          	bleu	a1,a5,11020 <__divdi3+0x4a0>
   10ed8:	ffe80813          	addi	a6,a6,-2
   10edc:	00d787b3          	add	a5,a5,a3
   10ee0:	010e1e13          	slli	t3,t3,0x10
	      umul_ppmm (m1, m0, q0, d0);
   10ee4:	000103b7          	lui	t2,0x10
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   10ee8:	010e6533          	or	a0,t3,a6
	      umul_ppmm (m1, m0, q0, d0);
   10eec:	fff38713          	addi	a4,t2,-1 # ffff <_reset+0xfdff>
   10ef0:	00e576b3          	and	a3,a0,a4
   10ef4:	01055813          	srli	a6,a0,0x10
   10ef8:	00e67733          	and	a4,a2,a4
   10efc:	01065613          	srli	a2,a2,0x10
   10f00:	02e68e33          	mul	t3,a3,a4
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   10f04:	40b787b3          	sub	a5,a5,a1
   10f08:	02c686b3          	mul	a3,a3,a2
	      umul_ppmm (m1, m0, q0, d0);
   10f0c:	010e5593          	srli	a1,t3,0x10
   10f10:	02e80733          	mul	a4,a6,a4
   10f14:	00e686b3          	add	a3,a3,a4
   10f18:	00d586b3          	add	a3,a1,a3
   10f1c:	02c80633          	mul	a2,a6,a2
   10f20:	00e6f463          	bleu	a4,a3,10f28 <__divdi3+0x3a8>
   10f24:	00760633          	add	a2,a2,t2
   10f28:	0106d813          	srli	a6,a3,0x10
   10f2c:	00c80633          	add	a2,a6,a2

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   10f30:	0cc7ee63          	bltu	a5,a2,1100c <__divdi3+0x48c>
   10f34:	0ac78c63          	beq	a5,a2,10fec <__divdi3+0x46c>
		{
		  q0--;
   10f38:	00000593          	li	a1,0
   10f3c:	d49ff06f          	j	10c84 <__divdi3+0x104>
	    {
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
   10f40:	01c292b3          	sll	t0,t0,t3
	      n2 = n1 >> b;
   10f44:	00a7d833          	srl	a6,a5,a0
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   10f48:	0102d713          	srli	a4,t0,0x10
   10f4c:	02e85eb3          	divu	t4,a6,a4
   10f50:	01029f13          	slli	t5,t0,0x10

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   10f54:	01c796b3          	sll	a3,a5,t3
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   10f58:	010f5f13          	srli	t5,t5,0x10

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   10f5c:	00a35533          	srl	a0,t1,a0
   10f60:	00d56533          	or	a0,a0,a3
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   10f64:	01055613          	srli	a2,a0,0x10
	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;
   10f68:	01c313b3          	sll	t2,t1,t3

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   10f6c:	02e87833          	remu	a6,a6,a4
   10f70:	03df06b3          	mul	a3,t5,t4
   10f74:	01081813          	slli	a6,a6,0x10
   10f78:	01066633          	or	a2,a2,a6
   10f7c:	00d67e63          	bleu	a3,a2,10f98 <__divdi3+0x418>
   10f80:	00560633          	add	a2,a2,t0
   10f84:	fffe8793          	addi	a5,t4,-1
   10f88:	0a566063          	bltu	a2,t0,11028 <__divdi3+0x4a8>
   10f8c:	08d67e63          	bleu	a3,a2,11028 <__divdi3+0x4a8>
   10f90:	ffee8e93          	addi	t4,t4,-2
   10f94:	00560633          	add	a2,a2,t0
   10f98:	40d60633          	sub	a2,a2,a3
   10f9c:	02e655b3          	divu	a1,a2,a4
   10fa0:	01051513          	slli	a0,a0,0x10
   10fa4:	01055513          	srli	a0,a0,0x10
   10fa8:	02e67633          	remu	a2,a2,a4
   10fac:	02bf07b3          	mul	a5,t5,a1
   10fb0:	01061613          	slli	a2,a2,0x10
   10fb4:	00c566b3          	or	a3,a0,a2
   10fb8:	00f6fe63          	bleu	a5,a3,10fd4 <__divdi3+0x454>
   10fbc:	005686b3          	add	a3,a3,t0
   10fc0:	fff58613          	addi	a2,a1,-1
   10fc4:	0456ea63          	bltu	a3,t0,11018 <__divdi3+0x498>
   10fc8:	04f6f863          	bleu	a5,a3,11018 <__divdi3+0x498>
   10fcc:	ffe58593          	addi	a1,a1,-2
   10fd0:	005686b3          	add	a3,a3,t0
   10fd4:	010e9e93          	slli	t4,t4,0x10
   10fd8:	40f686b3          	sub	a3,a3,a5
   10fdc:	00bee5b3          	or	a1,t4,a1
   10fe0:	000f0813          	mv	a6,t5
   10fe4:	00070613          	mv	a2,a4
   10fe8:	d85ff06f          	j	10d6c <__divdi3+0x1ec>
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   10fec:	000107b7          	lui	a5,0x10
   10ff0:	fff78793          	addi	a5,a5,-1 # ffff <_reset+0xfdff>
   10ff4:	00f6f6b3          	and	a3,a3,a5
   10ff8:	01069693          	slli	a3,a3,0x10
   10ffc:	00fe77b3          	and	a5,t3,a5
   11000:	00531333          	sll	t1,t1,t0
   11004:	00f687b3          	add	a5,a3,a5
   11008:	f2f378e3          	bleu	a5,t1,10f38 <__divdi3+0x3b8>
   1100c:	fff50513          	addi	a0,a0,-1
		{
		  q0--;
   11010:	00000593          	li	a1,0
   11014:	c71ff06f          	j	10c84 <__divdi3+0x104>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11018:	00060593          	mv	a1,a2
   1101c:	fb9ff06f          	j	10fd4 <__divdi3+0x454>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11020:	00070813          	mv	a6,a4
   11024:	ebdff06f          	j	10ee0 <__divdi3+0x360>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11028:	00078e93          	mv	t4,a5
   1102c:	f6dff06f          	j	10f98 <__divdi3+0x418>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11030:	00058e13          	mv	t3,a1
   11034:	e71ff06f          	j	10ea4 <__divdi3+0x324>
	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
	      n0 = n0 << bm;
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11038:	ffe50513          	addi	a0,a0,-2
   1103c:	005585b3          	add	a1,a1,t0
   11040:	bfdff06f          	j	10c3c <__divdi3+0xbc>
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11044:	ffe50513          	addi	a0,a0,-2
   11048:	005787b3          	add	a5,a5,t0
   1104c:	d51ff06f          	j	10d9c <__divdi3+0x21c>

00011050 <__moddi3>:

#ifdef L_moddi3
DWtype
__moddi3 (DWtype u, DWtype v)
{
  Wtype c = 0;
   11050:	00000813          	li	a6,0
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
   11054:	1605c863          	bltz	a1,111c4 <__moddi3+0x174>
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
   11058:	1806c263          	bltz	a3,111dc <__moddi3+0x18c>
  DWunion rr;
  UWtype d0, d1, n0, n1, n2;
  UWtype q0, q1;
  UWtype b, bm;

  d0 = dd.s.low;
   1105c:	00060893          	mv	a7,a2
  d1 = dd.s.high;
  n0 = nn.s.low;
   11060:	00050313          	mv	t1,a0
  n1 = nn.s.high;
   11064:	00058393          	mv	t2,a1
	}
    }

#else /* UDIV_NEEDS_NORMALIZATION */

  if (d1 == 0)
   11068:	0e069663          	bnez	a3,11154 <__moddi3+0x104>
    {
      if (d0 > n1)
   1106c:	18c5f263          	bleu	a2,a1,111f0 <__moddi3+0x1a0>
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   11070:	000107b7          	lui	a5,0x10
   11074:	24f66063          	bltu	a2,a5,112b4 <__moddi3+0x264>
   11078:	010002b7          	lui	t0,0x1000
   1107c:	005632b3          	sltu	t0,a2,t0
   11080:	0012c293          	xori	t0,t0,1
   11084:	405002b3          	neg	t0,t0
   11088:	0082f293          	andi	t0,t0,8
   1108c:	01028293          	addi	t0,t0,16 # 1000010 <_gp+0xfe19d0>
   11090:	0001c7b7          	lui	a5,0x1c
   11094:	00565733          	srl	a4,a2,t0
   11098:	bc478793          	addi	a5,a5,-1084 # 1bbc4 <__clz_tab>
   1109c:	00f707b3          	add	a5,a4,a5
   110a0:	0007c783          	lbu	a5,0(a5)
   110a4:	005787b3          	add	a5,a5,t0
   110a8:	02000293          	li	t0,32
   110ac:	40f282b3          	sub	t0,t0,a5

	  if (bm != 0)
   110b0:	00028c63          	beqz	t0,110c8 <__moddi3+0x78>
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   110b4:	005595b3          	sll	a1,a1,t0
   110b8:	00f557b3          	srl	a5,a0,a5
	  if (bm != 0)
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
   110bc:	005618b3          	sll	a7,a2,t0
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   110c0:	00b7e3b3          	or	t2,a5,a1
	      n0 = n0 << bm;
   110c4:	00551333          	sll	t1,a0,t0
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   110c8:	0108de13          	srli	t3,a7,0x10
   110cc:	03c3d633          	divu	a2,t2,t3
   110d0:	01089693          	slli	a3,a7,0x10
   110d4:	0106d693          	srli	a3,a3,0x10
   110d8:	01035713          	srli	a4,t1,0x10
   110dc:	03c3f5b3          	remu	a1,t2,t3
   110e0:	02c68633          	mul	a2,a3,a2
   110e4:	01059593          	slli	a1,a1,0x10
   110e8:	00b76733          	or	a4,a4,a1
   110ec:	00c77863          	bleu	a2,a4,110fc <__moddi3+0xac>
   110f0:	01170733          	add	a4,a4,a7
   110f4:	01176463          	bltu	a4,a7,110fc <__moddi3+0xac>
   110f8:	3cc76863          	bltu	a4,a2,114c8 <__moddi3+0x478>
   110fc:	40c70733          	sub	a4,a4,a2
   11100:	03c757b3          	divu	a5,a4,t3
   11104:	01031313          	slli	t1,t1,0x10
   11108:	01035313          	srli	t1,t1,0x10
   1110c:	03c77733          	remu	a4,a4,t3
   11110:	02f68533          	mul	a0,a3,a5
   11114:	01071713          	slli	a4,a4,0x10
   11118:	00e367b3          	or	a5,t1,a4
   1111c:	00a7fa63          	bleu	a0,a5,11130 <__moddi3+0xe0>
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11120:	011787b3          	add	a5,a5,a7
   11124:	0117e663          	bltu	a5,a7,11130 <__moddi3+0xe0>
   11128:	00a7f463          	bleu	a0,a5,11130 <__moddi3+0xe0>
   1112c:	011787b3          	add	a5,a5,a7
   11130:	40a787b3          	sub	a5,a5,a0
	  /* Remainder in n0 >> bm.  */
	}

      if (rp != 0)
	{
	  rr.s.low = n0 >> bm;
   11134:	0057d533          	srl	a0,a5,t0
	  rr.s.high = 0;
	  *rp = rr.ll;
   11138:	00000593          	li	a1,0
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    vv.ll = -vv.ll;

  (void) __udivmoddi4 (uu.ll, vv.ll, (UDWtype*)&w);
  if (c)
   1113c:	00080a63          	beqz	a6,11150 <__moddi3+0x100>
    w = -w;
   11140:	40a00533          	neg	a0,a0
   11144:	00a037b3          	snez	a5,a0
   11148:	40b005b3          	neg	a1,a1
   1114c:	40f585b3          	sub	a1,a1,a5

  return w;
}
   11150:	00008067          	ret
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
   11154:	fed5e4e3          	bltu	a1,a3,1113c <__moddi3+0xec>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   11158:	000107b7          	lui	a5,0x10
   1115c:	16f6e463          	bltu	a3,a5,112c4 <__moddi3+0x274>
   11160:	010008b7          	lui	a7,0x1000
   11164:	0116b8b3          	sltu	a7,a3,a7
   11168:	0018c893          	xori	a7,a7,1
   1116c:	411008b3          	neg	a7,a7
   11170:	0088f893          	andi	a7,a7,8
   11174:	01088893          	addi	a7,a7,16 # 1000010 <_gp+0xfe19d0>
   11178:	0001c7b7          	lui	a5,0x1c
   1117c:	0116d733          	srl	a4,a3,a7
   11180:	bc478793          	addi	a5,a5,-1084 # 1bbc4 <__clz_tab>
   11184:	00f707b3          	add	a5,a4,a5
   11188:	0007ce83          	lbu	t4,0(a5)
   1118c:	02000e13          	li	t3,32
   11190:	011e8eb3          	add	t4,t4,a7
   11194:	41de0e33          	sub	t3,t3,t4
	  if (bm == 0)
   11198:	1c0e1863          	bnez	t3,11368 <__moddi3+0x318>

		 This special case is necessary, not an optimization.  */

	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
   1119c:	00b6e663          	bltu	a3,a1,111a8 <__moddi3+0x158>
   111a0:	00050793          	mv	a5,a0
   111a4:	00c56a63          	bltu	a0,a2,111b8 <__moddi3+0x168>
		{
		  q0 = 1;
		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
   111a8:	40c507b3          	sub	a5,a0,a2
   111ac:	40d585b3          	sub	a1,a1,a3
   111b0:	00f53533          	sltu	a0,a0,a5
   111b4:	40a583b3          	sub	t2,a1,a0

	      if (rp != 0)
		{
		  rr.s.low = n0;
		  rr.s.high = n1;
		  *rp = rr.ll;
   111b8:	00078513          	mv	a0,a5
   111bc:	00038593          	mv	a1,t2
   111c0:	f7dff06f          	j	1113c <__moddi3+0xec>
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
   111c4:	40a00533          	neg	a0,a0
   111c8:	00a037b3          	snez	a5,a0
   111cc:	40b00733          	neg	a4,a1
   111d0:	40f705b3          	sub	a1,a4,a5
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
   111d4:	fff00813          	li	a6,-1
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
   111d8:	e806d2e3          	bgez	a3,1105c <__moddi3+0xc>
    vv.ll = -vv.ll;
   111dc:	40c00633          	neg	a2,a2
   111e0:	00c037b3          	snez	a5,a2
   111e4:	40d006b3          	neg	a3,a3
   111e8:	40f686b3          	sub	a3,a3,a5
   111ec:	e71ff06f          	j	1105c <__moddi3+0xc>
	}
      else
	{
	  /* qq = NN / 0d */

	  if (d0 == 0)
   111f0:	00061663          	bnez	a2,111fc <__moddi3+0x1ac>
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
   111f4:	00100893          	li	a7,1
   111f8:	02d8d8b3          	divu	a7,a7,a3

	  count_leading_zeros (bm, d0);
   111fc:	000107b7          	lui	a5,0x10
   11200:	0af8e263          	bltu	a7,a5,112a4 <__moddi3+0x254>
   11204:	010007b7          	lui	a5,0x1000
   11208:	00f8b7b3          	sltu	a5,a7,a5
   1120c:	0017c793          	xori	a5,a5,1
   11210:	40f007b3          	neg	a5,a5
   11214:	0087f793          	andi	a5,a5,8
   11218:	01078793          	addi	a5,a5,16 # 1000010 <_gp+0xfe19d0>
   1121c:	0001c737          	lui	a4,0x1c
   11220:	00f8d6b3          	srl	a3,a7,a5
   11224:	bc470713          	addi	a4,a4,-1084 # 1bbc4 <__clz_tab>
   11228:	00e68733          	add	a4,a3,a4
   1122c:	00074703          	lbu	a4,0(a4)
   11230:	02000293          	li	t0,32
   11234:	00f707b3          	add	a5,a4,a5
   11238:	40f282b3          	sub	t0,t0,a5

	  if (bm == 0)
   1123c:	08029c63          	bnez	t0,112d4 <__moddi3+0x284>
   11240:	01089793          	slli	a5,a7,0x10
		 leading quotient digit q1 = 1).

		 This special case is necessary, not an optimization.
		 (Shifts counts of W_TYPE_SIZE are undefined.)  */

	      n1 -= d0;
   11244:	411585b3          	sub	a1,a1,a7
   11248:	0108d693          	srli	a3,a7,0x10
   1124c:	0107d793          	srli	a5,a5,0x10
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11250:	01035713          	srli	a4,t1,0x10
   11254:	02d5d633          	divu	a2,a1,a3
   11258:	02d5f5b3          	remu	a1,a1,a3
   1125c:	02f60633          	mul	a2,a2,a5
   11260:	01059593          	slli	a1,a1,0x10
   11264:	00b76733          	or	a4,a4,a1
   11268:	00c77a63          	bleu	a2,a4,1127c <__moddi3+0x22c>
   1126c:	01170733          	add	a4,a4,a7
   11270:	01176663          	bltu	a4,a7,1127c <__moddi3+0x22c>
   11274:	00c77463          	bleu	a2,a4,1127c <__moddi3+0x22c>
   11278:	01170733          	add	a4,a4,a7
   1127c:	40c70733          	sub	a4,a4,a2
   11280:	02d75633          	divu	a2,a4,a3
   11284:	01031313          	slli	t1,t1,0x10
   11288:	01035313          	srli	t1,t1,0x10
   1128c:	02d77733          	remu	a4,a4,a3
   11290:	02f60533          	mul	a0,a2,a5
   11294:	01071713          	slli	a4,a4,0x10
   11298:	00e367b3          	or	a5,t1,a4
   1129c:	e8a7fae3          	bleu	a0,a5,11130 <__moddi3+0xe0>
   112a0:	e81ff06f          	j	11120 <__moddi3+0xd0>
	  /* qq = NN / 0d */

	  if (d0 == 0)
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */

	  count_leading_zeros (bm, d0);
   112a4:	0ff00793          	li	a5,255
   112a8:	0117b7b3          	sltu	a5,a5,a7
   112ac:	00379793          	slli	a5,a5,0x3
   112b0:	f6dff06f          	j	1121c <__moddi3+0x1cc>
    {
      if (d0 > n1)
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   112b4:	0ff00293          	li	t0,255
   112b8:	00c2b2b3          	sltu	t0,t0,a2
   112bc:	00329293          	slli	t0,t0,0x3
   112c0:	dd1ff06f          	j	11090 <__moddi3+0x40>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   112c4:	0ff00893          	li	a7,255
   112c8:	00d8b8b3          	sltu	a7,a7,a3
   112cc:	00389893          	slli	a7,a7,0x3
   112d0:	ea9ff06f          	j	11178 <__moddi3+0x128>
	    {
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
   112d4:	005898b3          	sll	a7,a7,t0
	      n2 = n1 >> b;
   112d8:	00f5de33          	srl	t3,a1,a5
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   112dc:	0108d713          	srli	a4,a7,0x10
   112e0:	02ee5633          	divu	a2,t3,a4
   112e4:	01089393          	slli	t2,a7,0x10

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   112e8:	005595b3          	sll	a1,a1,t0
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   112ec:	0103d393          	srli	t2,t2,0x10

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   112f0:	00f557b3          	srl	a5,a0,a5
   112f4:	00b7e7b3          	or	a5,a5,a1
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   112f8:	0107d693          	srli	a3,a5,0x10
	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;
   112fc:	00551333          	sll	t1,a0,t0

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11300:	02ee7e33          	remu	t3,t3,a4
   11304:	02c385b3          	mul	a1,t2,a2
   11308:	010e1e13          	slli	t3,t3,0x10
   1130c:	01c6e633          	or	a2,a3,t3
   11310:	00b67a63          	bleu	a1,a2,11324 <__moddi3+0x2d4>
   11314:	01160633          	add	a2,a2,a7
   11318:	01166663          	bltu	a2,a7,11324 <__moddi3+0x2d4>
   1131c:	00b67463          	bleu	a1,a2,11324 <__moddi3+0x2d4>
   11320:	01160633          	add	a2,a2,a7
   11324:	40b60633          	sub	a2,a2,a1
   11328:	02e655b3          	divu	a1,a2,a4
   1132c:	01079793          	slli	a5,a5,0x10
   11330:	0107d793          	srli	a5,a5,0x10
   11334:	02e67633          	remu	a2,a2,a4
   11338:	02b385b3          	mul	a1,t2,a1
   1133c:	01061613          	slli	a2,a2,0x10
   11340:	00c7e6b3          	or	a3,a5,a2
   11344:	00b6fa63          	bleu	a1,a3,11358 <__moddi3+0x308>
   11348:	011686b3          	add	a3,a3,a7
   1134c:	0116e663          	bltu	a3,a7,11358 <__moddi3+0x308>
   11350:	00b6f463          	bleu	a1,a3,11358 <__moddi3+0x308>
   11354:	011686b3          	add	a3,a3,a7
   11358:	40b685b3          	sub	a1,a3,a1
   1135c:	00038793          	mv	a5,t2
   11360:	00070693          	mv	a3,a4
   11364:	eedff06f          	j	11250 <__moddi3+0x200>
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
   11368:	01c696b3          	sll	a3,a3,t3
   1136c:	01d653b3          	srl	t2,a2,t4
   11370:	0076e3b3          	or	t2,a3,t2
	      d0 = d0 << bm;
	      n2 = n1 >> b;
   11374:	01d5d333          	srl	t1,a1,t4
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11378:	0103d893          	srli	a7,t2,0x10
   1137c:	031357b3          	divu	a5,t1,a7
   11380:	01039713          	slli	a4,t2,0x10
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   11384:	01c596b3          	sll	a3,a1,t3
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11388:	01075713          	srli	a4,a4,0x10
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   1138c:	01d555b3          	srl	a1,a0,t4
   11390:	00d5e6b3          	or	a3,a1,a3
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11394:	0106d293          	srli	t0,a3,0x10
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
   11398:	01c61633          	sll	a2,a2,t3
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;
   1139c:	01c51533          	sll	a0,a0,t3

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   113a0:	03137333          	remu	t1,t1,a7
   113a4:	02f705b3          	mul	a1,a4,a5
   113a8:	01031313          	slli	t1,t1,0x10
   113ac:	0062e2b3          	or	t0,t0,t1
   113b0:	00b2fe63          	bleu	a1,t0,113cc <__moddi3+0x37c>
   113b4:	007282b3          	add	t0,t0,t2
   113b8:	fff78313          	addi	t1,a5,-1
   113bc:	1072e263          	bltu	t0,t2,114c0 <__moddi3+0x470>
   113c0:	10b2f063          	bleu	a1,t0,114c0 <__moddi3+0x470>
   113c4:	ffe78793          	addi	a5,a5,-2
   113c8:	007282b3          	add	t0,t0,t2
   113cc:	40b282b3          	sub	t0,t0,a1
   113d0:	0312d333          	divu	t1,t0,a7
   113d4:	01069693          	slli	a3,a3,0x10
   113d8:	0106d693          	srli	a3,a3,0x10
   113dc:	0312f2b3          	remu	t0,t0,a7
   113e0:	02670733          	mul	a4,a4,t1
   113e4:	01029893          	slli	a7,t0,0x10
   113e8:	0116e8b3          	or	a7,a3,a7
   113ec:	00e8fe63          	bleu	a4,a7,11408 <__moddi3+0x3b8>
   113f0:	007888b3          	add	a7,a7,t2
   113f4:	fff30693          	addi	a3,t1,-1
   113f8:	0c78e063          	bltu	a7,t2,114b8 <__moddi3+0x468>
   113fc:	0ae8fe63          	bleu	a4,a7,114b8 <__moddi3+0x468>
   11400:	ffe30313          	addi	t1,t1,-2
   11404:	007888b3          	add	a7,a7,t2
   11408:	01079793          	slli	a5,a5,0x10
	      umul_ppmm (m1, m0, q0, d0);
   1140c:	00010fb7          	lui	t6,0x10
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11410:	0067e333          	or	t1,a5,t1
	      umul_ppmm (m1, m0, q0, d0);
   11414:	ffff8793          	addi	a5,t6,-1 # ffff <_reset+0xfdff>
   11418:	00f376b3          	and	a3,t1,a5
   1141c:	01065593          	srli	a1,a2,0x10
   11420:	01035313          	srli	t1,t1,0x10
   11424:	00f677b3          	and	a5,a2,a5
   11428:	02f68f33          	mul	t5,a3,a5
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   1142c:	40e88733          	sub	a4,a7,a4
	      umul_ppmm (m1, m0, q0, d0);
   11430:	02f307b3          	mul	a5,t1,a5
   11434:	010f5293          	srli	t0,t5,0x10
   11438:	02b686b3          	mul	a3,a3,a1
   1143c:	00f686b3          	add	a3,a3,a5
   11440:	00d288b3          	add	a7,t0,a3
   11444:	02b30333          	mul	t1,t1,a1
   11448:	00f8f463          	bleu	a5,a7,11450 <__moddi3+0x400>
   1144c:	01f30333          	add	t1,t1,t6
   11450:	000106b7          	lui	a3,0x10
   11454:	fff68793          	addi	a5,a3,-1 # ffff <_reset+0xfdff>
   11458:	0108d693          	srli	a3,a7,0x10
   1145c:	00f8f8b3          	and	a7,a7,a5
   11460:	01089293          	slli	t0,a7,0x10
   11464:	00668333          	add	t1,a3,t1
   11468:	00ff78b3          	and	a7,t5,a5
   1146c:	011288b3          	add	a7,t0,a7

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   11470:	00676a63          	bltu	a4,t1,11484 <__moddi3+0x434>
   11474:	04670e63          	beq	a4,t1,114d0 <__moddi3+0x480>
   11478:	40670733          	sub	a4,a4,t1
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);
   1147c:	00088793          	mv	a5,a7
   11480:	0180006f          	j	11498 <__moddi3+0x448>

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
		{
		  q0--;
		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
   11484:	40c887b3          	sub	a5,a7,a2
   11488:	40730333          	sub	t1,t1,t2
   1148c:	00f8b8b3          	sltu	a7,a7,a5
   11490:	411308b3          	sub	a7,t1,a7
   11494:	41170733          	sub	a4,a4,a7
	      q1 = 0;

	      /* Remainder in (n1n0 - m1m0) >> bm.  */
	      if (rp != 0)
		{
		  sub_ddmmss (n1, n0, n1, n0, m1, m0);
   11498:	40f507b3          	sub	a5,a0,a5
   1149c:	00f53533          	sltu	a0,a0,a5
   114a0:	40a70733          	sub	a4,a4,a0
		  rr.s.low = (n1 << b) | (n0 >> bm);
   114a4:	01d71533          	sll	a0,a4,t4
   114a8:	01c7d7b3          	srl	a5,a5,t3
		  rr.s.high = n1 >> bm;
		  *rp = rr.ll;
   114ac:	00f56533          	or	a0,a0,a5
   114b0:	01c755b3          	srl	a1,a4,t3
   114b4:	c89ff06f          	j	1113c <__moddi3+0xec>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   114b8:	00068313          	mv	t1,a3
   114bc:	f4dff06f          	j	11408 <__moddi3+0x3b8>
   114c0:	00030793          	mv	a5,t1
   114c4:	f09ff06f          	j	113cc <__moddi3+0x37c>
	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
	      n0 = n0 << bm;
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   114c8:	01170733          	add	a4,a4,a7
   114cc:	c31ff06f          	j	110fc <__moddi3+0xac>
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   114d0:	fb156ae3          	bltu	a0,a7,11484 <__moddi3+0x434>
   114d4:	00088793          	mv	a5,a7
   114d8:	00000713          	li	a4,0
   114dc:	fbdff06f          	j	11498 <__moddi3+0x448>

000114e0 <atexit>:
int
_DEFUN (atexit,
	(fn),
	_VOID _EXFNPTR(fn, (_VOID)))
{
  return __register_exitproc (__et_atexit, fn, NULL, NULL);
   114e0:	00050593          	mv	a1,a0
   114e4:	00000693          	li	a3,0
   114e8:	00000613          	li	a2,0
   114ec:	00000513          	li	a0,0
   114f0:	2380206f          	j	13728 <__register_exitproc>

000114f4 <__libc_fini_array>:
extern void _fini (void);

/* Run all the cleanup routines.  */
void
__libc_fini_array (void)
{
   114f4:	ff010113          	addi	sp,sp,-16
   114f8:	00812423          	sw	s0,8(sp)
   114fc:	00912223          	sw	s1,4(sp)
  size_t count;
  size_t i;
  
  count = __fini_array_end - __fini_array_start;
   11500:	0001c437          	lui	s0,0x1c
   11504:	0001c4b7          	lui	s1,0x1c
   11508:	19048493          	addi	s1,s1,400 # 1c190 <__init_array_end>
   1150c:	19440413          	addi	s0,s0,404 # 1c194 <__fini_array_end>
   11510:	40940433          	sub	s0,s0,s1
   11514:	40245413          	srai	s0,s0,0x2
   11518:	00241793          	slli	a5,s0,0x2
   1151c:	ffc78793          	addi	a5,a5,-4
extern void _fini (void);

/* Run all the cleanup routines.  */
void
__libc_fini_array (void)
{
   11520:	00112623          	sw	ra,12(sp)
   11524:	009784b3          	add	s1,a5,s1
  size_t count;
  size_t i;
  
  count = __fini_array_end - __fini_array_start;
  for (i = count; i > 0; i--)
   11528:	00040c63          	beqz	s0,11540 <__libc_fini_array+0x4c>
    __fini_array_start[i-1] ();
   1152c:	0004a783          	lw	a5,0(s1)
   11530:	fff40413          	addi	s0,s0,-1
   11534:	ffc48493          	addi	s1,s1,-4
   11538:	000780e7          	jalr	a5
{
  size_t count;
  size_t i;
  
  count = __fini_array_end - __fini_array_start;
  for (i = count; i > 0; i--)
   1153c:	fe0418e3          	bnez	s0,1152c <__libc_fini_array+0x38>
    __fini_array_start[i-1] ();

  _fini ();
}
   11540:	00c12083          	lw	ra,12(sp)
   11544:	00812403          	lw	s0,8(sp)
   11548:	00412483          	lw	s1,4(sp)
   1154c:	01010113          	addi	sp,sp,16
  
  count = __fini_array_end - __fini_array_start;
  for (i = count; i > 0; i--)
    __fini_array_start[i-1] ();

  _fini ();
   11550:	af9fe06f          	j	10048 <_fini>

00011554 <__libc_init_array>:
extern void _init (void);

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
   11554:	ff010113          	addi	sp,sp,-16
   11558:	00812423          	sw	s0,8(sp)
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
   1155c:	0001c7b7          	lui	a5,0x1c
   11560:	0001c437          	lui	s0,0x1c
extern void _init (void);

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
   11564:	01212023          	sw	s2,0(sp)
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
   11568:	18878793          	addi	a5,a5,392 # 1c188 <_etext>
   1156c:	18840913          	addi	s2,s0,392 # 1c188 <_etext>
   11570:	41278933          	sub	s2,a5,s2
   11574:	40295913          	srai	s2,s2,0x2
extern void _init (void);

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
   11578:	00912223          	sw	s1,4(sp)
   1157c:	00112623          	sw	ra,12(sp)
   11580:	18840413          	addi	s0,s0,392
   11584:	00000493          	li	s1,0
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
   11588:	00090c63          	beqz	s2,115a0 <__libc_init_array+0x4c>
    __preinit_array_start[i] ();
   1158c:	00042783          	lw	a5,0(s0)
{
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
   11590:	00148493          	addi	s1,s1,1
   11594:	00440413          	addi	s0,s0,4
    __preinit_array_start[i] ();
   11598:	000780e7          	jalr	a5
{
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
   1159c:	fe9918e3          	bne	s2,s1,1158c <__libc_init_array+0x38>
    __preinit_array_start[i] ();

  _init ();

  count = __init_array_end - __init_array_start;
   115a0:	0001c437          	lui	s0,0x1c

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
    __preinit_array_start[i] ();

  _init ();
   115a4:	aa5fe0ef          	jal	10048 <_fini>

  count = __init_array_end - __init_array_start;
   115a8:	0001c7b7          	lui	a5,0x1c
   115ac:	18840913          	addi	s2,s0,392 # 1c188 <_etext>
   115b0:	19078793          	addi	a5,a5,400 # 1c190 <__init_array_end>
   115b4:	41278933          	sub	s2,a5,s2
   115b8:	40295913          	srai	s2,s2,0x2
   115bc:	18840413          	addi	s0,s0,392
  for (i = 0; i < count; i++)
   115c0:	00000493          	li	s1,0
   115c4:	00090c63          	beqz	s2,115dc <__libc_init_array+0x88>
    __init_array_start[i] ();
   115c8:	00042783          	lw	a5,0(s0)
    __preinit_array_start[i] ();

  _init ();

  count = __init_array_end - __init_array_start;
  for (i = 0; i < count; i++)
   115cc:	00148493          	addi	s1,s1,1
   115d0:	00440413          	addi	s0,s0,4
    __init_array_start[i] ();
   115d4:	000780e7          	jalr	a5
    __preinit_array_start[i] ();

  _init ();

  count = __init_array_end - __init_array_start;
  for (i = 0; i < count; i++)
   115d8:	fe9918e3          	bne	s2,s1,115c8 <__libc_init_array+0x74>
    __init_array_start[i] ();
}
   115dc:	00c12083          	lw	ra,12(sp)
   115e0:	00812403          	lw	s0,8(sp)
   115e4:	00412483          	lw	s1,4(sp)
   115e8:	00012903          	lw	s2,0(sp)
   115ec:	01010113          	addi	sp,sp,16
   115f0:	00008067          	ret

000115f4 <_printf_r>:

int
_DEFUN(_printf_r, (ptr, fmt),
       struct _reent *ptr _AND
       const char *__restrict fmt _DOTS)
{
   115f4:	fc010113          	addi	sp,sp,-64
   115f8:	02c12423          	sw	a2,40(sp)
   115fc:	02d12623          	sw	a3,44(sp)
   11600:	02f12a23          	sw	a5,52(sp)
   11604:	02e12823          	sw	a4,48(sp)
   11608:	03012c23          	sw	a6,56(sp)
   1160c:	03112e23          	sw	a7,60(sp)
  int ret;
  va_list ap;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   11610:	00058613          	mv	a2,a1
   11614:	00852583          	lw	a1,8(a0)
{
  int ret;
  va_list ap;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
   11618:	02810793          	addi	a5,sp,40
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   1161c:	00078693          	mv	a3,a5

int
_DEFUN(_printf_r, (ptr, fmt),
       struct _reent *ptr _AND
       const char *__restrict fmt _DOTS)
{
   11620:	00112e23          	sw	ra,28(sp)
  int ret;
  va_list ap;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
   11624:	00f12623          	sw	a5,12(sp)
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   11628:	1ac000ef          	jal	117d4 <_vfprintf_r>
  va_end (ap);
  return ret;
}
   1162c:	01c12083          	lw	ra,28(sp)
   11630:	04010113          	addi	sp,sp,64
   11634:	00008067          	ret

00011638 <printf>:
_DEFUN(printf, (fmt),
       const char *__restrict fmt _DOTS)
{
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;
   11638:	8101a283          	lw	t0,-2032(gp) # 1de50 <_impure_ptr>
#ifndef _REENT_ONLY

int
_DEFUN(printf, (fmt),
       const char *__restrict fmt _DOTS)
{
   1163c:	fc010113          	addi	sp,sp,-64
   11640:	02c12423          	sw	a2,40(sp)
   11644:	02d12623          	sw	a3,44(sp)
   11648:	02f12a23          	sw	a5,52(sp)
   1164c:	02b12223          	sw	a1,36(sp)
   11650:	02e12823          	sw	a4,48(sp)
   11654:	03012c23          	sw	a6,56(sp)
   11658:	03112e23          	sw	a7,60(sp)
  va_list ap;
  struct _reent *ptr = _REENT;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   1165c:	0082a583          	lw	a1,8(t0)
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
   11660:	02410793          	addi	a5,sp,36
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   11664:	00050613          	mv	a2,a0
   11668:	00078693          	mv	a3,a5
   1166c:	00028513          	mv	a0,t0
#ifndef _REENT_ONLY

int
_DEFUN(printf, (fmt),
       const char *__restrict fmt _DOTS)
{
   11670:	00112e23          	sw	ra,28(sp)
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
   11674:	00f12623          	sw	a5,12(sp)
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   11678:	15c000ef          	jal	117d4 <_vfprintf_r>
  va_end (ap);
  return ret;
}
   1167c:	01c12083          	lw	ra,28(sp)
   11680:	04010113          	addi	sp,sp,64
   11684:	00008067          	ret

00011688 <_puts_r>:

int
_DEFUN(_puts_r, (ptr, s),
       struct _reent *ptr _AND
       _CONST char * s)
{
   11688:	fd010113          	addi	sp,sp,-48
   1168c:	02812423          	sw	s0,40(sp)
   11690:	00050413          	mv	s0,a0
#ifdef _FVWRITE_IN_STREAMIO
  int result;
  size_t c = strlen (s);
   11694:	00058513          	mv	a0,a1

int
_DEFUN(_puts_r, (ptr, s),
       struct _reent *ptr _AND
       _CONST char * s)
{
   11698:	02912223          	sw	s1,36(sp)
   1169c:	02112623          	sw	ra,44(sp)
   116a0:	00058493          	mv	s1,a1
#ifdef _FVWRITE_IN_STREAMIO
  int result;
  size_t c = strlen (s);
   116a4:	0a0000ef          	jal	11744 <strlen>
  uio.uio_resid = c + 1;
  uio.uio_iov = &iov[0];
  uio.uio_iovcnt = 2;

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
   116a8:	00842583          	lw	a1,8(s0)
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
  iov[0].iov_len = c;
  iov[1].iov_base = "\n";
   116ac:	0001c737          	lui	a4,0x1c
   116b0:	12070713          	addi	a4,a4,288 # 1c120 <__thenan_sf+0x10>
  uio.uio_iovcnt = 2;

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
   116b4:	00c59683          	lh	a3,12(a1)
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
  iov[0].iov_len = c;
  iov[1].iov_base = "\n";
   116b8:	00e12c23          	sw	a4,24(sp)
  iov[1].iov_len = 1;
   116bc:	00100713          	li	a4,1
   116c0:	00e12e23          	sw	a4,28(sp)
  uio.uio_resid = c + 1;
  uio.uio_iov = &iov[0];
   116c4:	01010713          	addi	a4,sp,16

  iov[0].iov_base = s;
  iov[0].iov_len = c;
  iov[1].iov_base = "\n";
  iov[1].iov_len = 1;
  uio.uio_resid = c + 1;
   116c8:	00150613          	addi	a2,a0,1
  uio.uio_iov = &iov[0];
   116cc:	00e12223          	sw	a4,4(sp)
  uio.uio_iovcnt = 2;

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
   116d0:	01269793          	slli	a5,a3,0x12
  iov[0].iov_len = c;
  iov[1].iov_base = "\n";
  iov[1].iov_len = 1;
  uio.uio_resid = c + 1;
  uio.uio_iov = &iov[0];
  uio.uio_iovcnt = 2;
   116d4:	00200713          	li	a4,2
  size_t c = strlen (s);
  struct __suio uio;
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
   116d8:	00912823          	sw	s1,16(sp)
  iov[0].iov_len = c;
   116dc:	00a12a23          	sw	a0,20(sp)
  iov[1].iov_base = "\n";
  iov[1].iov_len = 1;
  uio.uio_resid = c + 1;
   116e0:	00c12623          	sw	a2,12(sp)
  uio.uio_iov = &iov[0];
  uio.uio_iovcnt = 2;
   116e4:	00e12423          	sw	a4,8(sp)

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
   116e8:	0207c263          	bltz	a5,1170c <_puts_r+0x84>
  uio.uio_iov = &iov[0];
  uio.uio_iovcnt = 2;

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  _newlib_flockfile_start (fp);
   116ec:	0685a783          	lw	a5,104(a1)
  ORIENT (fp, -1);
   116f0:	ffffe737          	lui	a4,0xffffe
   116f4:	00002637          	lui	a2,0x2
   116f8:	fff70713          	addi	a4,a4,-1 # ffffdfff <_gp+0xfffdf9bf>
   116fc:	00c6e6b3          	or	a3,a3,a2
   11700:	00e7f733          	and	a4,a5,a4
   11704:	00d59623          	sh	a3,12(a1)
   11708:	06e5a423          	sw	a4,104(a1)
  result = (__sfvwrite_r (ptr, fp, &uio) ? EOF : '\n');
   1170c:	00410613          	addi	a2,sp,4
   11710:	00040513          	mv	a0,s0
   11714:	264040ef          	jal	15978 <__sfvwrite_r>

err:
  _newlib_flockfile_end (fp);
  return result;
#endif
}
   11718:	02c12083          	lw	ra,44(sp)

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
  result = (__sfvwrite_r (ptr, fp, &uio) ? EOF : '\n');
   1171c:	00a03533          	snez	a0,a0
   11720:	40a00533          	neg	a0,a0

err:
  _newlib_flockfile_end (fp);
  return result;
#endif
}
   11724:	00a56513          	ori	a0,a0,10
   11728:	02812403          	lw	s0,40(sp)
   1172c:	02412483          	lw	s1,36(sp)
   11730:	03010113          	addi	sp,sp,48
   11734:	00008067          	ret

00011738 <puts>:

int
_DEFUN(puts, (s),
       char _CONST * s)
{
  return _puts_r (_REENT, s);
   11738:	00050593          	mv	a1,a0
   1173c:	8101a503          	lw	a0,-2032(gp) # 1de50 <_impure_ptr>
   11740:	f49ff06f          	j	11688 <_puts_r>

00011744 <strlen>:
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  while (*str++)
    ;
  return str - start - 1;
#else
  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
   11744:	00357793          	andi	a5,a0,3
   11748:	00050593          	mv	a1,a0
   1174c:	04079a63          	bnez	a5,117a0 <strlen+0x5c>
    if (!ch)
      return str - start - 1;
  } while ((uintptr_t)str & (sizeof(long)-1));

  unsigned long* ls = (unsigned long*)str;
  while (!__libc_detect_null(*ls++))
   11750:	7f7f86b7          	lui	a3,0x7f7f8
   11754:	f7f68693          	addi	a3,a3,-129 # 7f7f7f7f <_gp+0x7f7d993f>
   11758:	fff00613          	li	a2,-1
   1175c:	00450513          	addi	a0,a0,4
   11760:	ffc52783          	lw	a5,-4(a0)
   11764:	00d7f733          	and	a4,a5,a3
   11768:	00d70733          	add	a4,a4,a3
   1176c:	00d7e7b3          	or	a5,a5,a3
   11770:	00f767b3          	or	a5,a4,a5
   11774:	fec784e3          	beq	a5,a2,1175c <strlen+0x18>

  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
   11778:	ffc54703          	lbu	a4,-4(a0)
  while (!__libc_detect_null(*ls++))
    ;
  asm volatile ("" : "+r"(ls)); /* prevent "optimization" */

  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);
   1177c:	40b507b3          	sub	a5,a0,a1

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
   11780:	ffd54683          	lbu	a3,-3(a0)
   11784:	ffe54603          	lbu	a2,-2(a0)
  if (c0 == 0)            return ret + 0 - sl;
   11788:	02070e63          	beqz	a4,117c4 <strlen+0x80>
  if (c1 == 0)            return ret + 1 - sl;
   1178c:	02068863          	beqz	a3,117bc <strlen+0x78>
  if (c2 == 0)            return ret + 2 - sl;
  if (sl == 4 || c3 == 0) return ret + 3 - sl;
   11790:	fff78513          	addi	a0,a5,-1
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
  if (c1 == 0)            return ret + 1 - sl;
  if (c2 == 0)            return ret + 2 - sl;
   11794:	02060c63          	beqz	a2,117cc <strlen+0x88>
  if (c0 == 0)            return ret + 4 - sl;
  if (c1 == 0)            return ret + 5 - sl;
  if (c2 == 0)            return ret + 6 - sl;
                          return ret + 7 - sl;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   11798:	00008067          	ret
  {
    char ch = *str;
    str++;
    if (!ch)
      return str - start - 1;
  } while ((uintptr_t)str & (sizeof(long)-1));
   1179c:	fa070ae3          	beqz	a4,11750 <strlen+0xc>
    ;
  return str - start - 1;
#else
  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
  {
    char ch = *str;
   117a0:	00054783          	lbu	a5,0(a0)
    str++;
   117a4:	00150513          	addi	a0,a0,1
    if (!ch)
      return str - start - 1;
  } while ((uintptr_t)str & (sizeof(long)-1));
   117a8:	00357713          	andi	a4,a0,3
#else
  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
  {
    char ch = *str;
    str++;
    if (!ch)
   117ac:	fe0798e3          	bnez	a5,1179c <strlen+0x58>
      return str - start - 1;
   117b0:	40b50533          	sub	a0,a0,a1
   117b4:	fff50513          	addi	a0,a0,-1
   117b8:	00008067          	ret
  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
  if (c1 == 0)            return ret + 1 - sl;
   117bc:	ffd78513          	addi	a0,a5,-3
   117c0:	00008067          	ret

  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
   117c4:	ffc78513          	addi	a0,a5,-4
   117c8:	00008067          	ret
  if (c1 == 0)            return ret + 1 - sl;
  if (c2 == 0)            return ret + 2 - sl;
   117cc:	ffe78513          	addi	a0,a5,-2
  if (c0 == 0)            return ret + 4 - sl;
  if (c1 == 0)            return ret + 5 - sl;
  if (c2 == 0)            return ret + 6 - sl;
                          return ret + 7 - sl;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   117d0:	00008067          	ret

000117d4 <_vfprintf_r>:
_DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
       struct _reent *data _AND
       FILE * fp           _AND
       _CONST char *fmt0   _AND
       va_list ap)
{
   117d4:	ec010113          	addi	sp,sp,-320
   117d8:	12112e23          	sw	ra,316(sp)
   117dc:	12912a23          	sw	s1,308(sp)
   117e0:	13412423          	sw	s4,296(sp)
   117e4:	11812c23          	sw	s8,280(sp)
   117e8:	00058a13          	mv	s4,a1
   117ec:	00060493          	mv	s1,a2
   117f0:	02d12823          	sw	a3,48(sp)
   117f4:	12812c23          	sw	s0,312(sp)
   117f8:	13212823          	sw	s2,304(sp)
   117fc:	13312623          	sw	s3,300(sp)
   11800:	13512223          	sw	s5,292(sp)
   11804:	13612023          	sw	s6,288(sp)
   11808:	11712e23          	sw	s7,284(sp)
   1180c:	11912a23          	sw	s9,276(sp)
   11810:	11a12823          	sw	s10,272(sp)
   11814:	11b12623          	sw	s11,268(sp)
   11818:	00050c13          	mv	s8,a0
	char *thousands_sep = NULL;
	size_t thsnd_len = 0;
	const char *grouping = NULL;
#endif
#ifdef FLOATING_POINT
	char *decimal_point = _localeconv_r (data)->decimal_point;
   1181c:	005040ef          	jal	16020 <_localeconv_r>
   11820:	00052503          	lw	a0,0(a0)
   11824:	04a12223          	sw	a0,68(sp)
	size_t decp_len = strlen (decimal_point);
   11828:	f1dff0ef          	jal	11744 <strlen>
   1182c:	04a12623          	sw	a0,76(sp)
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
   11830:	000c0663          	beqz	s8,1183c <_vfprintf_r+0x68>
   11834:	038c2783          	lw	a5,56(s8)
   11838:	2a078863          	beqz	a5,11ae8 <_vfprintf_r+0x314>
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);
   1183c:	00ca1683          	lh	a3,12(s4)
   11840:	01069793          	slli	a5,a3,0x10
   11844:	0107d793          	srli	a5,a5,0x10
   11848:	01279613          	slli	a2,a5,0x12
   1184c:	02064663          	bltz	a2,11878 <_vfprintf_r+0xa4>
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
	_newlib_flockfile_start (fp);
   11850:	068a2603          	lw	a2,104(s4)

	ORIENT(fp, -1);
   11854:	000027b7          	lui	a5,0x2
   11858:	ffffe737          	lui	a4,0xffffe
   1185c:	00f6e7b3          	or	a5,a3,a5
   11860:	fff70713          	addi	a4,a4,-1 # ffffdfff <_gp+0xfffdf9bf>
   11864:	00e67733          	and	a4,a2,a4
   11868:	00fa1623          	sh	a5,12(s4)
   1186c:	01079793          	slli	a5,a5,0x10
   11870:	06ea2423          	sw	a4,104(s4)
   11874:	0107d793          	srli	a5,a5,0x10

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   11878:	0087f713          	andi	a4,a5,8
   1187c:	1a070263          	beqz	a4,11a20 <_vfprintf_r+0x24c>
   11880:	010a2703          	lw	a4,16(s4)
   11884:	18070e63          	beqz	a4,11a20 <_vfprintf_r+0x24c>
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   11888:	01a7f793          	andi	a5,a5,26
   1188c:	00a00713          	li	a4,10
   11890:	1ae78a63          	beq	a5,a4,11a44 <_vfprintf_r+0x270>
   11894:	0001c7b7          	lui	a5,0x1c
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   11898:	0c010693          	addi	a3,sp,192
   1189c:	e2878b93          	addi	s7,a5,-472 # 1be28 <blanks.4190>
   118a0:	0001c7b7          	lui	a5,0x1c
   118a4:	00d12e23          	sw	a3,28(sp)
   118a8:	08d12623          	sw	a3,140(sp)
	uio.uio_resid = 0;
   118ac:	08012a23          	sw	zero,148(sp)
	uio.uio_iovcnt = 0;
   118b0:	08012823          	sw	zero,144(sp)
	int expsize = 0;	/* character count for expstr */
	char expstr[MAXEXPLEN];	/* buffer for exponent string */
	int lead;		/* sig figs before decimal or group sep */
#endif /* FLOATING_POINT */
#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
	int ndig = 0;		/* actual number of digits returned by cvt */
   118b4:	04012023          	sw	zero,64(sp)
#endif
#ifdef FLOATING_POINT
	char *decimal_point = _localeconv_r (data)->decimal_point;
	size_t decp_len = strlen (decimal_point);
	char softsign;		/* temporary negative sign for floats */
	union { int i; _PRINTF_FLOAT_TYPE fp; } _double_ = {0};
   118b8:	04012823          	sw	zero,80(sp)
   118bc:	04012a23          	sw	zero,84(sp)
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   118c0:	00068293          	mv	t0,a3
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
   118c4:	04012c23          	sw	zero,88(sp)
	size_t decp_len = strlen (decimal_point);
	char softsign;		/* temporary negative sign for floats */
	union { int i; _PRINTF_FLOAT_TYPE fp; } _double_ = {0};
# define _fpvalue (_double_.fp)
	int expt;		/* integer value of exponent */
	int expsize = 0;	/* character count for expstr */
   118c8:	04012e23          	sw	zero,92(sp)
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
	uio.uio_resid = 0;
	uio.uio_iovcnt = 0;
#endif
	ret = 0;
   118cc:	02012a23          	sw	zero,52(sp)
   118d0:	e3878d13          	addi	s10,a5,-456 # 1be38 <zeroes.4191>
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   118d4:	0004c783          	lbu	a5,0(s1)
   118d8:	6c078263          	beqz	a5,11f9c <_vfprintf_r+0x7c8>
   118dc:	02500713          	li	a4,37
   118e0:	00048413          	mv	s0,s1
   118e4:	00e79663          	bne	a5,a4,118f0 <_vfprintf_r+0x11c>
   118e8:	0540006f          	j	1193c <_vfprintf_r+0x168>
   118ec:	00e78863          	beq	a5,a4,118fc <_vfprintf_r+0x128>
                    fmt += 1;
   118f0:	00140413          	addi	s0,s0,1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   118f4:	00044783          	lbu	a5,0(s0)
   118f8:	fe079ae3          	bnez	a5,118ec <_vfprintf_r+0x118>
   118fc:	40940933          	sub	s2,s0,s1
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
   11900:	02090e63          	beqz	s2,1193c <_vfprintf_r+0x168>
			PRINT (cp, m);
   11904:	09412703          	lw	a4,148(sp)
   11908:	09012783          	lw	a5,144(sp)
   1190c:	0092a023          	sw	s1,0(t0)
   11910:	01270733          	add	a4,a4,s2
   11914:	00178793          	addi	a5,a5,1
   11918:	08e12a23          	sw	a4,148(sp)
   1191c:	00700713          	li	a4,7
   11920:	0122a223          	sw	s2,4(t0)
   11924:	08f12823          	sw	a5,144(sp)
   11928:	00828293          	addi	t0,t0,8
   1192c:	12f74c63          	blt	a4,a5,11a64 <_vfprintf_r+0x290>
			ret += m;
   11930:	03412703          	lw	a4,52(sp)
   11934:	01270733          	add	a4,a4,s2
   11938:	02e12a23          	sw	a4,52(sp)
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
   1193c:	00044783          	lbu	a5,0(s0)
   11940:	14078063          	beqz	a5,11a80 <_vfprintf_r+0x2ac>
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
   11944:	fff00793          	li	a5,-1
#else
                if (*fmt == '\0')
                    goto done;
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */
   11948:	00140493          	addi	s1,s0,1

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
   1194c:	060107a3          	sb	zero,111(sp)
   11950:	00000593          	li	a1,0
   11954:	00000513          	li	a0,0
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
   11958:	02f12423          	sw	a5,40(sp)
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
   1195c:	00000b13          	li	s6,0
                    goto done;
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
   11960:	00000913          	li	s2,0
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   11964:	05800693          	li	a3,88
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			} while (is_digit (ch));
   11968:	00900613          	li	a2,9
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
   1196c:	02a00813          	li	a6,42
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
   11970:	0004c983          	lbu	s3,0(s1)
   11974:	00148493          	addi	s1,s1,1
reswitch:	switch (ch) {
   11978:	fe098793          	addi	a5,s3,-32
   1197c:	1ef6e0e3          	bltu	a3,a5,1235c <_vfprintf_r+0xb88>
   11980:	0001c737          	lui	a4,0x1c
   11984:	00279793          	slli	a5,a5,0x2
   11988:	cc470713          	addi	a4,a4,-828 # 1bcc4 <__clz_tab+0x100>
   1198c:	00e787b3          	add	a5,a5,a4
   11990:	0007a783          	lw	a5,0(a5)
   11994:	00078067          	jr	a5
			} else
#endif
				flags |= LONGINT;
			goto rflag;
		case 'q': /* extension */
			flags |= QUADINT;
   11998:	01096913          	ori	s2,s2,16
			goto rflag;
   1199c:	fd5ff06f          	j	11970 <_vfprintf_r+0x19c>
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   119a0:	03012783          	lw	a5,48(sp)
   119a4:	0007ab03          	lw	s6,0(a5)
   119a8:	00478793          	addi	a5,a5,4
   119ac:	02f12823          	sw	a5,48(sp)
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
   119b0:	fc0b50e3          	bgez	s6,11970 <_vfprintf_r+0x19c>
				goto rflag;
			width = -width;
   119b4:	41600b33          	neg	s6,s6
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
   119b8:	00496913          	ori	s2,s2,4
			goto rflag;
   119bc:	fb5ff06f          	j	11970 <_vfprintf_r+0x19c>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   119c0:	03012683          	lw	a3,48(sp)
			base = HEX;
			xdigs = "0123456789abcdef";
			flags |= HEXPREFIX;
   119c4:	00296613          	ori	a2,s2,2

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   119c8:	060107a3          	sb	zero,111(sp)
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   119cc:	00468713          	addi	a4,a3,4
   119d0:	0006a783          	lw	a5,0(a3)
			base = HEX;
			xdigs = "0123456789abcdef";
			flags |= HEXPREFIX;
			ox[0] = '0';
   119d4:	03000693          	li	a3,48
   119d8:	06d10823          	sb	a3,112(sp)
			ox[1] = ch = 'x';
   119dc:	07800693          	li	a3,120
   119e0:	06d108a3          	sb	a3,113(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   119e4:	02812683          	lw	a3,40(sp)
   119e8:	1806cae3          	bltz	a3,1237c <_vfprintf_r+0xba8>
   119ec:	f7f97913          	andi	s2,s2,-129
				flags &= ~ZEROPAD;
   119f0:	00296913          	ori	s2,s2,2
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   119f4:	02e12823          	sw	a4,48(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   119f8:	140796e3          	bnez	a5,12344 <_vfprintf_r+0xb70>
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   119fc:	0001c7b7          	lui	a5,0x1c
   11a00:	14878793          	addi	a5,a5,328 # 1c148 <__thenan_sf+0x38>
   11a04:	04f12c23          	sw	a5,88(sp)
			flags |= HEXPREFIX;
			ox[0] = '0';
			ox[1] = ch = 'x';
   11a08:	07800993          	li	s3,120
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   11a0c:	02812783          	lw	a5,40(sp)
   11a10:	00000613          	li	a2,0
   11a14:	7e078063          	beqz	a5,121f4 <_vfprintf_r+0xa20>
   11a18:	00000793          	li	a5,0
   11a1c:	7140006f          	j	12130 <_vfprintf_r+0x95c>
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   11a20:	000a0593          	mv	a1,s4
   11a24:	000c0513          	mv	a0,s8
   11a28:	3ad010ef          	jal	135d4 <__swsetup_r>
   11a2c:	00050463          	beqz	a0,11a34 <_vfprintf_r+0x260>
   11a30:	3e00106f          	j	12e10 <_vfprintf_r+0x163c>
   11a34:	00ca5783          	lhu	a5,12(s4)
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   11a38:	00a00713          	li	a4,10
   11a3c:	01a7f793          	andi	a5,a5,26
   11a40:	e4e79ae3          	bne	a5,a4,11894 <_vfprintf_r+0xc0>
   11a44:	00ea1783          	lh	a5,14(s4)
   11a48:	e407c6e3          	bltz	a5,11894 <_vfprintf_r+0xc0>
	    fp->_file >= 0) {
		_newlib_flockfile_exit (fp);
		return (__sbprintf (data, fp, fmt0, ap));
   11a4c:	03012683          	lw	a3,48(sp)
   11a50:	00048613          	mv	a2,s1
   11a54:	000a0593          	mv	a1,s4
   11a58:	000c0513          	mv	a0,s8
   11a5c:	2b9010ef          	jal	13514 <__sbprintf>
   11a60:	04c0006f          	j	11aac <_vfprintf_r+0x2d8>
#else
                while (*fmt != '\0' && *fmt != '%')
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
			PRINT (cp, m);
   11a64:	08c10613          	addi	a2,sp,140
   11a68:	000a0593          	mv	a1,s4
   11a6c:	000c0513          	mv	a0,s8
   11a70:	445060ef          	jal	186b4 <__sprint_r>
   11a74:	02051263          	bnez	a0,11a98 <_vfprintf_r+0x2c4>
   11a78:	0c010293          	addi	t0,sp,192
   11a7c:	eb5ff06f          	j	11930 <_vfprintf_r+0x15c>
			_free_r (data, malloc_buf);
			malloc_buf = NULL;
		}
	}
done:
	FLUSH ();
   11a80:	09412783          	lw	a5,148(sp)
   11a84:	00078a63          	beqz	a5,11a98 <_vfprintf_r+0x2c4>
   11a88:	08c10613          	addi	a2,sp,140
   11a8c:	000a0593          	mv	a1,s4
   11a90:	000c0513          	mv	a0,s8
   11a94:	421060ef          	jal	186b4 <__sprint_r>
	if (malloc_buf != NULL)
		_free_r (data, malloc_buf);
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
   11a98:	00ca5783          	lhu	a5,12(s4)
   11a9c:	0407f793          	andi	a5,a5,64
   11aa0:	00078463          	beqz	a5,11aa8 <_vfprintf_r+0x2d4>
   11aa4:	36c0106f          	j	12e10 <_vfprintf_r+0x163c>
   11aa8:	03412503          	lw	a0,52(sp)
	/* NOTREACHED */
}
   11aac:	13c12083          	lw	ra,316(sp)
   11ab0:	13812403          	lw	s0,312(sp)
   11ab4:	13412483          	lw	s1,308(sp)
   11ab8:	13012903          	lw	s2,304(sp)
   11abc:	12c12983          	lw	s3,300(sp)
   11ac0:	12812a03          	lw	s4,296(sp)
   11ac4:	12412a83          	lw	s5,292(sp)
   11ac8:	12012b03          	lw	s6,288(sp)
   11acc:	11c12b83          	lw	s7,284(sp)
   11ad0:	11812c03          	lw	s8,280(sp)
   11ad4:	11412c83          	lw	s9,276(sp)
   11ad8:	11012d03          	lw	s10,272(sp)
   11adc:	10c12d83          	lw	s11,268(sp)
   11ae0:	14010113          	addi	sp,sp,320
   11ae4:	00008067          	ret
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
   11ae8:	000c0513          	mv	a0,s8
   11aec:	271030ef          	jal	1555c <__sinit>
   11af0:	d4dff06f          	j	1183c <_vfprintf_r+0x68>
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   11af4:	00100593          	li	a1,1
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
			goto rflag;
		case '+':
			sign = '+';
   11af8:	02b00513          	li	a0,43
   11afc:	e75ff06f          	j	11970 <_vfprintf_r+0x19c>
   11b00:	00058463          	beqz	a1,11b08 <_vfprintf_r+0x334>
   11b04:	1d50106f          	j	134d8 <_vfprintf_r+0x1d04>
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   11b08:	01097793          	andi	a5,s2,16
   11b0c:	54078463          	beqz	a5,12054 <_vfprintf_r+0x880>
   11b10:	03012683          	lw	a3,48(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   11b14:	02812603          	lw	a2,40(sp)
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   11b18:	0006a783          	lw	a5,0(a3)
   11b1c:	00468713          	addi	a4,a3,4

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   11b20:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   11b24:	54064863          	bltz	a2,12074 <_vfprintf_r+0x8a0>
				flags &= ~ZEROPAD;
   11b28:	f7f97913          	andi	s2,s2,-129
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   11b2c:	02e12823          	sw	a4,48(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   11b30:	54079863          	bnez	a5,12080 <_vfprintf_r+0x8ac>
   11b34:	02812683          	lw	a3,40(sp)
   11b38:	00000613          	li	a2,0
   11b3c:	00000793          	li	a5,0
   11b40:	00069463          	bnez	a3,11b48 <_vfprintf_r+0x374>
   11b44:	3c40106f          	j	12f08 <_vfprintf_r+0x1734>
   11b48:	0c010413          	addi	s0,sp,192
				 * a variable; hence this switch.
				 */
				switch (base) {
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   11b4c:	0077f713          	andi	a4,a5,7
   11b50:	fff40413          	addi	s0,s0,-1
   11b54:	03070713          	addi	a4,a4,48
						_uquad >>= 3;
   11b58:	0037d793          	srli	a5,a5,0x3
				 * a variable; hence this switch.
				 */
				switch (base) {
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   11b5c:	00e40023          	sb	a4,0(s0)
						_uquad >>= 3;
					} while (_uquad);
   11b60:	fe0796e3          	bnez	a5,11b4c <_vfprintf_r+0x378>
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
   11b64:	00197793          	andi	a5,s2,1
   11b68:	3e0780e3          	beqz	a5,12748 <_vfprintf_r+0xf74>
   11b6c:	03000793          	li	a5,48
   11b70:	48f70a63          	beq	a4,a5,12004 <_vfprintf_r+0x830>
   11b74:	01c12683          	lw	a3,28(sp)
						*--cp = '0';
   11b78:	fff40713          	addi	a4,s0,-1
   11b7c:	fef40fa3          	sb	a5,-1(s0)
   11b80:	40e686b3          	sub	a3,a3,a4
   11b84:	02d12623          	sw	a3,44(sp)
   11b88:	00070413          	mv	s0,a4
   11b8c:	5d40006f          	j	12160 <_vfprintf_r+0x98c>
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
   11b90:	0004c983          	lbu	s3,0(s1)
   11b94:	00148493          	addi	s1,s1,1
   11b98:	01099463          	bne	s3,a6,11ba0 <_vfprintf_r+0x3cc>
   11b9c:	0b90106f          	j	13454 <_vfprintf_r+0x1c80>
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   11ba0:	fd098893          	addi	a7,s3,-48
   11ba4:	00000793          	li	a5,0
   11ba8:	01167463          	bleu	a7,a2,11bb0 <_vfprintf_r+0x3dc>
   11bac:	6300106f          	j	131dc <_vfprintf_r+0x1a08>
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
   11bb0:	00148493          	addi	s1,s1,1
   11bb4:	fff4c983          	lbu	s3,-1(s1)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
				n = 10 * n + to_digit (ch);
   11bb8:	00179713          	slli	a4,a5,0x1
   11bbc:	00379793          	slli	a5,a5,0x3
   11bc0:	00f707b3          	add	a5,a4,a5
   11bc4:	011787b3          	add	a5,a5,a7
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   11bc8:	fd098893          	addi	a7,s3,-48
   11bcc:	ff1672e3          	bleu	a7,a2,11bb0 <_vfprintf_r+0x3dc>
   11bd0:	0007d463          	bgez	a5,11bd8 <_vfprintf_r+0x404>
   11bd4:	42c0106f          	j	13000 <_vfprintf_r+0x182c>
   11bd8:	02f12423          	sw	a5,40(sp)
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			}
			prec = n < 0 ? -1 : n;
			goto reswitch;
   11bdc:	d9dff06f          	j	11978 <_vfprintf_r+0x1a4>
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
   11be0:	08096913          	ori	s2,s2,128
			goto rflag;
   11be4:	d8dff06f          	j	11970 <_vfprintf_r+0x19c>
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
   11be8:	d80514e3          	bnez	a0,11970 <_vfprintf_r+0x19c>
   11bec:	00100593          	li	a1,1
				sign = ' ';
   11bf0:	02000513          	li	a0,32
   11bf4:	d7dff06f          	j	11970 <_vfprintf_r+0x19c>
			goto rflag;
		case '#':
			flags |= ALT;
   11bf8:	00196913          	ori	s2,s2,1
			goto rflag;
   11bfc:	d75ff06f          	j	11970 <_vfprintf_r+0x19c>
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   11c00:	03012703          	lw	a4,48(sp)
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
   11c04:	060107a3          	sb	zero,111(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   11c08:	00072403          	lw	s0,0(a4)
   11c0c:	00470c93          	addi	s9,a4,4
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
   11c10:	00041463          	bnez	s0,11c18 <_vfprintf_r+0x444>
   11c14:	4240106f          	j	13038 <_vfprintf_r+0x1864>
				}
				cp[size] = '\0';
			}
			else
#endif /* _MB_CAPABLE */
			if (prec >= 0) {
   11c18:	02812783          	lw	a5,40(sp)
   11c1c:	0007d463          	bgez	a5,11c24 <_vfprintf_r+0x450>
   11c20:	3400106f          	j	12f60 <_vfprintf_r+0x178c>
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);
   11c24:	00078613          	mv	a2,a5
   11c28:	00000593          	li	a1,0
   11c2c:	00040513          	mv	a0,s0
   11c30:	00512a23          	sw	t0,20(sp)
   11c34:	51d040ef          	jal	16950 <memchr>

				if (p != NULL)
   11c38:	01412283          	lw	t0,20(sp)
   11c3c:	00051463          	bnez	a0,11c44 <_vfprintf_r+0x470>
   11c40:	4c80106f          	j	13108 <_vfprintf_r+0x1934>
					size = p - cp;
   11c44:	40850533          	sub	a0,a0,s0
   11c48:	02a12623          	sw	a0,44(sp)
   11c4c:	00050a93          	mv	s5,a0
   11c50:	00055463          	bgez	a0,11c58 <_vfprintf_r+0x484>
   11c54:	32c0106f          	j	12f80 <_vfprintf_r+0x17ac>
   11c58:	06f14603          	lbu	a2,111(sp)
				else
					size = prec;
			} else
				size = strlen (cp);
   11c5c:	03512023          	sw	s5,32(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   11c60:	03912823          	sw	s9,48(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   11c64:	02012423          	sw	zero,40(sp)
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   11c68:	02012e23          	sw	zero,60(sp)
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
		if (sign)
   11c6c:	00060863          	beqz	a2,11c7c <_vfprintf_r+0x4a8>
			realsz++;
   11c70:	02012783          	lw	a5,32(sp)
   11c74:	00178793          	addi	a5,a5,1
   11c78:	02f12023          	sw	a5,32(sp)
		if (flags & HEXPREFIX)
   11c7c:	00297693          	andi	a3,s2,2
   11c80:	02d12223          	sw	a3,36(sp)
   11c84:	00068863          	beqz	a3,11c94 <_vfprintf_r+0x4c0>
			realsz+= 2;
   11c88:	02012703          	lw	a4,32(sp)
   11c8c:	00270713          	addi	a4,a4,2
   11c90:	02e12023          	sw	a4,32(sp)

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   11c94:	08497793          	andi	a5,s2,132
   11c98:	02f12c23          	sw	a5,56(sp)
   11c9c:	70079e63          	bnez	a5,123b8 <_vfprintf_r+0xbe4>
			PAD (width - realsz, blanks);
   11ca0:	02012703          	lw	a4,32(sp)
   11ca4:	40eb0db3          	sub	s11,s6,a4
   11ca8:	71b05863          	blez	s11,123b8 <_vfprintf_r+0xbe4>
   11cac:	01000813          	li	a6,16
   11cb0:	09412783          	lw	a5,148(sp)
   11cb4:	09012703          	lw	a4,144(sp)
   11cb8:	05712423          	sw	s7,72(sp)
   11cbc:	07b85063          	ble	s11,a6,11d1c <_vfprintf_r+0x548>
   11cc0:	00080c93          	mv	s9,a6
   11cc4:	00700a93          	li	s5,7
   11cc8:	00c0006f          	j	11cd4 <_vfprintf_r+0x500>
   11ccc:	ff0d8d93          	addi	s11,s11,-16
   11cd0:	05bcd663          	ble	s11,s9,11d1c <_vfprintf_r+0x548>
   11cd4:	01078793          	addi	a5,a5,16
   11cd8:	00170713          	addi	a4,a4,1
   11cdc:	0172a023          	sw	s7,0(t0)
   11ce0:	0192a223          	sw	s9,4(t0)
   11ce4:	08f12a23          	sw	a5,148(sp)
   11ce8:	08e12823          	sw	a4,144(sp)
   11cec:	00828293          	addi	t0,t0,8
   11cf0:	fceadee3          	ble	a4,s5,11ccc <_vfprintf_r+0x4f8>
   11cf4:	08c10613          	addi	a2,sp,140
   11cf8:	000a0593          	mv	a1,s4
   11cfc:	000c0513          	mv	a0,s8
   11d00:	1b5060ef          	jal	186b4 <__sprint_r>
   11d04:	d8051ae3          	bnez	a0,11a98 <_vfprintf_r+0x2c4>
   11d08:	ff0d8d93          	addi	s11,s11,-16
   11d0c:	09412783          	lw	a5,148(sp)
   11d10:	09012703          	lw	a4,144(sp)
   11d14:	0c010293          	addi	t0,sp,192
   11d18:	fbbccee3          	blt	s9,s11,11cd4 <_vfprintf_r+0x500>
   11d1c:	04812683          	lw	a3,72(sp)
   11d20:	00fd87b3          	add	a5,s11,a5
   11d24:	00170713          	addi	a4,a4,1
   11d28:	00d2a023          	sw	a3,0(t0)
   11d2c:	00700693          	li	a3,7
   11d30:	01b2a223          	sw	s11,4(t0)
   11d34:	08f12a23          	sw	a5,148(sp)
   11d38:	08e12823          	sw	a4,144(sp)
   11d3c:	2ee6c8e3          	blt	a3,a4,1282c <_vfprintf_r+0x1058>
   11d40:	06f14603          	lbu	a2,111(sp)
   11d44:	00828293          	addi	t0,t0,8

		/* prefix */
		if (sign)
   11d48:	02060a63          	beqz	a2,11d7c <_vfprintf_r+0x5a8>
			PRINT (&sign, 1);
   11d4c:	09012703          	lw	a4,144(sp)
   11d50:	06f10693          	addi	a3,sp,111
   11d54:	00d2a023          	sw	a3,0(t0)
   11d58:	00100693          	li	a3,1
   11d5c:	00d2a223          	sw	a3,4(t0)
   11d60:	00178793          	addi	a5,a5,1
   11d64:	00170713          	addi	a4,a4,1
   11d68:	00700693          	li	a3,7
   11d6c:	08f12a23          	sw	a5,148(sp)
   11d70:	08e12823          	sw	a4,144(sp)
   11d74:	00828293          	addi	t0,t0,8
   11d78:	18e6c0e3          	blt	a3,a4,126f8 <_vfprintf_r+0xf24>
		if (flags & HEXPREFIX)
   11d7c:	02412703          	lw	a4,36(sp)
   11d80:	02070a63          	beqz	a4,11db4 <_vfprintf_r+0x5e0>
			PRINT (ox, 2);
   11d84:	09012703          	lw	a4,144(sp)
   11d88:	07010693          	addi	a3,sp,112
   11d8c:	00d2a023          	sw	a3,0(t0)
   11d90:	00200693          	li	a3,2
   11d94:	00d2a223          	sw	a3,4(t0)
   11d98:	00278793          	addi	a5,a5,2
   11d9c:	00170713          	addi	a4,a4,1
   11da0:	00700693          	li	a3,7
   11da4:	08f12a23          	sw	a5,148(sp)
   11da8:	08e12823          	sw	a4,144(sp)
   11dac:	00828293          	addi	t0,t0,8
   11db0:	16e6c4e3          	blt	a3,a4,12718 <_vfprintf_r+0xf44>

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   11db4:	03812683          	lw	a3,56(sp)
   11db8:	08000713          	li	a4,128
   11dbc:	02e682e3          	beq	a3,a4,125e0 <_vfprintf_r+0xe0c>
			PAD (width - realsz, zeroes);

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   11dc0:	02812703          	lw	a4,40(sp)
   11dc4:	02c12683          	lw	a3,44(sp)
   11dc8:	40d70cb3          	sub	s9,a4,a3
   11dcc:	0b905863          	blez	s9,11e7c <_vfprintf_r+0x6a8>
   11dd0:	01000d93          	li	s11,16
   11dd4:	09012703          	lw	a4,144(sp)
   11dd8:	03a12223          	sw	s10,36(sp)
   11ddc:	059dde63          	ble	s9,s11,11e38 <_vfprintf_r+0x664>
   11de0:	00700a93          	li	s5,7
   11de4:	00c0006f          	j	11df0 <_vfprintf_r+0x61c>
   11de8:	ff0c8c93          	addi	s9,s9,-16
   11dec:	059dd663          	ble	s9,s11,11e38 <_vfprintf_r+0x664>
   11df0:	01078793          	addi	a5,a5,16
   11df4:	00170713          	addi	a4,a4,1
   11df8:	01a2a023          	sw	s10,0(t0)
   11dfc:	01b2a223          	sw	s11,4(t0)
   11e00:	08f12a23          	sw	a5,148(sp)
   11e04:	08e12823          	sw	a4,144(sp)
   11e08:	00828293          	addi	t0,t0,8
   11e0c:	fceadee3          	ble	a4,s5,11de8 <_vfprintf_r+0x614>
   11e10:	08c10613          	addi	a2,sp,140
   11e14:	000a0593          	mv	a1,s4
   11e18:	000c0513          	mv	a0,s8
   11e1c:	099060ef          	jal	186b4 <__sprint_r>
   11e20:	c6051ce3          	bnez	a0,11a98 <_vfprintf_r+0x2c4>
   11e24:	ff0c8c93          	addi	s9,s9,-16
   11e28:	09412783          	lw	a5,148(sp)
   11e2c:	09012703          	lw	a4,144(sp)
   11e30:	0c010293          	addi	t0,sp,192
   11e34:	fb9dcee3          	blt	s11,s9,11df0 <_vfprintf_r+0x61c>
   11e38:	02412683          	lw	a3,36(sp)
   11e3c:	019787b3          	add	a5,a5,s9
   11e40:	00170713          	addi	a4,a4,1
   11e44:	00d2a023          	sw	a3,0(t0)
   11e48:	00700693          	li	a3,7
   11e4c:	0192a223          	sw	s9,4(t0)
   11e50:	08f12a23          	sw	a5,148(sp)
   11e54:	08e12823          	sw	a4,144(sp)
   11e58:	00828293          	addi	t0,t0,8
   11e5c:	02e6d063          	ble	a4,a3,11e7c <_vfprintf_r+0x6a8>
   11e60:	08c10613          	addi	a2,sp,140
   11e64:	000a0593          	mv	a1,s4
   11e68:	000c0513          	mv	a0,s8
   11e6c:	049060ef          	jal	186b4 <__sprint_r>
   11e70:	c20514e3          	bnez	a0,11a98 <_vfprintf_r+0x2c4>
   11e74:	09412783          	lw	a5,148(sp)
   11e78:	0c010293          	addi	t0,sp,192

		/* the string or number proper */
#ifdef FLOATING_POINT
		if ((flags & FPT) == 0) {
   11e7c:	10097713          	andi	a4,s2,256
   11e80:	64071263          	bnez	a4,124c4 <_vfprintf_r+0xcf0>
			PRINT (cp, size);
   11e84:	02c12703          	lw	a4,44(sp)
   11e88:	02c12683          	lw	a3,44(sp)
   11e8c:	0082a023          	sw	s0,0(t0)
   11e90:	00e787b3          	add	a5,a5,a4
   11e94:	09012703          	lw	a4,144(sp)
   11e98:	00d2a223          	sw	a3,4(t0)
   11e9c:	00700693          	li	a3,7
   11ea0:	00170713          	addi	a4,a4,1
   11ea4:	08f12a23          	sw	a5,148(sp)
   11ea8:	08e12823          	sw	a4,144(sp)
   11eac:	5ee6cc63          	blt	a3,a4,124a4 <_vfprintf_r+0xcd0>
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
   11eb0:	00828293          	addi	t0,t0,8
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   11eb4:	00497913          	andi	s2,s2,4
   11eb8:	0a090a63          	beqz	s2,11f6c <_vfprintf_r+0x798>
			PAD (width - realsz, blanks);
   11ebc:	02012703          	lw	a4,32(sp)
   11ec0:	40eb0433          	sub	s0,s6,a4
   11ec4:	0a805463          	blez	s0,11f6c <_vfprintf_r+0x798>
   11ec8:	01000913          	li	s2,16
   11ecc:	09012703          	lw	a4,144(sp)
   11ed0:	05712423          	sw	s7,72(sp)
   11ed4:	04895e63          	ble	s0,s2,11f30 <_vfprintf_r+0x75c>
   11ed8:	00700993          	li	s3,7
   11edc:	00c0006f          	j	11ee8 <_vfprintf_r+0x714>
   11ee0:	ff040413          	addi	s0,s0,-16
   11ee4:	04895663          	ble	s0,s2,11f30 <_vfprintf_r+0x75c>
   11ee8:	01078793          	addi	a5,a5,16
   11eec:	00170713          	addi	a4,a4,1
   11ef0:	0172a023          	sw	s7,0(t0)
   11ef4:	0122a223          	sw	s2,4(t0)
   11ef8:	08f12a23          	sw	a5,148(sp)
   11efc:	08e12823          	sw	a4,144(sp)
   11f00:	00828293          	addi	t0,t0,8
   11f04:	fce9dee3          	ble	a4,s3,11ee0 <_vfprintf_r+0x70c>
   11f08:	08c10613          	addi	a2,sp,140
   11f0c:	000a0593          	mv	a1,s4
   11f10:	000c0513          	mv	a0,s8
   11f14:	7a0060ef          	jal	186b4 <__sprint_r>
   11f18:	b80510e3          	bnez	a0,11a98 <_vfprintf_r+0x2c4>
   11f1c:	ff040413          	addi	s0,s0,-16
   11f20:	09412783          	lw	a5,148(sp)
   11f24:	09012703          	lw	a4,144(sp)
   11f28:	0c010293          	addi	t0,sp,192
   11f2c:	fa894ee3          	blt	s2,s0,11ee8 <_vfprintf_r+0x714>
   11f30:	04812683          	lw	a3,72(sp)
   11f34:	008787b3          	add	a5,a5,s0
   11f38:	00170713          	addi	a4,a4,1
   11f3c:	00d2a023          	sw	a3,0(t0)
   11f40:	00700693          	li	a3,7
   11f44:	0082a223          	sw	s0,4(t0)
   11f48:	08f12a23          	sw	a5,148(sp)
   11f4c:	08e12823          	sw	a4,144(sp)
   11f50:	00e6de63          	ble	a4,a3,11f6c <_vfprintf_r+0x798>
   11f54:	08c10613          	addi	a2,sp,140
   11f58:	000a0593          	mv	a1,s4
   11f5c:	000c0513          	mv	a0,s8
   11f60:	754060ef          	jal	186b4 <__sprint_r>
   11f64:	b2051ae3          	bnez	a0,11a98 <_vfprintf_r+0x2c4>
   11f68:	09412783          	lw	a5,148(sp)

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   11f6c:	02012603          	lw	a2,32(sp)
   11f70:	000b0713          	mv	a4,s6
   11f74:	00cb5463          	ble	a2,s6,11f7c <_vfprintf_r+0x7a8>
   11f78:	00060713          	mv	a4,a2
   11f7c:	03412683          	lw	a3,52(sp)
   11f80:	00e686b3          	add	a3,a3,a4
   11f84:	02d12a23          	sw	a3,52(sp)

		FLUSH ();	/* copy out the I/O vectors */
   11f88:	74079c63          	bnez	a5,126e0 <_vfprintf_r+0xf0c>
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   11f8c:	0004c783          	lbu	a5,0(s1)
			PAD (width - realsz, blanks);

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;

		FLUSH ();	/* copy out the I/O vectors */
   11f90:	08012823          	sw	zero,144(sp)
   11f94:	0c010293          	addi	t0,sp,192
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   11f98:	940792e3          	bnez	a5,118dc <_vfprintf_r+0x108>
   11f9c:	00048413          	mv	s0,s1
   11fa0:	99dff06f          	j	1193c <_vfprintf_r+0x168>
   11fa4:	00058463          	beqz	a1,11fac <_vfprintf_r+0x7d8>
   11fa8:	5200106f          	j	134c8 <_vfprintf_r+0x1cf4>
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   11fac:	01097793          	andi	a5,s2,16
   11fb0:	0e078663          	beqz	a5,1209c <_vfprintf_r+0x8c8>
   11fb4:	03012683          	lw	a3,48(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   11fb8:	02812603          	lw	a2,40(sp)
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   11fbc:	0006a783          	lw	a5,0(a3)
   11fc0:	00468713          	addi	a4,a3,4

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   11fc4:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   11fc8:	0e064a63          	bltz	a2,120bc <_vfprintf_r+0x8e8>
				flags &= ~ZEROPAD;
   11fcc:	f7f97913          	andi	s2,s2,-129
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   11fd0:	02e12823          	sw	a4,48(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   11fd4:	00000613          	li	a2,0
   11fd8:	20078a63          	beqz	a5,121ec <_vfprintf_r+0xa18>
						*--cp = '0';
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   11fdc:	00900713          	li	a4,9
   11fe0:	0c010413          	addi	s0,sp,192
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   11fe4:	00a00693          	li	a3,10
						*--cp = '0';
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   11fe8:	74f77a63          	bleu	a5,a4,1273c <_vfprintf_r+0xf68>
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   11fec:	02d7f733          	remu	a4,a5,a3
   11ff0:	fff40413          	addi	s0,s0,-1
					       next cases. */
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
   11ff4:	02d7d7b3          	divu	a5,a5,a3
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   11ff8:	03070713          	addi	a4,a4,48
   11ffc:	00e40023          	sb	a4,0(s0)
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
					} while (_uquad != 0);
   12000:	fe0796e3          	bnez	a5,11fec <_vfprintf_r+0x818>
   12004:	01c12783          	lw	a5,28(sp)
   12008:	408787b3          	sub	a5,a5,s0
   1200c:	02f12623          	sw	a5,44(sp)
   12010:	1500006f          	j	12160 <_vfprintf_r+0x98c>
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   12014:	00000b13          	li	s6,0
   12018:	fd098893          	addi	a7,s3,-48
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
   1201c:	00148493          	addi	s1,s1,1
   12020:	fff4c983          	lbu	s3,-1(s1)
			goto rflag;
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
   12024:	001b1793          	slli	a5,s6,0x1
   12028:	003b1b13          	slli	s6,s6,0x3
   1202c:	01678b33          	add	s6,a5,s6
   12030:	01688b33          	add	s6,a7,s6
				ch = *fmt++;
			} while (is_digit (ch));
   12034:	fd098893          	addi	a7,s3,-48
   12038:	ff1672e3          	bleu	a7,a2,1201c <_vfprintf_r+0x848>
   1203c:	93dff06f          	j	11978 <_vfprintf_r+0x1a4>
   12040:	00058463          	beqz	a1,12048 <_vfprintf_r+0x874>
   12044:	4780106f          	j	134bc <_vfprintf_r+0x1ce8>
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
   12048:	01096913          	ori	s2,s2,16
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   1204c:	01097793          	andi	a5,s2,16
   12050:	ac0790e3          	bnez	a5,11b10 <_vfprintf_r+0x33c>
   12054:	03012683          	lw	a3,48(sp)
   12058:	04097793          	andi	a5,s2,64
   1205c:	00468713          	addi	a4,a3,4
   12060:	200788e3          	beqz	a5,12a70 <_vfprintf_r+0x129c>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12064:	02812603          	lw	a2,40(sp)
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   12068:	0006d783          	lhu	a5,0(a3)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   1206c:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12070:	aa065ce3          	bgez	a2,11b28 <_vfprintf_r+0x354>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12074:	02e12823          	sw	a4,48(sp)
   12078:	00000613          	li	a2,0
   1207c:	32078263          	beqz	a5,123a0 <_vfprintf_r+0xbcc>
   12080:	00000613          	li	a2,0
   12084:	ac5ff06f          	j	11b48 <_vfprintf_r+0x374>
   12088:	00058463          	beqz	a1,12090 <_vfprintf_r+0x8bc>
   1208c:	4240106f          	j	134b0 <_vfprintf_r+0x1cdc>
			} else
				size = strlen (cp);

			break;
		case 'U': /* extension */
			flags |= LONGINT;
   12090:	01096913          	ori	s2,s2,16
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   12094:	01097793          	andi	a5,s2,16
   12098:	f0079ee3          	bnez	a5,11fb4 <_vfprintf_r+0x7e0>
   1209c:	03012683          	lw	a3,48(sp)
   120a0:	04097793          	andi	a5,s2,64
   120a4:	00468713          	addi	a4,a3,4
   120a8:	1a078ae3          	beqz	a5,12a5c <_vfprintf_r+0x1288>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   120ac:	02812603          	lw	a2,40(sp)
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   120b0:	0006d783          	lhu	a5,0(a3)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   120b4:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   120b8:	f0065ae3          	bgez	a2,11fcc <_vfprintf_r+0x7f8>
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   120bc:	02e12823          	sw	a4,48(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   120c0:	00000613          	li	a2,0
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   120c4:	f0079ce3          	bnez	a5,11fdc <_vfprintf_r+0x808>
   120c8:	00100793          	li	a5,1
   120cc:	2d40006f          	j	123a0 <_vfprintf_r+0xbcc>
   120d0:	00058463          	beqz	a1,120d8 <_vfprintf_r+0x904>
   120d4:	3d40106f          	j	134a8 <_vfprintf_r+0x1cd4>
		case 'u':
			_uquad = UARG ();
			base = DEC;
			goto nosign;
		case 'X':
			xdigs = "0123456789ABCDEF";
   120d8:	0001c7b7          	lui	a5,0x1c
   120dc:	13478793          	addi	a5,a5,308 # 1c134 <__thenan_sf+0x24>
   120e0:	04f12c23          	sw	a5,88(sp)
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
   120e4:	01097793          	andi	a5,s2,16
   120e8:	12078c63          	beqz	a5,12220 <_vfprintf_r+0xa4c>
   120ec:	03012683          	lw	a3,48(sp)
   120f0:	0006a783          	lw	a5,0(a3)
   120f4:	00468693          	addi	a3,a3,4
   120f8:	02d12823          	sw	a3,48(sp)
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
   120fc:	00197713          	andi	a4,s2,1
   12100:	64070c63          	beqz	a4,12758 <_vfprintf_r+0xf84>
   12104:	400780e3          	beqz	a5,12d04 <_vfprintf_r+0x1530>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12108:	02812603          	lw	a2,40(sp)
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
				ox[0] = '0';
   1210c:	03000713          	li	a4,48
   12110:	06e10823          	sb	a4,112(sp)
				ox[1] = ch;
   12114:	073108a3          	sb	s3,113(sp)
				flags |= HEXPREFIX;
   12118:	00296713          	ori	a4,s2,2

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   1211c:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12120:	760648e3          	bltz	a2,13090 <_vfprintf_r+0x18bc>
   12124:	f7f97913          	andi	s2,s2,-129
				flags &= ~ZEROPAD;
   12128:	00296913          	ori	s2,s2,2
   1212c:	00000613          	li	a2,0
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12130:	05812683          	lw	a3,88(sp)
   12134:	0c010413          	addi	s0,sp,192
					} while (_uquad != 0);
					break;

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   12138:	00f7f713          	andi	a4,a5,15
   1213c:	00e68733          	add	a4,a3,a4
   12140:	00074703          	lbu	a4,0(a4)
   12144:	fff40413          	addi	s0,s0,-1
						_uquad >>= 4;
   12148:	0047d793          	srli	a5,a5,0x4
					} while (_uquad != 0);
					break;

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   1214c:	00e40023          	sb	a4,0(s0)
						_uquad >>= 4;
					} while (_uquad);
   12150:	fe0794e3          	bnez	a5,12138 <_vfprintf_r+0x964>
   12154:	01c12683          	lw	a3,28(sp)
   12158:	408686b3          	sub	a3,a3,s0
   1215c:	02d12623          	sw	a3,44(sp)
   12160:	02c12a83          	lw	s5,44(sp)
   12164:	02812783          	lw	a5,40(sp)
   12168:	00fad463          	ble	a5,s5,12170 <_vfprintf_r+0x99c>
   1216c:	00078a93          	mv	s5,a5
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   12170:	03512023          	sw	s5,32(sp)
   12174:	02012e23          	sw	zero,60(sp)
   12178:	af5ff06f          	j	11c6c <_vfprintf_r+0x498>
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   1217c:	03012603          	lw	a2,48(sp)
				size = 1;
			}
			sign = '\0';
			break;
   12180:	00100713          	li	a4,1
   12184:	02e12023          	sw	a4,32(sp)
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   12188:	00062783          	lw	a5,0(a2) # 2000 <_reset+0x1e00>
   1218c:	00460613          	addi	a2,a2,4
				size = 1;
			}
			sign = '\0';
   12190:	060107a3          	sb	zero,111(sp)
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   12194:	08f10c23          	sb	a5,152(sp)
   12198:	02c12823          	sw	a2,48(sp)
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
   1219c:	00000613          	li	a2,0
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
   121a0:	02e12623          	sw	a4,44(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   121a4:	02012423          	sw	zero,40(sp)
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   121a8:	02012e23          	sw	zero,60(sp)
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
   121ac:	09810413          	addi	s0,sp,152
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
   121b0:	acdff06f          	j	11c7c <_vfprintf_r+0x4a8>
   121b4:	00058463          	beqz	a1,121bc <_vfprintf_r+0x9e8>
   121b8:	2cc0106f          	j	13484 <_vfprintf_r+0x1cb0>
		case 'D':  /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   121bc:	01097793          	andi	a5,s2,16
   121c0:	12078a63          	beqz	a5,122f4 <_vfprintf_r+0xb20>
   121c4:	03012603          	lw	a2,48(sp)
   121c8:	00062783          	lw	a5,0(a2)
   121cc:	00460613          	addi	a2,a2,4
   121d0:	02c12823          	sw	a2,48(sp)
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
#else
			if ((long) _uquad < 0)
   121d4:	1207c4e3          	bltz	a5,12afc <_vfprintf_r+0x1328>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   121d8:	02812683          	lw	a3,40(sp)
   121dc:	06f14603          	lbu	a2,111(sp)
   121e0:	ee06c2e3          	bltz	a3,120c4 <_vfprintf_r+0x8f0>
				flags &= ~ZEROPAD;
   121e4:	f7f97913          	andi	s2,s2,-129
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   121e8:	de079ae3          	bnez	a5,11fdc <_vfprintf_r+0x808>
   121ec:	02812703          	lw	a4,40(sp)
   121f0:	54071463          	bnez	a4,12738 <_vfprintf_r+0xf64>
   121f4:	02012423          	sw	zero,40(sp)
   121f8:	02012623          	sw	zero,44(sp)
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   121fc:	0c010413          	addi	s0,sp,192
   12200:	f61ff06f          	j	12160 <_vfprintf_r+0x98c>
   12204:	00058463          	beqz	a1,1220c <_vfprintf_r+0xa38>
   12208:	2980106f          	j	134a0 <_vfprintf_r+0x1ccc>
			goto nosign;
		case 'X':
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
   1220c:	0001c7b7          	lui	a5,0x1c
   12210:	14878793          	addi	a5,a5,328 # 1c148 <__thenan_sf+0x38>
   12214:	04f12c23          	sw	a5,88(sp)
hex:			_uquad = UARG ();
   12218:	01097793          	andi	a5,s2,16
   1221c:	ec0798e3          	bnez	a5,120ec <_vfprintf_r+0x918>
   12220:	04097793          	andi	a5,s2,64
   12224:	2c0786e3          	beqz	a5,12cf0 <_vfprintf_r+0x151c>
   12228:	03012703          	lw	a4,48(sp)
   1222c:	00075783          	lhu	a5,0(a4)
   12230:	00470713          	addi	a4,a4,4
   12234:	02e12823          	sw	a4,48(sp)
   12238:	ec5ff06f          	j	120fc <_vfprintf_r+0x928>
   1223c:	00058463          	beqz	a1,12244 <_vfprintf_r+0xa70>
   12240:	2580106f          	j	13498 <_vfprintf_r+0x1cc4>
		case 'E':
		case 'f':
		case 'g':
		case 'G':
# ifdef _NO_LONGDBL
			if (flags & LONGDBL) {
   12244:	00897793          	andi	a5,s2,8
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
   12248:	03012603          	lw	a2,48(sp)
		case 'E':
		case 'f':
		case 'g':
		case 'G':
# ifdef _NO_LONGDBL
			if (flags & LONGDBL) {
   1224c:	280780e3          	beqz	a5,12ccc <_vfprintf_r+0x14f8>
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
   12250:	00760793          	addi	a5,a2,7
   12254:	ff87f793          	andi	a5,a5,-8
   12258:	00878693          	addi	a3,a5,8
   1225c:	0007a703          	lw	a4,0(a5)
   12260:	0047a783          	lw	a5,4(a5)
   12264:	02d12823          	sw	a3,48(sp)
   12268:	04e12823          	sw	a4,80(sp)
   1226c:	04f12a23          	sw	a5,84(sp)

			   If the output is infinite or NaN, leading
			   zeros are not permitted.  Otherwise, scanf
			   could not read what printf wrote.
			 */
			if (isinf (_fpvalue)) {
   12270:	05012503          	lw	a0,80(sp)
   12274:	05412583          	lw	a1,84(sp)
   12278:	00512a23          	sw	t0,20(sp)
   1227c:	00100413          	li	s0,1
   12280:	054060ef          	jal	182d4 <__fpclassifyd>
   12284:	01412283          	lw	t0,20(sp)
   12288:	08851ae3          	bne	a0,s0,12b1c <_vfprintf_r+0x1348>
				if (_fpvalue < 0)
   1228c:	05012503          	lw	a0,80(sp)
   12290:	05412583          	lw	a1,84(sp)
   12294:	00000613          	li	a2,0
   12298:	00000693          	li	a3,0
   1229c:	15d080ef          	jal	1abf8 <__ltdf2>
   122a0:	01412283          	lw	t0,20(sp)
   122a4:	600544e3          	bltz	a0,130ac <_vfprintf_r+0x18d8>
   122a8:	06f14603          	lbu	a2,111(sp)
					sign = '-';
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
   122ac:	04700793          	li	a5,71
   122b0:	3b37dae3          	ble	s3,a5,12e64 <_vfprintf_r+0x1690>
					cp = "INF";
				else
					cp = "inf";
   122b4:	0001c437          	lui	s0,0x1c
   122b8:	12840413          	addi	s0,s0,296 # 1c128 <__thenan_sf+0x18>
				size = 3;
				flags &= ~ZEROPAD;
				break;
   122bc:	00300793          	li	a5,3
   122c0:	02f12023          	sw	a5,32(sp)
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "INF";
				else
					cp = "inf";
				size = 3;
				flags &= ~ZEROPAD;
   122c4:	f7f97913          	andi	s2,s2,-129
					sign = '-';
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "INF";
				else
					cp = "inf";
				size = 3;
   122c8:	02f12623          	sw	a5,44(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   122cc:	02012423          	sw	zero,40(sp)
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   122d0:	02012e23          	sw	zero,60(sp)
					cp = "INF";
				else
					cp = "inf";
				size = 3;
				flags &= ~ZEROPAD;
				break;
   122d4:	999ff06f          	j	11c6c <_vfprintf_r+0x498>
#endif /* !_NO_POS_ARGS */
			width = n;
			goto reswitch;
#ifdef FLOATING_POINT
		case 'L':
			flags |= LONGDBL;
   122d8:	00896913          	ori	s2,s2,8
			goto rflag;
   122dc:	e94ff06f          	j	11970 <_vfprintf_r+0x19c>
   122e0:	00058463          	beqz	a1,122e8 <_vfprintf_r+0xb14>
   122e4:	1a80106f          	j	1348c <_vfprintf_r+0x1cb8>
				size = 1;
			}
			sign = '\0';
			break;
		case 'D':  /* extension */
			flags |= LONGINT;
   122e8:	01096913          	ori	s2,s2,16
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   122ec:	01097793          	andi	a5,s2,16
   122f0:	ec079ae3          	bnez	a5,121c4 <_vfprintf_r+0x9f0>
   122f4:	04097793          	andi	a5,s2,64
   122f8:	1c0780e3          	beqz	a5,12cb8 <_vfprintf_r+0x14e4>
   122fc:	03012683          	lw	a3,48(sp)
   12300:	00069783          	lh	a5,0(a3)
   12304:	00468693          	addi	a3,a3,4
   12308:	02d12823          	sw	a3,48(sp)
   1230c:	ec9ff06f          	j	121d4 <_vfprintf_r+0xa00>
   12310:	00058463          	beqz	a1,12318 <_vfprintf_r+0xb44>
   12314:	1e40106f          	j	134f8 <_vfprintf_r+0x1d24>
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
				*GET_ARG (N, ap, quad_ptr_t) = ret;
			else
#endif
			if (flags & LONGINT)
   12318:	01097793          	andi	a5,s2,16
   1231c:	16078ce3          	beqz	a5,12c94 <_vfprintf_r+0x14c0>
				*GET_ARG (N, ap, long_ptr_t) = ret;
   12320:	03012683          	lw	a3,48(sp)
   12324:	03412703          	lw	a4,52(sp)
   12328:	0006a783          	lw	a5,0(a3)
   1232c:	00468693          	addi	a3,a3,4
   12330:	02d12823          	sw	a3,48(sp)
   12334:	00e7a023          	sw	a4,0(a5)
   12338:	d9cff06f          	j	118d4 <_vfprintf_r+0x100>
			if (*fmt == 'h') {
				fmt++;
				flags |= CHARINT;
			} else
#endif
				flags |= SHORTINT;
   1233c:	04096913          	ori	s2,s2,64
			goto rflag;
   12340:	e30ff06f          	j	11970 <_vfprintf_r+0x19c>
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   12344:	0001c737          	lui	a4,0x1c
   12348:	14870713          	addi	a4,a4,328 # 1c148 <__thenan_sf+0x38>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   1234c:	00000613          	li	a2,0
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   12350:	04e12c23          	sw	a4,88(sp)
			flags |= HEXPREFIX;
			ox[0] = '0';
			ox[1] = ch = 'x';
   12354:	07800993          	li	s3,120
   12358:	dd9ff06f          	j	12130 <_vfprintf_r+0x95c>
   1235c:	00058463          	beqz	a1,12364 <_vfprintf_r+0xb90>
   12360:	1900106f          	j	134f0 <_vfprintf_r+0x1d1c>

			size = buf + BUF - cp;
		skipsize:
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
   12364:	f0098e63          	beqz	s3,11a80 <_vfprintf_r+0x2ac>
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
   12368:	00100713          	li	a4,1
   1236c:	02e12023          	sw	a4,32(sp)
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
   12370:	09310c23          	sb	s3,152(sp)
			size = 1;
			sign = '\0';
   12374:	060107a3          	sb	zero,111(sp)
   12378:	e25ff06f          	j	1219c <_vfprintf_r+0x9c8>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   1237c:	02e12823          	sw	a4,48(sp)
			base = HEX;
			xdigs = "0123456789abcdef";
   12380:	0001c737          	lui	a4,0x1c
   12384:	14870713          	addi	a4,a4,328 # 1c148 <__thenan_sf+0x38>
			flags |= HEXPREFIX;
   12388:	00060913          	mv	s2,a2
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   1238c:	04e12c23          	sw	a4,88(sp)
			flags |= HEXPREFIX;
			ox[0] = '0';
			ox[1] = ch = 'x';
   12390:	07800993          	li	s3,120
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12394:	3c079c63          	bnez	a5,1276c <_vfprintf_r+0xf98>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12398:	00000613          	li	a2,0
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
   1239c:	00200793          	li	a5,2
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   123a0:	00100713          	li	a4,1
   123a4:	38e78a63          	beq	a5,a4,12738 <_vfprintf_r+0xf64>
   123a8:	00200713          	li	a4,2
   123ac:	e6e78663          	beq	a5,a4,11a18 <_vfprintf_r+0x244>
   123b0:	00000793          	li	a5,0
   123b4:	f94ff06f          	j	11b48 <_vfprintf_r+0x374>
   123b8:	09412783          	lw	a5,148(sp)
   123bc:	98dff06f          	j	11d48 <_vfprintf_r+0x574>
					PRINTANDPAD (cp, convbuf + ndig,
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
   123c0:	09012983          	lw	s3,144(sp)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
   123c4:	04012603          	lw	a2,64(sp)
   123c8:	00100713          	li	a4,1
					PRINT (cp, 1);
   123cc:	00178793          	addi	a5,a5,1
   123d0:	00198993          	addi	s3,s3,1
   123d4:	0082a023          	sw	s0,0(t0)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
   123d8:	2cc75263          	ble	a2,a4,1269c <_vfprintf_r+0xec8>
					PRINT (cp, 1);
   123dc:	00100713          	li	a4,1
   123e0:	00e2a223          	sw	a4,4(t0)
   123e4:	00700713          	li	a4,7
   123e8:	08f12a23          	sw	a5,148(sp)
   123ec:	09312823          	sw	s3,144(sp)
   123f0:	00828293          	addi	t0,t0,8
   123f4:	69374863          	blt	a4,s3,12a84 <_vfprintf_r+0x12b0>
					cp++;
					PRINT (decimal_point, decp_len);
   123f8:	04c12683          	lw	a3,76(sp)
   123fc:	04412703          	lw	a4,68(sp)
   12400:	00198993          	addi	s3,s3,1
   12404:	00f687b3          	add	a5,a3,a5
   12408:	00e2a023          	sw	a4,0(t0)
   1240c:	00700713          	li	a4,7
   12410:	00d2a223          	sw	a3,4(t0)
   12414:	08f12a23          	sw	a5,148(sp)
   12418:	09312823          	sw	s3,144(sp)
   1241c:	00828c93          	addi	s9,t0,8
   12420:	69374663          	blt	a4,s3,12aac <_vfprintf_r+0x12d8>
					if (_fpvalue) {
   12424:	05012503          	lw	a0,80(sp)
   12428:	05412583          	lw	a1,84(sp)
   1242c:	00000613          	li	a2,0
   12430:	00000693          	li	a3,0
   12434:	00f12c23          	sw	a5,24(sp)
   12438:	7c4080ef          	jal	1abfc <__nedf2>
   1243c:	01812783          	lw	a5,24(sp)
   12440:	40050863          	beqz	a0,12850 <_vfprintf_r+0x107c>
						PRINT (cp, ndig - 1);
   12444:	04012603          	lw	a2,64(sp)
   12448:	00140413          	addi	s0,s0,1
   1244c:	00198993          	addi	s3,s3,1
   12450:	fff60713          	addi	a4,a2,-1
   12454:	00e787b3          	add	a5,a5,a4
   12458:	00eca223          	sw	a4,4(s9)
   1245c:	00700713          	li	a4,7
   12460:	008ca023          	sw	s0,0(s9)
   12464:	08f12a23          	sw	a5,148(sp)
   12468:	09312823          	sw	s3,144(sp)
   1246c:	25374863          	blt	a4,s3,126bc <_vfprintf_r+0xee8>
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
   12470:	008c8c93          	addi	s9,s9,8
				} else	/* XeYYY */
					PRINT (cp, 1);
				PRINT (expstr, expsize);
   12474:	05c12703          	lw	a4,92(sp)
   12478:	05c12603          	lw	a2,92(sp)
   1247c:	00198993          	addi	s3,s3,1
   12480:	00f707b3          	add	a5,a4,a5
   12484:	07c10713          	addi	a4,sp,124
   12488:	00eca023          	sw	a4,0(s9)
   1248c:	00700713          	li	a4,7
   12490:	00cca223          	sw	a2,4(s9)
   12494:	08f12a23          	sw	a5,148(sp)
   12498:	09312823          	sw	s3,144(sp)
   1249c:	008c8293          	addi	t0,s9,8
   124a0:	a1375ae3          	ble	s3,a4,11eb4 <_vfprintf_r+0x6e0>
   124a4:	08c10613          	addi	a2,sp,140
   124a8:	000a0593          	mv	a1,s4
   124ac:	000c0513          	mv	a0,s8
   124b0:	204060ef          	jal	186b4 <__sprint_r>
   124b4:	de051263          	bnez	a0,11a98 <_vfprintf_r+0x2c4>
   124b8:	09412783          	lw	a5,148(sp)
   124bc:	0c010293          	addi	t0,sp,192
   124c0:	9f5ff06f          	j	11eb4 <_vfprintf_r+0x6e0>
		/* the string or number proper */
#ifdef FLOATING_POINT
		if ((flags & FPT) == 0) {
			PRINT (cp, size);
		} else {	/* glue together f_p fragments */
			if (ch >= 'f') {	/* 'f' or 'g' */
   124c4:	06500713          	li	a4,101
   124c8:	ef375ce3          	ble	s3,a4,123c0 <_vfprintf_r+0xbec>
				if (_fpvalue == 0) {
   124cc:	05012503          	lw	a0,80(sp)
   124d0:	05412583          	lw	a1,84(sp)
   124d4:	00000613          	li	a2,0
   124d8:	00000693          	li	a3,0
   124dc:	00512a23          	sw	t0,20(sp)
   124e0:	00f12c23          	sw	a5,24(sp)
   124e4:	71c080ef          	jal	1ac00 <__eqdf2>
   124e8:	01412283          	lw	t0,20(sp)
   124ec:	01812783          	lw	a5,24(sp)
   124f0:	28051263          	bnez	a0,12774 <_vfprintf_r+0xfa0>
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
   124f4:	09012703          	lw	a4,144(sp)
   124f8:	00100693          	li	a3,1
   124fc:	0001c637          	lui	a2,0x1c
   12500:	00d2a223          	sw	a3,4(t0)
   12504:	00178793          	addi	a5,a5,1
   12508:	00170713          	addi	a4,a4,1
   1250c:	16460613          	addi	a2,a2,356 # 1c164 <__thenan_sf+0x54>
   12510:	00700693          	li	a3,7
   12514:	00c2a023          	sw	a2,0(t0)
   12518:	08f12a23          	sw	a5,148(sp)
   1251c:	08e12823          	sw	a4,144(sp)
   12520:	00828293          	addi	t0,t0,8
   12524:	7ee6ca63          	blt	a3,a4,12d18 <_vfprintf_r+0x1544>
					if (expt < ndig || flags & ALT) {
   12528:	07412703          	lw	a4,116(sp)
   1252c:	04012683          	lw	a3,64(sp)
   12530:	00d74663          	blt	a4,a3,1253c <_vfprintf_r+0xd68>
   12534:	00197713          	andi	a4,s2,1
   12538:	96070ee3          	beqz	a4,11eb4 <_vfprintf_r+0x6e0>
						PRINT (decimal_point, decp_len);
   1253c:	04c12703          	lw	a4,76(sp)
   12540:	04c12683          	lw	a3,76(sp)
   12544:	04412603          	lw	a2,68(sp)
   12548:	00e787b3          	add	a5,a5,a4
   1254c:	09012703          	lw	a4,144(sp)
   12550:	00d2a223          	sw	a3,4(t0)
   12554:	00700693          	li	a3,7
   12558:	00170713          	addi	a4,a4,1
   1255c:	00c2a023          	sw	a2,0(t0)
   12560:	08f12a23          	sw	a5,148(sp)
   12564:	08e12823          	sw	a4,144(sp)
   12568:	00828293          	addi	t0,t0,8
   1256c:	1ce6c8e3          	blt	a3,a4,12f3c <_vfprintf_r+0x1768>
						PAD (ndig - 1, zeroes);
   12570:	04012703          	lw	a4,64(sp)
   12574:	fff70413          	addi	s0,a4,-1
   12578:	92805ee3          	blez	s0,11eb4 <_vfprintf_r+0x6e0>
   1257c:	01000993          	li	s3,16
   12580:	09012703          	lw	a4,144(sp)
   12584:	03a12223          	sw	s10,36(sp)
   12588:	3289de63          	ble	s0,s3,128c4 <_vfprintf_r+0x10f0>
   1258c:	00700c93          	li	s9,7
   12590:	00c0006f          	j	1259c <_vfprintf_r+0xdc8>
   12594:	ff040413          	addi	s0,s0,-16
   12598:	3289d663          	ble	s0,s3,128c4 <_vfprintf_r+0x10f0>
   1259c:	01078793          	addi	a5,a5,16
   125a0:	00170713          	addi	a4,a4,1
   125a4:	01a2a023          	sw	s10,0(t0)
   125a8:	0132a223          	sw	s3,4(t0)
   125ac:	08f12a23          	sw	a5,148(sp)
   125b0:	08e12823          	sw	a4,144(sp)
   125b4:	00828293          	addi	t0,t0,8
   125b8:	fcecdee3          	ble	a4,s9,12594 <_vfprintf_r+0xdc0>
   125bc:	08c10613          	addi	a2,sp,140
   125c0:	000a0593          	mv	a1,s4
   125c4:	000c0513          	mv	a0,s8
   125c8:	0ec060ef          	jal	186b4 <__sprint_r>
   125cc:	cc051663          	bnez	a0,11a98 <_vfprintf_r+0x2c4>
   125d0:	09412783          	lw	a5,148(sp)
   125d4:	09012703          	lw	a4,144(sp)
   125d8:	0c010293          	addi	t0,sp,192
   125dc:	fb9ff06f          	j	12594 <_vfprintf_r+0xdc0>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   125e0:	02012703          	lw	a4,32(sp)
   125e4:	40eb0cb3          	sub	s9,s6,a4
   125e8:	fd905c63          	blez	s9,11dc0 <_vfprintf_r+0x5ec>
   125ec:	01000d93          	li	s11,16
   125f0:	09012703          	lw	a4,144(sp)
   125f4:	03a12223          	sw	s10,36(sp)
   125f8:	059dde63          	ble	s9,s11,12654 <_vfprintf_r+0xe80>
   125fc:	00700a93          	li	s5,7
   12600:	00c0006f          	j	1260c <_vfprintf_r+0xe38>
   12604:	ff0c8c93          	addi	s9,s9,-16
   12608:	059dd663          	ble	s9,s11,12654 <_vfprintf_r+0xe80>
   1260c:	01078793          	addi	a5,a5,16
   12610:	00170713          	addi	a4,a4,1
   12614:	01a2a023          	sw	s10,0(t0)
   12618:	01b2a223          	sw	s11,4(t0)
   1261c:	08f12a23          	sw	a5,148(sp)
   12620:	08e12823          	sw	a4,144(sp)
   12624:	00828293          	addi	t0,t0,8
   12628:	fceadee3          	ble	a4,s5,12604 <_vfprintf_r+0xe30>
   1262c:	08c10613          	addi	a2,sp,140
   12630:	000a0593          	mv	a1,s4
   12634:	000c0513          	mv	a0,s8
   12638:	07c060ef          	jal	186b4 <__sprint_r>
   1263c:	c4051e63          	bnez	a0,11a98 <_vfprintf_r+0x2c4>
   12640:	ff0c8c93          	addi	s9,s9,-16
   12644:	09412783          	lw	a5,148(sp)
   12648:	09012703          	lw	a4,144(sp)
   1264c:	0c010293          	addi	t0,sp,192
   12650:	fb9dcee3          	blt	s11,s9,1260c <_vfprintf_r+0xe38>
   12654:	02412683          	lw	a3,36(sp)
   12658:	019787b3          	add	a5,a5,s9
   1265c:	00170713          	addi	a4,a4,1
   12660:	00d2a023          	sw	a3,0(t0)
   12664:	00700693          	li	a3,7
   12668:	0192a223          	sw	s9,4(t0)
   1266c:	08f12a23          	sw	a5,148(sp)
   12670:	08e12823          	sw	a4,144(sp)
   12674:	00828293          	addi	t0,t0,8
   12678:	f4e6d463          	ble	a4,a3,11dc0 <_vfprintf_r+0x5ec>
   1267c:	08c10613          	addi	a2,sp,140
   12680:	000a0593          	mv	a1,s4
   12684:	000c0513          	mv	a0,s8
   12688:	02c060ef          	jal	186b4 <__sprint_r>
   1268c:	c0051663          	bnez	a0,11a98 <_vfprintf_r+0x2c4>
   12690:	09412783          	lw	a5,148(sp)
   12694:	0c010293          	addi	t0,sp,192
   12698:	f28ff06f          	j	11dc0 <_vfprintf_r+0x5ec>
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
   1269c:	00e976b3          	and	a3,s2,a4
   126a0:	d2069ee3          	bnez	a3,123dc <_vfprintf_r+0xc08>
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
				} else	/* XeYYY */
					PRINT (cp, 1);
   126a4:	00e2a223          	sw	a4,4(t0)
   126a8:	00700713          	li	a4,7
   126ac:	08f12a23          	sw	a5,148(sp)
   126b0:	09312823          	sw	s3,144(sp)
   126b4:	00828c93          	addi	s9,t0,8
   126b8:	db375ee3          	ble	s3,a4,12474 <_vfprintf_r+0xca0>
   126bc:	08c10613          	addi	a2,sp,140
   126c0:	000a0593          	mv	a1,s4
   126c4:	000c0513          	mv	a0,s8
   126c8:	7ed050ef          	jal	186b4 <__sprint_r>
   126cc:	bc051663          	bnez	a0,11a98 <_vfprintf_r+0x2c4>
   126d0:	09412783          	lw	a5,148(sp)
   126d4:	09012983          	lw	s3,144(sp)
   126d8:	0c010c93          	addi	s9,sp,192
   126dc:	d99ff06f          	j	12474 <_vfprintf_r+0xca0>
			PAD (width - realsz, blanks);

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;

		FLUSH ();	/* copy out the I/O vectors */
   126e0:	08c10613          	addi	a2,sp,140
   126e4:	000a0593          	mv	a1,s4
   126e8:	000c0513          	mv	a0,s8
   126ec:	7c9050ef          	jal	186b4 <__sprint_r>
   126f0:	88050ee3          	beqz	a0,11f8c <_vfprintf_r+0x7b8>
   126f4:	ba4ff06f          	j	11a98 <_vfprintf_r+0x2c4>
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
   126f8:	08c10613          	addi	a2,sp,140
   126fc:	000a0593          	mv	a1,s4
   12700:	000c0513          	mv	a0,s8
   12704:	7b1050ef          	jal	186b4 <__sprint_r>
   12708:	b8051863          	bnez	a0,11a98 <_vfprintf_r+0x2c4>
   1270c:	09412783          	lw	a5,148(sp)
   12710:	0c010293          	addi	t0,sp,192
   12714:	e68ff06f          	j	11d7c <_vfprintf_r+0x5a8>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);
   12718:	08c10613          	addi	a2,sp,140
   1271c:	000a0593          	mv	a1,s4
   12720:	000c0513          	mv	a0,s8
   12724:	791050ef          	jal	186b4 <__sprint_r>
   12728:	b6051863          	bnez	a0,11a98 <_vfprintf_r+0x2c4>
   1272c:	09412783          	lw	a5,148(sp)
   12730:	0c010293          	addi	t0,sp,192
   12734:	e80ff06f          	j	11db4 <_vfprintf_r+0x5e0>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12738:	00000793          	li	a5,0
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
						*--cp = to_char(_uquad);
   1273c:	03078793          	addi	a5,a5,48
   12740:	0bf10413          	addi	s0,sp,191
   12744:	0af10fa3          	sb	a5,191(sp)
   12748:	01c12703          	lw	a4,28(sp)
   1274c:	40870733          	sub	a4,a4,s0
   12750:	02e12623          	sw	a4,44(sp)
						break;
   12754:	a0dff06f          	j	12160 <_vfprintf_r+0x98c>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12758:	02812683          	lw	a3,40(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   1275c:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12760:	c206cae3          	bltz	a3,12394 <_vfprintf_r+0xbc0>
				flags &= ~ZEROPAD;
   12764:	f7f97913          	andi	s2,s2,-129
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12768:	aa078263          	beqz	a5,11a0c <_vfprintf_r+0x238>
   1276c:	00000613          	li	a2,0
   12770:	9c1ff06f          	j	12130 <_vfprintf_r+0x95c>
					PRINT ("0", 1);
					if (expt < ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
   12774:	07412983          	lw	s3,116(sp)
   12778:	5d305263          	blez	s3,12d3c <_vfprintf_r+0x1568>
   1277c:	03c12983          	lw	s3,60(sp)
   12780:	04012703          	lw	a4,64(sp)
   12784:	01375463          	ble	s3,a4,1278c <_vfprintf_r+0xfb8>
   12788:	00070993          	mv	s3,a4
						PAD (-expt, zeroes);
						PRINT (cp, ndig);
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
   1278c:	03305663          	blez	s3,127b8 <_vfprintf_r+0xfe4>
   12790:	09012703          	lw	a4,144(sp)
   12794:	013787b3          	add	a5,a5,s3
   12798:	00700693          	li	a3,7
   1279c:	00170713          	addi	a4,a4,1
   127a0:	0082a023          	sw	s0,0(t0)
   127a4:	0132a223          	sw	s3,4(t0)
   127a8:	08f12a23          	sw	a5,148(sp)
   127ac:	08e12823          	sw	a4,144(sp)
   127b0:	00828293          	addi	t0,t0,8
   127b4:	6ae6ce63          	blt	a3,a4,12e70 <_vfprintf_r+0x169c>
   127b8:	0409c8e3          	bltz	s3,13008 <_vfprintf_r+0x1834>
   127bc:	03c12703          	lw	a4,60(sp)
   127c0:	413709b3          	sub	s3,a4,s3
   127c4:	17305663          	blez	s3,12930 <_vfprintf_r+0x115c>
   127c8:	01000c93          	li	s9,16
   127cc:	09012703          	lw	a4,144(sp)
   127d0:	03a12223          	sw	s10,36(sp)
   127d4:	113cdc63          	ble	s3,s9,128ec <_vfprintf_r+0x1118>
   127d8:	00700d93          	li	s11,7
   127dc:	00c0006f          	j	127e8 <_vfprintf_r+0x1014>
   127e0:	ff098993          	addi	s3,s3,-16
   127e4:	113cd463          	ble	s3,s9,128ec <_vfprintf_r+0x1118>
   127e8:	01078793          	addi	a5,a5,16
   127ec:	00170713          	addi	a4,a4,1
   127f0:	01a2a023          	sw	s10,0(t0)
   127f4:	0192a223          	sw	s9,4(t0)
   127f8:	08f12a23          	sw	a5,148(sp)
   127fc:	08e12823          	sw	a4,144(sp)
   12800:	00828293          	addi	t0,t0,8
   12804:	fceddee3          	ble	a4,s11,127e0 <_vfprintf_r+0x100c>
   12808:	08c10613          	addi	a2,sp,140
   1280c:	000a0593          	mv	a1,s4
   12810:	000c0513          	mv	a0,s8
   12814:	6a1050ef          	jal	186b4 <__sprint_r>
   12818:	a8051063          	bnez	a0,11a98 <_vfprintf_r+0x2c4>
   1281c:	09412783          	lw	a5,148(sp)
   12820:	09012703          	lw	a4,144(sp)
   12824:	0c010293          	addi	t0,sp,192
   12828:	fb9ff06f          	j	127e0 <_vfprintf_r+0x100c>
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   1282c:	08c10613          	addi	a2,sp,140
   12830:	000a0593          	mv	a1,s4
   12834:	000c0513          	mv	a0,s8
   12838:	67d050ef          	jal	186b4 <__sprint_r>
   1283c:	a4051e63          	bnez	a0,11a98 <_vfprintf_r+0x2c4>
   12840:	06f14603          	lbu	a2,111(sp)
   12844:	09412783          	lw	a5,148(sp)
   12848:	0c010293          	addi	t0,sp,192
   1284c:	cfcff06f          	j	11d48 <_vfprintf_r+0x574>
					PRINT (decimal_point, decp_len);
					if (_fpvalue) {
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
   12850:	04012703          	lw	a4,64(sp)
   12854:	fff70413          	addi	s0,a4,-1
   12858:	c0805ee3          	blez	s0,12474 <_vfprintf_r+0xca0>
   1285c:	01000d93          	li	s11,16
   12860:	03a12223          	sw	s10,36(sp)
   12864:	268dd863          	ble	s0,s11,12ad4 <_vfprintf_r+0x1300>
   12868:	00700713          	li	a4,7
   1286c:	00c0006f          	j	12878 <_vfprintf_r+0x10a4>
   12870:	ff040413          	addi	s0,s0,-16
   12874:	268dd063          	ble	s0,s11,12ad4 <_vfprintf_r+0x1300>
   12878:	01078793          	addi	a5,a5,16
   1287c:	00198993          	addi	s3,s3,1
   12880:	01aca023          	sw	s10,0(s9)
   12884:	01bca223          	sw	s11,4(s9)
   12888:	08f12a23          	sw	a5,148(sp)
   1288c:	09312823          	sw	s3,144(sp)
   12890:	008c8c93          	addi	s9,s9,8
   12894:	fd375ee3          	ble	s3,a4,12870 <_vfprintf_r+0x109c>
   12898:	08c10613          	addi	a2,sp,140
   1289c:	000a0593          	mv	a1,s4
   128a0:	000c0513          	mv	a0,s8
   128a4:	00e12c23          	sw	a4,24(sp)
   128a8:	60d050ef          	jal	186b4 <__sprint_r>
   128ac:	01812703          	lw	a4,24(sp)
   128b0:	9e051463          	bnez	a0,11a98 <_vfprintf_r+0x2c4>
   128b4:	09412783          	lw	a5,148(sp)
   128b8:	09012983          	lw	s3,144(sp)
   128bc:	0c010c93          	addi	s9,sp,192
   128c0:	fb1ff06f          	j	12870 <_vfprintf_r+0x109c>
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
   128c4:	02412683          	lw	a3,36(sp)
   128c8:	008787b3          	add	a5,a5,s0
   128cc:	00170713          	addi	a4,a4,1
   128d0:	00d2a023          	sw	a3,0(t0)
   128d4:	00700693          	li	a3,7
   128d8:	0082a223          	sw	s0,4(t0)
   128dc:	08f12a23          	sw	a5,148(sp)
   128e0:	08e12823          	sw	a4,144(sp)
   128e4:	dce6d663          	ble	a4,a3,11eb0 <_vfprintf_r+0x6dc>
   128e8:	bbdff06f          	j	124a4 <_vfprintf_r+0xcd0>
						PAD (-expt, zeroes);
						PRINT (cp, ndig);
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
   128ec:	02412683          	lw	a3,36(sp)
   128f0:	013787b3          	add	a5,a5,s3
   128f4:	00170713          	addi	a4,a4,1
   128f8:	00d2a023          	sw	a3,0(t0)
   128fc:	00700693          	li	a3,7
   12900:	0132a223          	sw	s3,4(t0)
   12904:	08f12a23          	sw	a5,148(sp)
   12908:	08e12823          	sw	a4,144(sp)
   1290c:	00828293          	addi	t0,t0,8
   12910:	02e6d063          	ble	a4,a3,12930 <_vfprintf_r+0x115c>
   12914:	08c10613          	addi	a2,sp,140
   12918:	000a0593          	mv	a1,s4
   1291c:	000c0513          	mv	a0,s8
   12920:	595050ef          	jal	186b4 <__sprint_r>
   12924:	96051a63          	bnez	a0,11a98 <_vfprintf_r+0x2c4>
   12928:	09412783          	lw	a5,148(sp)
   1292c:	0c010293          	addi	t0,sp,192
						    lead, zeroes);
					cp += lead;
   12930:	03c12603          	lw	a2,60(sp)
					    }
					    if (cp > convbuf + ndig)
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
   12934:	07412703          	lw	a4,116(sp)
   12938:	04012683          	lw	a3,64(sp)
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
						    lead, zeroes);
					cp += lead;
   1293c:	00c409b3          	add	s3,s0,a2
					    }
					    if (cp > convbuf + ndig)
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
   12940:	0cd74063          	blt	a4,a3,12a00 <_vfprintf_r+0x122c>
   12944:	00197693          	andi	a3,s2,1
   12948:	0a069c63          	bnez	a3,12a00 <_vfprintf_r+0x122c>
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
   1294c:	04012683          	lw	a3,64(sp)
   12950:	00d40433          	add	s0,s0,a3
   12954:	40e68733          	sub	a4,a3,a4
   12958:	41340433          	sub	s0,s0,s3
   1295c:	00875463          	ble	s0,a4,12964 <_vfprintf_r+0x1190>
   12960:	00070413          	mv	s0,a4
   12964:	02805663          	blez	s0,12990 <_vfprintf_r+0x11bc>
   12968:	09012683          	lw	a3,144(sp)
   1296c:	008787b3          	add	a5,a5,s0
   12970:	00700613          	li	a2,7
   12974:	00168693          	addi	a3,a3,1
   12978:	0132a023          	sw	s3,0(t0)
   1297c:	0082a223          	sw	s0,4(t0)
   12980:	08f12a23          	sw	a5,148(sp)
   12984:	08d12823          	sw	a3,144(sp)
   12988:	00828293          	addi	t0,t0,8
   1298c:	52d64063          	blt	a2,a3,12eac <_vfprintf_r+0x16d8>
   12990:	68044063          	bltz	s0,13010 <_vfprintf_r+0x183c>
   12994:	40870433          	sub	s0,a4,s0
   12998:	d0805e63          	blez	s0,11eb4 <_vfprintf_r+0x6e0>
   1299c:	01000993          	li	s3,16
   129a0:	09012703          	lw	a4,144(sp)
   129a4:	03a12223          	sw	s10,36(sp)
   129a8:	f089dee3          	ble	s0,s3,128c4 <_vfprintf_r+0x10f0>
   129ac:	00700c93          	li	s9,7
   129b0:	00c0006f          	j	129bc <_vfprintf_r+0x11e8>
   129b4:	ff040413          	addi	s0,s0,-16
   129b8:	f089d6e3          	ble	s0,s3,128c4 <_vfprintf_r+0x10f0>
   129bc:	01078793          	addi	a5,a5,16
   129c0:	00170713          	addi	a4,a4,1
   129c4:	01a2a023          	sw	s10,0(t0)
   129c8:	0132a223          	sw	s3,4(t0)
   129cc:	08f12a23          	sw	a5,148(sp)
   129d0:	08e12823          	sw	a4,144(sp)
   129d4:	00828293          	addi	t0,t0,8
   129d8:	fcecdee3          	ble	a4,s9,129b4 <_vfprintf_r+0x11e0>
   129dc:	08c10613          	addi	a2,sp,140
   129e0:	000a0593          	mv	a1,s4
   129e4:	000c0513          	mv	a0,s8
   129e8:	4cd050ef          	jal	186b4 <__sprint_r>
   129ec:	8a051663          	bnez	a0,11a98 <_vfprintf_r+0x2c4>
   129f0:	09412783          	lw	a5,148(sp)
   129f4:	09012703          	lw	a4,144(sp)
   129f8:	0c010293          	addi	t0,sp,192
   129fc:	fb9ff06f          	j	129b4 <_vfprintf_r+0x11e0>
					    if (cp > convbuf + ndig)
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
   12a00:	04c12603          	lw	a2,76(sp)
   12a04:	09012683          	lw	a3,144(sp)
   12a08:	00828293          	addi	t0,t0,8
   12a0c:	00c787b3          	add	a5,a5,a2
   12a10:	04412603          	lw	a2,68(sp)
   12a14:	00168693          	addi	a3,a3,1
   12a18:	08f12a23          	sw	a5,148(sp)
   12a1c:	fec2ac23          	sw	a2,-8(t0)
   12a20:	04c12603          	lw	a2,76(sp)
   12a24:	08d12823          	sw	a3,144(sp)
   12a28:	fec2ae23          	sw	a2,-4(t0)
   12a2c:	00700613          	li	a2,7
   12a30:	f0d65ee3          	ble	a3,a2,1294c <_vfprintf_r+0x1178>
   12a34:	08c10613          	addi	a2,sp,140
   12a38:	000a0593          	mv	a1,s4
   12a3c:	000c0513          	mv	a0,s8
   12a40:	475050ef          	jal	186b4 <__sprint_r>
   12a44:	00050463          	beqz	a0,12a4c <_vfprintf_r+0x1278>
   12a48:	850ff06f          	j	11a98 <_vfprintf_r+0x2c4>
   12a4c:	07412703          	lw	a4,116(sp)
   12a50:	09412783          	lw	a5,148(sp)
   12a54:	0c010293          	addi	t0,sp,192
   12a58:	ef5ff06f          	j	1294c <_vfprintf_r+0x1178>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12a5c:	02812603          	lw	a2,40(sp)
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   12a60:	0006a783          	lw	a5,0(a3)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   12a64:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12a68:	d6065263          	bgez	a2,11fcc <_vfprintf_r+0x7f8>
   12a6c:	e50ff06f          	j	120bc <_vfprintf_r+0x8e8>
   12a70:	02812603          	lw	a2,40(sp)
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   12a74:	0006a783          	lw	a5,0(a3)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   12a78:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12a7c:	8a065663          	bgez	a2,11b28 <_vfprintf_r+0x354>
   12a80:	df4ff06f          	j	12074 <_vfprintf_r+0x8a0>
					PRINTANDPAD (cp, convbuf + ndig,
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
   12a84:	08c10613          	addi	a2,sp,140
   12a88:	000a0593          	mv	a1,s4
   12a8c:	000c0513          	mv	a0,s8
   12a90:	425050ef          	jal	186b4 <__sprint_r>
   12a94:	00050463          	beqz	a0,12a9c <_vfprintf_r+0x12c8>
   12a98:	800ff06f          	j	11a98 <_vfprintf_r+0x2c4>
   12a9c:	09412783          	lw	a5,148(sp)
   12aa0:	09012983          	lw	s3,144(sp)
   12aa4:	0c010293          	addi	t0,sp,192
   12aa8:	951ff06f          	j	123f8 <_vfprintf_r+0xc24>
					cp++;
					PRINT (decimal_point, decp_len);
   12aac:	08c10613          	addi	a2,sp,140
   12ab0:	000a0593          	mv	a1,s4
   12ab4:	000c0513          	mv	a0,s8
   12ab8:	3fd050ef          	jal	186b4 <__sprint_r>
   12abc:	00050463          	beqz	a0,12ac4 <_vfprintf_r+0x12f0>
   12ac0:	fd9fe06f          	j	11a98 <_vfprintf_r+0x2c4>
   12ac4:	09412783          	lw	a5,148(sp)
   12ac8:	09012983          	lw	s3,144(sp)
   12acc:	0c010c93          	addi	s9,sp,192
   12ad0:	955ff06f          	j	12424 <_vfprintf_r+0xc50>
					if (_fpvalue) {
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
   12ad4:	02412683          	lw	a3,36(sp)
   12ad8:	008787b3          	add	a5,a5,s0
   12adc:	00198993          	addi	s3,s3,1
   12ae0:	00700713          	li	a4,7
   12ae4:	00dca023          	sw	a3,0(s9)
   12ae8:	008ca223          	sw	s0,4(s9)
   12aec:	08f12a23          	sw	a5,148(sp)
   12af0:	09312823          	sw	s3,144(sp)
   12af4:	97375ee3          	ble	s3,a4,12470 <_vfprintf_r+0xc9c>
   12af8:	bc5ff06f          	j	126bc <_vfprintf_r+0xee8>
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
				sign = '-';
   12afc:	02d00713          	li	a4,45
   12b00:	06e107a3          	sb	a4,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12b04:	02812703          	lw	a4,40(sp)
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
   12b08:	40f007b3          	neg	a5,a5
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12b0c:	50074663          	bltz	a4,13018 <_vfprintf_r+0x1844>
				flags &= ~ZEROPAD;
   12b10:	f7f97913          	andi	s2,s2,-129
   12b14:	02d00613          	li	a2,45
   12b18:	cc4ff06f          	j	11fdc <_vfprintf_r+0x808>
					cp = "inf";
				size = 3;
				flags &= ~ZEROPAD;
				break;
			}
			if (isnan (_fpvalue)) {
   12b1c:	05012503          	lw	a0,80(sp)
   12b20:	05412583          	lw	a1,84(sp)
   12b24:	00512a23          	sw	t0,20(sp)
   12b28:	7ac050ef          	jal	182d4 <__fpclassifyd>
   12b2c:	01412283          	lw	t0,20(sp)
   12b30:	2e050463          	beqz	a0,12e18 <_vfprintf_r+0x1644>
				  }
				else
				  cp = buf;
			} else
# endif /* _WANT_IO_C99_FORMATS */
			if (prec == -1) {
   12b34:	02812603          	lw	a2,40(sp)
   12b38:	fff00793          	li	a5,-1
   12b3c:	6af60463          	beq	a2,a5,131e4 <_vfprintf_r+0x1a10>
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
   12b40:	fdf9f793          	andi	a5,s3,-33
   12b44:	02f12023          	sw	a5,32(sp)
   12b48:	02012603          	lw	a2,32(sp)
   12b4c:	04700793          	li	a5,71
   12b50:	64f60863          	beq	a2,a5,131a0 <_vfprintf_r+0x19cc>
	int mode, dsgn;
	char *digits, *bp, *rve;
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
   12b54:	05412a83          	lw	s5,84(sp)
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
				prec = 1;
			}

			flags |= FPT;
   12b58:	10096713          	ori	a4,s2,256
   12b5c:	02e12223          	sw	a4,36(sp)
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
		value = -value;
   12b60:	05012c83          	lw	s9,80(sp)
	char *digits, *bp, *rve;
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
   12b64:	6e0ac663          	bltz	s5,13250 <_vfprintf_r+0x1a7c>
		value = -value;
		*sign = '-';
	} else
		*sign = '\000';
   12b68:	02012c23          	sw	zero,56(sp)
		}
		*length = bp - buf;
		return buf;
	}
# endif /* _WANT_IO_C99_FORMATS */
	if (ch == 'f' || ch == 'F') {
   12b6c:	06600793          	li	a5,102
   12b70:	68f98463          	beq	s3,a5,131f8 <_vfprintf_r+0x1a24>
   12b74:	04600793          	li	a5,70
   12b78:	7cf98463          	beq	s3,a5,13340 <_vfprintf_r+0x1b6c>
		/* To obtain ndigits after the decimal point for the 'e'
		 * and 'E' formats, round to ndigits + 1 significant
		 * figures.
		 */
		if (ch == 'e' || ch == 'E') {
			ndigits++;
   12b7c:	02012683          	lw	a3,32(sp)
   12b80:	02812703          	lw	a4,40(sp)
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   12b84:	08410793          	addi	a5,sp,132
		/* To obtain ndigits after the decimal point for the 'e'
		 * and 'E' formats, round to ndigits + 1 significant
		 * figures.
		 */
		if (ch == 'e' || ch == 'E') {
			ndigits++;
   12b88:	fbb68313          	addi	t1,a3,-69
   12b8c:	00133313          	seqz	t1,t1
   12b90:	00670333          	add	t1,a4,t1
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   12b94:	00f12023          	sw	a5,0(sp)
   12b98:	000c8613          	mv	a2,s9
   12b9c:	00030793          	mv	a5,t1
   12ba0:	000a8693          	mv	a3,s5
   12ba4:	07810893          	addi	a7,sp,120
   12ba8:	07410813          	addi	a6,sp,116
   12bac:	00200713          	li	a4,2
   12bb0:	000c0513          	mv	a0,s8
   12bb4:	00512a23          	sw	t0,20(sp)
   12bb8:	00612c23          	sw	t1,24(sp)
   12bbc:	649000ef          	jal	13a04 <_dtoa_r>

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   12bc0:	06700793          	li	a5,103
			ndigits++;
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   12bc4:	00050413          	mv	s0,a0

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   12bc8:	01412283          	lw	t0,20(sp)
   12bcc:	01812303          	lw	t1,24(sp)
   12bd0:	4ef98663          	beq	s3,a5,130bc <_vfprintf_r+0x18e8>
   12bd4:	04700793          	li	a5,71
		bp = digits + ndigits;
   12bd8:	00650db3          	add	s11,a0,t1
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   12bdc:	4ef98a63          	beq	s3,a5,130d0 <_vfprintf_r+0x18fc>
		if (ch == 'f' || ch == 'F') {
			if (*digits == '0' && value)
				*decpt = -ndigits + 1;
			bp += *decpt;
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
   12be0:	000c8513          	mv	a0,s9
   12be4:	000a8593          	mv	a1,s5
   12be8:	00000613          	li	a2,0
   12bec:	00000693          	li	a3,0
   12bf0:	00512a23          	sw	t0,20(sp)
   12bf4:	00c080ef          	jal	1ac00 <__eqdf2>
   12bf8:	000d8793          	mv	a5,s11
   12bfc:	01412283          	lw	t0,20(sp)
   12c00:	02050263          	beqz	a0,12c24 <_vfprintf_r+0x1450>
			rve = bp;
		while (rve < bp)
   12c04:	08412783          	lw	a5,132(sp)
   12c08:	01b7fe63          	bleu	s11,a5,12c24 <_vfprintf_r+0x1450>
			*rve++ = '0';
   12c0c:	03000693          	li	a3,48
   12c10:	00178713          	addi	a4,a5,1
   12c14:	08e12223          	sw	a4,132(sp)
   12c18:	00d78023          	sb	a3,0(a5)
				*decpt = -ndigits + 1;
			bp += *decpt;
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
			rve = bp;
		while (rve < bp)
   12c1c:	08412783          	lw	a5,132(sp)
   12c20:	ffb7e8e3          	bltu	a5,s11,12c10 <_vfprintf_r+0x143c>
			flags |= FPT;

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
   12c24:	02012603          	lw	a2,32(sp)
		if (value == 0)	/* kludge for __dtoa irregularity */
			rve = bp;
		while (rve < bp)
			*rve++ = '0';
	}
	*length = rve - digits;
   12c28:	408787b3          	sub	a5,a5,s0
   12c2c:	04f12023          	sw	a5,64(sp)
			flags |= FPT;

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
   12c30:	04700793          	li	a5,71
   12c34:	4af60c63          	beq	a2,a5,130ec <_vfprintf_r+0x1918>
			}
# ifdef _WANT_IO_C99_FORMATS
			else if (ch == 'F')
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
   12c38:	06500793          	li	a5,101
   12c3c:	0b37d6e3          	ble	s3,a5,134e8 <_vfprintf_r+0x1d14>
					++size;
# ifdef _WANT_IO_C99_FORMATS
				flags &= ~GROUPING;
# endif
			} else {
				if (ch == 'f') {		/* f fmt */
   12c40:	06600793          	li	a5,102
   12c44:	66f98663          	beq	s3,a5,132b0 <_vfprintf_r+0x1adc>
   12c48:	07412703          	lw	a4,116(sp)
   12c4c:	02e12e23          	sw	a4,60(sp)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
							  ? prec + 2
							  : 1;
				} else if (expt >= ndig) { /* fixed g fmt */
   12c50:	03c12703          	lw	a4,60(sp)
   12c54:	04012783          	lw	a5,64(sp)
   12c58:	60f74863          	blt	a4,a5,13268 <_vfprintf_r+0x1a94>
					size = expt;
					if (flags & ALT)
   12c5c:	00197913          	andi	s2,s2,1
   12c60:	62091863          	bnez	s2,13290 <_vfprintf_r+0x1abc>
   12c64:	00070a93          	mv	s5,a4
   12c68:	060744e3          	bltz	a4,134d0 <_vfprintf_r+0x1cfc>
   12c6c:	03c12703          	lw	a4,60(sp)
   12c70:	06700993          	li	s3,103
   12c74:	02e12623          	sw	a4,44(sp)
				} else
# endif
					lead = expt;
			}

			if (softsign)
   12c78:	03812603          	lw	a2,56(sp)
   12c7c:	3e061c63          	bnez	a2,13074 <_vfprintf_r+0x18a0>
   12c80:	06f14603          	lbu	a2,111(sp)
   12c84:	03512023          	sw	s5,32(sp)
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
				prec = 1;
			}

			flags |= FPT;
   12c88:	02412903          	lw	s2,36(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   12c8c:	02012423          	sw	zero,40(sp)
   12c90:	fddfe06f          	j	11c6c <_vfprintf_r+0x498>
				*GET_ARG (N, ap, quad_ptr_t) = ret;
			else
#endif
			if (flags & LONGINT)
				*GET_ARG (N, ap, long_ptr_t) = ret;
			else if (flags & SHORTINT)
   12c94:	04097913          	andi	s2,s2,64
   12c98:	1a090863          	beqz	s2,12e48 <_vfprintf_r+0x1674>
				*GET_ARG (N, ap, short_ptr_t) = ret;
   12c9c:	03012603          	lw	a2,48(sp)
   12ca0:	03412683          	lw	a3,52(sp)
   12ca4:	00062783          	lw	a5,0(a2)
   12ca8:	00460613          	addi	a2,a2,4
   12cac:	02c12823          	sw	a2,48(sp)
   12cb0:	00d79023          	sh	a3,0(a5)
   12cb4:	c21fe06f          	j	118d4 <_vfprintf_r+0x100>
		case 'D':  /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   12cb8:	03012703          	lw	a4,48(sp)
   12cbc:	00072783          	lw	a5,0(a4)
   12cc0:	00470713          	addi	a4,a4,4
   12cc4:	02e12823          	sw	a4,48(sp)
   12cc8:	d0cff06f          	j	121d4 <_vfprintf_r+0xa00>
		case 'G':
# ifdef _NO_LONGDBL
			if (flags & LONGDBL) {
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
			} else {
				_fpvalue = GET_ARG (N, ap, double);
   12ccc:	00760793          	addi	a5,a2,7
   12cd0:	ff87f793          	andi	a5,a5,-8
   12cd4:	0007a683          	lw	a3,0(a5)
   12cd8:	0047a703          	lw	a4,4(a5)
   12cdc:	00878793          	addi	a5,a5,8
   12ce0:	04d12823          	sw	a3,80(sp)
   12ce4:	04e12a23          	sw	a4,84(sp)
   12ce8:	02f12823          	sw	a5,48(sp)
   12cec:	d84ff06f          	j	12270 <_vfprintf_r+0xa9c>
		case 'X':
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
   12cf0:	03012603          	lw	a2,48(sp)
   12cf4:	00062783          	lw	a5,0(a2)
   12cf8:	00460613          	addi	a2,a2,4
   12cfc:	02c12823          	sw	a2,48(sp)
   12d00:	bfcff06f          	j	120fc <_vfprintf_r+0x928>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12d04:	02812683          	lw	a3,40(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   12d08:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12d0c:	e806c663          	bltz	a3,12398 <_vfprintf_r+0xbc4>
				flags &= ~ZEROPAD;
   12d10:	f7f97913          	andi	s2,s2,-129
   12d14:	cf9fe06f          	j	11a0c <_vfprintf_r+0x238>
			PRINT (cp, size);
		} else {	/* glue together f_p fragments */
			if (ch >= 'f') {	/* 'f' or 'g' */
				if (_fpvalue == 0) {
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
   12d18:	08c10613          	addi	a2,sp,140
   12d1c:	000a0593          	mv	a1,s4
   12d20:	000c0513          	mv	a0,s8
   12d24:	191050ef          	jal	186b4 <__sprint_r>
   12d28:	00050463          	beqz	a0,12d30 <_vfprintf_r+0x155c>
   12d2c:	d6dfe06f          	j	11a98 <_vfprintf_r+0x2c4>
   12d30:	09412783          	lw	a5,148(sp)
   12d34:	0c010293          	addi	t0,sp,192
   12d38:	ff0ff06f          	j	12528 <_vfprintf_r+0xd54>
					if (expt < ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
   12d3c:	09012703          	lw	a4,144(sp)
   12d40:	00100693          	li	a3,1
   12d44:	0001c637          	lui	a2,0x1c
   12d48:	00d2a223          	sw	a3,4(t0)
   12d4c:	00178793          	addi	a5,a5,1
   12d50:	00170713          	addi	a4,a4,1
   12d54:	16460613          	addi	a2,a2,356 # 1c164 <__thenan_sf+0x54>
   12d58:	00700693          	li	a3,7
   12d5c:	00c2a023          	sw	a2,0(t0)
   12d60:	08f12a23          	sw	a5,148(sp)
   12d64:	08e12823          	sw	a4,144(sp)
   12d68:	00828293          	addi	t0,t0,8
   12d6c:	16e6c863          	blt	a3,a4,12edc <_vfprintf_r+0x1708>
					if (expt || ndig || flags & ALT) {
   12d70:	12098263          	beqz	s3,12e94 <_vfprintf_r+0x16c0>
						PRINT (decimal_point, decp_len);
   12d74:	04c12603          	lw	a2,76(sp)
   12d78:	09012703          	lw	a4,144(sp)
   12d7c:	04412683          	lw	a3,68(sp)
   12d80:	00f607b3          	add	a5,a2,a5
   12d84:	00170713          	addi	a4,a4,1
   12d88:	00d2a023          	sw	a3,0(t0)
   12d8c:	00700693          	li	a3,7
   12d90:	00c2a223          	sw	a2,4(t0)
   12d94:	08f12a23          	sw	a5,148(sp)
   12d98:	08e12823          	sw	a4,144(sp)
   12d9c:	00828293          	addi	t0,t0,8
   12da0:	40e6c863          	blt	a3,a4,131b0 <_vfprintf_r+0x19dc>
						PAD (-expt, zeroes);
   12da4:	413009b3          	neg	s3,s3
   12da8:	23305663          	blez	s3,12fd4 <_vfprintf_r+0x1800>
   12dac:	01000c93          	li	s9,16
   12db0:	03a12223          	sw	s10,36(sp)
   12db4:	1d3cda63          	ble	s3,s9,12f88 <_vfprintf_r+0x17b4>
   12db8:	00700d93          	li	s11,7
   12dbc:	00c0006f          	j	12dc8 <_vfprintf_r+0x15f4>
   12dc0:	ff098993          	addi	s3,s3,-16
   12dc4:	1d3cd263          	ble	s3,s9,12f88 <_vfprintf_r+0x17b4>
   12dc8:	01078793          	addi	a5,a5,16
   12dcc:	00170713          	addi	a4,a4,1
   12dd0:	01a2a023          	sw	s10,0(t0)
   12dd4:	0192a223          	sw	s9,4(t0)
   12dd8:	08f12a23          	sw	a5,148(sp)
   12ddc:	08e12823          	sw	a4,144(sp)
   12de0:	00828293          	addi	t0,t0,8
   12de4:	fceddee3          	ble	a4,s11,12dc0 <_vfprintf_r+0x15ec>
   12de8:	08c10613          	addi	a2,sp,140
   12dec:	000a0593          	mv	a1,s4
   12df0:	000c0513          	mv	a0,s8
   12df4:	0c1050ef          	jal	186b4 <__sprint_r>
   12df8:	00050463          	beqz	a0,12e00 <_vfprintf_r+0x162c>
   12dfc:	c9dfe06f          	j	11a98 <_vfprintf_r+0x2c4>
   12e00:	09412783          	lw	a5,148(sp)
   12e04:	09012703          	lw	a4,144(sp)
   12e08:	0c010293          	addi	t0,sp,192
   12e0c:	fb5ff06f          	j	12dc0 <_vfprintf_r+0x15ec>
	ORIENT(fp, -1);

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
		_newlib_flockfile_exit (fp);
		return (EOF);
   12e10:	fff00513          	li	a0,-1
   12e14:	c99fe06f          	j	11aac <_vfprintf_r+0x2d8>
				size = 3;
				flags &= ~ZEROPAD;
				break;
			}
			if (isnan (_fpvalue)) {
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
   12e18:	04700793          	li	a5,71
   12e1c:	2937c263          	blt	a5,s3,130a0 <_vfprintf_r+0x18cc>
					cp = "NAN";
   12e20:	0001c437          	lui	s0,0x1c
   12e24:	12c40413          	addi	s0,s0,300 # 1c12c <__thenan_sf+0x1c>
				else
					cp = "nan";
				size = 3;
				flags &= ~ZEROPAD;
				break;
   12e28:	00300713          	li	a4,3
   12e2c:	02e12023          	sw	a4,32(sp)
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "NAN";
				else
					cp = "nan";
				size = 3;
				flags &= ~ZEROPAD;
   12e30:	f7f97913          	andi	s2,s2,-129
   12e34:	06f14603          	lbu	a2,111(sp)
			if (isnan (_fpvalue)) {
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "NAN";
				else
					cp = "nan";
				size = 3;
   12e38:	02e12623          	sw	a4,44(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   12e3c:	02012423          	sw	zero,40(sp)
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   12e40:	02012e23          	sw	zero,60(sp)
					cp = "NAN";
				else
					cp = "nan";
				size = 3;
				flags &= ~ZEROPAD;
				break;
   12e44:	e29fe06f          	j	11c6c <_vfprintf_r+0x498>
#ifdef _WANT_IO_C99_FORMATS
			else if (flags & CHARINT)
				*GET_ARG (N, ap, char_ptr_t) = ret;
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
   12e48:	03012703          	lw	a4,48(sp)
   12e4c:	03412603          	lw	a2,52(sp)
   12e50:	00072783          	lw	a5,0(a4)
   12e54:	00470713          	addi	a4,a4,4
   12e58:	02e12823          	sw	a4,48(sp)
   12e5c:	00c7a023          	sw	a2,0(a5)
   12e60:	a75fe06f          	j	118d4 <_vfprintf_r+0x100>
			 */
			if (isinf (_fpvalue)) {
				if (_fpvalue < 0)
					sign = '-';
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "INF";
   12e64:	0001c437          	lui	s0,0x1c
   12e68:	12440413          	addi	s0,s0,292 # 1c124 <__thenan_sf+0x14>
   12e6c:	c50ff06f          	j	122bc <_vfprintf_r+0xae8>
						PAD (-expt, zeroes);
						PRINT (cp, ndig);
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
   12e70:	08c10613          	addi	a2,sp,140
   12e74:	000a0593          	mv	a1,s4
   12e78:	000c0513          	mv	a0,s8
   12e7c:	039050ef          	jal	186b4 <__sprint_r>
   12e80:	00050463          	beqz	a0,12e88 <_vfprintf_r+0x16b4>
   12e84:	c15fe06f          	j	11a98 <_vfprintf_r+0x2c4>
   12e88:	09412783          	lw	a5,148(sp)
   12e8c:	0c010293          	addi	t0,sp,192
   12e90:	929ff06f          	j	127b8 <_vfprintf_r+0xfe4>
						PRINT (decimal_point, decp_len);
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
					if (expt || ndig || flags & ALT) {
   12e94:	04012703          	lw	a4,64(sp)
   12e98:	ec071ee3          	bnez	a4,12d74 <_vfprintf_r+0x15a0>
   12e9c:	00197713          	andi	a4,s2,1
   12ea0:	00071463          	bnez	a4,12ea8 <_vfprintf_r+0x16d4>
   12ea4:	810ff06f          	j	11eb4 <_vfprintf_r+0x6e0>
   12ea8:	ecdff06f          	j	12d74 <_vfprintf_r+0x15a0>
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
   12eac:	08c10613          	addi	a2,sp,140
   12eb0:	000a0593          	mv	a1,s4
   12eb4:	000c0513          	mv	a0,s8
   12eb8:	7fc050ef          	jal	186b4 <__sprint_r>
   12ebc:	00050463          	beqz	a0,12ec4 <_vfprintf_r+0x16f0>
   12ec0:	bd9fe06f          	j	11a98 <_vfprintf_r+0x2c4>
   12ec4:	07412703          	lw	a4,116(sp)
   12ec8:	04012603          	lw	a2,64(sp)
   12ecc:	09412783          	lw	a5,148(sp)
   12ed0:	0c010293          	addi	t0,sp,192
   12ed4:	40e60733          	sub	a4,a2,a4
   12ed8:	ab9ff06f          	j	12990 <_vfprintf_r+0x11bc>
					if (expt < ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
   12edc:	08c10613          	addi	a2,sp,140
   12ee0:	000a0593          	mv	a1,s4
   12ee4:	000c0513          	mv	a0,s8
   12ee8:	7cc050ef          	jal	186b4 <__sprint_r>
   12eec:	00050463          	beqz	a0,12ef4 <_vfprintf_r+0x1720>
   12ef0:	ba9fe06f          	j	11a98 <_vfprintf_r+0x2c4>
   12ef4:	07412983          	lw	s3,116(sp)
   12ef8:	09412783          	lw	a5,148(sp)
   12efc:	0c010293          	addi	t0,sp,192
					if (expt || ndig || flags & ALT) {
   12f00:	e6099ae3          	bnez	s3,12d74 <_vfprintf_r+0x15a0>
   12f04:	f91ff06f          	j	12e94 <_vfprintf_r+0x16c0>
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   12f08:	00197793          	andi	a5,s2,1
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12f0c:	00068613          	mv	a2,a3
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   12f10:	02078063          	beqz	a5,12f30 <_vfprintf_r+0x175c>
   12f14:	01c12703          	lw	a4,28(sp)
   12f18:	0bf10413          	addi	s0,sp,191
                         *--cp = '0';
   12f1c:	03000793          	li	a5,48
   12f20:	40870733          	sub	a4,a4,s0
   12f24:	0af10fa3          	sb	a5,191(sp)
   12f28:	02e12623          	sw	a4,44(sp)
   12f2c:	a34ff06f          	j	12160 <_vfprintf_r+0x98c>
   12f30:	02012623          	sw	zero,44(sp)
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   12f34:	0c010413          	addi	s0,sp,192
   12f38:	a28ff06f          	j	12160 <_vfprintf_r+0x98c>
			if (ch >= 'f') {	/* 'f' or 'g' */
				if (_fpvalue == 0) {
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
					if (expt < ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
   12f3c:	08c10613          	addi	a2,sp,140
   12f40:	000a0593          	mv	a1,s4
   12f44:	000c0513          	mv	a0,s8
   12f48:	76c050ef          	jal	186b4 <__sprint_r>
   12f4c:	00050463          	beqz	a0,12f54 <_vfprintf_r+0x1780>
   12f50:	b49fe06f          	j	11a98 <_vfprintf_r+0x2c4>
   12f54:	09412783          	lw	a5,148(sp)
   12f58:	0c010293          	addi	t0,sp,192
   12f5c:	e14ff06f          	j	12570 <_vfprintf_r+0xd9c>
				if (p != NULL)
					size = p - cp;
				else
					size = prec;
			} else
				size = strlen (cp);
   12f60:	00040513          	mv	a0,s0
   12f64:	00512a23          	sw	t0,20(sp)
   12f68:	fdcfe0ef          	jal	11744 <strlen>
   12f6c:	02a12623          	sw	a0,44(sp)
   12f70:	01412283          	lw	t0,20(sp)
   12f74:	00050a93          	mv	s5,a0
   12f78:	00054463          	bltz	a0,12f80 <_vfprintf_r+0x17ac>
   12f7c:	cddfe06f          	j	11c58 <_vfprintf_r+0x484>
   12f80:	00000a93          	li	s5,0
   12f84:	cd5fe06f          	j	11c58 <_vfprintf_r+0x484>
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
					if (expt || ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
						PAD (-expt, zeroes);
   12f88:	02412683          	lw	a3,36(sp)
   12f8c:	013787b3          	add	a5,a5,s3
   12f90:	00170713          	addi	a4,a4,1
   12f94:	00d2a023          	sw	a3,0(t0)
   12f98:	00700693          	li	a3,7
   12f9c:	0132a223          	sw	s3,4(t0)
   12fa0:	08f12a23          	sw	a5,148(sp)
   12fa4:	08e12823          	sw	a4,144(sp)
   12fa8:	00828293          	addi	t0,t0,8
   12fac:	02e6d463          	ble	a4,a3,12fd4 <_vfprintf_r+0x1800>
   12fb0:	08c10613          	addi	a2,sp,140
   12fb4:	000a0593          	mv	a1,s4
   12fb8:	000c0513          	mv	a0,s8
   12fbc:	6f8050ef          	jal	186b4 <__sprint_r>
   12fc0:	00050463          	beqz	a0,12fc8 <_vfprintf_r+0x17f4>
   12fc4:	ad5fe06f          	j	11a98 <_vfprintf_r+0x2c4>
   12fc8:	09412783          	lw	a5,148(sp)
   12fcc:	09012703          	lw	a4,144(sp)
   12fd0:	0c010293          	addi	t0,sp,192
						PRINT (cp, ndig);
   12fd4:	04012603          	lw	a2,64(sp)
   12fd8:	00170713          	addi	a4,a4,1
   12fdc:	00700693          	li	a3,7
   12fe0:	00f607b3          	add	a5,a2,a5
   12fe4:	0082a023          	sw	s0,0(t0)
   12fe8:	00c2a223          	sw	a2,4(t0)
   12fec:	08f12a23          	sw	a5,148(sp)
   12ff0:	08e12823          	sw	a4,144(sp)
   12ff4:	00e6c463          	blt	a3,a4,12ffc <_vfprintf_r+0x1828>
   12ff8:	eb9fe06f          	j	11eb0 <_vfprintf_r+0x6dc>
   12ffc:	ca8ff06f          	j	124a4 <_vfprintf_r+0xcd0>
   13000:	fff00793          	li	a5,-1
   13004:	bd5fe06f          	j	11bd8 <_vfprintf_r+0x404>
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
   13008:	00000993          	li	s3,0
   1300c:	fb0ff06f          	j	127bc <_vfprintf_r+0xfe8>
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
   13010:	00000413          	li	s0,0
   13014:	981ff06f          	j	12994 <_vfprintf_r+0x11c0>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   13018:	02d00613          	li	a2,45
			{

				_uquad = -_uquad;
				sign = '-';
			}
			base = DEC;
   1301c:	00100713          	li	a4,1
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   13020:	00100693          	li	a3,1
   13024:	00d71463          	bne	a4,a3,1302c <_vfprintf_r+0x1858>
   13028:	fb5fe06f          	j	11fdc <_vfprintf_r+0x808>
   1302c:	00200693          	li	a3,2
   13030:	90d70063          	beq	a4,a3,12130 <_vfprintf_r+0x95c>
   13034:	b15fe06f          	j	11b48 <_vfprintf_r+0x374>
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
				size = ((unsigned) prec > 6U) ? 6 : prec;
   13038:	02812503          	lw	a0,40(sp)
   1303c:	00600793          	li	a5,6
   13040:	00a7f463          	bleu	a0,a5,13048 <_vfprintf_r+0x1874>
   13044:	00078513          	mv	a0,a5
   13048:	02a12623          	sw	a0,44(sp)
   1304c:	00050a93          	mv	s5,a0
   13050:	38054c63          	bltz	a0,133e8 <_vfprintf_r+0x1c14>
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
   13054:	0001c437          	lui	s0,0x1c
   13058:	03512023          	sw	s5,32(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   1305c:	03912823          	sw	s9,48(sp)
   13060:	00000613          	li	a2,0
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   13064:	02012423          	sw	zero,40(sp)
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   13068:	02012e23          	sw	zero,60(sp)
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
   1306c:	15c40413          	addi	s0,s0,348 # 1c15c <__thenan_sf+0x4c>
   13070:	c0dfe06f          	j	11c7c <_vfprintf_r+0x4a8>
# endif
					lead = expt;
			}

			if (softsign)
				sign = '-';
   13074:	02d00793          	li	a5,45
   13078:	06f107a3          	sb	a5,111(sp)
   1307c:	03512023          	sw	s5,32(sp)
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
				prec = 1;
			}

			flags |= FPT;
   13080:	02412903          	lw	s2,36(sp)
# endif
					lead = expt;
			}

			if (softsign)
				sign = '-';
   13084:	02d00613          	li	a2,45
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   13088:	02012423          	sw	zero,40(sp)
   1308c:	be5fe06f          	j	11c70 <_vfprintf_r+0x49c>
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
				ox[0] = '0';
				ox[1] = ch;
				flags |= HEXPREFIX;
   13090:	00070913          	mv	s2,a4
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   13094:	00000613          	li	a2,0
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
   13098:	00200713          	li	a4,2
   1309c:	f85ff06f          	j	13020 <_vfprintf_r+0x184c>
			}
			if (isnan (_fpvalue)) {
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "NAN";
				else
					cp = "nan";
   130a0:	0001c437          	lui	s0,0x1c
   130a4:	13040413          	addi	s0,s0,304 # 1c130 <__thenan_sf+0x20>
   130a8:	d81ff06f          	j	12e28 <_vfprintf_r+0x1654>
			   zeros are not permitted.  Otherwise, scanf
			   could not read what printf wrote.
			 */
			if (isinf (_fpvalue)) {
				if (_fpvalue < 0)
					sign = '-';
   130ac:	02d00793          	li	a5,45
   130b0:	06f107a3          	sb	a5,111(sp)
   130b4:	02d00613          	li	a2,45
   130b8:	9f4ff06f          	j	122ac <_vfprintf_r+0xad8>
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   130bc:	00197793          	andi	a5,s2,1
		bp = digits + ndigits;
   130c0:	00650db3          	add	s11,a0,t1
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   130c4:	b0079ee3          	bnez	a5,12be0 <_vfprintf_r+0x140c>
   130c8:	08412783          	lw	a5,132(sp)
   130cc:	b59ff06f          	j	12c24 <_vfprintf_r+0x1450>
   130d0:	00197793          	andi	a5,s2,1
   130d4:	2a079263          	bnez	a5,13378 <_vfprintf_r+0x1ba4>
		if (value == 0)	/* kludge for __dtoa irregularity */
			rve = bp;
		while (rve < bp)
			*rve++ = '0';
	}
	*length = rve - digits;
   130d8:	08412783          	lw	a5,132(sp)
   130dc:	408787b3          	sub	a5,a5,s0
   130e0:	04f12023          	sw	a5,64(sp)
			flags |= FPT;

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
   130e4:	02012783          	lw	a5,32(sp)
   130e8:	41379063          	bne	a5,s3,134e8 <_vfprintf_r+0x1d14>
				if (expt <= -4 || expt > prec)
   130ec:	07412783          	lw	a5,116(sp)
   130f0:	ffd00713          	li	a4,-3
   130f4:	02e7ca63          	blt	a5,a4,13128 <_vfprintf_r+0x1954>
   130f8:	02812683          	lw	a3,40(sp)
   130fc:	02f6c663          	blt	a3,a5,13128 <_vfprintf_r+0x1954>
   13100:	02f12e23          	sw	a5,60(sp)
   13104:	b4dff06f          	j	12c50 <_vfprintf_r+0x147c>
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);

				if (p != NULL)
   13108:	02812603          	lw	a2,40(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   1310c:	03912823          	sw	s9,48(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   13110:	02012423          	sw	zero,40(sp)
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);

				if (p != NULL)
   13114:	02c12023          	sw	a2,32(sp)
   13118:	02c12623          	sw	a2,44(sp)
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   1311c:	02012e23          	sw	zero,60(sp)
   13120:	06f14603          	lbu	a2,111(sp)
   13124:	b49fe06f          	j	11c6c <_vfprintf_r+0x498>
			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
				if (expt <= -4 || expt > prec)
					ch -= 2; /* 'e' or 'E' */
   13128:	ffe98993          	addi	s3,s3,-2
# ifdef _WANT_IO_C99_FORMATS
			else if (ch == 'F')
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
   1312c:	fff78793          	addi	a5,a5,-1
   13130:	06f12a23          	sw	a5,116(sp)
# else
#  define isa 0
# endif

	p = p0;
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   13134:	07310e23          	sb	s3,124(sp)
	if (exp < 0) {
   13138:	2e07ca63          	bltz	a5,1342c <_vfprintf_r+0x1c58>
		exp = -exp;
		*p++ = '-';
	}
	else
		*p++ = '+';
   1313c:	02b00713          	li	a4,43
   13140:	06e10ea3          	sb	a4,125(sp)
	t = expbuf + MAXEXPLEN;
	if (exp > 9) {
   13144:	00900613          	li	a2,9
   13148:	18f64863          	blt	a2,a5,132d8 <_vfprintf_r+0x1b04>
		*--t = to_char (exp);
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
	}
	else {
		if (!isa)
			*p++ = '0';
   1314c:	03000713          	li	a4,48
		*p++ = to_char (exp);
   13150:	03078793          	addi	a5,a5,48
		*--t = to_char (exp);
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
	}
	else {
		if (!isa)
			*p++ = '0';
   13154:	06e10f23          	sb	a4,126(sp)
		*p++ = to_char (exp);
   13158:	06f10fa3          	sb	a5,127(sp)
   1315c:	08010713          	addi	a4,sp,128
	}
	return (p - p0);
   13160:	07c10793          	addi	a5,sp,124
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
   13164:	04012683          	lw	a3,64(sp)
	else {
		if (!isa)
			*p++ = '0';
		*p++ = to_char (exp);
	}
	return (p - p0);
   13168:	40f707b3          	sub	a5,a4,a5
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
				if (ndig > 1 || flags & ALT)
   1316c:	04012703          	lw	a4,64(sp)
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
   13170:	00d786b3          	add	a3,a5,a3
	else {
		if (!isa)
			*p++ = '0';
		*p++ = to_char (exp);
	}
	return (p - p0);
   13174:	04f12e23          	sw	a5,92(sp)
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
				if (ndig > 1 || flags & ALT)
   13178:	00100793          	li	a5,1
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
   1317c:	02d12623          	sw	a3,44(sp)
				if (ndig > 1 || flags & ALT)
   13180:	2ae7de63          	ble	a4,a5,1343c <_vfprintf_r+0x1c68>
					++size;
   13184:	02c12783          	lw	a5,44(sp)
   13188:	00178793          	addi	a5,a5,1
   1318c:	02f12623          	sw	a5,44(sp)
   13190:	00078a93          	mv	s5,a5
   13194:	2a07cc63          	bltz	a5,1344c <_vfprintf_r+0x1c78>
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   13198:	02012e23          	sw	zero,60(sp)
   1319c:	addff06f          	j	12c78 <_vfprintf_r+0x14a4>
				  cp = buf;
			} else
# endif /* _WANT_IO_C99_FORMATS */
			if (prec == -1) {
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
   131a0:	02812683          	lw	a3,40(sp)
   131a4:	9a0698e3          	bnez	a3,12b54 <_vfprintf_r+0x1380>
				prec = 1;
   131a8:	02812423          	sw	s0,40(sp)
   131ac:	9a9ff06f          	j	12b54 <_vfprintf_r+0x1380>
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
					if (expt || ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
   131b0:	08c10613          	addi	a2,sp,140
   131b4:	000a0593          	mv	a1,s4
   131b8:	000c0513          	mv	a0,s8
   131bc:	4f8050ef          	jal	186b4 <__sprint_r>
   131c0:	00050463          	beqz	a0,131c8 <_vfprintf_r+0x19f4>
   131c4:	8d5fe06f          	j	11a98 <_vfprintf_r+0x2c4>
   131c8:	07412983          	lw	s3,116(sp)
   131cc:	09412783          	lw	a5,148(sp)
   131d0:	09012703          	lw	a4,144(sp)
   131d4:	0c010293          	addi	t0,sp,192
   131d8:	bcdff06f          	j	12da4 <_vfprintf_r+0x15d0>
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   131dc:	02012423          	sw	zero,40(sp)
   131e0:	f98fe06f          	j	11978 <_vfprintf_r+0x1a4>
   131e4:	fdf9f693          	andi	a3,s3,-33
				else
				  cp = buf;
			} else
# endif /* _WANT_IO_C99_FORMATS */
			if (prec == -1) {
				prec = DEFPREC;
   131e8:	00600713          	li	a4,6
   131ec:	02d12023          	sw	a3,32(sp)
   131f0:	02e12423          	sw	a4,40(sp)
   131f4:	961ff06f          	j	12b54 <_vfprintf_r+0x1380>
			ndigits++;
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   131f8:	08410793          	addi	a5,sp,132
   131fc:	00f12023          	sw	a5,0(sp)
   13200:	02812783          	lw	a5,40(sp)
   13204:	00300713          	li	a4,3
   13208:	000c8613          	mv	a2,s9
   1320c:	000a8693          	mv	a3,s5
   13210:	07810893          	addi	a7,sp,120
   13214:	07410813          	addi	a6,sp,116
   13218:	000c0513          	mv	a0,s8
   1321c:	00512a23          	sw	t0,20(sp)
   13220:	7e4000ef          	jal	13a04 <_dtoa_r>

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
   13224:	02812703          	lw	a4,40(sp)
   13228:	01412283          	lw	t0,20(sp)
			ndigits++;
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   1322c:	00050413          	mv	s0,a0

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
   13230:	00e50db3          	add	s11,a0,a4
   13234:	00070313          	mv	t1,a4
		if (ch == 'f' || ch == 'F') {
			if (*digits == '0' && value)
   13238:	00044703          	lbu	a4,0(s0)
   1323c:	03000793          	li	a5,48
   13240:	16f70663          	beq	a4,a5,133ac <_vfprintf_r+0x1bd8>
   13244:	07412303          	lw	t1,116(sp)
				*decpt = -ndigits + 1;
			bp += *decpt;
   13248:	006d8db3          	add	s11,s11,t1
   1324c:	995ff06f          	j	12be0 <_vfprintf_r+0x140c>
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
		value = -value;
   13250:	05412783          	lw	a5,84(sp)
   13254:	80000ab7          	lui	s5,0x80000
		*sign = '-';
   13258:	02d00613          	li	a2,45
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
		value = -value;
   1325c:	0157cab3          	xor	s5,a5,s5
		*sign = '-';
   13260:	02c12c23          	sw	a2,56(sp)
   13264:	909ff06f          	j	12b6c <_vfprintf_r+0x1398>
					size = expt;
					if (flags & ALT)
						++size;
				} else
					size = ndig + (expt > 0 ?
						1 : 2 - expt);
   13268:	03c12703          	lw	a4,60(sp)
   1326c:	00100513          	li	a0,1
   13270:	1ae05863          	blez	a4,13420 <_vfprintf_r+0x1c4c>
				} else if (expt >= ndig) { /* fixed g fmt */
					size = expt;
					if (flags & ALT)
						++size;
				} else
					size = ndig + (expt > 0 ?
   13274:	04012783          	lw	a5,64(sp)
   13278:	00f50533          	add	a0,a0,a5
   1327c:	02a12623          	sw	a0,44(sp)
   13280:	00050a93          	mv	s5,a0
   13284:	02054063          	bltz	a0,132a4 <_vfprintf_r+0x1ad0>
   13288:	06700993          	li	s3,103
   1328c:	9edff06f          	j	12c78 <_vfprintf_r+0x14a4>
							  ? prec + 2
							  : 1;
				} else if (expt >= ndig) { /* fixed g fmt */
					size = expt;
					if (flags & ALT)
						++size;
   13290:	03c12783          	lw	a5,60(sp)
   13294:	00178793          	addi	a5,a5,1
   13298:	02f12623          	sw	a5,44(sp)
   1329c:	00078a93          	mv	s5,a5
   132a0:	fe07d4e3          	bgez	a5,13288 <_vfprintf_r+0x1ab4>
   132a4:	00000a93          	li	s5,0
				} else
					size = ndig + (expt > 0 ?
   132a8:	06700993          	li	s3,103
   132ac:	9cdff06f          	j	12c78 <_vfprintf_r+0x14a4>
# ifdef _WANT_IO_C99_FORMATS
				flags &= ~GROUPING;
# endif
			} else {
				if (ch == 'f') {		/* f fmt */
					if (expt > 0) {
   132b0:	07412783          	lw	a5,116(sp)
   132b4:	02f12e23          	sw	a5,60(sp)
   132b8:	12f05c63          	blez	a5,133f0 <_vfprintf_r+0x1c1c>
						size = expt;
						if (prec || flags & ALT)
   132bc:	02812603          	lw	a2,40(sp)
   132c0:	0c061463          	bnez	a2,13388 <_vfprintf_r+0x1bb4>
   132c4:	00197913          	andi	s2,s2,1
   132c8:	0c091063          	bnez	s2,13388 <_vfprintf_r+0x1bb4>
   132cc:	00078a93          	mv	s5,a5
   132d0:	02f12623          	sw	a5,44(sp)
   132d4:	9a5ff06f          	j	12c78 <_vfprintf_r+0x14a4>
		*p++ = '-';
	}
	else
		*p++ = '+';
	t = expbuf + MAXEXPLEN;
	if (exp > 9) {
   132d8:	08b10593          	addi	a1,sp,139
   132dc:	00058713          	mv	a4,a1
		do {
			*--t = to_char (exp % 10);
   132e0:	00a00513          	li	a0,10
   132e4:	02a7e6b3          	rem	a3,a5,a0
   132e8:	fff70713          	addi	a4,a4,-1
		} while ((exp /= 10) > 9);
   132ec:	02a7c7b3          	div	a5,a5,a0
	else
		*p++ = '+';
	t = expbuf + MAXEXPLEN;
	if (exp > 9) {
		do {
			*--t = to_char (exp % 10);
   132f0:	03068693          	addi	a3,a3,48
   132f4:	00d70023          	sb	a3,0(a4)
		} while ((exp /= 10) > 9);
   132f8:	fef646e3          	blt	a2,a5,132e4 <_vfprintf_r+0x1b10>
		*--t = to_char (exp);
   132fc:	03078793          	addi	a5,a5,48
   13300:	0ff7f793          	andi	a5,a5,255
   13304:	fff70693          	addi	a3,a4,-1
   13308:	fef70fa3          	sb	a5,-1(a4)
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
   1330c:	1cb6fa63          	bleu	a1,a3,134e0 <_vfprintf_r+0x1d0c>
   13310:	07e10613          	addi	a2,sp,126
   13314:	0080006f          	j	1331c <_vfprintf_r+0x1b48>
   13318:	0006c783          	lbu	a5,0(a3)
   1331c:	00160613          	addi	a2,a2,1
   13320:	00168693          	addi	a3,a3,1
   13324:	fef60fa3          	sb	a5,-1(a2)
   13328:	feb698e3          	bne	a3,a1,13318 <_vfprintf_r+0x1b44>
   1332c:	08c10793          	addi	a5,sp,140
   13330:	40e78733          	sub	a4,a5,a4
   13334:	07e10793          	addi	a5,sp,126
   13338:	00e78733          	add	a4,a5,a4
   1333c:	e25ff06f          	j	13160 <_vfprintf_r+0x198c>
			ndigits++;
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   13340:	08410793          	addi	a5,sp,132
   13344:	00f12023          	sw	a5,0(sp)
   13348:	02812783          	lw	a5,40(sp)
   1334c:	000c8613          	mv	a2,s9
   13350:	000a8693          	mv	a3,s5
   13354:	07810893          	addi	a7,sp,120
   13358:	07410813          	addi	a6,sp,116
   1335c:	00300713          	li	a4,3
   13360:	000c0513          	mv	a0,s8
   13364:	00512a23          	sw	t0,20(sp)
   13368:	69c000ef          	jal	13a04 <_dtoa_r>
   1336c:	02812303          	lw	t1,40(sp)
   13370:	01412283          	lw	t0,20(sp)
   13374:	00050413          	mv	s0,a0

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
		if (ch == 'f' || ch == 'F') {
   13378:	04600793          	li	a5,70
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
   1337c:	00640db3          	add	s11,s0,t1
		if (ch == 'f' || ch == 'F') {
   13380:	eaf98ce3          	beq	s3,a5,13238 <_vfprintf_r+0x1a64>
   13384:	85dff06f          	j	12be0 <_vfprintf_r+0x140c>
			} else {
				if (ch == 'f') {		/* f fmt */
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
   13388:	02812683          	lw	a3,40(sp)
   1338c:	03c12703          	lw	a4,60(sp)
   13390:	00168513          	addi	a0,a3,1
   13394:	00a70533          	add	a0,a4,a0
   13398:	02a12623          	sw	a0,44(sp)
   1339c:	00050a93          	mv	s5,a0
   133a0:	8c055ce3          	bgez	a0,12c78 <_vfprintf_r+0x14a4>
   133a4:	00000a93          	li	s5,0
					} else	/* "0.X" */
						size = (prec || flags & ALT)
							  ? prec + 2
							  : 1;
   133a8:	8d1ff06f          	j	12c78 <_vfprintf_r+0x14a4>
	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
		if (ch == 'f' || ch == 'F') {
			if (*digits == '0' && value)
   133ac:	000c8513          	mv	a0,s9
   133b0:	000a8593          	mv	a1,s5
   133b4:	00000613          	li	a2,0
   133b8:	00000693          	li	a3,0
   133bc:	00512a23          	sw	t0,20(sp)
   133c0:	00612c23          	sw	t1,24(sp)
   133c4:	039070ef          	jal	1abfc <__nedf2>
   133c8:	01412283          	lw	t0,20(sp)
   133cc:	01812303          	lw	t1,24(sp)
   133d0:	e6050ae3          	beqz	a0,13244 <_vfprintf_r+0x1a70>
				*decpt = -ndigits + 1;
   133d4:	00100793          	li	a5,1
   133d8:	40678333          	sub	t1,a5,t1
   133dc:	06612a23          	sw	t1,116(sp)
			bp += *decpt;
   133e0:	006d8db3          	add	s11,s11,t1
   133e4:	ffcff06f          	j	12be0 <_vfprintf_r+0x140c>
   133e8:	00000a93          	li	s5,0
   133ec:	c69ff06f          	j	13054 <_vfprintf_r+0x1880>
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
							  ? prec + 2
							  : 1;
   133f0:	02812783          	lw	a5,40(sp)
   133f4:	00079a63          	bnez	a5,13408 <_vfprintf_r+0x1c34>
   133f8:	00100a93          	li	s5,1
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
   133fc:	01597933          	and	s2,s2,s5
							  ? prec + 2
							  : 1;
   13400:	03512623          	sw	s5,44(sp)
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
   13404:	86090ae3          	beqz	s2,12c78 <_vfprintf_r+0x14a4>
							  ? prec + 2
							  : 1;
   13408:	02812683          	lw	a3,40(sp)
   1340c:	00268693          	addi	a3,a3,2
   13410:	02d12623          	sw	a3,44(sp)
   13414:	00068a93          	mv	s5,a3
   13418:	8606d0e3          	bgez	a3,12c78 <_vfprintf_r+0x14a4>
   1341c:	f89ff06f          	j	133a4 <_vfprintf_r+0x1bd0>
					size = expt;
					if (flags & ALT)
						++size;
				} else
					size = ndig + (expt > 0 ?
						1 : 2 - expt);
   13420:	00200513          	li	a0,2
   13424:	40e50533          	sub	a0,a0,a4
   13428:	e4dff06f          	j	13274 <_vfprintf_r+0x1aa0>

	p = p0;
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
	if (exp < 0) {
		exp = -exp;
		*p++ = '-';
   1342c:	02d00713          	li	a4,45
# endif

	p = p0;
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
	if (exp < 0) {
		exp = -exp;
   13430:	40f007b3          	neg	a5,a5
		*p++ = '-';
   13434:	06e10ea3          	sb	a4,125(sp)
   13438:	d0dff06f          	j	13144 <_vfprintf_r+0x1970>
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
				if (ndig > 1 || flags & ALT)
   1343c:	00f97933          	and	s2,s2,a5
   13440:	d40912e3          	bnez	s2,13184 <_vfprintf_r+0x19b0>
   13444:	00068a93          	mv	s5,a3
   13448:	d406d8e3          	bgez	a3,13198 <_vfprintf_r+0x19c4>
   1344c:	00000a93          	li	s5,0
   13450:	d49ff06f          	j	13198 <_vfprintf_r+0x19c4>
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
   13454:	03012703          	lw	a4,48(sp)
   13458:	00072703          	lw	a4,0(a4)
   1345c:	02e12423          	sw	a4,40(sp)
   13460:	03012703          	lw	a4,48(sp)
   13464:	00470793          	addi	a5,a4,4
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
   13468:	02812703          	lw	a4,40(sp)
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
   1346c:	02f12823          	sw	a5,48(sp)
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
   13470:	00074463          	bltz	a4,13478 <_vfprintf_r+0x1ca4>
   13474:	cfcfe06f          	j	11970 <_vfprintf_r+0x19c>
					prec = -1;
   13478:	fff00713          	li	a4,-1
   1347c:	02e12423          	sw	a4,40(sp)
   13480:	cf0fe06f          	j	11970 <_vfprintf_r+0x19c>
   13484:	06a107a3          	sb	a0,111(sp)
   13488:	d35fe06f          	j	121bc <_vfprintf_r+0x9e8>
   1348c:	06a107a3          	sb	a0,111(sp)
				size = 1;
			}
			sign = '\0';
			break;
		case 'D':  /* extension */
			flags |= LONGINT;
   13490:	01096913          	ori	s2,s2,16
   13494:	e59fe06f          	j	122ec <_vfprintf_r+0xb18>
   13498:	06a107a3          	sb	a0,111(sp)
   1349c:	da9fe06f          	j	12244 <_vfprintf_r+0xa70>
   134a0:	06a107a3          	sb	a0,111(sp)
   134a4:	d69fe06f          	j	1220c <_vfprintf_r+0xa38>
   134a8:	06a107a3          	sb	a0,111(sp)
   134ac:	c2dfe06f          	j	120d8 <_vfprintf_r+0x904>
   134b0:	06a107a3          	sb	a0,111(sp)
			} else
				size = strlen (cp);

			break;
		case 'U': /* extension */
			flags |= LONGINT;
   134b4:	01096913          	ori	s2,s2,16
   134b8:	bddfe06f          	j	12094 <_vfprintf_r+0x8c0>
   134bc:	06a107a3          	sb	a0,111(sp)
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
   134c0:	01096913          	ori	s2,s2,16
   134c4:	b89fe06f          	j	1204c <_vfprintf_r+0x878>
   134c8:	06a107a3          	sb	a0,111(sp)
   134cc:	ae1fe06f          	j	11fac <_vfprintf_r+0x7d8>
   134d0:	00000a93          	li	s5,0
   134d4:	f98ff06f          	j	12c6c <_vfprintf_r+0x1498>
   134d8:	06a107a3          	sb	a0,111(sp)
   134dc:	e2cfe06f          	j	11b08 <_vfprintf_r+0x334>
	if (exp > 9) {
		do {
			*--t = to_char (exp % 10);
		} while ((exp /= 10) > 9);
		*--t = to_char (exp);
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
   134e0:	07e10713          	addi	a4,sp,126
   134e4:	c7dff06f          	j	13160 <_vfprintf_r+0x198c>
   134e8:	07412783          	lw	a5,116(sp)
   134ec:	c41ff06f          	j	1312c <_vfprintf_r+0x1958>
   134f0:	06a107a3          	sb	a0,111(sp)
   134f4:	e71fe06f          	j	12364 <_vfprintf_r+0xb90>
   134f8:	06a107a3          	sb	a0,111(sp)
   134fc:	e1dfe06f          	j	12318 <_vfprintf_r+0xb44>

00013500 <vfprintf>:
       FILE * fp         _AND
       _CONST char *fmt0 _AND
       va_list ap)
{
  int result;
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
   13500:	00060693          	mv	a3,a2
   13504:	00058613          	mv	a2,a1
   13508:	00050593          	mv	a1,a0
   1350c:	8101a503          	lw	a0,-2032(gp) # 1de50 <_impure_ptr>
   13510:	ac4fe06f          	j	117d4 <_vfprintf_r>

00013514 <__sbprintf>:
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   13514:	00c5d783          	lhu	a5,12(a1)
	fake._flags2 = fp->_flags2;
   13518:	0685a303          	lw	t1,104(a1)
	fake._file = fp->_file;
   1351c:	00e5d283          	lhu	t0,14(a1)
	fake._cookie = fp->_cookie;
   13520:	01c5a883          	lw	a7,28(a1)
	fake._write = fp->_write;
   13524:	0245a803          	lw	a6,36(a1)
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   13528:	b8010113          	addi	sp,sp,-1152
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   1352c:	ffd7f793          	andi	a5,a5,-3
	fake._cookie = fp->_cookie;
	fake._write = fp->_write;

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
	fake._bf._size = fake._w = sizeof (buf);
   13530:	40000713          	li	a4,1024
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   13534:	46812c23          	sw	s0,1144(sp)
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   13538:	00f11623          	sh	a5,12(sp)
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   1353c:	00058413          	mv	s0,a1
	fake._file = fp->_file;
	fake._cookie = fp->_cookie;
	fake._write = fp->_write;

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
   13540:	07010793          	addi	a5,sp,112
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   13544:	00010593          	mv	a1,sp
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   13548:	46912a23          	sw	s1,1140(sp)
   1354c:	47212823          	sw	s2,1136(sp)
   13550:	46112e23          	sw	ra,1148(sp)
   13554:	00050913          	mv	s2,a0
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
	fake._flags2 = fp->_flags2;
   13558:	06612423          	sw	t1,104(sp)
	fake._file = fp->_file;
   1355c:	00511723          	sh	t0,14(sp)
	fake._cookie = fp->_cookie;
   13560:	01112e23          	sw	a7,28(sp)
	fake._write = fp->_write;
   13564:	03012223          	sw	a6,36(sp)

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
   13568:	00f12023          	sw	a5,0(sp)
   1356c:	00f12823          	sw	a5,16(sp)
	fake._bf._size = fake._w = sizeof (buf);
   13570:	00e12423          	sw	a4,8(sp)
   13574:	00e12a23          	sw	a4,20(sp)
	fake._lbfsize = 0;	/* not actually used, but Just In Case */
   13578:	00012c23          	sw	zero,24(sp)
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   1357c:	a58fe0ef          	jal	117d4 <_vfprintf_r>
   13580:	00050493          	mv	s1,a0
	if (ret >= 0 && _fflush_r (rptr, &fake))
   13584:	00054a63          	bltz	a0,13598 <__sbprintf+0x84>
   13588:	00010593          	mv	a1,sp
   1358c:	00090513          	mv	a0,s2
   13590:	41d010ef          	jal	151ac <_fflush_r>
   13594:	02051c63          	bnez	a0,135cc <__sbprintf+0xb8>
		ret = EOF;
	if (fake._flags & __SERR)
   13598:	00c15783          	lhu	a5,12(sp)
   1359c:	0407f793          	andi	a5,a5,64
   135a0:	00078863          	beqz	a5,135b0 <__sbprintf+0x9c>
		fp->_flags |= __SERR;
   135a4:	00c45783          	lhu	a5,12(s0)
   135a8:	0407e793          	ori	a5,a5,64
   135ac:	00f41623          	sh	a5,12(s0)

#ifndef __SINGLE_THREAD__
	__lock_close_recursive (fake._lock);
#endif
	return (ret);
}
   135b0:	47c12083          	lw	ra,1148(sp)
   135b4:	00048513          	mv	a0,s1
   135b8:	47812403          	lw	s0,1144(sp)
   135bc:	47412483          	lw	s1,1140(sp)
   135c0:	47012903          	lw	s2,1136(sp)
   135c4:	48010113          	addi	sp,sp,1152
   135c8:	00008067          	ret
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
	if (ret >= 0 && _fflush_r (rptr, &fake))
		ret = EOF;
   135cc:	fff00493          	li	s1,-1
   135d0:	fc9ff06f          	j	13598 <__sbprintf+0x84>

000135d4 <__swsetup_r>:
       struct _reent *ptr _AND
       register FILE * fp)
{
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   135d4:	8101a783          	lw	a5,-2032(gp) # 1de50 <_impure_ptr>

int
_DEFUN(__swsetup_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   135d8:	ff010113          	addi	sp,sp,-16
   135dc:	00812423          	sw	s0,8(sp)
   135e0:	00912223          	sw	s1,4(sp)
   135e4:	00112623          	sw	ra,12(sp)
   135e8:	00050493          	mv	s1,a0
   135ec:	00058413          	mv	s0,a1
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   135f0:	00078663          	beqz	a5,135fc <__swsetup_r+0x28>
   135f4:	0387a703          	lw	a4,56(a5)
   135f8:	0c070c63          	beqz	a4,136d0 <__swsetup_r+0xfc>

  /*
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
   135fc:	00c41703          	lh	a4,12(s0)
   13600:	01071793          	slli	a5,a4,0x10
   13604:	0107d793          	srli	a5,a5,0x10
   13608:	0087f693          	andi	a3,a5,8
   1360c:	04068263          	beqz	a3,13650 <__swsetup_r+0x7c>
   13610:	01042683          	lw	a3,16(s0)
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
   13614:	06068263          	beqz	a3,13678 <__swsetup_r+0xa4>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
    __smakebuf_r (ptr, fp);

  if (fp->_flags & __SLBF)
   13618:	0017f713          	andi	a4,a5,1
   1361c:	08071063          	bnez	a4,1369c <__swsetup_r+0xc8>
       */
      fp->_w = 0;
      fp->_lbfsize = -fp->_bf._size;
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;
   13620:	0027f793          	andi	a5,a5,2
   13624:	00000713          	li	a4,0
   13628:	00079463          	bnez	a5,13630 <__swsetup_r+0x5c>
   1362c:	01442703          	lw	a4,20(s0)
   13630:	00e42423          	sw	a4,8(s0)
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
      return EOF;
    }
  return 0;
   13634:	00000513          	li	a0,0
      fp->_lbfsize = -fp->_bf._size;
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;

  if (!fp->_bf._base && (fp->_flags & __SMBF))
   13638:	06068e63          	beqz	a3,136b4 <__swsetup_r+0xe0>
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
      return EOF;
    }
  return 0;
}
   1363c:	00c12083          	lw	ra,12(sp)
   13640:	00812403          	lw	s0,8(sp)
   13644:	00412483          	lw	s1,4(sp)
   13648:	01010113          	addi	sp,sp,16
   1364c:	00008067          	ret
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
   13650:	0107f693          	andi	a3,a5,16
   13654:	0a068e63          	beqz	a3,13710 <__swsetup_r+0x13c>
        {
	  ptr->_errno = EBADF;
	  fp->_flags |= __SERR;
	  return EOF;
        }
      if (fp->_flags & __SRD)
   13658:	0047f793          	andi	a5,a5,4
   1365c:	08079063          	bnez	a5,136dc <__swsetup_r+0x108>
   13660:	01042683          	lw	a3,16(s0)
	    FREEUB (ptr, fp);
	  fp->_flags &= ~(__SRD | __SEOF);
	  fp->_r = 0;
	  fp->_p = fp->_bf._base;
	}
      fp->_flags |= __SWR;
   13664:	00876793          	ori	a5,a4,8
   13668:	00f41623          	sh	a5,12(s0)
   1366c:	01079793          	slli	a5,a5,0x10
   13670:	0107d793          	srli	a5,a5,0x10
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
   13674:	fa0692e3          	bnez	a3,13618 <__swsetup_r+0x44>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
   13678:	2807f713          	andi	a4,a5,640
   1367c:	20000613          	li	a2,512
   13680:	f8c70ce3          	beq	a4,a2,13618 <__swsetup_r+0x44>
    __smakebuf_r (ptr, fp);
   13684:	00040593          	mv	a1,s0
   13688:	00048513          	mv	a0,s1
   1368c:	1bd020ef          	jal	16048 <__smakebuf_r>
   13690:	00c45783          	lhu	a5,12(s0)
   13694:	01042683          	lw	a3,16(s0)
   13698:	f81ff06f          	j	13618 <__swsetup_r+0x44>
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
      fp->_lbfsize = -fp->_bf._size;
   1369c:	01442783          	lw	a5,20(s0)
      /*
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
   136a0:	00042423          	sw	zero,8(s0)
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
      return EOF;
    }
  return 0;
   136a4:	00000513          	li	a0,0
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
      fp->_lbfsize = -fp->_bf._size;
   136a8:	40f007b3          	neg	a5,a5
   136ac:	00f42c23          	sw	a5,24(s0)
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;

  if (!fp->_bf._base && (fp->_flags & __SMBF))
   136b0:	f80696e3          	bnez	a3,1363c <__swsetup_r+0x68>
   136b4:	00c41783          	lh	a5,12(s0)
   136b8:	0807f713          	andi	a4,a5,128
   136bc:	f80700e3          	beqz	a4,1363c <__swsetup_r+0x68>
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
   136c0:	0407e793          	ori	a5,a5,64
   136c4:	00f41623          	sh	a5,12(s0)
      return EOF;
   136c8:	fff00513          	li	a0,-1
   136cc:	f71ff06f          	j	1363c <__swsetup_r+0x68>
       struct _reent *ptr _AND
       register FILE * fp)
{
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   136d0:	00078513          	mv	a0,a5
   136d4:	689010ef          	jal	1555c <__sinit>
   136d8:	f25ff06f          	j	135fc <__swsetup_r+0x28>
	  return EOF;
        }
      if (fp->_flags & __SRD)
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
   136dc:	03042583          	lw	a1,48(s0)
   136e0:	00058e63          	beqz	a1,136fc <__swsetup_r+0x128>
	    FREEUB (ptr, fp);
   136e4:	04040793          	addi	a5,s0,64
   136e8:	00f58863          	beq	a1,a5,136f8 <__swsetup_r+0x124>
   136ec:	00048513          	mv	a0,s1
   136f0:	7ad010ef          	jal	1569c <_free_r>
   136f4:	00c41703          	lh	a4,12(s0)
   136f8:	02042823          	sw	zero,48(s0)
	  fp->_flags &= ~(__SRD | __SEOF);
	  fp->_r = 0;
	  fp->_p = fp->_bf._base;
   136fc:	01042683          	lw	a3,16(s0)
      if (fp->_flags & __SRD)
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
	    FREEUB (ptr, fp);
	  fp->_flags &= ~(__SRD | __SEOF);
   13700:	fdb77713          	andi	a4,a4,-37
	  fp->_r = 0;
   13704:	00042223          	sw	zero,4(s0)
	  fp->_p = fp->_bf._base;
   13708:	00d42023          	sw	a3,0(s0)
   1370c:	f59ff06f          	j	13664 <__swsetup_r+0x90>
  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
        {
	  ptr->_errno = EBADF;
	  fp->_flags |= __SERR;
   13710:	04076713          	ori	a4,a4,64

  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
        {
	  ptr->_errno = EBADF;
   13714:	00900793          	li	a5,9
   13718:	00f4a023          	sw	a5,0(s1)
	  fp->_flags |= __SERR;
	  return EOF;
   1371c:	fff00513          	li	a0,-1
  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
        {
	  ptr->_errno = EBADF;
	  fp->_flags |= __SERR;
   13720:	00e41623          	sh	a4,12(s0)
	  return EOF;
   13724:	f19ff06f          	j	1363c <__swsetup_r+0x68>

00013728 <__register_exitproc>:
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
   13728:	fe010113          	addi	sp,sp,-32
   1372c:	00812c23          	sw	s0,24(sp)

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
   13730:	80c1a403          	lw	s0,-2036(gp) # 1de4c <_global_impure_ptr>
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
   13734:	00912a23          	sw	s1,20(sp)
   13738:	00050493          	mv	s1,a0

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
   1373c:	14842503          	lw	a0,328(s0)
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
   13740:	00112e23          	sw	ra,28(sp)
#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
  if (p == NULL)
   13744:	0c050263          	beqz	a0,13808 <__register_exitproc+0xe0>
    _GLOBAL_ATEXIT = p = _GLOBAL_ATEXIT0;
  if (p->_ind >= _ATEXIT_SIZE)
   13748:	00452783          	lw	a5,4(a0)
   1374c:	01f00713          	li	a4,31
   13750:	00178813          	addi	a6,a5,1
   13754:	04f75863          	ble	a5,a4,137a4 <__register_exitproc+0x7c>
#ifndef _ATEXIT_DYNAMIC_ALLOC
      return -1;
#else
      /* Don't dynamically allocate the atexit array if malloc is not
	 available.  */
      if (!malloc)
   13758:	00000793          	li	a5,0
   1375c:	0a078c63          	beqz	a5,13814 <__register_exitproc+0xec>
	return -1;

      p = (struct _atexit *) malloc (sizeof *p);
   13760:	19000513          	li	a0,400
   13764:	00b12623          	sw	a1,12(sp)
   13768:	00c12423          	sw	a2,8(sp)
   1376c:	00d12223          	sw	a3,4(sp)
   13770:	891ec0ef          	jal	0 <_reset-0x200>
      if (p == NULL)
   13774:	00c12583          	lw	a1,12(sp)
   13778:	00812603          	lw	a2,8(sp)
   1377c:	00412683          	lw	a3,4(sp)
   13780:	08050a63          	beqz	a0,13814 <__register_exitproc+0xec>
	  __lock_release_recursive(__atexit_lock);
#endif
	  return -1;
	}
      p->_ind = 0;
      p->_next = _GLOBAL_ATEXIT;
   13784:	14842783          	lw	a5,328(s0)
      _GLOBAL_ATEXIT = p;
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
      p->_on_exit_args._is_cxa = 0;
   13788:	00100813          	li	a6,1
#ifndef __SINGLE_THREAD__
	  __lock_release_recursive(__atexit_lock);
#endif
	  return -1;
	}
      p->_ind = 0;
   1378c:	00052223          	sw	zero,4(a0)
      p->_next = _GLOBAL_ATEXIT;
   13790:	00f52023          	sw	a5,0(a0)
      _GLOBAL_ATEXIT = p;
   13794:	14a42423          	sw	a0,328(s0)
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
      p->_on_exit_args._is_cxa = 0;
   13798:	00000793          	li	a5,0
	}
      p->_ind = 0;
      p->_next = _GLOBAL_ATEXIT;
      _GLOBAL_ATEXIT = p;
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
   1379c:	18052423          	sw	zero,392(a0)
      p->_on_exit_args._is_cxa = 0;
   137a0:	18052623          	sw	zero,396(a0)
   137a4:	00279713          	slli	a4,a5,0x2
      p->_on_exit_args_ptr = NULL;
#endif
#endif
    }

  if (type != __et_atexit)
   137a8:	02049463          	bnez	s1,137d0 <__register_exitproc+0xa8>
      args->_fntypes |= (1 << p->_ind);
      args->_dso_handle[p->_ind] = d;
      if (type == __et_cxa)
	args->_is_cxa |= (1 << p->_ind);
    }
  p->_fns[p->_ind++] = fn;
   137ac:	00e50733          	add	a4,a0,a4
   137b0:	01052223          	sw	a6,4(a0)
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif
  return 0;
   137b4:	00000513          	li	a0,0
      args->_fntypes |= (1 << p->_ind);
      args->_dso_handle[p->_ind] = d;
      if (type == __et_cxa)
	args->_is_cxa |= (1 << p->_ind);
    }
  p->_fns[p->_ind++] = fn;
   137b8:	00b72423          	sw	a1,8(a4)
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif
  return 0;
}
   137bc:	01c12083          	lw	ra,28(sp)
   137c0:	01812403          	lw	s0,24(sp)
   137c4:	01412483          	lw	s1,20(sp)
   137c8:	02010113          	addi	sp,sp,32
   137cc:	00008067          	ret
   137d0:	00e502b3          	add	t0,a0,a4
	  p->_on_exit_args_ptr = args;
	}
#else
      args = &p->_on_exit_args;
#endif
      args->_fnargs[p->_ind] = arg;
   137d4:	08c2a423          	sw	a2,136(t0)
      args->_fntypes |= (1 << p->_ind);
   137d8:	18852883          	lw	a7,392(a0)
   137dc:	00100613          	li	a2,1
   137e0:	00f617b3          	sll	a5,a2,a5
   137e4:	00f8e633          	or	a2,a7,a5
   137e8:	18c52423          	sw	a2,392(a0)
      args->_dso_handle[p->_ind] = d;
   137ec:	10d2a423          	sw	a3,264(t0)
      if (type == __et_cxa)
   137f0:	00200693          	li	a3,2
   137f4:	fad49ce3          	bne	s1,a3,137ac <__register_exitproc+0x84>
	args->_is_cxa |= (1 << p->_ind);
   137f8:	18c52683          	lw	a3,396(a0)
   137fc:	00f6e7b3          	or	a5,a3,a5
   13800:	18f52623          	sw	a5,396(a0)
   13804:	fa9ff06f          	j	137ac <__register_exitproc+0x84>
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
  if (p == NULL)
    _GLOBAL_ATEXIT = p = _GLOBAL_ATEXIT0;
   13808:	14c40513          	addi	a0,s0,332
   1380c:	14a42423          	sw	a0,328(s0)
   13810:	f39ff06f          	j	13748 <__register_exitproc+0x20>
      return -1;
#else
      /* Don't dynamically allocate the atexit array if malloc is not
	 available.  */
      if (!malloc)
	return -1;
   13814:	fff00513          	li	a0,-1
   13818:	fa5ff06f          	j	137bc <__register_exitproc+0x94>

0001381c <quorem>:

static int
_DEFUN (quorem,
	(b, S),
	_Bigint * b _AND _Bigint * S)
{
   1381c:	fe010113          	addi	sp,sp,-32
   13820:	01212823          	sw	s2,16(sp)
  n = S->_wds;
#ifdef DEBUG
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
   13824:	01052783          	lw	a5,16(a0)
#ifdef Pack_32
  __Long z;
  __ULong si, zs;
#endif

  n = S->_wds;
   13828:	0105a903          	lw	s2,16(a1)

static int
_DEFUN (quorem,
	(b, S),
	_Bigint * b _AND _Bigint * S)
{
   1382c:	00112e23          	sw	ra,28(sp)
   13830:	00812c23          	sw	s0,24(sp)
   13834:	00912a23          	sw	s1,20(sp)
   13838:	01312623          	sw	s3,12(sp)
   1383c:	01412423          	sw	s4,8(sp)
   13840:	01512223          	sw	s5,4(sp)
  n = S->_wds;
#ifdef DEBUG
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
   13844:	1b27cc63          	blt	a5,s2,139fc <quorem+0x1e0>
    return 0;
  sx = S->_x;
  sxe = sx + --n;
   13848:	fff90913          	addi	s2,s2,-1
   1384c:	00291e13          	slli	t3,s2,0x2
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
    return 0;
  sx = S->_x;
   13850:	01458413          	addi	s0,a1,20
  sxe = sx + --n;
   13854:	01c409b3          	add	s3,s0,t3
  bx = b->_x;
   13858:	01450a13          	addi	s4,a0,20
  bxe = bx + n;
   1385c:	01ca0e33          	add	t3,s4,t3
  q = *bxe / (*sxe + 1);	/* ensure q <= true quotient */
   13860:	0009a783          	lw	a5,0(s3)
   13864:	000e2483          	lw	s1,0(t3)
   13868:	00178793          	addi	a5,a5,1
   1386c:	02f4d4b3          	divu	s1,s1,a5
#ifdef DEBUG
  /*debug*/ if (q > 9)
    /*debug*/ Bug ("oversized quotient in quorem");
#endif
  if (q)
   13870:	0a048e63          	beqz	s1,1392c <quorem+0x110>
      carry = 0;
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
   13874:	000102b7          	lui	t0,0x10
   13878:	00040393          	mv	t2,s0
#endif
  if (b->_wds < n)
    return 0;
  sx = S->_x;
  sxe = sx + --n;
  bx = b->_x;
   1387c:	000a0313          	mv	t1,s4
   13880:	00000693          	li	a3,0
   13884:	00000793          	li	a5,0
      carry = 0;
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
   13888:	fff28293          	addi	t0,t0,-1 # ffff <_reset+0xfdff>
      borrow = 0;
      carry = 0;
      do
	{
#ifdef Pack_32
	  si = *sx++;
   1388c:	00438393          	addi	t2,t2,4
   13890:	ffc3a603          	lw	a2,-4(t2)
	  ys = (si & 0xffff) * q + carry;
	  zs = (si >> 16) * q + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   13894:	00032703          	lw	a4,0(t1)
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
	  borrow = z >> 16;
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   13898:	00430313          	addi	t1,t1,4
      carry = 0;
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
   1389c:	005678b3          	and	a7,a2,t0
   138a0:	029888b3          	mul	a7,a7,s1
	  zs = (si >> 16) * q + (ys >> 16);
   138a4:	01065613          	srli	a2,a2,0x10
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   138a8:	00577833          	and	a6,a4,t0
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   138ac:	01075713          	srli	a4,a4,0x10
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
	  zs = (si >> 16) * q + (ys >> 16);
   138b0:	02960633          	mul	a2,a2,s1
      carry = 0;
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
   138b4:	00d888b3          	add	a7,a7,a3
	  zs = (si >> 16) * q + (ys >> 16);
   138b8:	0108d693          	srli	a3,a7,0x10
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   138bc:	0058f8b3          	and	a7,a7,t0
   138c0:	411787b3          	sub	a5,a5,a7
   138c4:	01078833          	add	a6,a5,a6
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   138c8:	41085893          	srai	a7,a6,0x10
	  borrow = z >> 16;
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   138cc:	00587833          	and	a6,a6,t0
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
	  zs = (si >> 16) * q + (ys >> 16);
   138d0:	00d606b3          	add	a3,a2,a3
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   138d4:	0056f7b3          	and	a5,a3,t0
   138d8:	40f70733          	sub	a4,a4,a5
   138dc:	011707b3          	add	a5,a4,a7
	  borrow = z >> 16;
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   138e0:	01079713          	slli	a4,a5,0x10
   138e4:	01076833          	or	a6,a4,a6
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
	  zs = (si >> 16) * q + (ys >> 16);
	  carry = zs >> 16;
   138e8:	0106d693          	srli	a3,a3,0x10
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
	  borrow = z >> 16;
   138ec:	4107d793          	srai	a5,a5,0x10
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   138f0:	ff032e23          	sw	a6,-4(t1)
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
   138f4:	f879fce3          	bleu	t2,s3,1388c <quorem+0x70>
      if (!*bxe)
   138f8:	000e2783          	lw	a5,0(t3)
   138fc:	02079863          	bnez	a5,1392c <quorem+0x110>
	{
	  bx = b->_x;
	  while (--bxe > bx && !*bxe)
   13900:	ffce0793          	addi	a5,t3,-4
   13904:	02fa7263          	bleu	a5,s4,13928 <quorem+0x10c>
   13908:	ffce2703          	lw	a4,-4(t3)
   1390c:	00070863          	beqz	a4,1391c <quorem+0x100>
   13910:	0180006f          	j	13928 <quorem+0x10c>
   13914:	0007a703          	lw	a4,0(a5)
   13918:	00071863          	bnez	a4,13928 <quorem+0x10c>
   1391c:	ffc78793          	addi	a5,a5,-4
	    --n;
   13920:	fff90913          	addi	s2,s2,-1
	}
      while (sx <= sxe);
      if (!*bxe)
	{
	  bx = b->_x;
	  while (--bxe > bx && !*bxe)
   13924:	fefa68e3          	bltu	s4,a5,13914 <quorem+0xf8>
	    --n;
	  b->_wds = n;
   13928:	01252823          	sw	s2,16(a0)
   1392c:	00050a93          	mv	s5,a0
	}
    }
  if (cmp (b, S) >= 0)
   13930:	4cd030ef          	jal	175fc <__mcmp>
   13934:	0a054063          	bltz	a0,139d4 <quorem+0x1b8>
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) + carry;
	  zs = (si >> 16) + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   13938:	00010837          	lui	a6,0x10
	  b->_wds = n;
	}
    }
  if (cmp (b, S) >= 0)
    {
      q++;
   1393c:	00148493          	addi	s1,s1,1
#endif
  if (b->_wds < n)
    return 0;
  sx = S->_x;
  sxe = sx + --n;
  bx = b->_x;
   13940:	000a0593          	mv	a1,s4
	}
    }
  if (cmp (b, S) >= 0)
    {
      q++;
      borrow = 0;
   13944:	00000793          	li	a5,0
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) + carry;
	  zs = (si >> 16) + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   13948:	fff80813          	addi	a6,a6,-1 # ffff <_reset+0xfdff>
      bx = b->_x;
      sx = S->_x;
      do
	{
#ifdef Pack_32
	  si = *sx++;
   1394c:	00440413          	addi	s0,s0,4
   13950:	ffc42603          	lw	a2,-4(s0)
	  ys = (si & 0xffff) + carry;
	  zs = (si >> 16) + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   13954:	0005a703          	lw	a4,0(a1)
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
	  borrow = z >> 16;
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   13958:	00458593          	addi	a1,a1,4
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) + carry;
	  zs = (si >> 16) + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   1395c:	010676b3          	and	a3,a2,a6
   13960:	40d787b3          	sub	a5,a5,a3
   13964:	010776b3          	and	a3,a4,a6
   13968:	00d786b3          	add	a3,a5,a3
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   1396c:	01075713          	srli	a4,a4,0x10
   13970:	01065793          	srli	a5,a2,0x10
   13974:	40f70733          	sub	a4,a4,a5
   13978:	4106d793          	srai	a5,a3,0x10
   1397c:	00f707b3          	add	a5,a4,a5
	  borrow = z >> 16;
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   13980:	01079713          	slli	a4,a5,0x10
   13984:	0106f6b3          	and	a3,a3,a6
   13988:	00d766b3          	or	a3,a4,a3
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
	  borrow = z >> 16;
   1398c:	4107d793          	srai	a5,a5,0x10
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   13990:	fed5ae23          	sw	a3,-4(a1)
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
   13994:	fa89fce3          	bleu	s0,s3,1394c <quorem+0x130>
      bx = b->_x;
      bxe = bx + n;
   13998:	00291713          	slli	a4,s2,0x2
   1399c:	00ea0733          	add	a4,s4,a4
      if (!*bxe)
   139a0:	00072783          	lw	a5,0(a4)
   139a4:	02079863          	bnez	a5,139d4 <quorem+0x1b8>
	{
	  while (--bxe > bx && !*bxe)
   139a8:	ffc70793          	addi	a5,a4,-4
   139ac:	02fa7263          	bleu	a5,s4,139d0 <quorem+0x1b4>
   139b0:	ffc72703          	lw	a4,-4(a4)
   139b4:	00070863          	beqz	a4,139c4 <quorem+0x1a8>
   139b8:	0180006f          	j	139d0 <quorem+0x1b4>
   139bc:	0007a703          	lw	a4,0(a5)
   139c0:	00071863          	bnez	a4,139d0 <quorem+0x1b4>
   139c4:	ffc78793          	addi	a5,a5,-4
	    --n;
   139c8:	fff90913          	addi	s2,s2,-1
      while (sx <= sxe);
      bx = b->_x;
      bxe = bx + n;
      if (!*bxe)
	{
	  while (--bxe > bx && !*bxe)
   139cc:	fefa68e3          	bltu	s4,a5,139bc <quorem+0x1a0>
	    --n;
	  b->_wds = n;
   139d0:	012aa823          	sw	s2,16(s5) # 80000010 <_gp+0x7ffe19d0>
	}
    }
  return q;
   139d4:	00048513          	mv	a0,s1
}
   139d8:	01c12083          	lw	ra,28(sp)
   139dc:	01812403          	lw	s0,24(sp)
   139e0:	01412483          	lw	s1,20(sp)
   139e4:	01012903          	lw	s2,16(sp)
   139e8:	00c12983          	lw	s3,12(sp)
   139ec:	00812a03          	lw	s4,8(sp)
   139f0:	00412a83          	lw	s5,4(sp)
   139f4:	02010113          	addi	sp,sp,32
   139f8:	00008067          	ret
#ifdef DEBUG
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
    return 0;
   139fc:	00000513          	li	a0,0
   13a00:	fd9ff06f          	j	139d8 <quorem+0x1bc>

00013a04 <_dtoa_r>:
  char *s, *s0;

  d.d = _d;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
   13a04:	04052283          	lw	t0,64(a0)
	int mode _AND
	int ndigits _AND
	int *decpt _AND
	int *sign _AND
	char **rve)
{
   13a08:	f6010113          	addi	sp,sp,-160
   13a0c:	08812c23          	sw	s0,152(sp)
   13a10:	09212823          	sw	s2,144(sp)
   13a14:	09312623          	sw	s3,140(sp)
   13a18:	07712e23          	sw	s7,124(sp)
   13a1c:	07b12623          	sw	s11,108(sp)
   13a20:	08112e23          	sw	ra,156(sp)
   13a24:	08912a23          	sw	s1,148(sp)
   13a28:	09412423          	sw	s4,136(sp)
   13a2c:	09512223          	sw	s5,132(sp)
   13a30:	09612023          	sw	s6,128(sp)
   13a34:	07812c23          	sw	s8,120(sp)
   13a38:	07912a23          	sw	s9,116(sp)
   13a3c:	07a12823          	sw	s10,112(sp)
   13a40:	00050413          	mv	s0,a0
   13a44:	00070d93          	mv	s11,a4
   13a48:	00078b93          	mv	s7,a5
   13a4c:	01012a23          	sw	a6,20(sp)
#endif
  _Bigint *b, *b1, *delta, *mlo = NULL, *mhi, *S;
  double ds;
  char *s, *s0;

  d.d = _d;
   13a50:	00060913          	mv	s2,a2
   13a54:	00068993          	mv	s3,a3

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
   13a58:	02028663          	beqz	t0,13a84 <_dtoa_r+0x80>
    {
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
   13a5c:	04452703          	lw	a4,68(a0)
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
   13a60:	00100793          	li	a5,1
      Bfree (ptr, _REENT_MP_RESULT(ptr));
   13a64:	00028593          	mv	a1,t0

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
    {
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
   13a68:	00e797b3          	sll	a5,a5,a4
  d.d = _d;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
    {
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
   13a6c:	00e2a223          	sw	a4,4(t0)
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
   13a70:	00f2a423          	sw	a5,8(t0)
      Bfree (ptr, _REENT_MP_RESULT(ptr));
   13a74:	01112423          	sw	a7,8(sp)
   13a78:	374030ef          	jal	16dec <_Bfree>
      _REENT_MP_RESULT(ptr) = 0;
   13a7c:	00812883          	lw	a7,8(sp)
   13a80:	04042023          	sw	zero,64(s0)
    }

  if (word0 (d) & Sign_bit)
   13a84:	00098b13          	mv	s6,s3
   13a88:	0c09c863          	bltz	s3,13b58 <_dtoa_r+0x154>
      /* set sign for everything, including 0's and NaNs */
      *sign = 1;
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
    }
  else
    *sign = 0;
   13a8c:	0008a023          	sw	zero,0(a7)

#if defined(IEEE_Arith) + defined(VAX)
#ifdef IEEE_Arith
  if ((word0 (d) & Exp_mask) == Exp_mask)
   13a90:	7ff007b7          	lui	a5,0x7ff00
   13a94:	00fb7733          	and	a4,s6,a5
   13a98:	08f70063          	beq	a4,a5,13b18 <_dtoa_r+0x114>
    }
#endif
#ifdef IBM
  d.d += 0;			/* normalize */
#endif
  if (!d.d)
   13a9c:	00000613          	li	a2,0
   13aa0:	00000693          	li	a3,0
   13aa4:	00090513          	mv	a0,s2
   13aa8:	00098593          	mv	a1,s3
   13aac:	154070ef          	jal	1ac00 <__eqdf2>
   13ab0:	0c051263          	bnez	a0,13b74 <_dtoa_r+0x170>
    {
      *decpt = 1;
   13ab4:	01412583          	lw	a1,20(sp)
      s = "0";
      if (rve)
   13ab8:	0a012603          	lw	a2,160(sp)
#ifdef IBM
  d.d += 0;			/* normalize */
#endif
  if (!d.d)
    {
      *decpt = 1;
   13abc:	00100793          	li	a5,1
   13ac0:	00f5a023          	sw	a5,0(a1)
      s = "0";
      if (rve)
   13ac4:	62060863          	beqz	a2,140f4 <_dtoa_r+0x6f0>
	*rve = s + 1;
   13ac8:	0001c7b7          	lui	a5,0x1c
   13acc:	16578793          	addi	a5,a5,357 # 1c165 <__thenan_sf+0x55>
      return s;
   13ad0:	0001c537          	lui	a0,0x1c
  if (!d.d)
    {
      *decpt = 1;
      s = "0";
      if (rve)
	*rve = s + 1;
   13ad4:	00f62023          	sw	a5,0(a2)
      return s;
   13ad8:	16450513          	addi	a0,a0,356 # 1c164 <__thenan_sf+0x54>
  *s = 0;
  *decpt = k + 1;
  if (rve)
    *rve = s;
  return s0;
}
   13adc:	09c12083          	lw	ra,156(sp)
   13ae0:	09812403          	lw	s0,152(sp)
   13ae4:	09412483          	lw	s1,148(sp)
   13ae8:	09012903          	lw	s2,144(sp)
   13aec:	08c12983          	lw	s3,140(sp)
   13af0:	08812a03          	lw	s4,136(sp)
   13af4:	08412a83          	lw	s5,132(sp)
   13af8:	08012b03          	lw	s6,128(sp)
   13afc:	07c12b83          	lw	s7,124(sp)
   13b00:	07812c03          	lw	s8,120(sp)
   13b04:	07412c83          	lw	s9,116(sp)
   13b08:	07012d03          	lw	s10,112(sp)
   13b0c:	06c12d83          	lw	s11,108(sp)
   13b10:	0a010113          	addi	sp,sp,160
   13b14:	00008067          	ret
#else
  if (word0 (d) == 0x8000)
#endif
    {
      /* Infinity or NaN */
      *decpt = 9999;
   13b18:	01412583          	lw	a1,20(sp)
   13b1c:	000027b7          	lui	a5,0x2
   13b20:	70f78793          	addi	a5,a5,1807 # 270f <_reset+0x250f>
   13b24:	00f5a023          	sw	a5,0(a1)
      s =
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
   13b28:	56090663          	beqz	s2,14094 <_dtoa_r+0x690>
   13b2c:	0001c537          	lui	a0,0x1c
   13b30:	17450513          	addi	a0,a0,372 # 1c174 <__thenan_sf+0x64>
#endif
	"NaN";
      if (rve)
   13b34:	0a012683          	lw	a3,160(sp)
   13b38:	fa0682e3          	beqz	a3,13adc <_dtoa_r+0xd8>
	*rve =
#ifdef IEEE_Arith
	  s[3] ? s + 8 :
   13b3c:	00354703          	lbu	a4,3(a0)
   13b40:	00350793          	addi	a5,a0,3
   13b44:	00070463          	beqz	a4,13b4c <_dtoa_r+0x148>
   13b48:	00850793          	addi	a5,a0,8
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
#endif
	"NaN";
      if (rve)
	*rve =
   13b4c:	0a012703          	lw	a4,160(sp)
   13b50:	00f72023          	sw	a5,0(a4)
   13b54:	f89ff06f          	j	13adc <_dtoa_r+0xd8>

  if (word0 (d) & Sign_bit)
    {
      /* set sign for everything, including 0's and NaNs */
      *sign = 1;
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
   13b58:	80000b37          	lui	s6,0x80000
   13b5c:	fffb4b13          	not	s6,s6
   13b60:	013b7b33          	and	s6,s6,s3
    }

  if (word0 (d) & Sign_bit)
    {
      /* set sign for everything, including 0's and NaNs */
      *sign = 1;
   13b64:	00100793          	li	a5,1
   13b68:	00f8a023          	sw	a5,0(a7)
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
   13b6c:	000b0993          	mv	s3,s6
   13b70:	f21ff06f          	j	13a90 <_dtoa_r+0x8c>
      if (rve)
	*rve = s + 1;
      return s;
    }

  b = d2b (ptr, d.d, &be, &bbits);
   13b74:	05810793          	addi	a5,sp,88
   13b78:	05c10713          	addi	a4,sp,92
   13b7c:	00090613          	mv	a2,s2
   13b80:	00098693          	mv	a3,s3
   13b84:	00040513          	mv	a0,s0
   13b88:	671030ef          	jal	179f8 <__d2b>
#ifdef Sudden_Underflow
  i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1));
#else
  if ((i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1))) != 0)
   13b8c:	014b5493          	srli	s1,s6,0x14
      if (rve)
	*rve = s + 1;
      return s;
    }

  b = d2b (ptr, d.d, &be, &bbits);
   13b90:	00a12e23          	sw	a0,28(sp)
#ifdef Sudden_Underflow
  i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1));
#else
  if ((i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1))) != 0)
   13b94:	50048a63          	beqz	s1,140a8 <_dtoa_r+0x6a4>
    {
#endif
      d2.d = d.d;
      word0 (d2) &= Frac_mask1;
      word0 (d2) |= Exp_11;
   13b98:	001007b7          	lui	a5,0x100
   13b9c:	fff78793          	addi	a5,a5,-1 # fffff <_gp+0xe19bf>
   13ba0:	05812c83          	lw	s9,88(sp)
   13ba4:	00f9f7b3          	and	a5,s3,a5
   13ba8:	3ff00737          	lui	a4,0x3ff00
  i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1));
#else
  if ((i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1))) != 0)
    {
#endif
      d2.d = d.d;
   13bac:	00090513          	mv	a0,s2
      word0 (d2) &= Frac_mask1;
      word0 (d2) |= Exp_11;
   13bb0:	00e7e5b3          	or	a1,a5,a4
		 * Hence we adjust the constant term to 0.1760912590558.
		 * (We could get a more accurate k by invoking log10,
		 *  but this is probably not worthwhile.)
		 */

      i -= Bias;
   13bb4:	c0148493          	addi	s1,s1,-1023
#ifdef IBM
      i <<= 2;
      i += j;
#endif
#ifndef Sudden_Underflow
      denorm = 0;
   13bb8:	04012423          	sw	zero,72(sp)
    }
#endif
#if defined (_DOUBLE_IS_32BITS)
  ds = (d2.d - 1.5) * 0.289529651 + 0.176091269 + i * 0.30103001;
#else
  ds = (d2.d - 1.5) * 0.289529654602168 + 0.1760912590558 + i * 0.301029995663981;
   13bbc:	8281a603          	lw	a2,-2008(gp) # 1de68 <__wctomb+0x8>
   13bc0:	82c1a683          	lw	a3,-2004(gp) # 1de6c <__wctomb+0xc>
   13bc4:	1e1060ef          	jal	1a5a4 <__subdf3>
   13bc8:	8301a603          	lw	a2,-2000(gp) # 1de70 <__wctomb+0x10>
   13bcc:	8341a683          	lw	a3,-1996(gp) # 1de74 <__wctomb+0x14>
   13bd0:	231060ef          	jal	1a600 <__muldf3>
   13bd4:	8381a603          	lw	a2,-1992(gp) # 1de78 <__wctomb+0x18>
   13bd8:	83c1a683          	lw	a3,-1988(gp) # 1de7c <__wctomb+0x1c>
   13bdc:	179060ef          	jal	1a554 <__adddf3>
   13be0:	00050a13          	mv	s4,a0
   13be4:	00048513          	mv	a0,s1
   13be8:	00058a93          	mv	s5,a1
   13bec:	068070ef          	jal	1ac54 <__floatsidf>
   13bf0:	8401a603          	lw	a2,-1984(gp) # 1de80 <__wctomb+0x20>
   13bf4:	8441a683          	lw	a3,-1980(gp) # 1de84 <__wctomb+0x24>
   13bf8:	209060ef          	jal	1a600 <__muldf3>
   13bfc:	00050613          	mv	a2,a0
   13c00:	00058693          	mv	a3,a1
   13c04:	000a0513          	mv	a0,s4
   13c08:	000a8593          	mv	a1,s5
   13c0c:	149060ef          	jal	1a554 <__adddf3>
   13c10:	00050a13          	mv	s4,a0
   13c14:	00058a93          	mv	s5,a1
#endif
  k = (int) ds;
   13c18:	184070ef          	jal	1ad9c <__fixdfsi>
   13c1c:	00a12823          	sw	a0,16(sp)
  if (ds < 0. && ds != k)
   13c20:	00000613          	li	a2,0
   13c24:	00000693          	li	a3,0
   13c28:	000a0513          	mv	a0,s4
   13c2c:	000a8593          	mv	a1,s5
   13c30:	7c9060ef          	jal	1abf8 <__ltdf2>
   13c34:	02054ae3          	bltz	a0,14468 <_dtoa_r+0xa64>
    k--;			/* want k = floor(ds) */
  k_check = 1;
   13c38:	00100713          	li	a4,1
   13c3c:	02e12223          	sw	a4,36(sp)
  if (k >= 0 && k <= Ten_pmax)
   13c40:	01012703          	lw	a4,16(sp)
   13c44:	01600793          	li	a5,22
   13c48:	02e7ee63          	bltu	a5,a4,13c84 <_dtoa_r+0x280>
    {
      if (d.d < tens[k])
   13c4c:	00371793          	slli	a5,a4,0x3
   13c50:	0001c737          	lui	a4,0x1c
   13c54:	e5870713          	addi	a4,a4,-424 # 1be58 <__mprec_tens>
   13c58:	00e787b3          	add	a5,a5,a4
   13c5c:	0007a503          	lw	a0,0(a5)
   13c60:	0047a583          	lw	a1,4(a5)
   13c64:	00090613          	mv	a2,s2
   13c68:	00098693          	mv	a3,s3
   13c6c:	72d060ef          	jal	1ab98 <__gtdf2>
   13c70:	04a058e3          	blez	a0,144c0 <_dtoa_r+0xabc>
	k--;
   13c74:	01012783          	lw	a5,16(sp)
      k_check = 0;
   13c78:	02012223          	sw	zero,36(sp)
    k--;			/* want k = floor(ds) */
  k_check = 1;
  if (k >= 0 && k <= Ten_pmax)
    {
      if (d.d < tens[k])
	k--;
   13c7c:	fff78793          	addi	a5,a5,-1
   13c80:	00f12823          	sw	a5,16(sp)
      k_check = 0;
    }
  j = bbits - i - 1;
   13c84:	409c8cb3          	sub	s9,s9,s1
   13c88:	fffc8c93          	addi	s9,s9,-1
   13c8c:	01912623          	sw	s9,12(sp)
  if (j >= 0)
    {
      b2 = 0;
   13c90:	00000a93          	li	s5,0
      if (d.d < tens[k])
	k--;
      k_check = 0;
    }
  j = bbits - i - 1;
  if (j >= 0)
   13c94:	000cc2e3          	bltz	s9,14498 <_dtoa_r+0xa94>
  else
    {
      b2 = -j;
      s2 = 0;
    }
  if (k >= 0)
   13c98:	01012703          	lw	a4,16(sp)
   13c9c:	7a074c63          	bltz	a4,14454 <_dtoa_r+0xa50>
    {
      b5 = 0;
      s5 = k;
      s2 += k;
   13ca0:	00c12783          	lw	a5,12(sp)
   13ca4:	02e12423          	sw	a4,40(sp)
      b2 = -j;
      s2 = 0;
    }
  if (k >= 0)
    {
      b5 = 0;
   13ca8:	00000b13          	li	s6,0
      s5 = k;
      s2 += k;
   13cac:	00e787b3          	add	a5,a5,a4
   13cb0:	00f12623          	sw	a5,12(sp)
    {
      b2 -= k;
      b5 = -k;
      s5 = 0;
    }
  if (mode < 0 || mode > 9)
   13cb4:	00900793          	li	a5,9
   13cb8:	45b7e463          	bltu	a5,s11,14100 <_dtoa_r+0x6fc>
    mode = 0;
  try_quick = 1;
  if (mode > 5)
   13cbc:	00500793          	li	a5,5
      b5 = -k;
      s5 = 0;
    }
  if (mode < 0 || mode > 9)
    mode = 0;
  try_quick = 1;
   13cc0:	00100a13          	li	s4,1
  if (mode > 5)
   13cc4:	01b7d663          	ble	s11,a5,13cd0 <_dtoa_r+0x2cc>
    {
      mode -= 4;
   13cc8:	ffcd8d93          	addi	s11,s11,-4
      try_quick = 0;
   13ccc:	00000a13          	li	s4,0
    }
  leftright = 1;
  ilim = ilim1 = -1;
  switch (mode)
   13cd0:	00300793          	li	a5,3
   13cd4:	50fd8ae3          	beq	s11,a5,149e8 <_dtoa_r+0xfe4>
   13cd8:	47b7dce3          	ble	s11,a5,14950 <_dtoa_r+0xf4c>
   13cdc:	00400793          	li	a5,4
   13ce0:	32fd84e3          	beq	s11,a5,14808 <_dtoa_r+0xe04>
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   13ce4:	00100713          	li	a4,1
  ilim = ilim1 = -1;
  switch (mode)
   13ce8:	00500793          	li	a5,5
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   13cec:	02e12023          	sw	a4,32(sp)
  ilim = ilim1 = -1;
  switch (mode)
   13cf0:	46fd96e3          	bne	s11,a5,1495c <_dtoa_r+0xf58>
      break;
    case 3:
      leftright = 0;
      /* no break */
    case 5:
      i = ndigits + k + 1;
   13cf4:	01012703          	lw	a4,16(sp)
   13cf8:	01770733          	add	a4,a4,s7
   13cfc:	00170793          	addi	a5,a4,1
   13d00:	02e12623          	sw	a4,44(sp)
   13d04:	00f12c23          	sw	a5,24(sp)
   13d08:	00078613          	mv	a2,a5
      ilim = i;
      ilim1 = i - 1;
      if (i <= 0)
   13d0c:	00078493          	mv	s1,a5
   13d10:	42f05ae3          	blez	a5,14944 <_dtoa_r+0xf40>
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   13d14:	01700793          	li	a5,23
   13d18:	04042223          	sw	zero,68(s0)
   13d1c:	00000593          	li	a1,0
   13d20:	02c7f263          	bleu	a2,a5,13d44 <_dtoa_r+0x340>
   13d24:	00100713          	li	a4,1
   13d28:	00400793          	li	a5,4
       j <<= 1)
   13d2c:	00179793          	slli	a5,a5,0x1
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   13d30:	01478693          	addi	a3,a5,20
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
   13d34:	00070593          	mv	a1,a4
   13d38:	00170713          	addi	a4,a4,1
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   13d3c:	fed678e3          	bleu	a3,a2,13d2c <_dtoa_r+0x328>
   13d40:	04b42223          	sw	a1,68(s0)
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   13d44:	00040513          	mv	a0,s0
   13d48:	000030ef          	jal	16d48 <_Balloc>
  s = s0 = (char *) _REENT_MP_RESULT(ptr);

  if (ilim >= 0 && ilim <= Quick_max && try_quick)
   13d4c:	00e00793          	li	a5,14
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   13d50:	00050d13          	mv	s10,a0
   13d54:	04a42023          	sw	a0,64(s0)
  s = s0 = (char *) _REENT_MP_RESULT(ptr);

  if (ilim >= 0 && ilim <= Quick_max && try_quick)
   13d58:	3c97ee63          	bltu	a5,s1,14134 <_dtoa_r+0x730>
   13d5c:	3c0a0c63          	beqz	s4,14134 <_dtoa_r+0x730>
      i = 0;
      d2.d = d.d;
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
      if (k > 0)
   13d60:	01012703          	lw	a4,16(sp)
  if (ilim >= 0 && ilim <= Quick_max && try_quick)
    {
      /* Try to get by with floating-point arithmetic. */

      i = 0;
      d2.d = d.d;
   13d64:	03212823          	sw	s2,48(sp)
   13d68:	03312a23          	sw	s3,52(sp)
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
      if (k > 0)
   13d6c:	58e056e3          	blez	a4,14af8 <_dtoa_r+0x10f4>
	{
	  ds = tens[k & 0xf];
   13d70:	00f77793          	andi	a5,a4,15
   13d74:	00379713          	slli	a4,a5,0x3
	  j = k >> 4;
   13d78:	01012783          	lw	a5,16(sp)

      i = 0;
      d2.d = d.d;
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
   13d7c:	00200493          	li	s1,2
      if (k > 0)
	{
	  ds = tens[k & 0xf];
	  j = k >> 4;
   13d80:	4047da13          	srai	s4,a5,0x4
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
      if (k > 0)
	{
	  ds = tens[k & 0xf];
   13d84:	0001c7b7          	lui	a5,0x1c
   13d88:	e5878793          	addi	a5,a5,-424 # 1be58 <__mprec_tens>
   13d8c:	00f707b3          	add	a5,a4,a5
	  j = k >> 4;
	  if (j & Bletch)
   13d90:	010a7693          	andi	a3,s4,16
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
      if (k > 0)
	{
	  ds = tens[k & 0xf];
   13d94:	0007a703          	lw	a4,0(a5)
   13d98:	0047a783          	lw	a5,4(a5)
	  j = k >> 4;
	  if (j & Bletch)
   13d9c:	02068e63          	beqz	a3,13dd8 <_dtoa_r+0x3d4>
	    {
	      /* prevent overflows */
	      j &= Bletch - 1;
	      d.d /= bigtens[n_bigtens - 1];
   13da0:	0001c6b7          	lui	a3,0x1c
   13da4:	f686a603          	lw	a2,-152(a3) # 1bf68 <__mprec_bigtens+0x20>
   13da8:	f6c6a683          	lw	a3,-148(a3)
   13dac:	00090513          	mv	a0,s2
   13db0:	00098593          	mv	a1,s3
   13db4:	00e12423          	sw	a4,8(sp)
   13db8:	00f12223          	sw	a5,4(sp)
   13dbc:	2a9060ef          	jal	1a864 <__divdf3>
	      ieps++;
   13dc0:	00412783          	lw	a5,4(sp)
   13dc4:	00812703          	lw	a4,8(sp)
	  ds = tens[k & 0xf];
	  j = k >> 4;
	  if (j & Bletch)
	    {
	      /* prevent overflows */
	      j &= Bletch - 1;
   13dc8:	00fa7a13          	andi	s4,s4,15
	      d.d /= bigtens[n_bigtens - 1];
   13dcc:	00050913          	mv	s2,a0
   13dd0:	00058993          	mv	s3,a1
	      ieps++;
   13dd4:	00300493          	li	s1,3
	    }
	  for (; j; j >>= 1, i++)
   13dd8:	040a0063          	beqz	s4,13e18 <_dtoa_r+0x414>
   13ddc:	0001cc37          	lui	s8,0x1c
   13de0:	f48c0c13          	addi	s8,s8,-184 # 1bf48 <__mprec_bigtens>
	    if (j & 1)
   13de4:	001a7693          	andi	a3,s4,1
	      {
		ieps++;
		ds *= bigtens[i];
   13de8:	00070513          	mv	a0,a4
	      /* prevent overflows */
	      j &= Bletch - 1;
	      d.d /= bigtens[n_bigtens - 1];
	      ieps++;
	    }
	  for (; j; j >>= 1, i++)
   13dec:	401a5a13          	srai	s4,s4,0x1
	    if (j & 1)
	      {
		ieps++;
		ds *= bigtens[i];
   13df0:	00078593          	mv	a1,a5
	      j &= Bletch - 1;
	      d.d /= bigtens[n_bigtens - 1];
	      ieps++;
	    }
	  for (; j; j >>= 1, i++)
	    if (j & 1)
   13df4:	00068e63          	beqz	a3,13e10 <_dtoa_r+0x40c>
	      {
		ieps++;
		ds *= bigtens[i];
   13df8:	000c2603          	lw	a2,0(s8)
   13dfc:	004c2683          	lw	a3,4(s8)
	      ieps++;
	    }
	  for (; j; j >>= 1, i++)
	    if (j & 1)
	      {
		ieps++;
   13e00:	00148493          	addi	s1,s1,1
		ds *= bigtens[i];
   13e04:	7fc060ef          	jal	1a600 <__muldf3>
   13e08:	00050713          	mv	a4,a0
   13e0c:	00058793          	mv	a5,a1
   13e10:	008c0c13          	addi	s8,s8,8
	      /* prevent overflows */
	      j &= Bletch - 1;
	      d.d /= bigtens[n_bigtens - 1];
	      ieps++;
	    }
	  for (; j; j >>= 1, i++)
   13e14:	fc0a18e3          	bnez	s4,13de4 <_dtoa_r+0x3e0>
	    if (j & 1)
	      {
		ieps++;
		ds *= bigtens[i];
	      }
	  d.d /= ds;
   13e18:	00090513          	mv	a0,s2
   13e1c:	00098593          	mv	a1,s3
   13e20:	00070613          	mv	a2,a4
   13e24:	00078693          	mv	a3,a5
   13e28:	23d060ef          	jal	1a864 <__divdf3>
   13e2c:	00050913          	mv	s2,a0
   13e30:	00058993          	mv	s3,a1
	      {
		ieps++;
		d.d *= bigtens[i];
	      }
	}
      if (k_check && d.d < 1. && ilim > 0)
   13e34:	02412783          	lw	a5,36(sp)
   13e38:	02078063          	beqz	a5,13e58 <_dtoa_r+0x454>
   13e3c:	8481a603          	lw	a2,-1976(gp) # 1de88 <__wctomb+0x28>
   13e40:	84c1a683          	lw	a3,-1972(gp) # 1de8c <__wctomb+0x2c>
   13e44:	00090513          	mv	a0,s2
   13e48:	00098593          	mv	a1,s3
   13e4c:	5ad060ef          	jal	1abf8 <__ltdf2>
   13e50:	00055463          	bgez	a0,13e58 <_dtoa_r+0x454>
   13e54:	7650006f          	j	14db8 <_dtoa_r+0x13b4>
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   13e58:	00048513          	mv	a0,s1
   13e5c:	5f9060ef          	jal	1ac54 <__floatsidf>
   13e60:	00090613          	mv	a2,s2
   13e64:	00098693          	mv	a3,s3
   13e68:	798060ef          	jal	1a600 <__muldf3>
   13e6c:	85c1a683          	lw	a3,-1956(gp) # 1de9c <__wctomb+0x3c>
   13e70:	8581a603          	lw	a2,-1960(gp) # 1de98 <__wctomb+0x38>
   13e74:	6e0060ef          	jal	1a554 <__adddf3>
      word0 (eps) -= (P - 1) * Exp_msk1;
   13e78:	fcc006b7          	lui	a3,0xfcc00
   13e7c:	00b687b3          	add	a5,a3,a1
      if (ilim == 0)
   13e80:	01812583          	lw	a1,24(sp)
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   13e84:	00050713          	mv	a4,a0
      word0 (eps) -= (P - 1) * Exp_msk1;
      if (ilim == 0)
   13e88:	3a0586e3          	beqz	a1,14a34 <_dtoa_r+0x1030>
   13e8c:	01012603          	lw	a2,16(sp)
   13e90:	01812483          	lw	s1,24(sp)
   13e94:	04c12623          	sw	a2,76(sp)
	  if (d.d < -eps.d)
	    goto no_digits;
	  goto fast_failed;
	}
#ifndef No_leftright
      if (leftright)
   13e98:	02012683          	lw	a3,32(sp)
   13e9c:	54068ae3          	beqz	a3,14bf0 <_dtoa_r+0x11ec>
	{
	  /* Use Steele & White method of only
	   * generating digits needed.
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
   13ea0:	fff48693          	addi	a3,s1,-1
   13ea4:	00369613          	slli	a2,a3,0x3
   13ea8:	0001c6b7          	lui	a3,0x1c
   13eac:	e5868693          	addi	a3,a3,-424 # 1be58 <__mprec_tens>
   13eb0:	00d606b3          	add	a3,a2,a3
   13eb4:	0006a603          	lw	a2,0(a3)
   13eb8:	8681a503          	lw	a0,-1944(gp) # 1dea8 <__wctomb+0x48>
   13ebc:	0046a683          	lw	a3,4(a3)
   13ec0:	86c1a583          	lw	a1,-1940(gp) # 1deac <__wctomb+0x4c>
   13ec4:	00e12423          	sw	a4,8(sp)
   13ec8:	00f12223          	sw	a5,4(sp)
   13ecc:	199060ef          	jal	1a864 <__divdf3>
   13ed0:	00812703          	lw	a4,8(sp)
   13ed4:	00412783          	lw	a5,4(sp)
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
   13ed8:	001d0c93          	addi	s9,s10,1
      if (leftright)
	{
	  /* Use Steele & White method of only
	   * generating digits needed.
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
   13edc:	00070613          	mv	a2,a4
   13ee0:	00078693          	mv	a3,a5
   13ee4:	6c0060ef          	jal	1a5a4 <__subdf3>
   13ee8:	02a12c23          	sw	a0,56(sp)
   13eec:	02b12e23          	sw	a1,60(sp)
	  for (i = 0;;)
	    {
	      L = d.d;
   13ef0:	00090513          	mv	a0,s2
   13ef4:	00098593          	mv	a1,s3
   13ef8:	6a5060ef          	jal	1ad9c <__fixdfsi>
   13efc:	00050a13          	mv	s4,a0
	      d.d -= L;
   13f00:	555060ef          	jal	1ac54 <__floatsidf>
   13f04:	00050613          	mv	a2,a0
   13f08:	00058693          	mv	a3,a1
   13f0c:	00090513          	mv	a0,s2
   13f10:	00098593          	mv	a1,s3
   13f14:	690060ef          	jal	1a5a4 <__subdf3>
   13f18:	00050913          	mv	s2,a0
   13f1c:	00058993          	mv	s3,a1
	      *s++ = '0' + (int) L;
   13f20:	030a0a13          	addi	s4,s4,48
	      if (d.d < eps.d)
   13f24:	00050613          	mv	a2,a0
   13f28:	00058693          	mv	a3,a1
   13f2c:	03812503          	lw	a0,56(sp)
   13f30:	03c12583          	lw	a1,60(sp)
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
   13f34:	0ffa7a13          	andi	s4,s4,255
   13f38:	014d0023          	sb	s4,0(s10)
	      if (d.d < eps.d)
   13f3c:	45d060ef          	jal	1ab98 <__gtdf2>
   13f40:	00a05463          	blez	a0,13f48 <_dtoa_r+0x544>
   13f44:	72d0006f          	j	14e70 <_dtoa_r+0x146c>
		goto ret1;
	      if (1. - d.d < eps.d)
   13f48:	8481a503          	lw	a0,-1976(gp) # 1de88 <__wctomb+0x28>
   13f4c:	84c1a583          	lw	a1,-1972(gp) # 1de8c <__wctomb+0x2c>
   13f50:	00090613          	mv	a2,s2
   13f54:	00098693          	mv	a3,s3
   13f58:	00f12223          	sw	a5,4(sp)
   13f5c:	648060ef          	jal	1a5a4 <__subdf3>
   13f60:	00050613          	mv	a2,a0
   13f64:	00058693          	mv	a3,a1
   13f68:	03812503          	lw	a0,56(sp)
   13f6c:	03c12583          	lw	a1,60(sp)
   13f70:	429060ef          	jal	1ab98 <__gtdf2>
   13f74:	00a05463          	blez	a0,13f7c <_dtoa_r+0x578>
   13f78:	7610006f          	j	14ed8 <_dtoa_r+0x14d4>
		goto bump_up;
	      if (++i >= ilim)
   13f7c:	00100713          	li	a4,1
   13f80:	369756e3          	ble	s1,a4,14aec <_dtoa_r+0x10e8>
		break;
	      eps.d *= 10.;
	      d.d *= 10.;
   13f84:	05512023          	sw	s5,64(sp)
   13f88:	009d04b3          	add	s1,s10,s1
   13f8c:	000c8a93          	mv	s5,s9
   13f90:	03812c03          	lw	s8,56(sp)
   13f94:	03c12c83          	lw	s9,60(sp)
   13f98:	02c0006f          	j	13fc4 <_dtoa_r+0x5c0>
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
	      if (d.d < eps.d)
		goto ret1;
	      if (1. - d.d < eps.d)
   13f9c:	84818713          	addi	a4,gp,-1976 # 1de88 <__wctomb+0x28>
   13fa0:	00072503          	lw	a0,0(a4)
   13fa4:	00472583          	lw	a1,4(a4)
   13fa8:	5fc060ef          	jal	1a5a4 <__subdf3>
   13fac:	000c0613          	mv	a2,s8
   13fb0:	000c8693          	mv	a3,s9
   13fb4:	445060ef          	jal	1abf8 <__ltdf2>
   13fb8:	00055463          	bgez	a0,13fc0 <_dtoa_r+0x5bc>
   13fbc:	6c10006f          	j	14e7c <_dtoa_r+0x1478>
		goto bump_up;
	      if (++i >= ilim)
   13fc0:	329a84e3          	beq	s5,s1,14ae8 <_dtoa_r+0x10e4>
		break;
	      eps.d *= 10.;
   13fc4:	85018793          	addi	a5,gp,-1968 # 1de90 <__wctomb+0x30>
   13fc8:	0007a603          	lw	a2,0(a5)
   13fcc:	0047a683          	lw	a3,4(a5)
   13fd0:	000c0513          	mv	a0,s8
   13fd4:	000c8593          	mv	a1,s9
   13fd8:	628060ef          	jal	1a600 <__muldf3>
   13fdc:	00058c93          	mv	s9,a1
	      d.d *= 10.;
   13fe0:	85018593          	addi	a1,gp,-1968 # 1de90 <__wctomb+0x30>
   13fe4:	0005a603          	lw	a2,0(a1)
   13fe8:	0045a683          	lw	a3,4(a1)
		goto ret1;
	      if (1. - d.d < eps.d)
		goto bump_up;
	      if (++i >= ilim)
		break;
	      eps.d *= 10.;
   13fec:	00050c13          	mv	s8,a0
	      d.d *= 10.;
   13ff0:	00098593          	mv	a1,s3
   13ff4:	00090513          	mv	a0,s2
   13ff8:	608060ef          	jal	1a600 <__muldf3>
   13ffc:	00058993          	mv	s3,a1
   14000:	00050913          	mv	s2,a0
	   * generating digits needed.
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
	  for (i = 0;;)
	    {
	      L = d.d;
   14004:	599060ef          	jal	1ad9c <__fixdfsi>
   14008:	00050a13          	mv	s4,a0
	      d.d -= L;
   1400c:	449060ef          	jal	1ac54 <__floatsidf>
   14010:	00050613          	mv	a2,a0
   14014:	00058693          	mv	a3,a1
   14018:	00090513          	mv	a0,s2
   1401c:	00098593          	mv	a1,s3
   14020:	584060ef          	jal	1a5a4 <__subdf3>
	      *s++ = '0' + (int) L;
   14024:	030a0793          	addi	a5,s4,48
   14028:	0ff7fa13          	andi	s4,a5,255
   1402c:	001a8a93          	addi	s5,s5,1
	      if (d.d < eps.d)
   14030:	000c0613          	mv	a2,s8
   14034:	000c8693          	mv	a3,s9
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
   14038:	ff4a8fa3          	sb	s4,-1(s5)
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
   1403c:	00050913          	mv	s2,a0
   14040:	00058993          	mv	s3,a1
	      *s++ = '0' + (int) L;
	      if (d.d < eps.d)
   14044:	3b5060ef          	jal	1abf8 <__ltdf2>
		goto ret1;
	      if (1. - d.d < eps.d)
   14048:	00090613          	mv	a2,s2
   1404c:	00098693          	mv	a3,s3
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
	      if (d.d < eps.d)
   14050:	f40556e3          	bgez	a0,13f9c <_dtoa_r+0x598>
   14054:	04c12703          	lw	a4,76(sp)
   14058:	000a8c93          	mv	s9,s5
   1405c:	00e12823          	sw	a4,16(sp)
      if (mlo && mlo != mhi)
	Bfree (ptr, mlo);
      Bfree (ptr, mhi);
    }
ret1:
  Bfree (ptr, b);
   14060:	01c12583          	lw	a1,28(sp)
   14064:	00040513          	mv	a0,s0
   14068:	585020ef          	jal	16dec <_Bfree>
  *s = 0;
  *decpt = k + 1;
   1406c:	01012703          	lw	a4,16(sp)
   14070:	01412583          	lw	a1,20(sp)
  if (rve)
   14074:	0a012603          	lw	a2,160(sp)
      Bfree (ptr, mhi);
    }
ret1:
  Bfree (ptr, b);
  *s = 0;
  *decpt = k + 1;
   14078:	00170793          	addi	a5,a4,1
	Bfree (ptr, mlo);
      Bfree (ptr, mhi);
    }
ret1:
  Bfree (ptr, b);
  *s = 0;
   1407c:	000c8023          	sb	zero,0(s9)
  *decpt = k + 1;
   14080:	00f5a023          	sw	a5,0(a1)
  if (rve)
   14084:	22060ae3          	beqz	a2,14ab8 <_dtoa_r+0x10b4>
    *rve = s;
   14088:	01962023          	sw	s9,0(a2)
   1408c:	000d0513          	mv	a0,s10
   14090:	a4dff06f          	j	13adc <_dtoa_r+0xd8>
    {
      /* Infinity or NaN */
      *decpt = 9999;
      s =
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
   14094:	00cb1613          	slli	a2,s6,0xc
   14098:	a8061ae3          	bnez	a2,13b2c <_dtoa_r+0x128>
   1409c:	0001c537          	lui	a0,0x1c
   140a0:	16850513          	addi	a0,a0,360 # 1c168 <__thenan_sf+0x58>
   140a4:	a91ff06f          	j	13b34 <_dtoa_r+0x130>
    }
  else
    {
      /* d is denormalized */

      i = bbits + be + (Bias + (P - 1) - 1);
   140a8:	05812c83          	lw	s9,88(sp)
   140ac:	05c12483          	lw	s1,92(sp)
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
       : (word1 (d) << (32 - i));
   140b0:	02000793          	li	a5,32
    }
  else
    {
      /* d is denormalized */

      i = bbits + be + (Bias + (P - 1) - 1);
   140b4:	009c84b3          	add	s1,s9,s1
   140b8:	43248713          	addi	a4,s1,1074
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
       : (word1 (d) << (32 - i));
   140bc:	3ee7dc63          	ble	a4,a5,144b4 <_dtoa_r+0xab0>
   140c0:	04000793          	li	a5,64
   140c4:	41248513          	addi	a0,s1,1042
   140c8:	40e78733          	sub	a4,a5,a4
   140cc:	00a95533          	srl	a0,s2,a0
   140d0:	00eb1b33          	sll	s6,s6,a4
   140d4:	01656533          	or	a0,a0,s6
#endif
      d2.d = x;
   140d8:	43d060ef          	jal	1ad14 <__floatunsidf>
      word0 (d2) -= 31 * Exp_msk1;	/* adjust exponent */
   140dc:	fe1007b7          	lui	a5,0xfe100
      i -= (Bias + (P - 1) - 1) + 1;
      denorm = 1;
   140e0:	00100713          	li	a4,1
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
       : (word1 (d) << (32 - i));
#endif
      d2.d = x;
      word0 (d2) -= 31 * Exp_msk1;	/* adjust exponent */
   140e4:	00b785b3          	add	a1,a5,a1
      i -= (Bias + (P - 1) - 1) + 1;
   140e8:	fff48493          	addi	s1,s1,-1
      denorm = 1;
   140ec:	04e12423          	sw	a4,72(sp)
   140f0:	acdff06f          	j	13bbc <_dtoa_r+0x1b8>
    {
      *decpt = 1;
      s = "0";
      if (rve)
	*rve = s + 1;
      return s;
   140f4:	0001c537          	lui	a0,0x1c
   140f8:	16450513          	addi	a0,a0,356 # 1c164 <__thenan_sf+0x54>
   140fc:	9e1ff06f          	j	13adc <_dtoa_r+0xd8>
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   14100:	04042223          	sw	zero,68(s0)
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   14104:	00000593          	li	a1,0
   14108:	00040513          	mv	a0,s0
   1410c:	43d020ef          	jal	16d48 <_Balloc>
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   14110:	fff00713          	li	a4,-1
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   14114:	00100793          	li	a5,1
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   14118:	00050d13          	mv	s10,a0
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   1411c:	00e12c23          	sw	a4,24(sp)
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   14120:	04a42023          	sw	a0,64(s0)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   14124:	02e12623          	sw	a4,44(sp)
  switch (mode)
    {
    case 0:
    case 1:
      i = 18;
      ndigits = 0;
   14128:	00000b93          	li	s7,0
      b2 -= k;
      b5 = -k;
      s5 = 0;
    }
  if (mode < 0 || mode > 9)
    mode = 0;
   1412c:	00000d93          	li	s11,0
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   14130:	02f12023          	sw	a5,32(sp)
      ilim = ilim0;
    }

  /* Do we have a "small" integer? */

  if (be >= 0 && k <= Int_max)
   14134:	05c12783          	lw	a5,92(sp)
   14138:	1c07c463          	bltz	a5,14300 <_dtoa_r+0x8fc>
   1413c:	01012683          	lw	a3,16(sp)
   14140:	00e00713          	li	a4,14
   14144:	1ad74e63          	blt	a4,a3,14300 <_dtoa_r+0x8fc>
    {
      /* Yes. */
      ds = tens[k];
   14148:	0001c737          	lui	a4,0x1c
   1414c:	00369793          	slli	a5,a3,0x3
   14150:	e5870713          	addi	a4,a4,-424 # 1be58 <__mprec_tens>
   14154:	00e787b3          	add	a5,a5,a4
   14158:	0007aa03          	lw	s4,0(a5) # fe100000 <_gp+0xfe0e19c0>
   1415c:	0047aa83          	lw	s5,4(a5)
      if (ndigits < 0 && ilim <= 0)
   14160:	6c0bc463          	bltz	s7,14828 <_dtoa_r+0xe24>
	    goto no_digits;
	  goto one_digit;
	}
      for (i = 1;; i++)
	{
	  L = d.d / ds;
   14164:	000a0613          	mv	a2,s4
   14168:	000a8693          	mv	a3,s5
   1416c:	00090513          	mv	a0,s2
   14170:	00098593          	mv	a1,s3
   14174:	6f0060ef          	jal	1a864 <__divdf3>
   14178:	425060ef          	jal	1ad9c <__fixdfsi>
   1417c:	00050c13          	mv	s8,a0
	  d.d -= L * ds;
   14180:	2d5060ef          	jal	1ac54 <__floatsidf>
   14184:	000a0613          	mv	a2,s4
   14188:	000a8693          	mv	a3,s5
   1418c:	474060ef          	jal	1a600 <__muldf3>
   14190:	00050613          	mv	a2,a0
   14194:	00058693          	mv	a3,a1
   14198:	00090513          	mv	a0,s2
   1419c:	00098593          	mv	a1,s3
   141a0:	404060ef          	jal	1a5a4 <__subdf3>
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
	  if (i == ilim)
   141a4:	01812603          	lw	a2,24(sp)
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
   141a8:	030c0693          	addi	a3,s8,48
   141ac:	00dd0023          	sb	a3,0(s10)
	  if (i == ilim)
   141b0:	00100693          	li	a3,1
	  goto one_digit;
	}
      for (i = 1;; i++)
	{
	  L = d.d / ds;
	  d.d -= L * ds;
   141b4:	00050713          	mv	a4,a0
   141b8:	00058793          	mv	a5,a1
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
   141bc:	001d0c93          	addi	s9,s10,1
	  if (i == ilim)
   141c0:	0cd60063          	beq	a2,a3,14280 <_dtoa_r+0x87c>
		      }
		  ++*s++;
		}
	      break;
	    }
	  if (!(d.d *= 10.))
   141c4:	8501a603          	lw	a2,-1968(gp) # 1de90 <__wctomb+0x30>
   141c8:	8541a683          	lw	a3,-1964(gp) # 1de94 <__wctomb+0x34>
   141cc:	434060ef          	jal	1a600 <__muldf3>
   141d0:	00000613          	li	a2,0
   141d4:	00000693          	li	a3,0
   141d8:	00050913          	mv	s2,a0
   141dc:	00058993          	mv	s3,a1
   141e0:	221060ef          	jal	1ac00 <__eqdf2>
   141e4:	e6050ee3          	beqz	a0,14060 <_dtoa_r+0x65c>
   141e8:	01812783          	lw	a5,24(sp)
   141ec:	8501ab03          	lw	s6,-1968(gp) # 1de90 <__wctomb+0x30>
   141f0:	8541ab83          	lw	s7,-1964(gp) # 1de94 <__wctomb+0x34>
   141f4:	002d0493          	addi	s1,s10,2
   141f8:	00fd0db3          	add	s11,s10,a5
   141fc:	0240006f          	j	14220 <_dtoa_r+0x81c>
   14200:	400060ef          	jal	1a600 <__muldf3>
   14204:	00000613          	li	a2,0
   14208:	00000693          	li	a3,0
   1420c:	00050913          	mv	s2,a0
   14210:	00058993          	mv	s3,a1
   14214:	00148493          	addi	s1,s1,1
   14218:	1e9060ef          	jal	1ac00 <__eqdf2>
   1421c:	e40502e3          	beqz	a0,14060 <_dtoa_r+0x65c>
	    goto no_digits;
	  goto one_digit;
	}
      for (i = 1;; i++)
	{
	  L = d.d / ds;
   14220:	000a0613          	mv	a2,s4
   14224:	000a8693          	mv	a3,s5
   14228:	00090513          	mv	a0,s2
   1422c:	00098593          	mv	a1,s3
   14230:	634060ef          	jal	1a864 <__divdf3>
   14234:	369060ef          	jal	1ad9c <__fixdfsi>
   14238:	00050c13          	mv	s8,a0
	  d.d -= L * ds;
   1423c:	219060ef          	jal	1ac54 <__floatsidf>
   14240:	000a0613          	mv	a2,s4
   14244:	000a8693          	mv	a3,s5
   14248:	3b8060ef          	jal	1a600 <__muldf3>
   1424c:	00050613          	mv	a2,a0
   14250:	00058693          	mv	a3,a1
   14254:	00090513          	mv	a0,s2
   14258:	00098593          	mv	a1,s3
   1425c:	348060ef          	jal	1a5a4 <__subdf3>
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
   14260:	030c0813          	addi	a6,s8,48
	  goto one_digit;
	}
      for (i = 1;; i++)
	{
	  L = d.d / ds;
	  d.d -= L * ds;
   14264:	00050713          	mv	a4,a0
   14268:	00058793          	mv	a5,a1
		      }
		  ++*s++;
		}
	      break;
	    }
	  if (!(d.d *= 10.))
   1426c:	000b0613          	mv	a2,s6
   14270:	000b8693          	mv	a3,s7
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
   14274:	ff048fa3          	sb	a6,-1(s1)
   14278:	00048c93          	mv	s9,s1
	  if (i == ilim)
   1427c:	f89d92e3          	bne	s11,s1,14200 <_dtoa_r+0x7fc>
	    {
	      d.d += d.d;
   14280:	00070613          	mv	a2,a4
   14284:	00078693          	mv	a3,a5
   14288:	00070513          	mv	a0,a4
   1428c:	00078593          	mv	a1,a5
   14290:	2c4060ef          	jal	1a554 <__adddf3>
   14294:	00050913          	mv	s2,a0
   14298:	00058993          	mv	s3,a1
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
   1429c:	00050613          	mv	a2,a0
   142a0:	00058693          	mv	a3,a1
   142a4:	000a0513          	mv	a0,s4
   142a8:	000a8593          	mv	a1,s5
   142ac:	14d060ef          	jal	1abf8 <__ltdf2>
   142b0:	02054263          	bltz	a0,142d4 <_dtoa_r+0x8d0>
   142b4:	00090613          	mv	a2,s2
   142b8:	00098693          	mv	a3,s3
   142bc:	000a0513          	mv	a0,s4
   142c0:	000a8593          	mv	a1,s5
   142c4:	13d060ef          	jal	1ac00 <__eqdf2>
   142c8:	d8051ce3          	bnez	a0,14060 <_dtoa_r+0x65c>
   142cc:	001c7c13          	andi	s8,s8,1
   142d0:	d80c08e3          	beqz	s8,14060 <_dtoa_r+0x65c>
   142d4:	fffcca03          	lbu	s4,-1(s9)
		{
		bump_up:
		  while (*--s == '9')
   142d8:	03900713          	li	a4,57
   142dc:	0100006f          	j	142ec <_dtoa_r+0x8e8>
		    if (s == s0)
   142e0:	0ba784e3          	beq	a5,s10,14b88 <_dtoa_r+0x1184>
   142e4:	fff7ca03          	lbu	s4,-1(a5)
   142e8:	00078c93          	mv	s9,a5
	    {
	      d.d += d.d;
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
		{
		bump_up:
		  while (*--s == '9')
   142ec:	fffc8793          	addi	a5,s9,-1
   142f0:	feea08e3          	beq	s4,a4,142e0 <_dtoa_r+0x8dc>
		      {
			k++;
			*s = '0';
			break;
		      }
		  ++*s++;
   142f4:	001a0a13          	addi	s4,s4,1
   142f8:	01478023          	sb	s4,0(a5)
   142fc:	d65ff06f          	j	14060 <_dtoa_r+0x65c>
    }

  m2 = b2;
  m5 = b5;
  mhi = mlo = 0;
  if (leftright)
   14300:	02012703          	lw	a4,32(sp)
   14304:	1a070063          	beqz	a4,144a4 <_dtoa_r+0xaa0>
    {
      if (mode < 2)
   14308:	00100713          	li	a4,1
   1430c:	57b75a63          	ble	s11,a4,14880 <_dtoa_r+0xe7c>
	    1 + P - bbits;
#endif
	}
      else
	{
	  j = ilim - 1;
   14310:	01812703          	lw	a4,24(sp)
   14314:	fff70793          	addi	a5,a4,-1
	  if (m5 >= j)
	    m5 -= j;
   14318:	40fb0cb3          	sub	s9,s6,a5
#endif
	}
      else
	{
	  j = ilim - 1;
	  if (m5 >= j)
   1431c:	00fb5e63          	ble	a5,s6,14338 <_dtoa_r+0x934>
	    m5 -= j;
	  else
	    {
	      s5 += j -= m5;
   14320:	02812583          	lw	a1,40(sp)
   14324:	41678733          	sub	a4,a5,s6
	      b5 += j;
	      m5 = 0;
   14328:	00000c93          	li	s9,0
	  j = ilim - 1;
	  if (m5 >= j)
	    m5 -= j;
	  else
	    {
	      s5 += j -= m5;
   1432c:	00e585b3          	add	a1,a1,a4
   14330:	02b12423          	sw	a1,40(sp)
   14334:	00078b13          	mv	s6,a5
	      b5 += j;
	      m5 = 0;
	    }
	  if ((i = ilim) < 0)
   14338:	01812783          	lw	a5,24(sp)
	    break;
	}
      goto ret1;
    }

  m2 = b2;
   1433c:	000a8c13          	mv	s8,s5
	    {
	      s5 += j -= m5;
	      b5 += j;
	      m5 = 0;
	    }
	  if ((i = ilim) < 0)
   14340:	2207c0e3          	bltz	a5,14d60 <_dtoa_r+0x135c>
	      m2 -= i;
	      i = 0;
	    }
	}
      b2 += i;
      s2 += i;
   14344:	00c12703          	lw	a4,12(sp)
      mhi = i2b (ptr, 1);
   14348:	00100593          	li	a1,1
   1434c:	00040513          	mv	a0,s0
	      m2 -= i;
	      i = 0;
	    }
	}
      b2 += i;
      s2 += i;
   14350:	00f70733          	add	a4,a4,a5
	    {
	      m2 -= i;
	      i = 0;
	    }
	}
      b2 += i;
   14354:	00fa8ab3          	add	s5,s5,a5
      s2 += i;
   14358:	00e12623          	sw	a4,12(sp)
      mhi = i2b (ptr, 1);
   1435c:	5f5020ef          	jal	17150 <__i2b>
   14360:	00050a13          	mv	s4,a0
    }
  if (m2 > 0 && s2 > 0)
   14364:	020c0663          	beqz	s8,14390 <_dtoa_r+0x98c>
   14368:	00c12783          	lw	a5,12(sp)
   1436c:	02f05263          	blez	a5,14390 <_dtoa_r+0x98c>
    {
      i = m2 < s2 ? m2 : s2;
   14370:	00c12703          	lw	a4,12(sp)
   14374:	000c0793          	mv	a5,s8
   14378:	45874463          	blt	a4,s8,147c0 <_dtoa_r+0xdbc>
      b2 -= i;
      m2 -= i;
      s2 -= i;
   1437c:	00c12703          	lw	a4,12(sp)
      mhi = i2b (ptr, 1);
    }
  if (m2 > 0 && s2 > 0)
    {
      i = m2 < s2 ? m2 : s2;
      b2 -= i;
   14380:	40fa8ab3          	sub	s5,s5,a5
      m2 -= i;
   14384:	40fc0c33          	sub	s8,s8,a5
      s2 -= i;
   14388:	40f70733          	sub	a4,a4,a5
   1438c:	00e12623          	sw	a4,12(sp)
      if (rve)
	*rve = s + 1;
      return s;
    }

  b = d2b (ptr, d.d, &be, &bbits);
   14390:	01c12483          	lw	s1,28(sp)
      i = m2 < s2 ? m2 : s2;
      b2 -= i;
      m2 -= i;
      s2 -= i;
    }
  if (b5 > 0)
   14394:	07605263          	blez	s6,143f8 <_dtoa_r+0x9f4>
    {
      if (leftright)
   14398:	02012783          	lw	a5,32(sp)
   1439c:	70078263          	beqz	a5,14aa0 <_dtoa_r+0x109c>
	{
	  if (m5 > 0)
   143a0:	040c8263          	beqz	s9,143e4 <_dtoa_r+0x9e0>
	    {
	      mhi = pow5mult (ptr, mhi, m5);
   143a4:	000a0593          	mv	a1,s4
   143a8:	000c8613          	mv	a2,s9
   143ac:	00040513          	mv	a0,s0
   143b0:	7c5020ef          	jal	17374 <__pow5mult>
	      b1 = mult (ptr, mhi, b);
   143b4:	01c12603          	lw	a2,28(sp)
   143b8:	00050593          	mv	a1,a0
    {
      if (leftright)
	{
	  if (m5 > 0)
	    {
	      mhi = pow5mult (ptr, mhi, m5);
   143bc:	00050a13          	mv	s4,a0
	      b1 = mult (ptr, mhi, b);
   143c0:	00040513          	mv	a0,s0
   143c4:	5c1020ef          	jal	17184 <__multiply>
	      Bfree (ptr, b);
   143c8:	01c12583          	lw	a1,28(sp)
      if (leftright)
	{
	  if (m5 > 0)
	    {
	      mhi = pow5mult (ptr, mhi, m5);
	      b1 = mult (ptr, mhi, b);
   143cc:	00050493          	mv	s1,a0
	      Bfree (ptr, b);
	      b = b1;
	    }
         if ((j = b5 - m5) != 0)
   143d0:	419b0b33          	sub	s6,s6,s9
	{
	  if (m5 > 0)
	    {
	      mhi = pow5mult (ptr, mhi, m5);
	      b1 = mult (ptr, mhi, b);
	      Bfree (ptr, b);
   143d4:	00040513          	mv	a0,s0
   143d8:	215020ef          	jal	16dec <_Bfree>
	      b = b1;
	    }
         if ((j = b5 - m5) != 0)
   143dc:	000b0e63          	beqz	s6,143f8 <_dtoa_r+0x9f4>
	  if (m5 > 0)
	    {
	      mhi = pow5mult (ptr, mhi, m5);
	      b1 = mult (ptr, mhi, b);
	      Bfree (ptr, b);
	      b = b1;
   143e0:	00912e23          	sw	s1,28(sp)
	    }
         if ((j = b5 - m5) != 0)
	    b = pow5mult (ptr, b, j);
   143e4:	01c12583          	lw	a1,28(sp)
   143e8:	000b0613          	mv	a2,s6
   143ec:	00040513          	mv	a0,s0
   143f0:	785020ef          	jal	17374 <__pow5mult>
   143f4:	00050493          	mv	s1,a0
	}
      else
	b = pow5mult (ptr, b, b5);
    }
  S = i2b (ptr, 1);
   143f8:	00100593          	li	a1,1
   143fc:	00040513          	mv	a0,s0
   14400:	551020ef          	jal	17150 <__i2b>
  if (s5 > 0)
   14404:	02812703          	lw	a4,40(sp)
	    b = pow5mult (ptr, b, j);
	}
      else
	b = pow5mult (ptr, b, b5);
    }
  S = i2b (ptr, 1);
   14408:	00050b13          	mv	s6,a0
  if (s5 > 0)
   1440c:	0a070e63          	beqz	a4,144c8 <_dtoa_r+0xac4>
    S = pow5mult (ptr, S, s5);
   14410:	00050593          	mv	a1,a0
   14414:	00070613          	mv	a2,a4
   14418:	00040513          	mv	a0,s0
   1441c:	759020ef          	jal	17374 <__pow5mult>

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
  if (mode < 2)
   14420:	00100793          	li	a5,1
      else
	b = pow5mult (ptr, b, b5);
    }
  S = i2b (ptr, 1);
  if (s5 > 0)
    S = pow5mult (ptr, S, s5);
   14424:	00050b13          	mv	s6,a0

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
  if (mode < 2)
   14428:	3bb7d063          	ble	s11,a5,147c8 <_dtoa_r+0xdc4>
  if (s5 > 0)
    S = pow5mult (ptr, S, s5);

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
   1442c:	00000c93          	li	s9,0
   * and for all and pass them and a shift to quorem, so it
   * can do shifts and ors to compute the numerator for q.
   */

#ifdef Pack_32
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
   14430:	010b2783          	lw	a5,16(s6) # 80000010 <_gp+0x7ffe19d0>
   14434:	00378793          	addi	a5,a5,3
   14438:	00279793          	slli	a5,a5,0x2
   1443c:	00fb07b3          	add	a5,s6,a5
   14440:	0047a503          	lw	a0,4(a5)
   14444:	3e1020ef          	jal	17024 <__hi0bits>
   14448:	02000793          	li	a5,32
   1444c:	40a78533          	sub	a0,a5,a0
   14450:	0840006f          	j	144d4 <_dtoa_r+0xad0>
      s5 = k;
      s2 += k;
    }
  else
    {
      b2 -= k;
   14454:	01012703          	lw	a4,16(sp)
      b5 = -k;
      s5 = 0;
   14458:	02012423          	sw	zero,40(sp)
      s5 = k;
      s2 += k;
    }
  else
    {
      b2 -= k;
   1445c:	40ea8ab3          	sub	s5,s5,a4
      b5 = -k;
   14460:	40e00b33          	neg	s6,a4
   14464:	851ff06f          	j	13cb4 <_dtoa_r+0x2b0>
  ds = (d2.d - 1.5) * 0.289529651 + 0.176091269 + i * 0.30103001;
#else
  ds = (d2.d - 1.5) * 0.289529654602168 + 0.1760912590558 + i * 0.301029995663981;
#endif
  k = (int) ds;
  if (ds < 0. && ds != k)
   14468:	01012503          	lw	a0,16(sp)
   1446c:	7e8060ef          	jal	1ac54 <__floatsidf>
   14470:	00050613          	mv	a2,a0
   14474:	00058693          	mv	a3,a1
   14478:	000a0513          	mv	a0,s4
   1447c:	000a8593          	mv	a1,s5
   14480:	77c060ef          	jal	1abfc <__nedf2>
    k--;			/* want k = floor(ds) */
   14484:	01012783          	lw	a5,16(sp)
   14488:	00a03533          	snez	a0,a0
   1448c:	40a787b3          	sub	a5,a5,a0
   14490:	00f12823          	sw	a5,16(sp)
   14494:	fa4ff06f          	j	13c38 <_dtoa_r+0x234>
      b2 = 0;
      s2 = j;
    }
  else
    {
      b2 = -j;
   14498:	41900ab3          	neg	s5,s9
      s2 = 0;
   1449c:	00012623          	sw	zero,12(sp)
   144a0:	ff8ff06f          	j	13c98 <_dtoa_r+0x294>
   144a4:	000b0c93          	mv	s9,s6
	    break;
	}
      goto ret1;
    }

  m2 = b2;
   144a8:	000a8c13          	mv	s8,s5
  m5 = b5;
  mhi = mlo = 0;
   144ac:	00000a13          	li	s4,0
   144b0:	eb5ff06f          	j	14364 <_dtoa_r+0x960>
      i = bbits + be + (Bias + (P - 1) - 1);
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
       : (word1 (d) << (32 - i));
   144b4:	40e78b33          	sub	s6,a5,a4
   144b8:	01691533          	sll	a0,s2,s6
   144bc:	c1dff06f          	j	140d8 <_dtoa_r+0x6d4>
  k_check = 1;
  if (k >= 0 && k <= Ten_pmax)
    {
      if (d.d < tens[k])
	k--;
      k_check = 0;
   144c0:	02012223          	sw	zero,36(sp)
   144c4:	fc0ff06f          	j	13c84 <_dtoa_r+0x280>
    S = pow5mult (ptr, S, s5);

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
  if (mode < 2)
   144c8:	00100513          	li	a0,1
   144cc:	45b55663          	ble	s11,a0,14918 <_dtoa_r+0xf14>
  if (s5 > 0)
    S = pow5mult (ptr, S, s5);

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
   144d0:	00000c93          	li	s9,0
   * and for all and pass them and a shift to quorem, so it
   * can do shifts and ors to compute the numerator for q.
   */

#ifdef Pack_32
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
   144d4:	00c12703          	lw	a4,12(sp)
   144d8:	00e50533          	add	a0,a0,a4
   144dc:	01f57513          	andi	a0,a0,31
   144e0:	1a050663          	beqz	a0,1468c <_dtoa_r+0xc88>
    i = 32 - i;
   144e4:	02000793          	li	a5,32
   144e8:	40a787b3          	sub	a5,a5,a0
#else
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0xf) != 0)
    i = 16 - i;
#endif
  if (i > 4)
   144ec:	00400713          	li	a4,4
   144f0:	20f752e3          	ble	a5,a4,14ef4 <_dtoa_r+0x14f0>
    {
      i -= 4;
   144f4:	01c00793          	li	a5,28
   144f8:	40a78533          	sub	a0,a5,a0
      b2 += i;
      m2 += i;
      s2 += i;
   144fc:	00c12783          	lw	a5,12(sp)
    i = 16 - i;
#endif
  if (i > 4)
    {
      i -= 4;
      b2 += i;
   14500:	00aa8ab3          	add	s5,s5,a0
      m2 += i;
   14504:	00ac0c33          	add	s8,s8,a0
      s2 += i;
   14508:	00a787b3          	add	a5,a5,a0
   1450c:	00f12623          	sw	a5,12(sp)
      i += 28;
      b2 += i;
      m2 += i;
      s2 += i;
    }
  if (b2 > 0)
   14510:	01505c63          	blez	s5,14528 <_dtoa_r+0xb24>
    b = lshift (ptr, b, b2);
   14514:	00048593          	mv	a1,s1
   14518:	000a8613          	mv	a2,s5
   1451c:	00040513          	mv	a0,s0
   14520:	78d020ef          	jal	174ac <__lshift>
   14524:	00050493          	mv	s1,a0
  if (s2 > 0)
   14528:	00c12783          	lw	a5,12(sp)
   1452c:	00f05c63          	blez	a5,14544 <_dtoa_r+0xb40>
    S = lshift (ptr, S, s2);
   14530:	000b0593          	mv	a1,s6
   14534:	00078613          	mv	a2,a5
   14538:	00040513          	mv	a0,s0
   1453c:	771020ef          	jal	174ac <__lshift>
   14540:	00050b13          	mv	s6,a0
  if (k_check)
   14544:	02412703          	lw	a4,36(sp)
   14548:	16071063          	bnez	a4,146a8 <_dtoa_r+0xca4>
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   1454c:	01812703          	lw	a4,24(sp)
   14550:	44e05063          	blez	a4,14990 <_dtoa_r+0xf8c>
    one_digit:
      *s++ = '1';
      k++;
      goto ret;
    }
  if (leftright)
   14554:	02012783          	lw	a5,32(sp)
   14558:	18078c63          	beqz	a5,146f0 <_dtoa_r+0xcec>
    {
      if (m2 > 0)
   1455c:	01805c63          	blez	s8,14574 <_dtoa_r+0xb70>
	mhi = lshift (ptr, mhi, m2);
   14560:	000a0593          	mv	a1,s4
   14564:	000c0613          	mv	a2,s8
   14568:	00040513          	mv	a0,s0
   1456c:	741020ef          	jal	174ac <__lshift>
   14570:	00050a13          	mv	s4,a0
   14574:	000a0c13          	mv	s8,s4
      /* Compute mlo -- check for special case
       * that d is a normalized power of 2.
       */

      mlo = mhi;
      if (spec_case)
   14578:	620c9663          	bnez	s9,14ba4 <_dtoa_r+0x11a0>
   1457c:	01812703          	lw	a4,24(sp)
	  j = cmp (b, mlo);
	  delta = diff (ptr, S, mhi);
	  j1 = delta->_sign ? 1 : cmp (b, delta);
	  Bfree (ptr, delta);
#ifndef ROUND_BIASED
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
   14580:	00197793          	andi	a5,s2,1
   14584:	001d0993          	addi	s3,s10,1
   14588:	00ed0733          	add	a4,s10,a4
   1458c:	00e12e23          	sw	a4,28(sp)
   14590:	00f12c23          	sw	a5,24(sp)
   14594:	03a12023          	sw	s10,32(sp)
	  mhi = lshift (ptr, mhi, Log2P);
	}

      for (i = 1;; i++)
	{
	  dig = quorem (b, S) + '0';
   14598:	000b0593          	mv	a1,s6
   1459c:	00048513          	mv	a0,s1
   145a0:	a7cff0ef          	jal	1381c <quorem>
   145a4:	00050c93          	mv	s9,a0
	  /* Do we yet have the shortest decimal string
	   * that will round to d?
	   */
	  j = cmp (b, mlo);
   145a8:	000a0593          	mv	a1,s4
   145ac:	00048513          	mv	a0,s1
   145b0:	04c030ef          	jal	175fc <__mcmp>
   145b4:	00050a93          	mv	s5,a0
	  delta = diff (ptr, S, mhi);
   145b8:	000c0613          	mv	a2,s8
   145bc:	000b0593          	mv	a1,s6
   145c0:	00040513          	mv	a0,s0
   145c4:	098030ef          	jal	1765c <__mdiff>
	  j1 = delta->_sign ? 1 : cmp (b, delta);
   145c8:	00c52683          	lw	a3,12(a0)
   145cc:	fff98713          	addi	a4,s3,-1
	  dig = quorem (b, S) + '0';
	  /* Do we yet have the shortest decimal string
	   * that will round to d?
	   */
	  j = cmp (b, mlo);
	  delta = diff (ptr, S, mhi);
   145d0:	00050d13          	mv	s10,a0
   145d4:	00e12623          	sw	a4,12(sp)
	  mhi = lshift (ptr, mhi, Log2P);
	}

      for (i = 1;; i++)
	{
	  dig = quorem (b, S) + '0';
   145d8:	030c8b93          	addi	s7,s9,48
	  /* Do we yet have the shortest decimal string
	   * that will round to d?
	   */
	  j = cmp (b, mlo);
	  delta = diff (ptr, S, mhi);
	  j1 = delta->_sign ? 1 : cmp (b, delta);
   145dc:	00100913          	li	s2,1
   145e0:	00069a63          	bnez	a3,145f4 <_dtoa_r+0xbf0>
   145e4:	00050593          	mv	a1,a0
   145e8:	00048513          	mv	a0,s1
   145ec:	010030ef          	jal	175fc <__mcmp>
   145f0:	00050913          	mv	s2,a0
	  Bfree (ptr, delta);
   145f4:	000d0593          	mv	a1,s10
   145f8:	00040513          	mv	a0,s0
   145fc:	7f0020ef          	jal	16dec <_Bfree>
#ifndef ROUND_BIASED
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
   14600:	01b967b3          	or	a5,s2,s11
   14604:	00079663          	bnez	a5,14610 <_dtoa_r+0xc0c>
   14608:	01812783          	lw	a5,24(sp)
   1460c:	28078663          	beqz	a5,14898 <_dtoa_r+0xe94>
		dig++;
	      *s++ = dig;
	      goto ret;
	    }
#endif
         if ((j < 0) || ((j == 0) && !mode
   14610:	2a0acc63          	bltz	s5,148c8 <_dtoa_r+0xec4>
   14614:	01baeab3          	or	s5,s5,s11
   14618:	000a9663          	bnez	s5,14624 <_dtoa_r+0xc20>
#ifndef ROUND_BIASED
	      && !(word1 (d) & 1)
   1461c:	01812703          	lw	a4,24(sp)
   14620:	2a070463          	beqz	a4,148c8 <_dtoa_r+0xec4>
		    goto round_9_up;
		}
	      *s++ = dig;
	      goto ret;
	    }
	  if (j1 > 0)
   14624:	71204063          	bgtz	s2,14d24 <_dtoa_r+0x1320>
		}
	      *s++ = dig + 1;
	      goto ret;
	    }
	  *s++ = dig;
	  if (i == ilim)
   14628:	01c12783          	lw	a5,28(sp)
		  goto roundoff;
		}
	      *s++ = dig + 1;
	      goto ret;
	    }
	  *s++ = dig;
   1462c:	00098c93          	mv	s9,s3
   14630:	ff798fa3          	sb	s7,-1(s3)
	  if (i == ilim)
   14634:	71378e63          	beq	a5,s3,14d50 <_dtoa_r+0x134c>
	    break;
	  b = multadd (ptr, b, 10, 0);
   14638:	00048593          	mv	a1,s1
   1463c:	00000693          	li	a3,0
   14640:	00a00613          	li	a2,10
   14644:	00040513          	mv	a0,s0
   14648:	7c8020ef          	jal	16e10 <__multadd>
   1464c:	00050493          	mv	s1,a0
	  if (mlo == mhi)
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
   14650:	00000693          	li	a3,0
   14654:	00a00613          	li	a2,10
   14658:	000a0593          	mv	a1,s4
   1465c:	00040513          	mv	a0,s0
	    }
	  *s++ = dig;
	  if (i == ilim)
	    break;
	  b = multadd (ptr, b, 10, 0);
	  if (mlo == mhi)
   14660:	2d8a0063          	beq	s4,s8,14920 <_dtoa_r+0xf1c>
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
	  else
	    {
	      mlo = multadd (ptr, mlo, 10, 0);
   14664:	7ac020ef          	jal	16e10 <__multadd>
   14668:	00050a13          	mv	s4,a0
	      mhi = multadd (ptr, mhi, 10, 0);
   1466c:	000c0593          	mv	a1,s8
   14670:	00000693          	li	a3,0
   14674:	00a00613          	li	a2,10
   14678:	00040513          	mv	a0,s0
   1467c:	794020ef          	jal	16e10 <__multadd>
   14680:	00050c13          	mv	s8,a0
   14684:	00198993          	addi	s3,s3,1
	    }
	}
   14688:	f11ff06f          	j	14598 <_dtoa_r+0xb94>
   1468c:	01c00513          	li	a0,28
  else if (i < 4)
    {
      i += 28;
      b2 += i;
      m2 += i;
      s2 += i;
   14690:	00c12703          	lw	a4,12(sp)
      s2 += i;
    }
  else if (i < 4)
    {
      i += 28;
      b2 += i;
   14694:	00aa8ab3          	add	s5,s5,a0
      m2 += i;
   14698:	00ac0c33          	add	s8,s8,a0
      s2 += i;
   1469c:	00a70733          	add	a4,a4,a0
   146a0:	00e12623          	sw	a4,12(sp)
   146a4:	e6dff06f          	j	14510 <_dtoa_r+0xb0c>
    b = lshift (ptr, b, b2);
  if (s2 > 0)
    S = lshift (ptr, S, s2);
  if (k_check)
    {
      if (cmp (b, S) < 0)
   146a8:	000b0593          	mv	a1,s6
   146ac:	00048513          	mv	a0,s1
   146b0:	74d020ef          	jal	175fc <__mcmp>
   146b4:	e8055ce3          	bgez	a0,1454c <_dtoa_r+0xb48>
	{
	  k--;
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
   146b8:	00048593          	mv	a1,s1
   146bc:	00000693          	li	a3,0
   146c0:	00a00613          	li	a2,10
   146c4:	00040513          	mv	a0,s0
   146c8:	748020ef          	jal	16e10 <__multadd>
    S = lshift (ptr, S, s2);
  if (k_check)
    {
      if (cmp (b, S) < 0)
	{
	  k--;
   146cc:	01012783          	lw	a5,16(sp)
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
	  if (leftright)
   146d0:	02012703          	lw	a4,32(sp)
  if (k_check)
    {
      if (cmp (b, S) < 0)
	{
	  k--;
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
   146d4:	00050493          	mv	s1,a0
    S = lshift (ptr, S, s2);
  if (k_check)
    {
      if (cmp (b, S) < 0)
	{
	  k--;
   146d8:	fff78793          	addi	a5,a5,-1
   146dc:	00f12823          	sw	a5,16(sp)
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
	  if (leftright)
   146e0:	7a071e63          	bnez	a4,14e9c <_dtoa_r+0x1498>
	    mhi = multadd (ptr, mhi, 10, 0);
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   146e4:	02c12783          	lw	a5,44(sp)
   146e8:	7cf05e63          	blez	a5,14ec4 <_dtoa_r+0x14c0>
   146ec:	00f12c23          	sw	a5,24(sp)
	  *s++ = dig;
	  if (i == ilim)
	    break;
	  b = multadd (ptr, b, 10, 0);
	  if (mlo == mhi)
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
   146f0:	000d0913          	mv	s2,s10
   146f4:	01812983          	lw	s3,24(sp)
   146f8:	00c0006f          	j	14704 <_dtoa_r+0xd00>
    for (i = 1;; i++)
      {
	*s++ = dig = quorem (b, S) + '0';
	if (i >= ilim)
	  break;
	b = multadd (ptr, b, 10, 0);
   146fc:	714020ef          	jal	16e10 <__multadd>
   14700:	00050493          	mv	s1,a0
	}
    }
  else
    for (i = 1;; i++)
      {
	*s++ = dig = quorem (b, S) + '0';
   14704:	000b0593          	mv	a1,s6
   14708:	00048513          	mv	a0,s1
   1470c:	910ff0ef          	jal	1381c <quorem>
   14710:	00190913          	addi	s2,s2,1
   14714:	03050b93          	addi	s7,a0,48
	if (i >= ilim)
   14718:	41a907b3          	sub	a5,s2,s10
	  break;
	b = multadd (ptr, b, 10, 0);
   1471c:	00000693          	li	a3,0
   14720:	00a00613          	li	a2,10
   14724:	00048593          	mv	a1,s1
   14728:	00040513          	mv	a0,s0
	}
    }
  else
    for (i = 1;; i++)
      {
	*s++ = dig = quorem (b, S) + '0';
   1472c:	ff790fa3          	sb	s7,-1(s2)
	if (i >= ilim)
   14730:	fd37c6e3          	blt	a5,s3,146fc <_dtoa_r+0xcf8>
   14734:	01812d83          	lw	s11,24(sp)
   14738:	63b05a63          	blez	s11,14d6c <_dtoa_r+0x1368>
   1473c:	01bd0cb3          	add	s9,s10,s11
      goto ret1;
    }

  m2 = b2;
  m5 = b5;
  mhi = mlo = 0;
   14740:	00000913          	li	s2,0
	b = multadd (ptr, b, 10, 0);
      }

  /* Round off last digit */

  b = lshift (ptr, b, 1);
   14744:	00048593          	mv	a1,s1
   14748:	00100613          	li	a2,1
   1474c:	00040513          	mv	a0,s0
   14750:	55d020ef          	jal	174ac <__lshift>
  j = cmp (b, S);
   14754:	000b0593          	mv	a1,s6
	b = multadd (ptr, b, 10, 0);
      }

  /* Round off last digit */

  b = lshift (ptr, b, 1);
   14758:	00a12e23          	sw	a0,28(sp)
  j = cmp (b, S);
   1475c:	6a1020ef          	jal	175fc <__mcmp>
  if ((j > 0) || ((j == 0) && (dig & 1)))
   14760:	36a05063          	blez	a0,14ac0 <_dtoa_r+0x10bc>
   14764:	fffcc703          	lbu	a4,-1(s9)
    {
    roundoff:
      while (*--s == '9')
   14768:	03900693          	li	a3,57
   1476c:	0100006f          	j	1477c <_dtoa_r+0xd78>
	if (s == s0)
   14770:	29a78063          	beq	a5,s10,149f0 <_dtoa_r+0xfec>
   14774:	fff7c703          	lbu	a4,-1(a5)
   14778:	00078c93          	mv	s9,a5
  b = lshift (ptr, b, 1);
  j = cmp (b, S);
  if ((j > 0) || ((j == 0) && (dig & 1)))
    {
    roundoff:
      while (*--s == '9')
   1477c:	fffc8793          	addi	a5,s9,-1
   14780:	fed708e3          	beq	a4,a3,14770 <_dtoa_r+0xd6c>
	  {
	    k++;
	    *s++ = '1';
	    goto ret;
	  }
      ++*s++;
   14784:	00170713          	addi	a4,a4,1
   14788:	00e78023          	sb	a4,0(a5)
    {
      while (*--s == '0');
      s++;
    }
ret:
  Bfree (ptr, S);
   1478c:	000b0593          	mv	a1,s6
   14790:	00040513          	mv	a0,s0
   14794:	658020ef          	jal	16dec <_Bfree>
  if (mhi)
   14798:	8c0a04e3          	beqz	s4,14060 <_dtoa_r+0x65c>
    {
      if (mlo && mlo != mhi)
   1479c:	00090a63          	beqz	s2,147b0 <_dtoa_r+0xdac>
   147a0:	01490863          	beq	s2,s4,147b0 <_dtoa_r+0xdac>
	Bfree (ptr, mlo);
   147a4:	00090593          	mv	a1,s2
   147a8:	00040513          	mv	a0,s0
   147ac:	640020ef          	jal	16dec <_Bfree>
      Bfree (ptr, mhi);
   147b0:	000a0593          	mv	a1,s4
   147b4:	00040513          	mv	a0,s0
   147b8:	634020ef          	jal	16dec <_Bfree>
   147bc:	8a5ff06f          	j	14060 <_dtoa_r+0x65c>
      s2 += i;
      mhi = i2b (ptr, 1);
    }
  if (m2 > 0 && s2 > 0)
    {
      i = m2 < s2 ? m2 : s2;
   147c0:	00070793          	mv	a5,a4
   147c4:	bb9ff06f          	j	1437c <_dtoa_r+0x978>
  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
  if (mode < 2)
    {
      if (!word1 (d) && !(word0 (d) & Bndry_mask)
   147c8:	c60912e3          	bnez	s2,1442c <_dtoa_r+0xa28>
   147cc:	00c99793          	slli	a5,s3,0xc
  if (s5 > 0)
    S = pow5mult (ptr, S, s5);

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
   147d0:	00000c93          	li	s9,0
  if (mode < 2)
    {
      if (!word1 (d) && !(word0 (d) & Bndry_mask)
   147d4:	02079263          	bnez	a5,147f8 <_dtoa_r+0xdf4>
#ifndef Sudden_Underflow
	  && word0 (d) & Exp_mask
   147d8:	7ff007b7          	lui	a5,0x7ff00
   147dc:	0137f7b3          	and	a5,a5,s3
   147e0:	00078c63          	beqz	a5,147f8 <_dtoa_r+0xdf4>
#endif
	)
	{
	  /* The special case */
	  b2 += Log2P;
	  s2 += Log2P;
   147e4:	00c12703          	lw	a4,12(sp)
	  && word0 (d) & Exp_mask
#endif
	)
	{
	  /* The special case */
	  b2 += Log2P;
   147e8:	001a8a93          	addi	s5,s5,1
	  s2 += Log2P;
	  spec_case = 1;
   147ec:	00100c93          	li	s9,1
#endif
	)
	{
	  /* The special case */
	  b2 += Log2P;
	  s2 += Log2P;
   147f0:	00170713          	addi	a4,a4,1
   147f4:	00e12623          	sw	a4,12(sp)
   * and for all and pass them and a shift to quorem, so it
   * can do shifts and ors to compute the numerator for q.
   */

#ifdef Pack_32
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
   147f8:	02812783          	lw	a5,40(sp)
   147fc:	00100513          	li	a0,1
   14800:	cc078ae3          	beqz	a5,144d4 <_dtoa_r+0xad0>
   14804:	c2dff06f          	j	14430 <_dtoa_r+0xa2c>
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   14808:	00100793          	li	a5,1
   1480c:	02f12023          	sw	a5,32(sp)
      break;
    case 2:
      leftright = 0;
      /* no break */
    case 4:
      if (ndigits <= 0)
   14810:	13705263          	blez	s7,14934 <_dtoa_r+0xf30>
   14814:	000b8613          	mv	a2,s7
   14818:	000b8493          	mv	s1,s7
   1481c:	03712623          	sw	s7,44(sp)
   14820:	01712c23          	sw	s7,24(sp)
   14824:	cf0ff06f          	j	13d14 <_dtoa_r+0x310>

  if (be >= 0 && k <= Int_max)
    {
      /* Yes. */
      ds = tens[k];
      if (ndigits < 0 && ilim <= 0)
   14828:	01812703          	lw	a4,24(sp)
   1482c:	92e04ce3          	bgtz	a4,14164 <_dtoa_r+0x760>
	{
	  S = mhi = 0;
	  if (ilim < 0 || d.d <= 5 * ds)
   14830:	26071263          	bnez	a4,14a94 <_dtoa_r+0x1090>
   14834:	8601a603          	lw	a2,-1952(gp) # 1dea0 <__wctomb+0x40>
   14838:	8641a683          	lw	a3,-1948(gp) # 1dea4 <__wctomb+0x44>
   1483c:	000a0513          	mv	a0,s4
   14840:	000a8593          	mv	a1,s5
   14844:	5bd050ef          	jal	1a600 <__muldf3>
   14848:	00090613          	mv	a2,s2
   1484c:	00098693          	mv	a3,s3
   14850:	2e8060ef          	jal	1ab38 <__gedf2>
    {
      /* Yes. */
      ds = tens[k];
      if (ndigits < 0 && ilim <= 0)
	{
	  S = mhi = 0;
   14854:	00000b13          	li	s6,0
   14858:	00000a13          	li	s4,0
	  if (ilim < 0 || d.d <= 5 * ds)
   1485c:	16054863          	bltz	a0,149cc <_dtoa_r+0xfc8>
    {
      if (ilim < 0 || cmp (b, S = multadd (ptr, S, 5, 0)) <= 0)
	{
	  /* no digits, fcvt style */
	no_digits:
	  k = -1 - ndigits;
   14860:	fffbcb93          	not	s7,s7
   14864:	01712823          	sw	s7,16(sp)
	  goto ret;
   14868:	000d0c93          	mv	s9,s10
    {
      while (*--s == '0');
      s++;
    }
ret:
  Bfree (ptr, S);
   1486c:	000b0593          	mv	a1,s6
   14870:	00040513          	mv	a0,s0
   14874:	578020ef          	jal	16dec <_Bfree>
  if (mhi)
   14878:	fe0a0463          	beqz	s4,14060 <_dtoa_r+0x65c>
   1487c:	f35ff06f          	j	147b0 <_dtoa_r+0xdac>
    {
      if (mode < 2)
	{
	  i =
#ifndef Sudden_Underflow
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
   14880:	04812703          	lw	a4,72(sp)
   14884:	4e070863          	beqz	a4,14d74 <_dtoa_r+0x1370>
   14888:	43378793          	addi	a5,a5,1075 # 7ff00433 <_gp+0x7fee1df3>
   1488c:	000b0c93          	mv	s9,s6
	    break;
	}
      goto ret1;
    }

  m2 = b2;
   14890:	000a8c13          	mv	s8,s5
   14894:	ab1ff06f          	j	14344 <_dtoa_r+0x940>
	  j1 = delta->_sign ? 1 : cmp (b, delta);
	  Bfree (ptr, delta);
#ifndef ROUND_BIASED
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
	    {
	      if (dig == '9')
   14898:	03900793          	li	a5,57
   1489c:	02012d03          	lw	s10,32(sp)
   148a0:	4efb8a63          	beq	s7,a5,14d94 <_dtoa_r+0x1390>
		goto round_9_up;
	      if (j > 0)
   148a4:	01505463          	blez	s5,148ac <_dtoa_r+0xea8>
		dig++;
   148a8:	031c8b93          	addi	s7,s9,49
	      *s++ = dig;
   148ac:	00c12683          	lw	a3,12(sp)
	      goto ret;
   148b0:	000a0913          	mv	s2,s4
   148b4:	00912e23          	sw	s1,28(sp)
	    {
	      if (dig == '9')
		goto round_9_up;
	      if (j > 0)
		dig++;
	      *s++ = dig;
   148b8:	00168c93          	addi	s9,a3,1
   148bc:	01768023          	sb	s7,0(a3)
	      goto ret;
   148c0:	000c0a13          	mv	s4,s8
   148c4:	ec9ff06f          	j	1478c <_dtoa_r+0xd88>
   148c8:	02012d03          	lw	s10,32(sp)
#ifndef ROUND_BIASED
	      && !(word1 (d) & 1)
#endif
           ))
	    {
	      if (j1 > 0)
   148cc:	03205863          	blez	s2,148fc <_dtoa_r+0xef8>
		{
		  b = lshift (ptr, b, 1);
   148d0:	00048593          	mv	a1,s1
   148d4:	00100613          	li	a2,1
   148d8:	00040513          	mv	a0,s0
   148dc:	3d1020ef          	jal	174ac <__lshift>
		  j1 = cmp (b, S);
   148e0:	000b0593          	mv	a1,s6
#endif
           ))
	    {
	      if (j1 > 0)
		{
		  b = lshift (ptr, b, 1);
   148e4:	00050493          	mv	s1,a0
		  j1 = cmp (b, S);
   148e8:	515020ef          	jal	175fc <__mcmp>
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
   148ec:	5aa05063          	blez	a0,14e8c <_dtoa_r+0x1488>
		      && dig++ == '9')
   148f0:	03900793          	li	a5,57
   148f4:	4afb8063          	beq	s7,a5,14d94 <_dtoa_r+0x1390>
   148f8:	031c8b93          	addi	s7,s9,49
		    goto round_9_up;
		}
	      *s++ = dig;
   148fc:	00c12783          	lw	a5,12(sp)
	      goto ret;
   14900:	000a0913          	mv	s2,s4
   14904:	00912e23          	sw	s1,28(sp)
		  j1 = cmp (b, S);
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
		      && dig++ == '9')
		    goto round_9_up;
		}
	      *s++ = dig;
   14908:	00178c93          	addi	s9,a5,1
   1490c:	01778023          	sb	s7,0(a5)
	      goto ret;
   14910:	000c0a13          	mv	s4,s8
   14914:	e79ff06f          	j	1478c <_dtoa_r+0xd88>
  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
  if (mode < 2)
    {
      if (!word1 (d) && !(word0 (d) & Bndry_mask)
   14918:	ba091ce3          	bnez	s2,144d0 <_dtoa_r+0xacc>
   1491c:	eb1ff06f          	j	147cc <_dtoa_r+0xdc8>
	  *s++ = dig;
	  if (i == ilim)
	    break;
	  b = multadd (ptr, b, 10, 0);
	  if (mlo == mhi)
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
   14920:	4f0020ef          	jal	16e10 <__multadd>
   14924:	00050a13          	mv	s4,a0
   14928:	00050c13          	mv	s8,a0
   1492c:	00198993          	addi	s3,s3,1
   14930:	c69ff06f          	j	14598 <_dtoa_r+0xb94>
   14934:	00100493          	li	s1,1
    case 2:
      leftright = 0;
      /* no break */
    case 4:
      if (ndigits <= 0)
	ndigits = 1;
   14938:	02912623          	sw	s1,44(sp)
   1493c:	00912c23          	sw	s1,24(sp)
   14940:	00048b93          	mv	s7,s1
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   14944:	04042223          	sw	zero,68(s0)
   14948:	00000593          	li	a1,0
   1494c:	bf8ff06f          	j	13d44 <_dtoa_r+0x340>
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
  switch (mode)
   14950:	00200793          	li	a5,2
    case 1:
      i = 18;
      ndigits = 0;
      break;
    case 2:
      leftright = 0;
   14954:	02012023          	sw	zero,32(sp)
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
  switch (mode)
   14958:	eafd8ce3          	beq	s11,a5,14810 <_dtoa_r+0xe0c>
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   1495c:	04042223          	sw	zero,68(s0)
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   14960:	00000593          	li	a1,0
   14964:	00040513          	mv	a0,s0
   14968:	3e0020ef          	jal	16d48 <_Balloc>
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   1496c:	fff00713          	li	a4,-1
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   14970:	00100793          	li	a5,1
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   14974:	00050d13          	mv	s10,a0
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   14978:	00e12c23          	sw	a4,24(sp)
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   1497c:	04a42023          	sw	a0,64(s0)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   14980:	02e12623          	sw	a4,44(sp)
  switch (mode)
    {
    case 0:
    case 1:
      i = 18;
      ndigits = 0;
   14984:	00000b93          	li	s7,0
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   14988:	02f12023          	sw	a5,32(sp)
   1498c:	fa8ff06f          	j	14134 <_dtoa_r+0x730>
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   14990:	00200793          	li	a5,2
   14994:	bdb7d0e3          	ble	s11,a5,14554 <_dtoa_r+0xb50>
    {
      if (ilim < 0 || cmp (b, S = multadd (ptr, S, 5, 0)) <= 0)
   14998:	01812783          	lw	a5,24(sp)
   1499c:	3e079863          	bnez	a5,14d8c <_dtoa_r+0x1388>
   149a0:	000b0593          	mv	a1,s6
   149a4:	00000693          	li	a3,0
   149a8:	00500613          	li	a2,5
   149ac:	00040513          	mv	a0,s0
   149b0:	460020ef          	jal	16e10 <__multadd>
   149b4:	00050593          	mv	a1,a0
   149b8:	00050b13          	mv	s6,a0
   149bc:	00048513          	mv	a0,s1
   149c0:	43d020ef          	jal	175fc <__mcmp>
   149c4:	00912e23          	sw	s1,28(sp)
   149c8:	e8a05ce3          	blez	a0,14860 <_dtoa_r+0xe5c>
	  k = -1 - ndigits;
	  goto ret;
	}
    one_digit:
      *s++ = '1';
      k++;
   149cc:	01012703          	lw	a4,16(sp)
	no_digits:
	  k = -1 - ndigits;
	  goto ret;
	}
    one_digit:
      *s++ = '1';
   149d0:	03100793          	li	a5,49
   149d4:	001d0c93          	addi	s9,s10,1
      k++;
   149d8:	00170713          	addi	a4,a4,1
	no_digits:
	  k = -1 - ndigits;
	  goto ret;
	}
    one_digit:
      *s++ = '1';
   149dc:	00fd0023          	sb	a5,0(s10)
      k++;
   149e0:	00e12823          	sw	a4,16(sp)
      goto ret;
   149e4:	e89ff06f          	j	1486c <_dtoa_r+0xe68>
      if (ndigits <= 0)
	ndigits = 1;
      ilim = ilim1 = i = ndigits;
      break;
    case 3:
      leftright = 0;
   149e8:	02012023          	sw	zero,32(sp)
   149ec:	b08ff06f          	j	13cf4 <_dtoa_r+0x2f0>
    {
    roundoff:
      while (*--s == '9')
	if (s == s0)
	  {
	    k++;
   149f0:	01012703          	lw	a4,16(sp)
	    *s++ = '1';
   149f4:	03100793          	li	a5,49
   149f8:	00fd0023          	sb	a5,0(s10)
    {
    roundoff:
      while (*--s == '9')
	if (s == s0)
	  {
	    k++;
   149fc:	00170713          	addi	a4,a4,1
   14a00:	00e12823          	sw	a4,16(sp)
	    *s++ = '1';
	    goto ret;
   14a04:	d89ff06f          	j	1478c <_dtoa_r+0xd88>
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   14a08:	00048513          	mv	a0,s1
   14a0c:	248060ef          	jal	1ac54 <__floatsidf>
   14a10:	00090613          	mv	a2,s2
   14a14:	00098693          	mv	a3,s3
   14a18:	3e9050ef          	jal	1a600 <__muldf3>
   14a1c:	85c1a683          	lw	a3,-1956(gp) # 1de9c <__wctomb+0x3c>
   14a20:	8581a603          	lw	a2,-1960(gp) # 1de98 <__wctomb+0x38>
   14a24:	331050ef          	jal	1a554 <__adddf3>
      word0 (eps) -= (P - 1) * Exp_msk1;
   14a28:	fcc006b7          	lui	a3,0xfcc00
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   14a2c:	00050713          	mv	a4,a0
      word0 (eps) -= (P - 1) * Exp_msk1;
   14a30:	00b687b3          	add	a5,a3,a1
      if (ilim == 0)
	{
	  S = mhi = 0;
	  d.d -= 5.;
   14a34:	8601a603          	lw	a2,-1952(gp) # 1dea0 <__wctomb+0x40>
   14a38:	8641a683          	lw	a3,-1948(gp) # 1dea4 <__wctomb+0x44>
   14a3c:	00090513          	mv	a0,s2
   14a40:	00098593          	mv	a1,s3
   14a44:	00e12423          	sw	a4,8(sp)
   14a48:	00f12223          	sw	a5,4(sp)
   14a4c:	359050ef          	jal	1a5a4 <__subdf3>
	  if (d.d > eps.d)
   14a50:	00812703          	lw	a4,8(sp)
   14a54:	00412783          	lw	a5,4(sp)
      eps.d = ieps * d.d + 7.;
      word0 (eps) -= (P - 1) * Exp_msk1;
      if (ilim == 0)
	{
	  S = mhi = 0;
	  d.d -= 5.;
   14a58:	00050913          	mv	s2,a0
	  if (d.d > eps.d)
   14a5c:	00070613          	mv	a2,a4
   14a60:	00078693          	mv	a3,a5
      eps.d = ieps * d.d + 7.;
      word0 (eps) -= (P - 1) * Exp_msk1;
      if (ilim == 0)
	{
	  S = mhi = 0;
	  d.d -= 5.;
   14a64:	00058993          	mv	s3,a1
	  if (d.d > eps.d)
   14a68:	130060ef          	jal	1ab98 <__gtdf2>
   14a6c:	00812703          	lw	a4,8(sp)
   14a70:	00412783          	lw	a5,4(sp)
   14a74:	16a04863          	bgtz	a0,14be4 <_dtoa_r+0x11e0>
	    goto one_digit;
	  if (d.d < -eps.d)
   14a78:	00070613          	mv	a2,a4
   14a7c:	80000737          	lui	a4,0x80000
   14a80:	00f746b3          	xor	a3,a4,a5
   14a84:	00090513          	mv	a0,s2
   14a88:	00098593          	mv	a1,s3
   14a8c:	16c060ef          	jal	1abf8 <__ltdf2>
   14a90:	04055e63          	bgez	a0,14aec <_dtoa_r+0x10e8>
    {
      /* Yes. */
      ds = tens[k];
      if (ndigits < 0 && ilim <= 0)
	{
	  S = mhi = 0;
   14a94:	00000b13          	li	s6,0
   14a98:	00000a13          	li	s4,0
   14a9c:	dc5ff06f          	j	14860 <_dtoa_r+0xe5c>
	    }
         if ((j = b5 - m5) != 0)
	    b = pow5mult (ptr, b, j);
	}
      else
	b = pow5mult (ptr, b, b5);
   14aa0:	00048593          	mv	a1,s1
   14aa4:	000b0613          	mv	a2,s6
   14aa8:	00040513          	mv	a0,s0
   14aac:	0c9020ef          	jal	17374 <__pow5mult>
   14ab0:	00050493          	mv	s1,a0
   14ab4:	945ff06f          	j	143f8 <_dtoa_r+0x9f4>
   14ab8:	000d0513          	mv	a0,s10
   14abc:	820ff06f          	j	13adc <_dtoa_r+0xd8>

  /* Round off last digit */

  b = lshift (ptr, b, 1);
  j = cmp (b, S);
  if ((j > 0) || ((j == 0) && (dig & 1)))
   14ac0:	00051663          	bnez	a0,14acc <_dtoa_r+0x10c8>
   14ac4:	001bfb93          	andi	s7,s7,1
   14ac8:	c80b9ee3          	bnez	s7,14764 <_dtoa_r+0xd60>
	  }
      ++*s++;
    }
  else
    {
      while (*--s == '0');
   14acc:	03000693          	li	a3,48
   14ad0:	0080006f          	j	14ad8 <_dtoa_r+0x10d4>
   14ad4:	00070c93          	mv	s9,a4
   14ad8:	fffcc783          	lbu	a5,-1(s9)
   14adc:	fffc8713          	addi	a4,s9,-1
   14ae0:	fed78ae3          	beq	a5,a3,14ad4 <_dtoa_r+0x10d0>
   14ae4:	ca9ff06f          	j	1478c <_dtoa_r+0xd88>
   14ae8:	04012a83          	lw	s5,64(sp)
#ifndef No_leftright
	}
#endif
    fast_failed:
      s = s0;
      d.d = d2.d;
   14aec:	03012903          	lw	s2,48(sp)
   14af0:	03412983          	lw	s3,52(sp)
   14af4:	e40ff06f          	j	14134 <_dtoa_r+0x730>
		ieps++;
		ds *= bigtens[i];
	      }
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
   14af8:	01012703          	lw	a4,16(sp)
   14afc:	03012903          	lw	s2,48(sp)
   14b00:	03412983          	lw	s3,52(sp)
   14b04:	40e00a33          	neg	s4,a4

      i = 0;
      d2.d = d.d;
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
   14b08:	00200493          	li	s1,2
		ieps++;
		ds *= bigtens[i];
	      }
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
   14b0c:	b20a0463          	beqz	s4,13e34 <_dtoa_r+0x430>
	{
	  d.d *= tens[j1 & 0xf];
   14b10:	00fa7793          	andi	a5,s4,15
   14b14:	00379713          	slli	a4,a5,0x3
   14b18:	0001c7b7          	lui	a5,0x1c
   14b1c:	e5878793          	addi	a5,a5,-424 # 1be58 <__mprec_tens>
   14b20:	00f707b3          	add	a5,a4,a5
   14b24:	0007a603          	lw	a2,0(a5)
   14b28:	0047a683          	lw	a3,4(a5)
   14b2c:	00090513          	mv	a0,s2
   14b30:	00098593          	mv	a1,s3
   14b34:	2cd050ef          	jal	1a600 <__muldf3>
	  for (j = j1 >> 4; j; j >>= 1, i++)
   14b38:	404a5a13          	srai	s4,s4,0x4
	      }
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
	{
	  d.d *= tens[j1 & 0xf];
   14b3c:	00050913          	mv	s2,a0
   14b40:	00058993          	mv	s3,a1
	  for (j = j1 >> 4; j; j >>= 1, i++)
   14b44:	ae0a0863          	beqz	s4,13e34 <_dtoa_r+0x430>
   14b48:	0001cc37          	lui	s8,0x1c
   14b4c:	f48c0c13          	addi	s8,s8,-184 # 1bf48 <__mprec_bigtens>
	    if (j & 1)
   14b50:	001a7793          	andi	a5,s4,1
	      {
		ieps++;
		d.d *= bigtens[i];
   14b54:	00090513          	mv	a0,s2
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
	{
	  d.d *= tens[j1 & 0xf];
	  for (j = j1 >> 4; j; j >>= 1, i++)
   14b58:	401a5a13          	srai	s4,s4,0x1
	    if (j & 1)
	      {
		ieps++;
		d.d *= bigtens[i];
   14b5c:	00098593          	mv	a1,s3
	}
      else if ((j1 = -k) != 0)
	{
	  d.d *= tens[j1 & 0xf];
	  for (j = j1 >> 4; j; j >>= 1, i++)
	    if (j & 1)
   14b60:	00078e63          	beqz	a5,14b7c <_dtoa_r+0x1178>
	      {
		ieps++;
		d.d *= bigtens[i];
   14b64:	000c2603          	lw	a2,0(s8)
   14b68:	004c2683          	lw	a3,4(s8)
	{
	  d.d *= tens[j1 & 0xf];
	  for (j = j1 >> 4; j; j >>= 1, i++)
	    if (j & 1)
	      {
		ieps++;
   14b6c:	00148493          	addi	s1,s1,1
		d.d *= bigtens[i];
   14b70:	291050ef          	jal	1a600 <__muldf3>
   14b74:	00050913          	mv	s2,a0
   14b78:	00058993          	mv	s3,a1
   14b7c:	008c0c13          	addi	s8,s8,8
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
	{
	  d.d *= tens[j1 & 0xf];
	  for (j = j1 >> 4; j; j >>= 1, i++)
   14b80:	fc0a18e3          	bnez	s4,14b50 <_dtoa_r+0x114c>
   14b84:	ab0ff06f          	j	13e34 <_dtoa_r+0x430>
		bump_up:
		  while (*--s == '9')
		    if (s == s0)
		      {
			k++;
			*s = '0';
   14b88:	03000713          	li	a4,48
   14b8c:	00ed0023          	sb	a4,0(s10)
		{
		bump_up:
		  while (*--s == '9')
		    if (s == s0)
		      {
			k++;
   14b90:	01012703          	lw	a4,16(sp)
   14b94:	fffcca03          	lbu	s4,-1(s9)
   14b98:	00170713          	addi	a4,a4,1 # 80000001 <_gp+0x7ffe19c1>
   14b9c:	00e12823          	sw	a4,16(sp)
			*s = '0';
			break;
   14ba0:	f54ff06f          	j	142f4 <_dtoa_r+0x8f0>
       */

      mlo = mhi;
      if (spec_case)
	{
	  mhi = Balloc (ptr, mhi->_k);
   14ba4:	004a2583          	lw	a1,4(s4)
   14ba8:	00040513          	mv	a0,s0
   14bac:	19c020ef          	jal	16d48 <_Balloc>
	  Bcopy (mhi, mlo);
   14bb0:	010a2603          	lw	a2,16(s4)
       */

      mlo = mhi;
      if (spec_case)
	{
	  mhi = Balloc (ptr, mhi->_k);
   14bb4:	00050a93          	mv	s5,a0
	  Bcopy (mhi, mlo);
   14bb8:	00ca0593          	addi	a1,s4,12
   14bbc:	00260613          	addi	a2,a2,2
   14bc0:	00261613          	slli	a2,a2,0x2
   14bc4:	00c50513          	addi	a0,a0,12
   14bc8:	65d010ef          	jal	16a24 <memcpy>
	  mhi = lshift (ptr, mhi, Log2P);
   14bcc:	00100613          	li	a2,1
   14bd0:	000a8593          	mv	a1,s5
   14bd4:	00040513          	mv	a0,s0
   14bd8:	0d5020ef          	jal	174ac <__lshift>
   14bdc:	00050c13          	mv	s8,a0
   14be0:	99dff06f          	j	1457c <_dtoa_r+0xb78>
	}
      eps.d = ieps * d.d + 7.;
      word0 (eps) -= (P - 1) * Exp_msk1;
      if (ilim == 0)
	{
	  S = mhi = 0;
   14be4:	00000b13          	li	s6,0
   14be8:	00000a13          	li	s4,0
   14bec:	de1ff06f          	j	149cc <_dtoa_r+0xfc8>
	}
      else
	{
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
   14bf0:	fff48613          	addi	a2,s1,-1
   14bf4:	0001c6b7          	lui	a3,0x1c
   14bf8:	02c12c23          	sw	a2,56(sp)
   14bfc:	e5868693          	addi	a3,a3,-424 # 1be58 <__mprec_tens>
   14c00:	00361613          	slli	a2,a2,0x3
   14c04:	00d606b3          	add	a3,a2,a3
   14c08:	0006a503          	lw	a0,0(a3)
   14c0c:	0046a583          	lw	a1,4(a3)
   14c10:	00070613          	mv	a2,a4
   14c14:	00078693          	mv	a3,a5
   14c18:	1e9050ef          	jal	1a600 <__muldf3>
   14c1c:	04a12023          	sw	a0,64(sp)
   14c20:	04b12223          	sw	a1,68(sp)
	  for (i = 1;; i++, d.d *= 10.)
	    {
	      L = d.d;
   14c24:	00090513          	mv	a0,s2
   14c28:	00098593          	mv	a1,s3
   14c2c:	170060ef          	jal	1ad9c <__fixdfsi>
   14c30:	00050c13          	mv	s8,a0
	      d.d -= L;
   14c34:	020060ef          	jal	1ac54 <__floatsidf>
   14c38:	00058693          	mv	a3,a1
   14c3c:	00050613          	mv	a2,a0
   14c40:	00098593          	mv	a1,s3
   14c44:	00090513          	mv	a0,s2
   14c48:	15d050ef          	jal	1a5a4 <__subdf3>
	      *s++ = '0' + (int) L;
   14c4c:	030c0c13          	addi	s8,s8,48
	      if (i == ilim)
   14c50:	00100693          	li	a3,1
	  eps.d *= tens[ilim - 1];
	  for (i = 1;; i++, d.d *= 10.)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
   14c54:	001d0c93          	addi	s9,s10,1
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
	  for (i = 1;; i++, d.d *= 10.)
	    {
	      L = d.d;
	      d.d -= L;
   14c58:	00050713          	mv	a4,a0
   14c5c:	00058793          	mv	a5,a1
	      *s++ = '0' + (int) L;
   14c60:	018d0023          	sb	s8,0(s10)
	      if (i == ilim)
   14c64:	06d48a63          	beq	s1,a3,14cd8 <_dtoa_r+0x12d4>
   14c68:	009d04b3          	add	s1,s10,s1
   14c6c:	000c8c13          	mv	s8,s9
   14c70:	000a8993          	mv	s3,s5
      else
	{
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
	  for (i = 1;; i++, d.d *= 10.)
   14c74:	85018593          	addi	a1,gp,-1968 # 1de90 <__wctomb+0x30>
   14c78:	0005a603          	lw	a2,0(a1)
   14c7c:	0045a683          	lw	a3,4(a1)
   14c80:	00070513          	mv	a0,a4
   14c84:	00078593          	mv	a1,a5
   14c88:	179050ef          	jal	1a600 <__muldf3>
   14c8c:	00058a93          	mv	s5,a1
   14c90:	00050a13          	mv	s4,a0
	    {
	      L = d.d;
   14c94:	108060ef          	jal	1ad9c <__fixdfsi>
   14c98:	00050913          	mv	s2,a0
	      d.d -= L;
   14c9c:	7b9050ef          	jal	1ac54 <__floatsidf>
   14ca0:	00050613          	mv	a2,a0
   14ca4:	00058693          	mv	a3,a1
   14ca8:	000a0513          	mv	a0,s4
   14cac:	000a8593          	mv	a1,s5
   14cb0:	0f5050ef          	jal	1a5a4 <__subdf3>
	      *s++ = '0' + (int) L;
   14cb4:	001c0c13          	addi	s8,s8,1
   14cb8:	03090913          	addi	s2,s2,48
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
	  for (i = 1;; i++, d.d *= 10.)
	    {
	      L = d.d;
	      d.d -= L;
   14cbc:	00050713          	mv	a4,a0
   14cc0:	00058793          	mv	a5,a1
	      *s++ = '0' + (int) L;
   14cc4:	ff2c0fa3          	sb	s2,-1(s8)
	      if (i == ilim)
   14cc8:	fb8496e3          	bne	s1,s8,14c74 <_dtoa_r+0x1270>
   14ccc:	03812603          	lw	a2,56(sp)
   14cd0:	00098a93          	mv	s5,s3
   14cd4:	00cc8cb3          	add	s9,s9,a2
		{
		  if (d.d > 0.5 + eps.d)
   14cd8:	8681a603          	lw	a2,-1944(gp) # 1dea8 <__wctomb+0x48>
   14cdc:	86c1a683          	lw	a3,-1940(gp) # 1deac <__wctomb+0x4c>
   14ce0:	04012503          	lw	a0,64(sp)
   14ce4:	04412583          	lw	a1,68(sp)
   14ce8:	00e12423          	sw	a4,8(sp)
   14cec:	00f12223          	sw	a5,4(sp)
   14cf0:	065050ef          	jal	1a554 <__adddf3>
   14cf4:	00812703          	lw	a4,8(sp)
   14cf8:	00412783          	lw	a5,4(sp)
   14cfc:	00070613          	mv	a2,a4
   14d00:	00078693          	mv	a3,a5
   14d04:	6f5050ef          	jal	1abf8 <__ltdf2>
   14d08:	00812703          	lw	a4,8(sp)
   14d0c:	00412783          	lw	a5,4(sp)
   14d10:	10055a63          	bgez	a0,14e24 <_dtoa_r+0x1420>
   14d14:	04c12703          	lw	a4,76(sp)
   14d18:	fffcca03          	lbu	s4,-1(s9)
   14d1c:	00e12823          	sw	a4,16(sp)
   14d20:	db8ff06f          	j	142d8 <_dtoa_r+0x8d4>
	      *s++ = dig;
	      goto ret;
	    }
	  if (j1 > 0)
	    {
	      if (dig == '9')
   14d24:	03900793          	li	a5,57
   14d28:	02012d03          	lw	s10,32(sp)
   14d2c:	06fb8463          	beq	s7,a5,14d94 <_dtoa_r+0x1390>
		{		/* possible if i == 1 */
		round_9_up:
		  *s++ = '9';
		  goto roundoff;
		}
	      *s++ = dig + 1;
   14d30:	00c12703          	lw	a4,12(sp)
   14d34:	001b8b93          	addi	s7,s7,1
	      goto ret;
   14d38:	000a0913          	mv	s2,s4
		{		/* possible if i == 1 */
		round_9_up:
		  *s++ = '9';
		  goto roundoff;
		}
	      *s++ = dig + 1;
   14d3c:	00170c93          	addi	s9,a4,1
   14d40:	01770023          	sb	s7,0(a4)
	      goto ret;
   14d44:	000c0a13          	mv	s4,s8
   14d48:	00912e23          	sw	s1,28(sp)
   14d4c:	a41ff06f          	j	1478c <_dtoa_r+0xd88>
   14d50:	000a0913          	mv	s2,s4
   14d54:	02012d03          	lw	s10,32(sp)
   14d58:	000c0a13          	mv	s4,s8
   14d5c:	9e9ff06f          	j	14744 <_dtoa_r+0xd40>
	      b5 += j;
	      m5 = 0;
	    }
	  if ((i = ilim) < 0)
	    {
	      m2 -= i;
   14d60:	40fa8c33          	sub	s8,s5,a5
	      i = 0;
   14d64:	00000793          	li	a5,0
   14d68:	ddcff06f          	j	14344 <_dtoa_r+0x940>
   14d6c:	00100d93          	li	s11,1
   14d70:	9cdff06f          	j	1473c <_dtoa_r+0xd38>
    {
      if (mode < 2)
	{
	  i =
#ifndef Sudden_Underflow
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
   14d74:	05812703          	lw	a4,88(sp)
   14d78:	03600793          	li	a5,54
   14d7c:	000b0c93          	mv	s9,s6
   14d80:	40e787b3          	sub	a5,a5,a4
	    break;
	}
      goto ret1;
    }

  m2 = b2;
   14d84:	000a8c13          	mv	s8,s5
   14d88:	dbcff06f          	j	14344 <_dtoa_r+0x940>
   14d8c:	00912e23          	sw	s1,28(sp)
   14d90:	ad1ff06f          	j	14860 <_dtoa_r+0xe5c>
	  if (j1 > 0)
	    {
	      if (dig == '9')
		{		/* possible if i == 1 */
		round_9_up:
		  *s++ = '9';
   14d94:	00c12683          	lw	a3,12(sp)
   14d98:	03900793          	li	a5,57
		  goto roundoff;
   14d9c:	000a0913          	mv	s2,s4
	  if (j1 > 0)
	    {
	      if (dig == '9')
		{		/* possible if i == 1 */
		round_9_up:
		  *s++ = '9';
   14da0:	00168c93          	addi	s9,a3,1
   14da4:	00f68023          	sb	a5,0(a3)
		  goto roundoff;
   14da8:	000c0a13          	mv	s4,s8
   14dac:	00912e23          	sw	s1,28(sp)
   14db0:	03900713          	li	a4,57
   14db4:	9b5ff06f          	j	14768 <_dtoa_r+0xd64>
	      {
		ieps++;
		d.d *= bigtens[i];
	      }
	}
      if (k_check && d.d < 1. && ilim > 0)
   14db8:	01812703          	lw	a4,24(sp)
   14dbc:	c40706e3          	beqz	a4,14a08 <_dtoa_r+0x1004>
	{
	  if (ilim1 <= 0)
   14dc0:	02c12783          	lw	a5,44(sp)
   14dc4:	d2f054e3          	blez	a5,14aec <_dtoa_r+0x10e8>
	    goto fast_failed;
	  ilim = ilim1;
	  k--;
   14dc8:	01012703          	lw	a4,16(sp)
	  d.d *= 10.;
   14dcc:	8501a603          	lw	a2,-1968(gp) # 1de90 <__wctomb+0x30>
   14dd0:	8541a683          	lw	a3,-1964(gp) # 1de94 <__wctomb+0x34>
      if (k_check && d.d < 1. && ilim > 0)
	{
	  if (ilim1 <= 0)
	    goto fast_failed;
	  ilim = ilim1;
	  k--;
   14dd4:	fff70713          	addi	a4,a4,-1
	  d.d *= 10.;
   14dd8:	00090513          	mv	a0,s2
   14ddc:	00098593          	mv	a1,s3
      if (k_check && d.d < 1. && ilim > 0)
	{
	  if (ilim1 <= 0)
	    goto fast_failed;
	  ilim = ilim1;
	  k--;
   14de0:	04e12623          	sw	a4,76(sp)
	  d.d *= 10.;
   14de4:	01d050ef          	jal	1a600 <__muldf3>
   14de8:	00050913          	mv	s2,a0
   14dec:	00058993          	mv	s3,a1
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   14df0:	00148513          	addi	a0,s1,1
   14df4:	661050ef          	jal	1ac54 <__floatsidf>
   14df8:	00090613          	mv	a2,s2
   14dfc:	00098693          	mv	a3,s3
   14e00:	001050ef          	jal	1a600 <__muldf3>
   14e04:	85c1a683          	lw	a3,-1956(gp) # 1de9c <__wctomb+0x3c>
   14e08:	8581a603          	lw	a2,-1960(gp) # 1de98 <__wctomb+0x38>
      word0 (eps) -= (P - 1) * Exp_msk1;
   14e0c:	02c12483          	lw	s1,44(sp)
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   14e10:	744050ef          	jal	1a554 <__adddf3>
      word0 (eps) -= (P - 1) * Exp_msk1;
   14e14:	fcc006b7          	lui	a3,0xfcc00
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   14e18:	00050713          	mv	a4,a0
      word0 (eps) -= (P - 1) * Exp_msk1;
   14e1c:	00b687b3          	add	a5,a3,a1
   14e20:	878ff06f          	j	13e98 <_dtoa_r+0x494>
	      *s++ = '0' + (int) L;
	      if (i == ilim)
		{
		  if (d.d > 0.5 + eps.d)
		    goto bump_up;
		  else if (d.d < 0.5 - eps.d)
   14e24:	04012603          	lw	a2,64(sp)
   14e28:	04412683          	lw	a3,68(sp)
   14e2c:	8681a503          	lw	a0,-1944(gp) # 1dea8 <__wctomb+0x48>
   14e30:	86c1a583          	lw	a1,-1940(gp) # 1deac <__wctomb+0x4c>
   14e34:	00e12423          	sw	a4,8(sp)
   14e38:	00f12223          	sw	a5,4(sp)
   14e3c:	768050ef          	jal	1a5a4 <__subdf3>
   14e40:	00812703          	lw	a4,8(sp)
   14e44:	00412783          	lw	a5,4(sp)
   14e48:	00070613          	mv	a2,a4
   14e4c:	00078693          	mv	a3,a5
   14e50:	549050ef          	jal	1ab98 <__gtdf2>
		    {
		      while (*--s == '0');
   14e54:	03000693          	li	a3,48
	      *s++ = '0' + (int) L;
	      if (i == ilim)
		{
		  if (d.d > 0.5 + eps.d)
		    goto bump_up;
		  else if (d.d < 0.5 - eps.d)
   14e58:	00a04663          	bgtz	a0,14e64 <_dtoa_r+0x1460>
   14e5c:	c91ff06f          	j	14aec <_dtoa_r+0x10e8>
   14e60:	00070c93          	mv	s9,a4
		    {
		      while (*--s == '0');
   14e64:	fffcc783          	lbu	a5,-1(s9)
   14e68:	fffc8713          	addi	a4,s9,-1
   14e6c:	fed78ae3          	beq	a5,a3,14e60 <_dtoa_r+0x145c>
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
	      if (d.d < eps.d)
   14e70:	04c12783          	lw	a5,76(sp)
   14e74:	00f12823          	sw	a5,16(sp)
   14e78:	9e8ff06f          	j	14060 <_dtoa_r+0x65c>
   14e7c:	04c12703          	lw	a4,76(sp)
   14e80:	000a8c93          	mv	s9,s5
   14e84:	00e12823          	sw	a4,16(sp)
   14e88:	c50ff06f          	j	142d8 <_dtoa_r+0x8d4>
	    {
	      if (j1 > 0)
		{
		  b = lshift (ptr, b, 1);
		  j1 = cmp (b, S);
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
   14e8c:	a60518e3          	bnez	a0,148fc <_dtoa_r+0xef8>
   14e90:	001bf793          	andi	a5,s7,1
   14e94:	a60784e3          	beqz	a5,148fc <_dtoa_r+0xef8>
   14e98:	a59ff06f          	j	148f0 <_dtoa_r+0xeec>
      if (cmp (b, S) < 0)
	{
	  k--;
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
   14e9c:	000a0593          	mv	a1,s4
   14ea0:	00000693          	li	a3,0
   14ea4:	00a00613          	li	a2,10
   14ea8:	00040513          	mv	a0,s0
   14eac:	765010ef          	jal	16e10 <__multadd>
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   14eb0:	02c12783          	lw	a5,44(sp)
      if (cmp (b, S) < 0)
	{
	  k--;
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
   14eb4:	00050a13          	mv	s4,a0
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   14eb8:	02f05663          	blez	a5,14ee4 <_dtoa_r+0x14e0>
   14ebc:	00f12c23          	sw	a5,24(sp)
   14ec0:	e9cff06f          	j	1455c <_dtoa_r+0xb58>
   14ec4:	00200793          	li	a5,2
   14ec8:	03b7ce63          	blt	a5,s11,14f04 <_dtoa_r+0x1500>
   14ecc:	02c12703          	lw	a4,44(sp)
   14ed0:	00e12c23          	sw	a4,24(sp)
   14ed4:	81dff06f          	j	146f0 <_dtoa_r+0xcec>
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
	      if (d.d < eps.d)
		goto ret1;
	      if (1. - d.d < eps.d)
   14ed8:	04c12783          	lw	a5,76(sp)
   14edc:	00f12823          	sw	a5,16(sp)
   14ee0:	bf8ff06f          	j	142d8 <_dtoa_r+0x8d4>
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   14ee4:	00200793          	li	a5,2
   14ee8:	03b7c463          	blt	a5,s11,14f10 <_dtoa_r+0x150c>
   14eec:	02c12783          	lw	a5,44(sp)
   14ef0:	fcdff06f          	j	14ebc <_dtoa_r+0x14b8>
      i -= 4;
      b2 += i;
      m2 += i;
      s2 += i;
    }
  else if (i < 4)
   14ef4:	e0e78e63          	beq	a5,a4,14510 <_dtoa_r+0xb0c>
   14ef8:	03c00793          	li	a5,60
   14efc:	40a78533          	sub	a0,a5,a0
   14f00:	f90ff06f          	j	14690 <_dtoa_r+0xc8c>
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   14f04:	02c12783          	lw	a5,44(sp)
   14f08:	00f12c23          	sw	a5,24(sp)
   14f0c:	a8dff06f          	j	14998 <_dtoa_r+0xf94>
   14f10:	02c12703          	lw	a4,44(sp)
   14f14:	00e12c23          	sw	a4,24(sp)
   14f18:	a81ff06f          	j	14998 <_dtoa_r+0xf94>

00014f1c <__sflush_r>:
  register unsigned char *p;
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
   14f1c:	00c59683          	lh	a3,12(a1)
   directly from __srefill. */
int
_DEFUN(__sflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   14f20:	fe010113          	addi	sp,sp,-32
   14f24:	00812c23          	sw	s0,24(sp)
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
  if ((flags & __SWR) == 0)
   14f28:	01069713          	slli	a4,a3,0x10
   14f2c:	01075713          	srli	a4,a4,0x10
   14f30:	00877793          	andi	a5,a4,8
   directly from __srefill. */
int
_DEFUN(__sflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   14f34:	01312623          	sw	s3,12(sp)
   14f38:	00112e23          	sw	ra,28(sp)
   14f3c:	00912a23          	sw	s1,20(sp)
   14f40:	01212823          	sw	s2,16(sp)
   14f44:	00058413          	mv	s0,a1
   14f48:	00050993          	mv	s3,a0
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
  if ((flags & __SWR) == 0)
   14f4c:	10079a63          	bnez	a5,15060 <__sflush_r+0x144>
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
   14f50:	000017b7          	lui	a5,0x1
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   14f54:	0045a703          	lw	a4,4(a1)
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
   14f58:	80078793          	addi	a5,a5,-2048 # 800 <_reset+0x600>
   14f5c:	00f6e7b3          	or	a5,a3,a5
   14f60:	00f59623          	sh	a5,12(a1)
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   14f64:	1ce05663          	blez	a4,15130 <__sflush_r+0x214>
   14f68:	02842803          	lw	a6,40(s0)
   14f6c:	0c080a63          	beqz	a6,15040 <__sflush_r+0x124>
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
	  ptr->_errno = 0;
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
   14f70:	01079793          	slli	a5,a5,0x10
   14f74:	0107d793          	srli	a5,a5,0x10
   14f78:	01379693          	slli	a3,a5,0x13
#endif

	  /* Save last errno and set errno to 0, so we can check if a device
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
   14f7c:	0009a483          	lw	s1,0(s3)
	  ptr->_errno = 0;
   14f80:	0009a023          	sw	zero,0(s3)
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
   14f84:	1a06dc63          	bgez	a3,1513c <__sflush_r+0x220>
	    curoff = fp->_offset;
   14f88:	05042603          	lw	a2,80(s0)
   14f8c:	05442683          	lw	a3,84(s0)
		  else
		    fp->_flags |= __SERR;
		  return result;
		}
            }
          if (fp->_flags & __SRD)
   14f90:	0047f793          	andi	a5,a5,4
   14f94:	04078263          	beqz	a5,14fd8 <__sflush_r+0xbc>
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
   14f98:	00442503          	lw	a0,4(s0)
              if (HASUB (fp))
   14f9c:	03042703          	lw	a4,48(s0)
            }
          if (fp->_flags & __SRD)
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
   14fa0:	40a607b3          	sub	a5,a2,a0
   14fa4:	41f55513          	srai	a0,a0,0x1f
   14fa8:	00f635b3          	sltu	a1,a2,a5
   14fac:	40a686b3          	sub	a3,a3,a0
   14fb0:	00078613          	mv	a2,a5
   14fb4:	40b686b3          	sub	a3,a3,a1
              if (HASUB (fp))
   14fb8:	02070063          	beqz	a4,14fd8 <__sflush_r+0xbc>
                curoff -= fp->_ur;
   14fbc:	03c42503          	lw	a0,60(s0)
   14fc0:	40a787b3          	sub	a5,a5,a0
   14fc4:	41f55513          	srai	a0,a0,0x1f
   14fc8:	00f63733          	sltu	a4,a2,a5
   14fcc:	40a686b3          	sub	a3,a3,a0
   14fd0:	00078613          	mv	a2,a5
   14fd4:	40e686b3          	sub	a3,a3,a4
#ifdef __LARGE64_FILES
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
   14fd8:	01c42583          	lw	a1,28(s0)
   14fdc:	00000713          	li	a4,0
   14fe0:	00098513          	mv	a0,s3
   14fe4:	000800e7          	jalr	a6
	  if (curoff != -1 || ptr->_errno == 0
   14fe8:	fff00793          	li	a5,-1
   14fec:	0ef50063          	beq	a0,a5,150cc <__sflush_r+0x1b0>
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   14ff0:	00c45683          	lhu	a3,12(s0)
   14ff4:	fffff7b7          	lui	a5,0xfffff
   14ff8:	7ff78793          	addi	a5,a5,2047 # fffff7ff <_gp+0xfffe11bf>
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   14ffc:	01042703          	lw	a4,16(s0)
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   15000:	00f6f7b3          	and	a5,a3,a5
   15004:	01079793          	slli	a5,a5,0x10
   15008:	4107d793          	srai	a5,a5,0x10
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   1500c:	00e42023          	sw	a4,0(s0)
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   15010:	01379713          	slli	a4,a5,0x13
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   15014:	00f41623          	sh	a5,12(s0)
#endif
	      fp->_r = 0;
   15018:	00042223          	sw	zero,4(s0)
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   1501c:	10074463          	bltz	a4,15124 <__sflush_r+0x208>
		fp->_offset = curoff;
	      ptr->_errno = tmp_errno;
	      if (HASUB (fp))
   15020:	03042583          	lw	a1,48(s0)
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
		fp->_offset = curoff;
	      ptr->_errno = tmp_errno;
   15024:	0099a023          	sw	s1,0(s3)
	      if (HASUB (fp))
   15028:	00058c63          	beqz	a1,15040 <__sflush_r+0x124>
		FREEUB (ptr, fp);
   1502c:	04040793          	addi	a5,s0,64
   15030:	00f58663          	beq	a1,a5,1503c <__sflush_r+0x120>
   15034:	00098513          	mv	a0,s3
   15038:	664000ef          	jal	1569c <_free_r>
   1503c:	02042823          	sw	zero,48(s0)
	    {
	      fp->_flags |= __SERR;
	      return EOF;
	    }
	}
      return 0;
   15040:	00000513          	li	a0,0
	}
      p += t;
      n -= t;
    }
  return 0;
}
   15044:	01c12083          	lw	ra,28(sp)
   15048:	01812403          	lw	s0,24(sp)
   1504c:	01412483          	lw	s1,20(sp)
   15050:	01012903          	lw	s2,16(sp)
   15054:	00c12983          	lw	s3,12(sp)
   15058:	02010113          	addi	sp,sp,32
   1505c:	00008067          	ret
	      return EOF;
	    }
	}
      return 0;
    }
  if ((p = fp->_bf._base) == NULL)
   15060:	0105a903          	lw	s2,16(a1)
   15064:	fc090ee3          	beqz	s2,15040 <__sflush_r+0x124>
    {
      /* Nothing to flush.  */
      return 0;
    }
  n = fp->_p - p;		/* write this much */
   15068:	0005a483          	lw	s1,0(a1)
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
   1506c:	00377713          	andi	a4,a4,3
  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
   15070:	0125a023          	sw	s2,0(a1)
  if ((p = fp->_bf._base) == NULL)
    {
      /* Nothing to flush.  */
      return 0;
    }
  n = fp->_p - p;		/* write this much */
   15074:	412484b3          	sub	s1,s1,s2
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
   15078:	00000793          	li	a5,0
   1507c:	00071463          	bnez	a4,15084 <__sflush_r+0x168>
   15080:	0145a783          	lw	a5,20(a1)
   15084:	00f42423          	sw	a5,8(s0)

  while (n > 0)
   15088:	00904863          	bgtz	s1,15098 <__sflush_r+0x17c>
   1508c:	fb5ff06f          	j	15040 <__sflush_r+0x124>
      if (t <= 0)
	{
          fp->_flags |= __SERR;
          return EOF;
	}
      p += t;
   15090:	00a90933          	add	s2,s2,a0
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
   15094:	fa9056e3          	blez	s1,15040 <__sflush_r+0x124>
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
   15098:	02442783          	lw	a5,36(s0)
   1509c:	01c42583          	lw	a1,28(s0)
   150a0:	00048693          	mv	a3,s1
   150a4:	00090613          	mv	a2,s2
   150a8:	00098513          	mv	a0,s3
   150ac:	000780e7          	jalr	a5
	{
          fp->_flags |= __SERR;
          return EOF;
	}
      p += t;
      n -= t;
   150b0:	40a484b3          	sub	s1,s1,a0
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
      if (t <= 0)
   150b4:	fca04ee3          	bgtz	a0,15090 <__sflush_r+0x174>
	{
          fp->_flags |= __SERR;
   150b8:	00c45783          	lhu	a5,12(s0)
          return EOF;
   150bc:	fff00513          	li	a0,-1
  while (n > 0)
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
      if (t <= 0)
	{
          fp->_flags |= __SERR;
   150c0:	0407e793          	ori	a5,a5,64
   150c4:	00f41623          	sh	a5,12(s0)
          return EOF;
   150c8:	f7dff06f          	j	15044 <__sflush_r+0x128>
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
	  if (curoff != -1 || ptr->_errno == 0
   150cc:	f2a592e3          	bne	a1,a0,14ff0 <__sflush_r+0xd4>
   150d0:	0009a703          	lw	a4,0(s3)
   150d4:	01d00793          	li	a5,29
   150d8:	fee7e0e3          	bltu	a5,a4,150b8 <__sflush_r+0x19c>
   150dc:	204007b7          	lui	a5,0x20400
   150e0:	00178793          	addi	a5,a5,1 # 20400001 <_gp+0x203e19c1>
   150e4:	00e7d7b3          	srl	a5,a5,a4
   150e8:	0017f793          	andi	a5,a5,1
   150ec:	fc0786e3          	beqz	a5,150b8 <__sflush_r+0x19c>
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   150f0:	00c45603          	lhu	a2,12(s0)
   150f4:	fffff7b7          	lui	a5,0xfffff
   150f8:	7ff78793          	addi	a5,a5,2047 # fffff7ff <_gp+0xfffe11bf>
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   150fc:	01042683          	lw	a3,16(s0)
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   15100:	00f677b3          	and	a5,a2,a5
   15104:	01079793          	slli	a5,a5,0x10
   15108:	4107d793          	srai	a5,a5,0x10
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   1510c:	00d42023          	sw	a3,0(s0)
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   15110:	01379693          	slli	a3,a5,0x13
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   15114:	00f41623          	sh	a5,12(s0)
#endif
	      fp->_r = 0;
   15118:	00042223          	sw	zero,4(s0)
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   1511c:	f006d2e3          	bgez	a3,15020 <__sflush_r+0x104>
   15120:	f00710e3          	bnez	a4,15020 <__sflush_r+0x104>
		fp->_offset = curoff;
   15124:	04a42823          	sw	a0,80(s0)
   15128:	04b42a23          	sw	a1,84(s0)
   1512c:	ef5ff06f          	j	15020 <__sflush_r+0x104>
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   15130:	03c5a703          	lw	a4,60(a1)
   15134:	e2e04ae3          	bgtz	a4,14f68 <__sflush_r+0x4c>
   15138:	f09ff06f          	j	15040 <__sflush_r+0x124>
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
   1513c:	01c42583          	lw	a1,28(s0)
   15140:	00000613          	li	a2,0
   15144:	00000693          	li	a3,0
   15148:	00100713          	li	a4,1
   1514c:	00098513          	mv	a0,s3
   15150:	000800e7          	jalr	a6
	      if (curoff == -1L && ptr->_errno != 0)
   15154:	fff00793          	li	a5,-1
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
   15158:	00050613          	mv	a2,a0
   1515c:	00058693          	mv	a3,a1
	      if (curoff == -1L && ptr->_errno != 0)
   15160:	00f50863          	beq	a0,a5,15170 <__sflush_r+0x254>
   15164:	00c45783          	lhu	a5,12(s0)
   15168:	02842803          	lw	a6,40(s0)
   1516c:	e25ff06f          	j	14f90 <__sflush_r+0x74>
   15170:	fea59ae3          	bne	a1,a0,15164 <__sflush_r+0x248>
   15174:	0009a783          	lw	a5,0(s3)
   15178:	fe0786e3          	beqz	a5,15164 <__sflush_r+0x248>
		{
		  int result = EOF;
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
   1517c:	01d00713          	li	a4,29
   15180:	00e78663          	beq	a5,a4,1518c <__sflush_r+0x270>
   15184:	01600713          	li	a4,22
   15188:	00e79863          	bne	a5,a4,15198 <__sflush_r+0x27c>
		    {
		      result = 0;
		      ptr->_errno = tmp_errno;
   1518c:	0099a023          	sw	s1,0(s3)
	      if (curoff == -1L && ptr->_errno != 0)
		{
		  int result = EOF;
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
		    {
		      result = 0;
   15190:	00000513          	li	a0,0
		      ptr->_errno = tmp_errno;
   15194:	eb1ff06f          	j	15044 <__sflush_r+0x128>
		    }
		  else
		    fp->_flags |= __SERR;
   15198:	00c45783          	lhu	a5,12(s0)
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
	      if (curoff == -1L && ptr->_errno != 0)
		{
		  int result = EOF;
   1519c:	00058513          	mv	a0,a1
		    {
		      result = 0;
		      ptr->_errno = tmp_errno;
		    }
		  else
		    fp->_flags |= __SERR;
   151a0:	0407e793          	ori	a5,a5,64
   151a4:	00f41623          	sh	a5,12(s0)
   151a8:	e9dff06f          	j	15044 <__sflush_r+0x128>

000151ac <_fflush_r>:

int
_DEFUN(_fflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   151ac:	fe010113          	addi	sp,sp,-32
   151b0:	00812c23          	sw	s0,24(sp)
   151b4:	00112e23          	sw	ra,28(sp)
   151b8:	00050413          	mv	s0,a0
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
   151bc:	00050663          	beqz	a0,151c8 <_fflush_r+0x1c>
   151c0:	03852783          	lw	a5,56(a0)
   151c4:	02078a63          	beqz	a5,151f8 <_fflush_r+0x4c>

  if (!fp->_flags)
   151c8:	00c59783          	lh	a5,12(a1)
   151cc:	00079c63          	bnez	a5,151e4 <_fflush_r+0x38>

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
  _newlib_flockfile_end (fp);
  return ret;
}
   151d0:	01c12083          	lw	ra,28(sp)
   151d4:	00000513          	li	a0,0
   151d8:	01812403          	lw	s0,24(sp)
   151dc:	02010113          	addi	sp,sp,32
   151e0:	00008067          	ret

  if (!fp->_flags)
    return 0;

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
   151e4:	00040513          	mv	a0,s0
  _newlib_flockfile_end (fp);
  return ret;
}
   151e8:	01c12083          	lw	ra,28(sp)
   151ec:	01812403          	lw	s0,24(sp)
   151f0:	02010113          	addi	sp,sp,32

  if (!fp->_flags)
    return 0;

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
   151f4:	d29ff06f          	j	14f1c <__sflush_r>
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
   151f8:	00b12623          	sw	a1,12(sp)
   151fc:	360000ef          	jal	1555c <__sinit>
   15200:	00c12583          	lw	a1,12(sp)
   15204:	fc5ff06f          	j	151c8 <_fflush_r+0x1c>

00015208 <fflush>:
#ifndef _REENT_ONLY

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
   15208:	00050593          	mv	a1,a0
  if (fp == NULL)
   1520c:	00050663          	beqz	a0,15218 <fflush+0x10>
    return _fwalk_reent (_GLOBAL_REENT, _fflush_r);

  return _fflush_r (_REENT, fp);
   15210:	8101a503          	lw	a0,-2032(gp) # 1de50 <_impure_ptr>
   15214:	f99ff06f          	j	151ac <_fflush_r>
int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
  if (fp == NULL)
    return _fwalk_reent (_GLOBAL_REENT, _fflush_r);
   15218:	80c1a503          	lw	a0,-2036(gp) # 1de4c <_global_impure_ptr>
   1521c:	000155b7          	lui	a1,0x15
   15220:	1ac58593          	addi	a1,a1,428 # 151ac <_fflush_r>
   15224:	49d0006f          	j	15ec0 <_fwalk_reent>

00015228 <__fp_unlock>:
       FILE * ptr)
{
  _funlockfile (ptr);

  return 0;
}
   15228:	00000513          	li	a0,0
   1522c:	00008067          	ret

00015230 <_cleanup_r>:
  cleanup_func = _fflush_r;
#else
  cleanup_func = _fclose_r;
#endif
#endif
  _CAST_VOID _fwalk_reent (ptr, cleanup_func);
   15230:	0001a5b7          	lui	a1,0x1a
   15234:	86858593          	addi	a1,a1,-1944 # 19868 <_fclose_r>
   15238:	4890006f          	j	15ec0 <_fwalk_reent>

0001523c <__sinit.part.1>:
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   1523c:	fe010113          	addi	sp,sp,-32
      __sinit_lock_release ();
      return;
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
   15240:	000157b7          	lui	a5,0x15
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   15244:	00812c23          	sw	s0,24(sp)
      __sinit_lock_release ();
      return;
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
   15248:	23078793          	addi	a5,a5,560 # 15230 <_cleanup_r>
  s->_stdin = __sfp(s);
  s->_stdout = __sfp(s);
  s->_stderr = __sfp(s);
#endif

  std (s->_stdin,  __SRD, 0, s);
   1524c:	00452403          	lw	s0,4(a0)
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   15250:	00112e23          	sw	ra,28(sp)
   15254:	00912a23          	sw	s1,20(sp)
   15258:	01212823          	sw	s2,16(sp)
   1525c:	01312623          	sw	s3,12(sp)
   15260:	01412423          	sw	s4,8(sp)
   15264:	01512223          	sw	s5,4(sp)
   15268:	01612023          	sw	s6,0(sp)
      __sinit_lock_release ();
      return;
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
   1526c:	02f52e23          	sw	a5,60(a0)

  s->__sglue._next = NULL;
#ifndef _REENT_SMALL
  s->__sglue._niobs = 3;
   15270:	00300793          	li	a5,3
   15274:	2ef52223          	sw	a5,740(a0)
  s->__sglue._iobs = &s->__sf[0];
   15278:	2f050713          	addi	a4,a0,752
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   1527c:	00400793          	li	a5,4
  s->__cleanup = _cleanup_r;	/* conservative */

  s->__sglue._next = NULL;
#ifndef _REENT_SMALL
  s->__sglue._niobs = 3;
  s->__sglue._iobs = &s->__sf[0];
   15280:	2ee52423          	sw	a4,744(a0)
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */

  s->__sglue._next = NULL;
   15284:	2e052023          	sw	zero,736(a0)
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   15288:	00050913          	mv	s2,a0
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   1528c:	00f41623          	sh	a5,12(s0)
  ptr->_flags2 = 0;
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   15290:	00800613          	li	a2,8
   15294:	00000593          	li	a1,0
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
  ptr->_p = 0;
   15298:	00042023          	sw	zero,0(s0)
  ptr->_r = 0;
   1529c:	00042223          	sw	zero,4(s0)
  ptr->_w = 0;
   152a0:	00042423          	sw	zero,8(s0)
  ptr->_flags = flags;
  ptr->_flags2 = 0;
   152a4:	06042423          	sw	zero,104(s0)
  ptr->_file = file;
   152a8:	00041723          	sh	zero,14(s0)
  ptr->_bf._base = 0;
   152ac:	00042823          	sw	zero,16(s0)
  ptr->_bf._size = 0;
   152b0:	00042a23          	sw	zero,20(s0)
  ptr->_lbfsize = 0;
   152b4:	00042c23          	sw	zero,24(s0)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   152b8:	06040513          	addi	a0,s0,96
   152bc:	1a9010ef          	jal	16c64 <memset>
     requires both stdin and stdout to be line-buffered, but tradition
     leaves stdin alone on systems without fcntl.  */
#ifdef HAVE_FCNTL
  std (s->_stdout, __SWR, 1, s);
#else
  std (s->_stdout, __SWR | __SLBF, 1, s);
   152c0:	00892483          	lw	s1,8(s2)
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   152c4:	00018b37          	lui	s6,0x18
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   152c8:	00018ab7          	lui	s5,0x18
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   152cc:	00018a37          	lui	s4,0x18
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   152d0:	000189b7          	lui	s3,0x18
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   152d4:	348b0b13          	addi	s6,s6,840 # 18348 <__sread>
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   152d8:	3cca8a93          	addi	s5,s5,972 # 183cc <__swrite>
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   152dc:	444a0a13          	addi	s4,s4,1092 # 18444 <__sseek>
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   152e0:	4b098993          	addi	s3,s3,1200 # 184b0 <__sclose>
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   152e4:	00900793          	li	a5,9
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   152e8:	03642023          	sw	s6,32(s0)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   152ec:	03542223          	sw	s5,36(s0)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   152f0:	03442423          	sw	s4,40(s0)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   152f4:	03342623          	sw	s3,44(s0)
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
   152f8:	00842e23          	sw	s0,28(s0)
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   152fc:	00f49623          	sh	a5,12(s1)
  ptr->_flags2 = 0;
  ptr->_file = file;
   15300:	00100793          	li	a5,1
   15304:	00f49723          	sh	a5,14(s1)
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   15308:	00800613          	li	a2,8
   1530c:	00000593          	li	a1,0
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
  ptr->_p = 0;
   15310:	0004a023          	sw	zero,0(s1)
  ptr->_r = 0;
   15314:	0004a223          	sw	zero,4(s1)
  ptr->_w = 0;
   15318:	0004a423          	sw	zero,8(s1)
  ptr->_flags = flags;
  ptr->_flags2 = 0;
   1531c:	0604a423          	sw	zero,104(s1)
  ptr->_file = file;
  ptr->_bf._base = 0;
   15320:	0004a823          	sw	zero,16(s1)
  ptr->_bf._size = 0;
   15324:	0004aa23          	sw	zero,20(s1)
  ptr->_lbfsize = 0;
   15328:	0004ac23          	sw	zero,24(s1)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   1532c:	06048513          	addi	a0,s1,96
   15330:	135010ef          	jal	16c64 <memset>
  std (s->_stdout, __SWR | __SLBF, 1, s);
#endif

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);
   15334:	00c92403          	lw	s0,12(s2)
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   15338:	01200793          	li	a5,18
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   1533c:	0364a023          	sw	s6,32(s1)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   15340:	0354a223          	sw	s5,36(s1)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   15344:	0344a423          	sw	s4,40(s1)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   15348:	0334a623          	sw	s3,44(s1)
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
   1534c:	0094ae23          	sw	s1,28(s1)
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   15350:	00f41623          	sh	a5,12(s0)
  ptr->_flags2 = 0;
  ptr->_file = file;
   15354:	00200793          	li	a5,2
   15358:	00f41723          	sh	a5,14(s0)
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
  ptr->_p = 0;
   1535c:	00042023          	sw	zero,0(s0)
  ptr->_r = 0;
   15360:	00042223          	sw	zero,4(s0)
  ptr->_w = 0;
   15364:	00042423          	sw	zero,8(s0)
  ptr->_flags = flags;
  ptr->_flags2 = 0;
   15368:	06042423          	sw	zero,104(s0)
  ptr->_file = file;
  ptr->_bf._base = 0;
   1536c:	00042823          	sw	zero,16(s0)
  ptr->_bf._size = 0;
   15370:	00042a23          	sw	zero,20(s0)
  ptr->_lbfsize = 0;
   15374:	00042c23          	sw	zero,24(s0)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   15378:	06040513          	addi	a0,s0,96
   1537c:	00800613          	li	a2,8
   15380:	00000593          	li	a1,0
   15384:	0e1010ef          	jal	16c64 <memset>
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;

  __sinit_lock_release ();
}
   15388:	01c12083          	lw	ra,28(sp)

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;
   1538c:	00100793          	li	a5,1
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   15390:	03642023          	sw	s6,32(s0)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   15394:	03542223          	sw	s5,36(s0)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   15398:	03442423          	sw	s4,40(s0)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   1539c:	03342623          	sw	s3,44(s0)
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
   153a0:	00842e23          	sw	s0,28(s0)
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;

  __sinit_lock_release ();
}
   153a4:	01412483          	lw	s1,20(sp)

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;
   153a8:	02f92c23          	sw	a5,56(s2)

  __sinit_lock_release ();
}
   153ac:	01812403          	lw	s0,24(sp)
   153b0:	01012903          	lw	s2,16(sp)
   153b4:	00c12983          	lw	s3,12(sp)
   153b8:	00812a03          	lw	s4,8(sp)
   153bc:	00412a83          	lw	s5,4(sp)
   153c0:	00012b03          	lw	s6,0(sp)
   153c4:	02010113          	addi	sp,sp,32
   153c8:	00008067          	ret

000153cc <__fp_lock>:
   153cc:	00000513          	li	a0,0
   153d0:	00008067          	ret

000153d4 <__sfmoreglue>:

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   153d4:	ff010113          	addi	sp,sp,-16
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
   153d8:	fff58793          	addi	a5,a1,-1

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   153dc:	00812423          	sw	s0,8(sp)
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
   153e0:	00479413          	slli	s0,a5,0x4
   153e4:	00779793          	slli	a5,a5,0x7
   153e8:	40878433          	sub	s0,a5,s0

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   153ec:	01212023          	sw	s2,0(sp)
   153f0:	00058913          	mv	s2,a1
  struct glue_with_file *g;

  g = (struct glue_with_file *)
   153f4:	08040593          	addi	a1,s0,128

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   153f8:	00912223          	sw	s1,4(sp)
   153fc:	00112623          	sw	ra,12(sp)
  struct glue_with_file *g;

  g = (struct glue_with_file *)
   15400:	5d9000ef          	jal	161d8 <_malloc_r>
   15404:	00050493          	mv	s1,a0
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  if (g == NULL)
   15408:	02050063          	beqz	a0,15428 <__sfmoreglue+0x54>
    return NULL;
  g->glue._next = NULL;
  g->glue._niobs = n;
  g->glue._iobs = &g->file;
   1540c:	01050513          	addi	a0,a0,16

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  if (g == NULL)
    return NULL;
  g->glue._next = NULL;
   15410:	0004a023          	sw	zero,0(s1)
  g->glue._niobs = n;
   15414:	0124a223          	sw	s2,4(s1)
  g->glue._iobs = &g->file;
   15418:	00a4a423          	sw	a0,8(s1)
  memset (&g->file, 0, n * sizeof (FILE));
   1541c:	07040613          	addi	a2,s0,112
   15420:	00000593          	li	a1,0
   15424:	041010ef          	jal	16c64 <memset>
  return &g->glue;
}
   15428:	00c12083          	lw	ra,12(sp)
   1542c:	00048513          	mv	a0,s1
   15430:	00812403          	lw	s0,8(sp)
   15434:	00412483          	lw	s1,4(sp)
   15438:	00012903          	lw	s2,0(sp)
   1543c:	01010113          	addi	sp,sp,16
   15440:	00008067          	ret

00015444 <__sfp>:
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
   15444:	fe010113          	addi	sp,sp,-32
   15448:	01212823          	sw	s2,16(sp)
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
   1544c:	80c1a903          	lw	s2,-2036(gp) # 1de4c <_global_impure_ptr>
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
   15450:	01312623          	sw	s3,12(sp)
   15454:	00112e23          	sw	ra,28(sp)
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
   15458:	03892783          	lw	a5,56(s2)
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
   1545c:	00812c23          	sw	s0,24(sp)
   15460:	00912a23          	sw	s1,20(sp)
   15464:	00050993          	mv	s3,a0
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
   15468:	00079663          	bnez	a5,15474 <__sfp+0x30>
   1546c:	00090513          	mv	a0,s2
   15470:	dcdff0ef          	jal	1523c <__sinit.part.1>
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
   15474:	2e090913          	addi	s2,s2,736
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   15478:	fff00493          	li	s1,-1
   1547c:	00492783          	lw	a5,4(s2)
   15480:	00892403          	lw	s0,8(s2)
   15484:	fff78793          	addi	a5,a5,-1
   15488:	0007da63          	bgez	a5,1549c <__sfp+0x58>
   1548c:	0840006f          	j	15510 <__sfp+0xcc>
   15490:	fff78793          	addi	a5,a5,-1
   15494:	07040413          	addi	s0,s0,112
   15498:	06978c63          	beq	a5,s1,15510 <__sfp+0xcc>
	if (fp->_flags == 0)
   1549c:	00c41703          	lh	a4,12(s0)
   154a0:	fe0718e3          	bnez	a4,15490 <__sfp+0x4c>
  _newlib_sfp_lock_exit ();
  d->_errno = ENOMEM;
  return NULL;

found:
  fp->_file = -1;		/* no file */
   154a4:	fff00793          	li	a5,-1
   154a8:	00f41723          	sh	a5,14(s0)
  fp->_flags = 1;		/* reserve this slot; caller sets real flags */
   154ac:	00100793          	li	a5,1
   154b0:	00f41623          	sh	a5,12(s0)
  fp->_flags2 = 0;
   154b4:	06042423          	sw	zero,104(s0)
#ifndef __SINGLE_THREAD__
  __lock_init_recursive (fp->_lock);
#endif
  _newlib_sfp_lock_end ();

  fp->_p = NULL;		/* no current pointer */
   154b8:	00042023          	sw	zero,0(s0)
  fp->_w = 0;			/* nothing to read or write */
   154bc:	00042423          	sw	zero,8(s0)
  fp->_r = 0;
   154c0:	00042223          	sw	zero,4(s0)
  fp->_bf._base = NULL;		/* no buffer */
   154c4:	00042823          	sw	zero,16(s0)
  fp->_bf._size = 0;
   154c8:	00042a23          	sw	zero,20(s0)
  fp->_lbfsize = 0;		/* not line buffered */
   154cc:	00042c23          	sw	zero,24(s0)
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
   154d0:	00800613          	li	a2,8
   154d4:	00000593          	li	a1,0
   154d8:	06040513          	addi	a0,s0,96
   154dc:	788010ef          	jal	16c64 <memset>
  /* fp->_cookie = <any>; */	/* caller sets cookie, _read/_write etc */
  fp->_ub._base = NULL;		/* no ungetc buffer */
   154e0:	02042823          	sw	zero,48(s0)
  fp->_ub._size = 0;
   154e4:	02042a23          	sw	zero,52(s0)
  fp->_lb._base = NULL;		/* no line buffer */
   154e8:	04042223          	sw	zero,68(s0)
  fp->_lb._size = 0;
   154ec:	04042423          	sw	zero,72(s0)

  return fp;
   154f0:	00040513          	mv	a0,s0
}
   154f4:	01c12083          	lw	ra,28(sp)
   154f8:	01812403          	lw	s0,24(sp)
   154fc:	01412483          	lw	s1,20(sp)
   15500:	01012903          	lw	s2,16(sp)
   15504:	00c12983          	lw	s3,12(sp)
   15508:	02010113          	addi	sp,sp,32
   1550c:	00008067          	ret
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
   15510:	00092783          	lw	a5,0(s2)
   15514:	00078663          	beqz	a5,15520 <__sfp+0xdc>
   15518:	00078913          	mv	s2,a5
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
    }
   1551c:	f61ff06f          	j	1547c <__sfp+0x38>
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
   15520:	00400593          	li	a1,4
   15524:	00098513          	mv	a0,s3
   15528:	eadff0ef          	jal	153d4 <__sfmoreglue>
   1552c:	00a92023          	sw	a0,0(s2)
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
   15530:	00050663          	beqz	a0,1553c <__sfp+0xf8>
   15534:	00050913          	mv	s2,a0
   15538:	f45ff06f          	j	1547c <__sfp+0x38>
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
    }
  _newlib_sfp_lock_exit ();
  d->_errno = ENOMEM;
   1553c:	00c00793          	li	a5,12
   15540:	00f9a023          	sw	a5,0(s3)
  return NULL;
   15544:	00000513          	li	a0,0
   15548:	fadff06f          	j	154f4 <__sfp+0xb0>

0001554c <_cleanup>:
  cleanup_func = _fflush_r;
#else
  cleanup_func = _fclose_r;
#endif
#endif
  _CAST_VOID _fwalk_reent (ptr, cleanup_func);
   1554c:	80c1a503          	lw	a0,-2036(gp) # 1de4c <_global_impure_ptr>
   15550:	0001a5b7          	lui	a1,0x1a
   15554:	86858593          	addi	a1,a1,-1944 # 19868 <_fclose_r>
   15558:	1690006f          	j	15ec0 <_fwalk_reent>

0001555c <__sinit>:
_DEFUN(__sinit, (s),
       struct _reent *s)
{
  __sinit_lock_acquire ();

  if (s->__sdidinit)
   1555c:	03852783          	lw	a5,56(a0)
   15560:	00078463          	beqz	a5,15568 <__sinit+0xc>
   15564:	00008067          	ret
   15568:	cd5ff06f          	j	1523c <__sinit.part.1>

0001556c <__sfp_lock_acquire>:
   1556c:	00008067          	ret

00015570 <__sfp_lock_release>:
   15570:	00008067          	ret

00015574 <__sinit_lock_acquire>:
   15574:	00008067          	ret

00015578 <__sinit_lock_release>:
  __lock_acquire_recursive (__sinit_lock);
}

_VOID
_DEFUN_VOID(__sinit_lock_release)
{
   15578:	00008067          	ret

0001557c <__fp_lock_all>:
_VOID
_DEFUN_VOID(__fp_lock_all)
{
  __sfp_lock_acquire ();

  _CAST_VOID _fwalk (_REENT, __fp_lock);
   1557c:	8101a503          	lw	a0,-2032(gp) # 1de50 <_impure_ptr>
   15580:	000155b7          	lui	a1,0x15
   15584:	3cc58593          	addi	a1,a1,972 # 153cc <__fp_lock>
   15588:	0890006f          	j	15e10 <_fwalk>

0001558c <__fp_unlock_all>:
}

_VOID
_DEFUN_VOID(__fp_unlock_all)
{
  _CAST_VOID _fwalk (_REENT, __fp_unlock);
   1558c:	8101a503          	lw	a0,-2032(gp) # 1de50 <_impure_ptr>
   15590:	000155b7          	lui	a1,0x15
   15594:	22858593          	addi	a1,a1,552 # 15228 <__fp_unlock>
   15598:	0790006f          	j	15e10 <_fwalk>

0001559c <_malloc_trim_r>:
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
   1559c:	fe010113          	addi	sp,sp,-32
   155a0:	01212823          	sw	s2,16(sp)

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;

  top_size = chunksize(top);
   155a4:	0001e937          	lui	s2,0x1e
   155a8:	a3890913          	addi	s2,s2,-1480 # 1da38 <__malloc_av_>
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
   155ac:	00812c23          	sw	s0,24(sp)
   155b0:	00912a23          	sw	s1,20(sp)
   155b4:	00058413          	mv	s0,a1
   155b8:	01312623          	sw	s3,12(sp)
   155bc:	00112e23          	sw	ra,28(sp)
   155c0:	00050993          	mv	s3,a0
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;
   155c4:	77c010ef          	jal	16d40 <__malloc_lock>

  top_size = chunksize(top);
   155c8:	00892703          	lw	a4,8(s2)
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
   155cc:	000017b7          	lui	a5,0x1
   155d0:	fef78593          	addi	a1,a5,-17 # fef <_reset+0xdef>

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;

  top_size = chunksize(top);
   155d4:	00472483          	lw	s1,4(a4)
   155d8:	ffc4f493          	andi	s1,s1,-4
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
   155dc:	40848433          	sub	s0,s1,s0
   155e0:	00b40433          	add	s0,s0,a1
   155e4:	00c45413          	srli	s0,s0,0xc
   155e8:	fff40413          	addi	s0,s0,-1
   155ec:	00c41413          	slli	s0,s0,0xc

  if (extra < (long)pagesz)  /* Not enough memory to release */
   155f0:	00f44c63          	blt	s0,a5,15608 <_malloc_trim_r+0x6c>
  }

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
   155f4:	00000513          	li	a0,0
   155f8:	dc9fa0ef          	jal	103c0 <sbrk>
    if (current_brk != (char*)(top) + top_size)
   155fc:	00892783          	lw	a5,8(s2)
   15600:	009787b3          	add	a5,a5,s1
   15604:	02f50663          	beq	a0,a5,15630 <_malloc_trim_r+0x94>
  top_size = chunksize(top);
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;

  if (extra < (long)pagesz)  /* Not enough memory to release */
  {
    MALLOC_UNLOCK;
   15608:	00098513          	mv	a0,s3
   1560c:	738010ef          	jal	16d44 <__malloc_unlock>
    return 0;
   15610:	00000513          	li	a0,0
	MALLOC_UNLOCK;
        return 1;
      }
    }
  }
}
   15614:	01c12083          	lw	ra,28(sp)
   15618:	01812403          	lw	s0,24(sp)
   1561c:	01412483          	lw	s1,20(sp)
   15620:	01012903          	lw	s2,16(sp)
   15624:	00c12983          	lw	s3,12(sp)
   15628:	02010113          	addi	sp,sp,32
   1562c:	00008067          	ret
      return 0;     /* Apparently we don't own memory; must fail */
    }

    else
    {
      new_brk = (char*)(MORECORE (-extra));
   15630:	40800533          	neg	a0,s0
   15634:	d8dfa0ef          	jal	103c0 <sbrk>
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
   15638:	fff00793          	li	a5,-1
   1563c:	02f50863          	beq	a0,a5,1566c <_malloc_trim_r+0xd0>

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
        sbrked_mem -= extra;
   15640:	8bc1a783          	lw	a5,-1860(gp) # 1defc <__malloc_current_mallinfo>
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
   15644:	00892683          	lw	a3,8(s2)
   15648:	408484b3          	sub	s1,s1,s0
   1564c:	0014e493          	ori	s1,s1,1
        sbrked_mem -= extra;
   15650:	40878433          	sub	s0,a5,s0
        check_chunk(top);
	MALLOC_UNLOCK;
   15654:	00098513          	mv	a0,s3
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
   15658:	0096a223          	sw	s1,4(a3) # fcc00004 <_gp+0xfcbe19c4>
        sbrked_mem -= extra;
   1565c:	8a81ae23          	sw	s0,-1860(gp) # 1defc <__malloc_current_mallinfo>
        check_chunk(top);
	MALLOC_UNLOCK;
   15660:	6e4010ef          	jal	16d44 <__malloc_unlock>
        return 1;
   15664:	00100513          	li	a0,1
   15668:	fadff06f          	j	15614 <_malloc_trim_r+0x78>
      new_brk = (char*)(MORECORE (-extra));
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
   1566c:	00000513          	li	a0,0
   15670:	d51fa0ef          	jal	103c0 <sbrk>
        top_size = current_brk - (char*)top;
   15674:	00892703          	lw	a4,8(s2)
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
   15678:	00f00693          	li	a3,15
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
        top_size = current_brk - (char*)top;
   1567c:	40e507b3          	sub	a5,a0,a4
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
   15680:	f8f6d4e3          	ble	a5,a3,15608 <_malloc_trim_r+0x6c>
        {
          sbrked_mem = current_brk - sbrk_base;
   15684:	8181a683          	lw	a3,-2024(gp) # 1de58 <__malloc_sbrk_base>
          set_head(top, top_size | PREV_INUSE);
   15688:	0017e793          	ori	a5,a5,1
   1568c:	00f72223          	sw	a5,4(a4)
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
        top_size = current_brk - (char*)top;
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
        {
          sbrked_mem = current_brk - sbrk_base;
   15690:	40d50533          	sub	a0,a0,a3
   15694:	8aa1ae23          	sw	a0,-1860(gp) # 1defc <__malloc_current_mallinfo>
   15698:	f71ff06f          	j	15608 <_malloc_trim_r+0x6c>

0001569c <_free_r>:
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
   1569c:	0e058e63          	beqz	a1,15798 <_free_r+0xfc>
#if __STD_C
void fREe(RARG Void_t* mem)
#else
void fREe(RARG mem) RDECL Void_t* mem;
#endif
{
   156a0:	ff010113          	addi	sp,sp,-16
   156a4:	00812423          	sw	s0,8(sp)
   156a8:	00058413          	mv	s0,a1
   156ac:	00912223          	sw	s1,4(sp)
   156b0:	00112623          	sw	ra,12(sp)
   156b4:	00050493          	mv	s1,a0
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
    return;

  MALLOC_LOCK;
   156b8:	688010ef          	jal	16d40 <__malloc_lock>

  p = mem2chunk(mem);
  hd = p->size;
   156bc:	ffc42503          	lw	a0,-4(s0)
  if (mem == 0)                              /* free(0) has no effect */
    return;

  MALLOC_LOCK;

  p = mem2chunk(mem);
   156c0:	ff840613          	addi	a2,s0,-8
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
   156c4:	0001e5b7          	lui	a1,0x1e
  }
#endif
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
   156c8:	ffe57793          	andi	a5,a0,-2
  next = chunk_at_offset(p, sz);
   156cc:	00f606b3          	add	a3,a2,a5
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
   156d0:	a3858593          	addi	a1,a1,-1480 # 1da38 <__malloc_av_>
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
   156d4:	0046a703          	lw	a4,4(a3)
  
  if (next == top)                            /* merge with top */
   156d8:	0085a803          	lw	a6,8(a1)
  {
    sz += nextsz;

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
   156dc:	00157513          	andi	a0,a0,1
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
   156e0:	ffc77713          	andi	a4,a4,-4
  
  if (next == top)                            /* merge with top */
   156e4:	15068463          	beq	a3,a6,1582c <_free_r+0x190>
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
    return;
  }

  set_head(next, nextsz);                    /* clear inuse bit */
   156e8:	00e6a223          	sw	a4,4(a3)

  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
   156ec:	02051663          	bnez	a0,15718 <_free_r+0x7c>
  {
    prevsz = p->prev_size;
   156f0:	ff842503          	lw	a0,-8(s0)
    p = chunk_at_offset(p, -prevsz);
   156f4:	40a60633          	sub	a2,a2,a0
    sz += prevsz;
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
   156f8:	00862803          	lw	a6,8(a2)

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
  {
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -prevsz);
    sz += prevsz;
   156fc:	00a787b3          	add	a5,a5,a0
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
   15700:	0001e537          	lui	a0,0x1e
   15704:	a4050513          	addi	a0,a0,-1472 # 1da40 <__malloc_av_+0x8>
   15708:	16a80663          	beq	a6,a0,15874 <_free_r+0x1d8>
      islr = 1;
    else
      unlink(p, bck, fwd);
   1570c:	00c62503          	lw	a0,12(a2)
   15710:	00a82623          	sw	a0,12(a6)
   15714:	01052423          	sw	a6,8(a0)
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
   15718:	00e68533          	add	a0,a3,a4
   1571c:	00452503          	lw	a0,4(a0)
   15720:	00157513          	andi	a0,a0,1
   15724:	0c050a63          	beqz	a0,157f8 <_free_r+0x15c>
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   15728:	0017e693          	ori	a3,a5,1
  set_foot(p, sz);
   1572c:	00f60733          	add	a4,a2,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   15730:	00d62223          	sw	a3,4(a2)
  set_foot(p, sz);
   15734:	00f72023          	sw	a5,0(a4)
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   15738:	1ff00713          	li	a4,511
   1573c:	06f76063          	bltu	a4,a5,1579c <_free_r+0x100>
   15740:	0037d793          	srli	a5,a5,0x3
   15744:	00178713          	addi	a4,a5,1
   15748:	00371713          	slli	a4,a4,0x3
   1574c:	0045a683          	lw	a3,4(a1)
   15750:	00e58733          	add	a4,a1,a4
   15754:	00072803          	lw	a6,0(a4)
   15758:	4027d793          	srai	a5,a5,0x2
   1575c:	00100513          	li	a0,1
   15760:	00f517b3          	sll	a5,a0,a5
   15764:	00d7e7b3          	or	a5,a5,a3
   15768:	ff870693          	addi	a3,a4,-8
   1576c:	00d62623          	sw	a3,12(a2)
   15770:	01062423          	sw	a6,8(a2)
   15774:	00f5a223          	sw	a5,4(a1)
   15778:	00c72023          	sw	a2,0(a4)
   1577c:	00c82623          	sw	a2,12(a6)

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
   15780:	00048513          	mv	a0,s1
    frontlink(p, sz, idx, bck, fwd);  

  MALLOC_UNLOCK;

#endif /* MALLOC_PROVIDED */
}
   15784:	00c12083          	lw	ra,12(sp)
   15788:	00812403          	lw	s0,8(sp)
   1578c:	00412483          	lw	s1,4(sp)
   15790:	01010113          	addi	sp,sp,16

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
   15794:	5b00106f          	j	16d44 <__malloc_unlock>
   15798:	00008067          	ret


  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   1579c:	0097d713          	srli	a4,a5,0x9
   157a0:	00400693          	li	a3,4
   157a4:	10e6e463          	bltu	a3,a4,158ac <_free_r+0x210>
   157a8:	0067d713          	srli	a4,a5,0x6
   157ac:	03970513          	addi	a0,a4,57
   157b0:	03870693          	addi	a3,a4,56
   157b4:	00151513          	slli	a0,a0,0x1
   157b8:	00251513          	slli	a0,a0,0x2
   157bc:	00a58533          	add	a0,a1,a0
   157c0:	00052703          	lw	a4,0(a0)
   157c4:	ff850513          	addi	a0,a0,-8
   157c8:	0ee50e63          	beq	a0,a4,158c4 <_free_r+0x228>
   157cc:	00472683          	lw	a3,4(a4)
   157d0:	ffc6f693          	andi	a3,a3,-4
   157d4:	00d7f663          	bleu	a3,a5,157e0 <_free_r+0x144>
   157d8:	00872703          	lw	a4,8(a4)
   157dc:	fee518e3          	bne	a0,a4,157cc <_free_r+0x130>
   157e0:	00c72503          	lw	a0,12(a4)
   157e4:	00a62623          	sw	a0,12(a2)
   157e8:	00e62423          	sw	a4,8(a2)
   157ec:	00c52423          	sw	a2,8(a0)
   157f0:	00c72623          	sw	a2,12(a4)
   157f4:	f8dff06f          	j	15780 <_free_r+0xe4>
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
   157f8:	0086a503          	lw	a0,8(a3)
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
   157fc:	00e787b3          	add	a5,a5,a4
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
   15800:	0001e737          	lui	a4,0x1e
   15804:	a4070713          	addi	a4,a4,-1472 # 1da40 <__malloc_av_+0x8>
   15808:	0ce50e63          	beq	a0,a4,158e4 <_free_r+0x248>
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   1580c:	00c6a803          	lw	a6,12(a3)
  }


  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
   15810:	00f60733          	add	a4,a2,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   15814:	0017e693          	ori	a3,a5,1
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   15818:	01052623          	sw	a6,12(a0)
   1581c:	00a82423          	sw	a0,8(a6)
  }


  set_head(p, sz | PREV_INUSE);
   15820:	00d62223          	sw	a3,4(a2)
  set_foot(p, sz);
   15824:	00f72023          	sw	a5,0(a4)
   15828:	f11ff06f          	j	15738 <_free_r+0x9c>
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
  {
    sz += nextsz;
   1582c:	00e787b3          	add	a5,a5,a4

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
   15830:	02051063          	bnez	a0,15850 <_free_r+0x1b4>
    {
      prevsz = p->prev_size;
   15834:	ff842503          	lw	a0,-8(s0)
      p = chunk_at_offset(p, -prevsz);
   15838:	40a60633          	sub	a2,a2,a0
      sz += prevsz;
      unlink(p, bck, fwd);
   1583c:	00c62703          	lw	a4,12(a2)
   15840:	00862683          	lw	a3,8(a2)

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
    {
      prevsz = p->prev_size;
      p = chunk_at_offset(p, -prevsz);
      sz += prevsz;
   15844:	00a787b3          	add	a5,a5,a0
      unlink(p, bck, fwd);
   15848:	00e6a623          	sw	a4,12(a3)
   1584c:	00d72423          	sw	a3,8(a4)
    }

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
   15850:	81c1a703          	lw	a4,-2020(gp) # 1de5c <__malloc_trim_threshold>
      p = chunk_at_offset(p, -prevsz);
      sz += prevsz;
      unlink(p, bck, fwd);
    }

    set_head(p, sz | PREV_INUSE);
   15854:	0017e693          	ori	a3,a5,1
   15858:	00d62223          	sw	a3,4(a2)
    top = p;
   1585c:	00c5a423          	sw	a2,8(a1)
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
   15860:	f2e7e0e3          	bltu	a5,a4,15780 <_free_r+0xe4>
      malloc_trim(RCALL top_pad); 
   15864:	8981a583          	lw	a1,-1896(gp) # 1ded8 <__malloc_top_pad>
   15868:	00048513          	mv	a0,s1
   1586c:	d31ff0ef          	jal	1559c <_malloc_trim_r>
   15870:	f11ff06f          	j	15780 <_free_r+0xe4>
      islr = 1;
    else
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
   15874:	00e685b3          	add	a1,a3,a4
   15878:	0045a583          	lw	a1,4(a1)
   1587c:	0015f593          	andi	a1,a1,1
   15880:	0e059263          	bnez	a1,15964 <_free_r+0x2c8>
   15884:	0086a583          	lw	a1,8(a3)
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   15888:	00c6a683          	lw	a3,12(a3)
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
   1588c:	00f707b3          	add	a5,a4,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   15890:	0017e513          	ori	a0,a5,1
  set_foot(p, sz);
   15894:	00f60733          	add	a4,a2,a5
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   15898:	00d5a623          	sw	a3,12(a1)
   1589c:	00b6a423          	sw	a1,8(a3)
  }


  set_head(p, sz | PREV_INUSE);
   158a0:	00a62223          	sw	a0,4(a2)
  set_foot(p, sz);
   158a4:	00f72023          	sw	a5,0(a4)
   158a8:	ed9ff06f          	j	15780 <_free_r+0xe4>
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   158ac:	01400693          	li	a3,20
   158b0:	04e6ec63          	bltu	a3,a4,15908 <_free_r+0x26c>
   158b4:	05c70513          	addi	a0,a4,92
   158b8:	05b70693          	addi	a3,a4,91
   158bc:	00151513          	slli	a0,a0,0x1
   158c0:	ef9ff06f          	j	157b8 <_free_r+0x11c>
   158c4:	0045a783          	lw	a5,4(a1)
   158c8:	4026d713          	srai	a4,a3,0x2
   158cc:	00100693          	li	a3,1
   158d0:	00e69733          	sll	a4,a3,a4
   158d4:	00f76733          	or	a4,a4,a5
   158d8:	00e5a223          	sw	a4,4(a1)
   158dc:	00050713          	mv	a4,a0
   158e0:	f05ff06f          	j	157e4 <_free_r+0x148>
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   158e4:	0017e693          	ori	a3,a5,1
  set_foot(p, sz);
   158e8:	00f60733          	add	a4,a2,a5
    sz += nextsz;
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
    {
      islr = 1;
      link_last_remainder(p);   
   158ec:	00c5aa23          	sw	a2,20(a1)
   158f0:	00c5a823          	sw	a2,16(a1)
   158f4:	00a62623          	sw	a0,12(a2)
   158f8:	00a62423          	sw	a0,8(a2)
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   158fc:	00d62223          	sw	a3,4(a2)
  set_foot(p, sz);
   15900:	00f72023          	sw	a5,0(a4)
   15904:	e7dff06f          	j	15780 <_free_r+0xe4>
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   15908:	05400693          	li	a3,84
   1590c:	00e6ec63          	bltu	a3,a4,15924 <_free_r+0x288>
   15910:	00c7d713          	srli	a4,a5,0xc
   15914:	06f70513          	addi	a0,a4,111
   15918:	06e70693          	addi	a3,a4,110
   1591c:	00151513          	slli	a0,a0,0x1
   15920:	e99ff06f          	j	157b8 <_free_r+0x11c>
   15924:	15400693          	li	a3,340
   15928:	00e6ec63          	bltu	a3,a4,15940 <_free_r+0x2a4>
   1592c:	00f7d713          	srli	a4,a5,0xf
   15930:	07870513          	addi	a0,a4,120
   15934:	07770693          	addi	a3,a4,119
   15938:	00151513          	slli	a0,a0,0x1
   1593c:	e7dff06f          	j	157b8 <_free_r+0x11c>
   15940:	55400813          	li	a6,1364
   15944:	0fe00513          	li	a0,254
   15948:	07e00693          	li	a3,126
   1594c:	e6e866e3          	bltu	a6,a4,157b8 <_free_r+0x11c>
   15950:	0127d713          	srli	a4,a5,0x12
   15954:	07d70513          	addi	a0,a4,125
   15958:	07c70693          	addi	a3,a4,124
   1595c:	00151513          	slli	a0,a0,0x1
   15960:	e59ff06f          	j	157b8 <_free_r+0x11c>
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   15964:	0017e693          	ori	a3,a5,1
  set_foot(p, sz);
   15968:	00f60733          	add	a4,a2,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   1596c:	00d62223          	sw	a3,4(a2)
  set_foot(p, sz);
   15970:	00f72023          	sw	a5,0(a4)
   15974:	e0dff06f          	j	15780 <_free_r+0xe4>

00015978 <__sfvwrite_r>:
  register struct __siov *iov;
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
   15978:	00862783          	lw	a5,8(a2)
   1597c:	1a078e63          	beqz	a5,15b38 <__sfvwrite_r+0x1c0>
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   15980:	00c5d703          	lhu	a4,12(a1)
int
_DEFUN(__sfvwrite_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       register FILE *fp _AND
       register struct __suio *uio)
{
   15984:	fd010113          	addi	sp,sp,-48
   15988:	02812423          	sw	s0,40(sp)

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   1598c:	00877793          	andi	a5,a4,8
int
_DEFUN(__sfvwrite_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       register FILE *fp _AND
       register struct __suio *uio)
{
   15990:	01412c23          	sw	s4,24(sp)
   15994:	01512a23          	sw	s5,20(sp)
   15998:	02112623          	sw	ra,44(sp)
   1599c:	02912223          	sw	s1,36(sp)
   159a0:	03212023          	sw	s2,32(sp)
   159a4:	01312e23          	sw	s3,28(sp)
   159a8:	01612823          	sw	s6,16(sp)
   159ac:	01712623          	sw	s7,12(sp)
   159b0:	01812423          	sw	s8,8(sp)
   159b4:	01912223          	sw	s9,4(sp)
   159b8:	01a12023          	sw	s10,0(sp)
   159bc:	00058413          	mv	s0,a1
   159c0:	00050a93          	mv	s5,a0
   159c4:	00060a13          	mv	s4,a2

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   159c8:	0a078463          	beqz	a5,15a70 <__sfvwrite_r+0xf8>
   159cc:	0105a783          	lw	a5,16(a1)
   159d0:	0a078063          	beqz	a5,15a70 <__sfvwrite_r+0xf8>
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   159d4:	00277793          	andi	a5,a4,2

  /* make sure we can write */
  if (cantwrite (ptr, fp))
    return EOF;

  iov = uio->uio_iov;
   159d8:	000a2483          	lw	s1,0(s4)
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   159dc:	0a078c63          	beqz	a5,15a94 <__sfvwrite_r+0x11c>
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
   159e0:	80000b37          	lui	s6,0x80000
   159e4:	00000993          	li	s3,0
   159e8:	00000913          	li	s2,0
   159ec:	c00b4b13          	xori	s6,s6,-1024
   159f0:	00098613          	mv	a2,s3
   159f4:	000a8513          	mv	a0,s5
       * Unbuffered: Split buffer in the largest multiple of BUFSIZ < INT_MAX
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
   159f8:	12090863          	beqz	s2,15b28 <__sfvwrite_r+0x1b0>
	  w = fp->_write (ptr, fp->_cookie, p,
   159fc:	00090693          	mv	a3,s2
   15a00:	012b7463          	bleu	s2,s6,15a08 <__sfvwrite_r+0x90>
   15a04:	000b0693          	mv	a3,s6
   15a08:	02442783          	lw	a5,36(s0)
   15a0c:	01c42583          	lw	a1,28(s0)
   15a10:	000780e7          	jalr	a5
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
	  if (w <= 0)
   15a14:	16a05863          	blez	a0,15b84 <__sfvwrite_r+0x20c>
	    goto err;
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
   15a18:	008a2783          	lw	a5,8(s4)
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
	  if (w <= 0)
	    goto err;
	  p += w;
   15a1c:	00a989b3          	add	s3,s3,a0
	  len -= w;
   15a20:	40a90933          	sub	s2,s2,a0
	}
      while ((uio->uio_resid -= w) != 0);
   15a24:	40a78533          	sub	a0,a5,a0
   15a28:	00aa2423          	sw	a0,8(s4)
   15a2c:	fc0512e3          	bnez	a0,159f0 <__sfvwrite_r+0x78>
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
    return 0;
   15a30:	00000793          	li	a5,0
  return 0;

err:
  fp->_flags |= __SERR;
  return EOF;
}
   15a34:	02c12083          	lw	ra,44(sp)
   15a38:	00078513          	mv	a0,a5
   15a3c:	02812403          	lw	s0,40(sp)
   15a40:	02412483          	lw	s1,36(sp)
   15a44:	02012903          	lw	s2,32(sp)
   15a48:	01c12983          	lw	s3,28(sp)
   15a4c:	01812a03          	lw	s4,24(sp)
   15a50:	01412a83          	lw	s5,20(sp)
   15a54:	01012b03          	lw	s6,16(sp)
   15a58:	00c12b83          	lw	s7,12(sp)
   15a5c:	00812c03          	lw	s8,8(sp)
   15a60:	00412c83          	lw	s9,4(sp)
   15a64:	00012d03          	lw	s10,0(sp)
   15a68:	03010113          	addi	sp,sp,48
   15a6c:	00008067          	ret

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   15a70:	00040593          	mv	a1,s0
   15a74:	000a8513          	mv	a0,s5
   15a78:	b5dfd0ef          	jal	135d4 <__swsetup_r>
    return EOF;
   15a7c:	fff00793          	li	a5,-1

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   15a80:	fa051ae3          	bnez	a0,15a34 <__sfvwrite_r+0xbc>
   15a84:	00c45703          	lhu	a4,12(s0)
    return EOF;

  iov = uio->uio_iov;
   15a88:	000a2483          	lw	s1,0(s4)
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   15a8c:	00277793          	andi	a5,a4,2
   15a90:	f40798e3          	bnez	a5,159e0 <__sfvwrite_r+0x68>
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
    }
  else if ((fp->_flags & __SLBF) == 0)
   15a94:	00177793          	andi	a5,a4,1
   15a98:	10079063          	bnez	a5,15b98 <__sfvwrite_r+0x220>
		goto err;
	    }
	  else
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
   15a9c:	80000b37          	lui	s6,0x80000
   15aa0:	00000b93          	li	s7,0
   15aa4:	00000913          	li	s2,0
   15aa8:	fffb4b13          	not	s6,s6
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
   15aac:	06090663          	beqz	s2,15b18 <__sfvwrite_r+0x1a0>
	  w = fp->_w;
	  if (fp->_flags & __SSTR)
   15ab0:	20077793          	andi	a5,a4,512
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
	  w = fp->_w;
   15ab4:	00842983          	lw	s3,8(s0)
	  if (fp->_flags & __SSTR)
   15ab8:	08078663          	beqz	a5,15b44 <__sfvwrite_r+0x1cc>
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
   15abc:	23396e63          	bltu	s2,s3,15cf8 <__sfvwrite_r+0x380>
   15ac0:	48077793          	andi	a5,a4,1152
   15ac4:	26079463          	bnez	a5,15d2c <__sfvwrite_r+0x3b4>
   15ac8:	00042503          	lw	a0,0(s0)
   15acc:	00098c13          	mv	s8,s3
		  w = len;
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
	      COPY (w);		/* copy MIN(fp->_w,len), */
   15ad0:	000c0613          	mv	a2,s8
   15ad4:	000b8593          	mv	a1,s7
   15ad8:	06c010ef          	jal	16b44 <memmove>
	      fp->_w -= w;
   15adc:	00842783          	lw	a5,8(s0)
	      fp->_p += w;
   15ae0:	00042603          	lw	a2,0(s0)
   15ae4:	00090513          	mv	a0,s2
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
	      COPY (w);		/* copy MIN(fp->_w,len), */
	      fp->_w -= w;
   15ae8:	413789b3          	sub	s3,a5,s3
	      fp->_p += w;
   15aec:	01860633          	add	a2,a2,s8
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
	      COPY (w);		/* copy MIN(fp->_w,len), */
	      fp->_w -= w;
   15af0:	01342423          	sw	s3,8(s0)
	      fp->_p += w;
   15af4:	00c42023          	sw	a2,0(s0)
		goto err;
	    }
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
   15af8:	008a2783          	lw	a5,8(s4)
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
	      w = fp->_write (ptr, fp->_cookie, p, w);
	      if (w <= 0)
		goto err;
	    }
	  p += w;
   15afc:	00ab8bb3          	add	s7,s7,a0
	  len -= w;
   15b00:	40a90933          	sub	s2,s2,a0
	}
      while ((uio->uio_resid -= w) != 0);
   15b04:	40a789b3          	sub	s3,a5,a0
   15b08:	013a2423          	sw	s3,8(s4)
   15b0c:	f20982e3          	beqz	s3,15a30 <__sfvwrite_r+0xb8>
   15b10:	00c45703          	lhu	a4,12(s0)
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
   15b14:	f8091ee3          	bnez	s2,15ab0 <__sfvwrite_r+0x138>
   15b18:	0004ab83          	lw	s7,0(s1)
   15b1c:	0044a903          	lw	s2,4(s1)
   15b20:	00848493          	addi	s1,s1,8
   15b24:	f89ff06f          	j	15aac <__sfvwrite_r+0x134>
       * Unbuffered: Split buffer in the largest multiple of BUFSIZ < INT_MAX
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
   15b28:	0004a983          	lw	s3,0(s1)
   15b2c:	0044a903          	lw	s2,4(s1)
   15b30:	00848493          	addi	s1,s1,8
   15b34:	ebdff06f          	j	159f0 <__sfvwrite_r+0x78>
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
    return 0;
   15b38:	00000793          	li	a5,0
  return 0;

err:
  fp->_flags |= __SERR;
  return EOF;
}
   15b3c:	00078513          	mv	a0,a5
   15b40:	00008067          	ret
	      COPY (w);		/* copy MIN(fp->_w,len), */
	      fp->_w -= w;
	      fp->_p += w;
	      w = len;		/* but pretend copied all */
	    }
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
   15b44:	00042503          	lw	a0,0(s0)
   15b48:	01042783          	lw	a5,16(s0)
   15b4c:	12a7ea63          	bltu	a5,a0,15c80 <__sfvwrite_r+0x308>
   15b50:	01442783          	lw	a5,20(s0)
   15b54:	12f96663          	bltu	s2,a5,15c80 <__sfvwrite_r+0x308>
		goto err;
	    }
	  else
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
   15b58:	00090693          	mv	a3,s2
   15b5c:	012b7463          	bleu	s2,s6,15b64 <__sfvwrite_r+0x1ec>
   15b60:	000b0693          	mv	a3,s6
   15b64:	02f6c6b3          	div	a3,a3,a5
	      w = fp->_write (ptr, fp->_cookie, p, w);
   15b68:	02442703          	lw	a4,36(s0)
   15b6c:	01c42583          	lw	a1,28(s0)
   15b70:	000b8613          	mv	a2,s7
   15b74:	000a8513          	mv	a0,s5
   15b78:	02f686b3          	mul	a3,a3,a5
   15b7c:	000700e7          	jalr	a4
	      if (w <= 0)
   15b80:	f6a04ce3          	bgtz	a0,15af8 <__sfvwrite_r+0x180>
   15b84:	00c41783          	lh	a5,12(s0)
      while ((uio->uio_resid -= w) != 0);
    }
  return 0;

err:
  fp->_flags |= __SERR;
   15b88:	0407e793          	ori	a5,a5,64
   15b8c:	00f41623          	sh	a5,12(s0)
  return EOF;
   15b90:	fff00793          	li	a5,-1
   15b94:	ea1ff06f          	j	15a34 <__sfvwrite_r+0xbc>
   15b98:	00000993          	li	s3,0
   15b9c:	00000c13          	li	s8,0
   15ba0:	00000d13          	li	s10,0
   15ba4:	00000913          	li	s2,0
       */
      nlknown = 0;
      nldist = 0;
      do
	{
	  GETIOV (nlknown = 0);
   15ba8:	06090c63          	beqz	s2,15c20 <__sfvwrite_r+0x2a8>
	  if (!nlknown)
   15bac:	140c0e63          	beqz	s8,15d08 <__sfvwrite_r+0x390>
	    {
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
	      nlknown = 1;
	    }
	  s = MIN (len, nldist);
   15bb0:	00098b93          	mv	s7,s3
   15bb4:	01397463          	bleu	s3,s2,15bbc <__sfvwrite_r+0x244>
   15bb8:	00090b93          	mv	s7,s2
	  w = fp->_w + fp->_bf._size;
	  if (fp->_p > fp->_bf._base && s > w)
   15bbc:	00042503          	lw	a0,0(s0)
   15bc0:	01042783          	lw	a5,16(s0)
	    {
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
	      nlknown = 1;
	    }
	  s = MIN (len, nldist);
   15bc4:	000b8b13          	mv	s6,s7
	  w = fp->_w + fp->_bf._size;
   15bc8:	01442683          	lw	a3,20(s0)
	  if (fp->_p > fp->_bf._base && s > w)
   15bcc:	00a7f863          	bleu	a0,a5,15bdc <__sfvwrite_r+0x264>
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
	      nlknown = 1;
	    }
	  s = MIN (len, nldist);
	  w = fp->_w + fp->_bf._size;
   15bd0:	00842c83          	lw	s9,8(s0)
   15bd4:	01968cb3          	add	s9,a3,s9
	  if (fp->_p > fp->_bf._base && s > w)
   15bd8:	057cce63          	blt	s9,s7,15c34 <__sfvwrite_r+0x2bc>
	      /* fp->_w -= w; */
	      fp->_p += w;
	      if (_fflush_r (ptr, fp))
		goto err;
	    }
	  else if (s >= (w = fp->_bf._size))
   15bdc:	0edbca63          	blt	s7,a3,15cd0 <__sfvwrite_r+0x358>
	    {
	      w = fp->_write (ptr, fp->_cookie, p, w);
   15be0:	02442783          	lw	a5,36(s0)
   15be4:	01c42583          	lw	a1,28(s0)
   15be8:	000d0613          	mv	a2,s10
   15bec:	000a8513          	mv	a0,s5
   15bf0:	000780e7          	jalr	a5
   15bf4:	00050b13          	mv	s6,a0
	      if (w <= 0)
   15bf8:	f8a056e3          	blez	a0,15b84 <__sfvwrite_r+0x20c>
	      w = s;
	      COPY (w);
	      fp->_w -= w;
	      fp->_p += w;
	    }
	  if ((nldist -= w) == 0)
   15bfc:	416989b3          	sub	s3,s3,s6
   15c00:	06098463          	beqz	s3,15c68 <__sfvwrite_r+0x2f0>
	      nlknown = 0;
	    }
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
   15c04:	008a2783          	lw	a5,8(s4)
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
		goto err;
	      nlknown = 0;
	    }
	  p += w;
   15c08:	016d0d33          	add	s10,s10,s6
	  len -= w;
   15c0c:	41690933          	sub	s2,s2,s6
	}
      while ((uio->uio_resid -= w) != 0);
   15c10:	41678b33          	sub	s6,a5,s6
   15c14:	016a2423          	sw	s6,8(s4)
   15c18:	e00b0ce3          	beqz	s6,15a30 <__sfvwrite_r+0xb8>
       */
      nlknown = 0;
      nldist = 0;
      do
	{
	  GETIOV (nlknown = 0);
   15c1c:	f80918e3          	bnez	s2,15bac <__sfvwrite_r+0x234>
   15c20:	0004ad03          	lw	s10,0(s1)
   15c24:	0044a903          	lw	s2,4(s1)
   15c28:	00000c13          	li	s8,0
   15c2c:	00848493          	addi	s1,s1,8
   15c30:	f79ff06f          	j	15ba8 <__sfvwrite_r+0x230>
	    }
	  s = MIN (len, nldist);
	  w = fp->_w + fp->_bf._size;
	  if (fp->_p > fp->_bf._base && s > w)
	    {
	      COPY (w);
   15c34:	000d0593          	mv	a1,s10
   15c38:	000c8613          	mv	a2,s9
   15c3c:	709000ef          	jal	16b44 <memmove>
	      /* fp->_w -= w; */
	      fp->_p += w;
   15c40:	00042783          	lw	a5,0(s0)
	      if (_fflush_r (ptr, fp))
   15c44:	00040593          	mv	a1,s0
   15c48:	000a8513          	mv	a0,s5
	  w = fp->_w + fp->_bf._size;
	  if (fp->_p > fp->_bf._base && s > w)
	    {
	      COPY (w);
	      /* fp->_w -= w; */
	      fp->_p += w;
   15c4c:	019787b3          	add	a5,a5,s9
   15c50:	00f42023          	sw	a5,0(s0)
	      if (_fflush_r (ptr, fp))
   15c54:	d58ff0ef          	jal	151ac <_fflush_r>
   15c58:	f20516e3          	bnez	a0,15b84 <__sfvwrite_r+0x20c>
   15c5c:	000c8b13          	mv	s6,s9
	      w = s;
	      COPY (w);
	      fp->_w -= w;
	      fp->_p += w;
	    }
	  if ((nldist -= w) == 0)
   15c60:	416989b3          	sub	s3,s3,s6
   15c64:	fa0990e3          	bnez	s3,15c04 <__sfvwrite_r+0x28c>
	    {
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
   15c68:	00040593          	mv	a1,s0
   15c6c:	000a8513          	mv	a0,s5
   15c70:	d3cff0ef          	jal	151ac <_fflush_r>
   15c74:	f00518e3          	bnez	a0,15b84 <__sfvwrite_r+0x20c>
		goto err;
	      nlknown = 0;
   15c78:	00000c13          	li	s8,0
   15c7c:	f89ff06f          	j	15c04 <__sfvwrite_r+0x28c>
	      w = len;		/* but pretend copied all */
	    }
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
   15c80:	01397463          	bleu	s3,s2,15c88 <__sfvwrite_r+0x310>
   15c84:	00090993          	mv	s3,s2
	      COPY (w);
   15c88:	00098613          	mv	a2,s3
   15c8c:	000b8593          	mv	a1,s7
   15c90:	6b5000ef          	jal	16b44 <memmove>
	      fp->_w -= w;
   15c94:	00842783          	lw	a5,8(s0)
	      fp->_p += w;
   15c98:	00042703          	lw	a4,0(s0)
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
	      COPY (w);
	      fp->_w -= w;
   15c9c:	413787b3          	sub	a5,a5,s3
	      fp->_p += w;
   15ca0:	01370733          	add	a4,a4,s3
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
	      COPY (w);
	      fp->_w -= w;
   15ca4:	00f42423          	sw	a5,8(s0)
	      fp->_p += w;
   15ca8:	00e42023          	sw	a4,0(s0)
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
   15cac:	00078663          	beqz	a5,15cb8 <__sfvwrite_r+0x340>
   15cb0:	00098513          	mv	a0,s3
   15cb4:	e45ff06f          	j	15af8 <__sfvwrite_r+0x180>
   15cb8:	00040593          	mv	a1,s0
   15cbc:	000a8513          	mv	a0,s5
   15cc0:	cecff0ef          	jal	151ac <_fflush_r>
   15cc4:	ec0510e3          	bnez	a0,15b84 <__sfvwrite_r+0x20c>
   15cc8:	00098513          	mv	a0,s3
   15ccc:	e2dff06f          	j	15af8 <__sfvwrite_r+0x180>
		goto err;
	    }
	  else
	    {
	      w = s;
	      COPY (w);
   15cd0:	000b8613          	mv	a2,s7
   15cd4:	000d0593          	mv	a1,s10
   15cd8:	66d000ef          	jal	16b44 <memmove>
	      fp->_w -= w;
   15cdc:	00842703          	lw	a4,8(s0)
	      fp->_p += w;
   15ce0:	00042783          	lw	a5,0(s0)
	    }
	  else
	    {
	      w = s;
	      COPY (w);
	      fp->_w -= w;
   15ce4:	41770733          	sub	a4,a4,s7
	      fp->_p += w;
   15ce8:	01778bb3          	add	s7,a5,s7
	    }
	  else
	    {
	      w = s;
	      COPY (w);
	      fp->_w -= w;
   15cec:	00e42423          	sw	a4,8(s0)
	      fp->_p += w;
   15cf0:	01742023          	sw	s7,0(s0)
   15cf4:	f09ff06f          	j	15bfc <__sfvwrite_r+0x284>
   15cf8:	00042503          	lw	a0,0(s0)
		  fp->_bf._size = newsize;
		  w = len;
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
   15cfc:	00090993          	mv	s3,s2
   15d00:	00090c13          	mv	s8,s2
   15d04:	dcdff06f          	j	15ad0 <__sfvwrite_r+0x158>
      do
	{
	  GETIOV (nlknown = 0);
	  if (!nlknown)
	    {
	      nl = memchr ((_PTR) p, '\n', len);
   15d08:	00090613          	mv	a2,s2
   15d0c:	00a00593          	li	a1,10
   15d10:	000d0513          	mv	a0,s10
   15d14:	43d000ef          	jal	16950 <memchr>
	      nldist = nl ? nl + 1 - p : len + 1;
   15d18:	0c050e63          	beqz	a0,15df4 <__sfvwrite_r+0x47c>
   15d1c:	00150513          	addi	a0,a0,1
   15d20:	41a509b3          	sub	s3,a0,s10
	      nlknown = 1;
   15d24:	00100c13          	li	s8,1
   15d28:	e89ff06f          	j	15bb0 <__sfvwrite_r+0x238>
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   15d2c:	01442983          	lw	s3,20(s0)
	  if (fp->_flags & __SSTR)
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
   15d30:	01042583          	lw	a1,16(s0)
   15d34:	00042c03          	lw	s8,0(s0)
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   15d38:	00199793          	slli	a5,s3,0x1
   15d3c:	013789b3          	add	s3,a5,s3
   15d40:	01f9d793          	srli	a5,s3,0x1f
	  if (fp->_flags & __SSTR)
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
   15d44:	40bc0c33          	sub	s8,s8,a1
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   15d48:	013789b3          	add	s3,a5,s3
		  if (newsize < curpos + len + 1)
   15d4c:	001c0793          	addi	a5,s8,1
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   15d50:	4019d993          	srai	s3,s3,0x1
		  if (newsize < curpos + len + 1)
   15d54:	012787b3          	add	a5,a5,s2
   15d58:	00098613          	mv	a2,s3
   15d5c:	00f9f663          	bleu	a5,s3,15d68 <__sfvwrite_r+0x3f0>
		    newsize = curpos + len + 1;
   15d60:	00078993          	mv	s3,a5
   15d64:	00078613          	mv	a2,a5
		  if (fp->_flags & __SOPT)
   15d68:	40077713          	andi	a4,a4,1024
   15d6c:	04070c63          	beqz	a4,15dc4 <__sfvwrite_r+0x44c>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
   15d70:	00060593          	mv	a1,a2
   15d74:	000a8513          	mv	a0,s5
   15d78:	460000ef          	jal	161d8 <_malloc_r>
   15d7c:	00050c93          	mv	s9,a0
		      if (!str)
   15d80:	08050063          	beqz	a0,15e00 <__sfvwrite_r+0x488>
			{
			  ptr->_errno = ENOMEM;
			  goto err;
			}
		      memcpy (str, fp->_bf._base, curpos);
   15d84:	01042583          	lw	a1,16(s0)
   15d88:	000c0613          	mv	a2,s8
   15d8c:	499000ef          	jal	16a24 <memcpy>
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
   15d90:	00c45783          	lhu	a5,12(s0)
   15d94:	b7f7f793          	andi	a5,a5,-1153
   15d98:	0807e793          	ori	a5,a5,128
   15d9c:	00f41623          	sh	a5,12(s0)
			  ptr->_errno = ENOMEM;
			  goto err;
			}
		    }
		  fp->_bf._base = str;
		  fp->_p = str + curpos;
   15da0:	018c8533          	add	a0,s9,s8
		  fp->_bf._size = newsize;
		  w = len;
		  fp->_w = newsize - curpos;
   15da4:	41898c33          	sub	s8,s3,s8
			  goto err;
			}
		    }
		  fp->_bf._base = str;
		  fp->_p = str + curpos;
		  fp->_bf._size = newsize;
   15da8:	01342a23          	sw	s3,20(s0)
		  w = len;
		  fp->_w = newsize - curpos;
   15dac:	01842423          	sw	s8,8(s0)
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
			  goto err;
			}
		    }
		  fp->_bf._base = str;
   15db0:	01942823          	sw	s9,16(s0)
		  fp->_p = str + curpos;
   15db4:	00a42023          	sw	a0,0(s0)
		  fp->_bf._size = newsize;
		  w = len;
   15db8:	00090993          	mv	s3,s2
   15dbc:	00090c13          	mv	s8,s2
   15dc0:	d11ff06f          	j	15ad0 <__sfvwrite_r+0x158>
		      memcpy (str, fp->_bf._base, curpos);
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
		    }
		  else
		    {
		      str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
   15dc4:	000a8513          	mv	a0,s5
   15dc8:	785010ef          	jal	17d4c <_realloc_r>
   15dcc:	00050c93          	mv	s9,a0
							 newsize);
		      if (!str)
   15dd0:	fc0518e3          	bnez	a0,15da0 <__sfvwrite_r+0x428>
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
   15dd4:	01042583          	lw	a1,16(s0)
   15dd8:	000a8513          	mv	a0,s5
   15ddc:	8c1ff0ef          	jal	1569c <_free_r>
			  fp->_flags &=  ~__SMBF;
   15de0:	00c41783          	lh	a5,12(s0)
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
   15de4:	00c00713          	li	a4,12
   15de8:	00eaa023          	sw	a4,0(s5)
		      if (!str)
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
			  fp->_flags &=  ~__SMBF;
   15dec:	f7f7f793          	andi	a5,a5,-129
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
			  goto err;
   15df0:	d99ff06f          	j	15b88 <__sfvwrite_r+0x210>
	{
	  GETIOV (nlknown = 0);
	  if (!nlknown)
	    {
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
   15df4:	00190993          	addi	s3,s2,1
	      nlknown = 1;
   15df8:	00100c13          	li	s8,1
   15dfc:	db5ff06f          	j	15bb0 <__sfvwrite_r+0x238>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
		      if (!str)
			{
			  ptr->_errno = ENOMEM;
   15e00:	00c00793          	li	a5,12
   15e04:	00faa023          	sw	a5,0(s5)
   15e08:	00c41783          	lh	a5,12(s0)
			  goto err;
   15e0c:	d7dff06f          	j	15b88 <__sfvwrite_r+0x210>

00015e10 <_fwalk>:

int
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
   15e10:	fe010113          	addi	sp,sp,-32
   15e14:	01512223          	sw	s5,4(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   15e18:	2e050a93          	addi	s5,a0,736

int
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
   15e1c:	00112e23          	sw	ra,28(sp)
   15e20:	00812c23          	sw	s0,24(sp)
   15e24:	00912a23          	sw	s1,20(sp)
   15e28:	01212823          	sw	s2,16(sp)
   15e2c:	01312623          	sw	s3,12(sp)
   15e30:	01412423          	sw	s4,8(sp)
   15e34:	01612023          	sw	s6,0(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   15e38:	080a8063          	beqz	s5,15eb8 <_fwalk+0xa8>
   15e3c:	00058b13          	mv	s6,a1
   15e40:	00000a13          	li	s4,0
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   15e44:	00100993          	li	s3,1
   15e48:	fff00913          	li	s2,-1
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   15e4c:	004aa483          	lw	s1,4(s5)
   15e50:	008aa403          	lw	s0,8(s5)
   15e54:	fff48493          	addi	s1,s1,-1
   15e58:	0204c663          	bltz	s1,15e84 <_fwalk+0x74>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   15e5c:	00c45783          	lhu	a5,12(s0)
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   15e60:	fff48493          	addi	s1,s1,-1
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   15e64:	00f9fc63          	bleu	a5,s3,15e7c <_fwalk+0x6c>
   15e68:	00e41783          	lh	a5,14(s0)
	ret |= (*function) (fp);
   15e6c:	00040513          	mv	a0,s0
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   15e70:	01278663          	beq	a5,s2,15e7c <_fwalk+0x6c>
	ret |= (*function) (fp);
   15e74:	000b00e7          	jalr	s6
   15e78:	00aa6a33          	or	s4,s4,a0
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   15e7c:	07040413          	addi	s0,s0,112
   15e80:	fd249ee3          	bne	s1,s2,15e5c <_fwalk+0x4c>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   15e84:	000aaa83          	lw	s5,0(s5)
   15e88:	fc0a92e3          	bnez	s5,15e4c <_fwalk+0x3c>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*function) (fp);

  return ret;
}
   15e8c:	01c12083          	lw	ra,28(sp)
   15e90:	000a0513          	mv	a0,s4
   15e94:	01812403          	lw	s0,24(sp)
   15e98:	01412483          	lw	s1,20(sp)
   15e9c:	01012903          	lw	s2,16(sp)
   15ea0:	00c12983          	lw	s3,12(sp)
   15ea4:	00812a03          	lw	s4,8(sp)
   15ea8:	00412a83          	lw	s5,4(sp)
   15eac:	00012b03          	lw	s6,0(sp)
   15eb0:	02010113          	addi	sp,sp,32
   15eb4:	00008067          	ret
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
  register FILE *fp;
  register int n, ret = 0;
   15eb8:	00000a13          	li	s4,0
   15ebc:	fd1ff06f          	j	15e8c <_fwalk+0x7c>

00015ec0 <_fwalk_reent>:
   I/O function (e.g. _fclose_r).  */
int
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
   15ec0:	fd010113          	addi	sp,sp,-48
   15ec4:	01612823          	sw	s6,16(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   15ec8:	2e050b13          	addi	s6,a0,736
   I/O function (e.g. _fclose_r).  */
int
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
   15ecc:	02112623          	sw	ra,44(sp)
   15ed0:	02812423          	sw	s0,40(sp)
   15ed4:	02912223          	sw	s1,36(sp)
   15ed8:	03212023          	sw	s2,32(sp)
   15edc:	01312e23          	sw	s3,28(sp)
   15ee0:	01412c23          	sw	s4,24(sp)
   15ee4:	01512a23          	sw	s5,20(sp)
   15ee8:	01712623          	sw	s7,12(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   15eec:	080b0663          	beqz	s6,15f78 <_fwalk_reent+0xb8>
   15ef0:	00058b93          	mv	s7,a1
   15ef4:	00050a93          	mv	s5,a0
   15ef8:	00000a13          	li	s4,0
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   15efc:	00100993          	li	s3,1
   15f00:	fff00913          	li	s2,-1
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   15f04:	004b2483          	lw	s1,4(s6) # 80000004 <_gp+0x7ffe19c4>
   15f08:	008b2403          	lw	s0,8(s6)
   15f0c:	fff48493          	addi	s1,s1,-1
   15f10:	0204c863          	bltz	s1,15f40 <_fwalk_reent+0x80>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   15f14:	00c45783          	lhu	a5,12(s0)
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   15f18:	fff48493          	addi	s1,s1,-1
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   15f1c:	00f9fe63          	bleu	a5,s3,15f38 <_fwalk_reent+0x78>
   15f20:	00e41783          	lh	a5,14(s0)
	ret |= (*reent_function) (ptr, fp);
   15f24:	00040593          	mv	a1,s0
   15f28:	000a8513          	mv	a0,s5
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   15f2c:	01278663          	beq	a5,s2,15f38 <_fwalk_reent+0x78>
	ret |= (*reent_function) (ptr, fp);
   15f30:	000b80e7          	jalr	s7
   15f34:	00aa6a33          	or	s4,s4,a0
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   15f38:	07040413          	addi	s0,s0,112
   15f3c:	fd249ce3          	bne	s1,s2,15f14 <_fwalk_reent+0x54>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   15f40:	000b2b03          	lw	s6,0(s6)
   15f44:	fc0b10e3          	bnez	s6,15f04 <_fwalk_reent+0x44>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*reent_function) (ptr, fp);

  return ret;
}
   15f48:	02c12083          	lw	ra,44(sp)
   15f4c:	000a0513          	mv	a0,s4
   15f50:	02812403          	lw	s0,40(sp)
   15f54:	02412483          	lw	s1,36(sp)
   15f58:	02012903          	lw	s2,32(sp)
   15f5c:	01c12983          	lw	s3,28(sp)
   15f60:	01812a03          	lw	s4,24(sp)
   15f64:	01412a83          	lw	s5,20(sp)
   15f68:	01012b03          	lw	s6,16(sp)
   15f6c:	00c12b83          	lw	s7,12(sp)
   15f70:	03010113          	addi	sp,sp,48
   15f74:	00008067          	ret
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
  register FILE *fp;
  register int n, ret = 0;
   15f78:	00000a13          	li	s4,0
   15f7c:	fcdff06f          	j	15f48 <_fwalk_reent+0x88>

00015f80 <_setlocale_r>:
char *
_DEFUN(_setlocale_r, (p, category, locale),
       struct _reent *p _AND
       int category _AND
       _CONST char *locale)
{
   15f80:	ff010113          	addi	sp,sp,-16
   15f84:	00912223          	sw	s1,4(sp)
   15f88:	00112623          	sw	ra,12(sp)
   15f8c:	00812423          	sw	s0,8(sp)
   15f90:	0001c4b7          	lui	s1,0x1c
#ifndef _MB_CAPABLE
  if (locale)
   15f94:	02060063          	beqz	a2,15fb4 <_setlocale_r+0x34>
    { 
      if (strcmp (locale, "POSIX") && strcmp (locale, "C")
   15f98:	0001c5b7          	lui	a1,0x1c
   15f9c:	17c58593          	addi	a1,a1,380 # 1c17c <__thenan_sf+0x6c>
   15fa0:	00060513          	mv	a0,a2
   15fa4:	00060413          	mv	s0,a2
   15fa8:	510020ef          	jal	184b8 <strcmp>
   15fac:	0001c4b7          	lui	s1,0x1c
   15fb0:	00051e63          	bnez	a0,15fcc <_setlocale_r+0x4c>
	  && strcmp (locale, ""))
        return NULL;
    }
  return "C";
   15fb4:	17848513          	addi	a0,s1,376 # 1c178 <__thenan_sf+0x68>
	  return NULL;
	}
    }
  return currentlocale ();
#endif /* !_MB_CAPABLE */
}
   15fb8:	00c12083          	lw	ra,12(sp)
   15fbc:	00812403          	lw	s0,8(sp)
   15fc0:	00412483          	lw	s1,4(sp)
   15fc4:	01010113          	addi	sp,sp,16
   15fc8:	00008067          	ret
       _CONST char *locale)
{
#ifndef _MB_CAPABLE
  if (locale)
    { 
      if (strcmp (locale, "POSIX") && strcmp (locale, "C")
   15fcc:	17848593          	addi	a1,s1,376
   15fd0:	00040513          	mv	a0,s0
   15fd4:	4e4020ef          	jal	184b8 <strcmp>
   15fd8:	fc050ee3          	beqz	a0,15fb4 <_setlocale_r+0x34>
	  && strcmp (locale, ""))
   15fdc:	0001c5b7          	lui	a1,0x1c
   15fe0:	14458593          	addi	a1,a1,324 # 1c144 <__thenan_sf+0x34>
   15fe4:	00040513          	mv	a0,s0
   15fe8:	4d0020ef          	jal	184b8 <strcmp>
   15fec:	fc0504e3          	beqz	a0,15fb4 <_setlocale_r+0x34>
        return NULL;
   15ff0:	00000513          	li	a0,0
   15ff4:	fc5ff06f          	j	15fb8 <_setlocale_r+0x38>

00015ff8 <__locale_charset>:
_DEFUN_VOID(__locale_charset)
{
#if 0//def __HAVE_LOCALE_INFO__
  return __get_current_ctype_locale ()->codeset;
#else
  return lc_ctype_charset;
   15ff8:	0001e537          	lui	a0,0x1e
#endif
}
   15ffc:	9c050513          	addi	a0,a0,-1600 # 1d9c0 <lc_ctype_charset>
   16000:	00008067          	ret

00016004 <__locale_mb_cur_max>:
#if 0//def __HAVE_LOCALE_INFO__
  return __get_current_ctype_locale ()->mb_cur_max[0];
#else
  return __mb_cur_max;
#endif
}
   16004:	8141a503          	lw	a0,-2028(gp) # 1de54 <__mb_cur_max>
   16008:	00008067          	ret

0001600c <__locale_msgcharset>:
_DEFUN_VOID(__locale_msgcharset)
{
#ifdef __HAVE_LOCALE_INFO__
  return (char *) __get_current_messages_locale ()->codeset;
#else
  return lc_message_charset;
   1600c:	0001e537          	lui	a0,0x1e
#endif
}
   16010:	9e050513          	addi	a0,a0,-1568 # 1d9e0 <lc_message_charset>
   16014:	00008067          	ret

00016018 <__locale_cjk_lang>:

int
_DEFUN_VOID(__locale_cjk_lang)
{
  return lc_ctype_cjk_lang;
}
   16018:	00000513          	li	a0,0
   1601c:	00008067          	ret

00016020 <_localeconv_r>:
      lconv.int_p_sign_posn = m->p_sign_posn[0];
#endif /* !__HAVE_LOCALE_INFO_EXTENDED__ */
      __mlocale_changed = 0;
    }
#endif /* __HAVE_LOCALE_INFO__ */
  return (struct lconv *) &lconv;
   16020:	0001e537          	lui	a0,0x1e
}
   16024:	a0050513          	addi	a0,a0,-1536 # 1da00 <lconv>
   16028:	00008067          	ret

0001602c <setlocale>:
char *
_DEFUN(setlocale, (category, locale),
       int category _AND
       _CONST char *locale)
{
  return _setlocale_r (_REENT, category, locale);
   1602c:	00058613          	mv	a2,a1
   16030:	00050593          	mv	a1,a0
   16034:	8101a503          	lw	a0,-2032(gp) # 1de50 <_impure_ptr>
   16038:	f49ff06f          	j	15f80 <_setlocale_r>

0001603c <localeconv>:
#endif /* __CYGWIN__ */

struct lconv *
_DEFUN_VOID(localeconv)
{
  return _localeconv_r (_REENT);
   1603c:	0001e537          	lui	a0,0x1e
}
   16040:	a0050513          	addi	a0,a0,-1536 # 1da00 <lconv>
   16044:	00008067          	ret

00016048 <__smakebuf_r>:
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
   16048:	00c59783          	lh	a5,12(a1)

_VOID
_DEFUN(__smakebuf_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE *fp)
{
   1604c:	f7010113          	addi	sp,sp,-144
   16050:	08912223          	sw	s1,132(sp)
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
   16054:	01079493          	slli	s1,a5,0x10
   16058:	0104d493          	srli	s1,s1,0x10
   1605c:	0024f713          	andi	a4,s1,2

_VOID
_DEFUN(__smakebuf_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE *fp)
{
   16060:	08112623          	sw	ra,140(sp)
   16064:	08812423          	sw	s0,136(sp)
   16068:	09212023          	sw	s2,128(sp)
   1606c:	07312e23          	sw	s3,124(sp)
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
   16070:	0e071063          	bnez	a4,16150 <__smakebuf_r+0x108>
   16074:	00050913          	mv	s2,a0
      return;
    }
#ifdef __USE_INTERNAL_STAT64
  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
   16078:	00e59503          	lh	a0,14(a1)
   1607c:	00058413          	mv	s0,a1
   16080:	04054c63          	bltz	a0,160d8 <__smakebuf_r+0x90>
   16084:	00010593          	mv	a1,sp
   16088:	94cfa0ef          	jal	101d4 <fstat>
   1608c:	04054063          	bltz	a0,160cc <__smakebuf_r+0x84>
      fp->_flags |= __SNPT;
#endif
    }
  else
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
   16090:	01012703          	lw	a4,16(sp)
   16094:	0000f7b7          	lui	a5,0xf
   16098:	ffffe9b7          	lui	s3,0xffffe
   1609c:	00f777b3          	and	a5,a4,a5
   160a0:	013789b3          	add	s3,a5,s3
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
   160a4:	00008737          	lui	a4,0x8
      fp->_flags |= __SNPT;
#endif
    }
  else
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
   160a8:	0019b993          	seqz	s3,s3
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
   160ac:	0ae78e63          	beq	a5,a4,16168 <__smakebuf_r+0x120>
#else
	  fp->_blksize = 1024;
#endif
	}
      else
	fp->_flags |= __SNPT;
   160b0:	00c45703          	lhu	a4,12(s0)
   160b4:	000017b7          	lui	a5,0x1
   160b8:	80078793          	addi	a5,a5,-2048 # 800 <_reset+0x600>
   160bc:	00f767b3          	or	a5,a4,a5
   160c0:	00f41623          	sh	a5,12(s0)
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
#ifdef HAVE_BLKSIZE
      size = st.st_blksize <= 0 ? BUFSIZ : st.st_blksize;
#else
      size = BUFSIZ;
   160c4:	40000493          	li	s1,1024
   160c8:	0340006f          	j	160fc <__smakebuf_r+0xb4>
   160cc:	00c41783          	lh	a5,12(s0)
   160d0:	01079493          	slli	s1,a5,0x10
   160d4:	0104d493          	srli	s1,s1,0x10
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   160d8:	01849493          	slli	s1,s1,0x18
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   160dc:	00001737          	lui	a4,0x1
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   160e0:	41f4d493          	srai	s1,s1,0x1f
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   160e4:	80070713          	addi	a4,a4,-2048 # 800 <_reset+0x600>
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   160e8:	c404f493          	andi	s1,s1,-960
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   160ec:	00e7e7b3          	or	a5,a5,a4
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   160f0:	40048493          	addi	s1,s1,1024
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   160f4:	00f41623          	sh	a5,12(s0)
  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
#endif
    {
      couldbetty = 0;
   160f8:	00000993          	li	s3,0
	}
      else
	fp->_flags |= __SNPT;
#endif
    }
  if ((p = _malloc_r (ptr, size)) == NULL)
   160fc:	00048593          	mv	a1,s1
   16100:	00090513          	mv	a0,s2
   16104:	0d4000ef          	jal	161d8 <_malloc_r>
   16108:	0a050263          	beqz	a0,161ac <__smakebuf_r+0x164>
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
      fp->_flags |= __SMBF;
   1610c:	00c45783          	lhu	a5,12(s0)
	  fp->_bf._size = 1;
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
   16110:	00015737          	lui	a4,0x15
   16114:	23070713          	addi	a4,a4,560 # 15230 <_cleanup_r>
      fp->_flags |= __SMBF;
   16118:	0807e793          	ori	a5,a5,128
	  fp->_bf._size = 1;
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
   1611c:	02e92e23          	sw	a4,60(s2)
      fp->_flags |= __SMBF;
   16120:	00f41623          	sh	a5,12(s0)
      fp->_bf._base = fp->_p = (unsigned char *) p;
   16124:	00a42023          	sw	a0,0(s0)
   16128:	00a42823          	sw	a0,16(s0)
      fp->_bf._size = size;
   1612c:	00942a23          	sw	s1,20(s0)
      if (couldbetty && _isatty_r (ptr, fp->_file))
   16130:	06099063          	bnez	s3,16190 <__smakebuf_r+0x148>
	fp->_flags |= __SLBF;
    }
}
   16134:	08c12083          	lw	ra,140(sp)
   16138:	08812403          	lw	s0,136(sp)
   1613c:	08412483          	lw	s1,132(sp)
   16140:	08012903          	lw	s2,128(sp)
   16144:	07c12983          	lw	s3,124(sp)
   16148:	09010113          	addi	sp,sp,144
   1614c:	00008067          	ret
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
    {
      fp->_bf._base = fp->_p = fp->_nbuf;
   16150:	04358793          	addi	a5,a1,67
   16154:	00f5a023          	sw	a5,0(a1)
   16158:	00f5a823          	sw	a5,16(a1)
      fp->_bf._size = 1;
   1615c:	00100793          	li	a5,1
   16160:	00f5aa23          	sw	a5,20(a1)
   16164:	fd1ff06f          	j	16134 <__smakebuf_r+0xec>
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
   16168:	02842703          	lw	a4,40(s0)
   1616c:	000187b7          	lui	a5,0x18
   16170:	44478793          	addi	a5,a5,1092 # 18444 <__sseek>
   16174:	f2f71ee3          	bne	a4,a5,160b0 <__smakebuf_r+0x68>
	{
	  fp->_flags |= __SOPT;
   16178:	00c45783          	lhu	a5,12(s0)
#ifdef HAVE_BLKSIZE
	  fp->_blksize = st.st_blksize;
#else
	  fp->_blksize = 1024;
   1617c:	40000493          	li	s1,1024
   16180:	04942623          	sw	s1,76(s0)
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
	{
	  fp->_flags |= __SOPT;
   16184:	0097e7b3          	or	a5,a5,s1
   16188:	00f41623          	sh	a5,12(s0)
#ifdef HAVE_BLKSIZE
	  fp->_blksize = st.st_blksize;
#else
	  fp->_blksize = 1024;
   1618c:	f71ff06f          	j	160fc <__smakebuf_r+0xb4>
    {
      ptr->__cleanup = _cleanup_r;
      fp->_flags |= __SMBF;
      fp->_bf._base = fp->_p = (unsigned char *) p;
      fp->_bf._size = size;
      if (couldbetty && _isatty_r (ptr, fp->_file))
   16190:	00e41503          	lh	a0,14(s0)
   16194:	894fa0ef          	jal	10228 <isatty>
   16198:	f8050ee3          	beqz	a0,16134 <__smakebuf_r+0xec>
	fp->_flags |= __SLBF;
   1619c:	00c45783          	lhu	a5,12(s0)
   161a0:	0017e793          	ori	a5,a5,1
   161a4:	00f41623          	sh	a5,12(s0)
   161a8:	f8dff06f          	j	16134 <__smakebuf_r+0xec>
	fp->_flags |= __SNPT;
#endif
    }
  if ((p = _malloc_r (ptr, size)) == NULL)
    {
      if (!(fp->_flags & __SSTR))
   161ac:	00c41783          	lh	a5,12(s0)
   161b0:	2007f713          	andi	a4,a5,512
   161b4:	f80710e3          	bnez	a4,16134 <__smakebuf_r+0xec>
	{
	  fp->_flags |= __SNBF;
   161b8:	0027e793          	ori	a5,a5,2
	  fp->_bf._base = fp->_p = fp->_nbuf;
   161bc:	04340713          	addi	a4,s0,67
    }
  if ((p = _malloc_r (ptr, size)) == NULL)
    {
      if (!(fp->_flags & __SSTR))
	{
	  fp->_flags |= __SNBF;
   161c0:	00f41623          	sh	a5,12(s0)
	  fp->_bf._base = fp->_p = fp->_nbuf;
	  fp->_bf._size = 1;
   161c4:	00100793          	li	a5,1
  if ((p = _malloc_r (ptr, size)) == NULL)
    {
      if (!(fp->_flags & __SSTR))
	{
	  fp->_flags |= __SNBF;
	  fp->_bf._base = fp->_p = fp->_nbuf;
   161c8:	00e42023          	sw	a4,0(s0)
   161cc:	00e42823          	sw	a4,16(s0)
	  fp->_bf._size = 1;
   161d0:	00f42a23          	sw	a5,20(s0)
   161d4:	f61ff06f          	j	16134 <__smakebuf_r+0xec>

000161d8 <_malloc_r>:
#if __STD_C
Void_t* mALLOc(RARG size_t bytes)
#else
Void_t* mALLOc(RARG bytes) RDECL size_t bytes;
#endif
{
   161d8:	fd010113          	addi	sp,sp,-48
   161dc:	02912223          	sw	s1,36(sp)
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
   161e0:	01600793          	li	a5,22
   161e4:	00b58493          	addi	s1,a1,11
#if __STD_C
Void_t* mALLOc(RARG size_t bytes)
#else
Void_t* mALLOc(RARG bytes) RDECL size_t bytes;
#endif
{
   161e8:	01312e23          	sw	s3,28(sp)
   161ec:	02112623          	sw	ra,44(sp)
   161f0:	02812423          	sw	s0,40(sp)
   161f4:	03212023          	sw	s2,32(sp)
   161f8:	01412c23          	sw	s4,24(sp)
   161fc:	01512a23          	sw	s5,20(sp)
   16200:	01612823          	sw	s6,16(sp)
   16204:	01712623          	sw	s7,12(sp)
   16208:	01812423          	sw	s8,8(sp)
   1620c:	01912223          	sw	s9,4(sp)
   16210:	00050993          	mv	s3,a0
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
   16214:	1a97fc63          	bleu	s1,a5,163cc <_malloc_r+0x1f4>
   16218:	ff84f493          	andi	s1,s1,-8

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   1621c:	2404c463          	bltz	s1,16464 <_malloc_r+0x28c>
   16220:	24b4e263          	bltu	s1,a1,16464 <_malloc_r+0x28c>
  {
    RERRNO = ENOMEM;
    return 0;
  }

  MALLOC_LOCK;
   16224:	31d000ef          	jal	16d40 <__malloc_lock>

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
   16228:	1f700793          	li	a5,503
   1622c:	7097fa63          	bleu	s1,a5,16940 <_malloc_r+0x768>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   16230:	0094d793          	srli	a5,s1,0x9
   16234:	08000693          	li	a3,128
   16238:	04000513          	li	a0,64
   1623c:	03f00593          	li	a1,63
   16240:	22079a63          	bnez	a5,16474 <_malloc_r+0x29c>
    bin = bin_at(idx);
   16244:	0001e937          	lui	s2,0x1e
   16248:	a3890913          	addi	s2,s2,-1480 # 1da38 <__malloc_av_>
   1624c:	00269693          	slli	a3,a3,0x2
   16250:	00d906b3          	add	a3,s2,a3

    for (victim = last(bin); victim != bin; victim = victim->bk)
   16254:	0046a403          	lw	s0,4(a3)

  }
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);
   16258:	ff868693          	addi	a3,a3,-8

    for (victim = last(bin); victim != bin; victim = victim->bk)
   1625c:	22868a63          	beq	a3,s0,16490 <_malloc_r+0x2b8>
    {
      victim_size = chunksize(victim);
   16260:	00442783          	lw	a5,4(s0)
      remainder_size = long_sub_size_t(victim_size, nb);
      
      if (remainder_size >= (long)MINSIZE) /* too big */
   16264:	00f00613          	li	a2,15
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
    {
      victim_size = chunksize(victim);
   16268:	ffc7f793          	andi	a5,a5,-4
      remainder_size = long_sub_size_t(victim_size, nb);
   1626c:	40978733          	sub	a4,a5,s1
      
      if (remainder_size >= (long)MINSIZE) /* too big */
   16270:	02e64063          	blt	a2,a4,16290 <_malloc_r+0xb8>
      {
        --idx; /* adjust to rescan below after checking last remainder */
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
   16274:	22075263          	bgez	a4,16498 <_malloc_r+0x2c0>
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
   16278:	00c42403          	lw	s0,12(s0)
   1627c:	20868a63          	beq	a3,s0,16490 <_malloc_r+0x2b8>
    {
      victim_size = chunksize(victim);
   16280:	00442783          	lw	a5,4(s0)
   16284:	ffc7f793          	andi	a5,a5,-4
      remainder_size = long_sub_size_t(victim_size, nb);
   16288:	40978733          	sub	a4,a5,s1
      
      if (remainder_size >= (long)MINSIZE) /* too big */
   1628c:	fee654e3          	ble	a4,a2,16274 <_malloc_r+0x9c>
      {
        --idx; /* adjust to rescan below after checking last remainder */
        break;   
   16290:	00058693          	mv	a3,a1

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
   16294:	01092403          	lw	s0,16(s2)
   16298:	00890813          	addi	a6,s2,8
   1629c:	4b040263          	beq	s0,a6,16740 <_malloc_r+0x568>
  {
    victim_size = chunksize(victim);
   162a0:	00442783          	lw	a5,4(s0)
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
   162a4:	00f00613          	li	a2,15

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
  {
    victim_size = chunksize(victim);
   162a8:	ffc7f793          	andi	a5,a5,-4
    remainder_size = long_sub_size_t(victim_size, nb);
   162ac:	40978733          	sub	a4,a5,s1

    if (remainder_size >= (long)MINSIZE) /* re-split */
   162b0:	44e64a63          	blt	a2,a4,16704 <_malloc_r+0x52c>
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
      return chunk2mem(victim);
    }

    clear_last_remainder;
   162b4:	01092a23          	sw	a6,20(s2)
   162b8:	01092823          	sw	a6,16(s2)

    if (remainder_size >= 0)  /* exhaust */
   162bc:	20075663          	bgez	a4,164c8 <_malloc_r+0x2f0>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   162c0:	1ff00713          	li	a4,511
   162c4:	3cf76e63          	bltu	a4,a5,166a0 <_malloc_r+0x4c8>
   162c8:	0037d793          	srli	a5,a5,0x3
   162cc:	00178613          	addi	a2,a5,1
   162d0:	00361613          	slli	a2,a2,0x3
   162d4:	00492703          	lw	a4,4(s2)
   162d8:	00c90633          	add	a2,s2,a2
   162dc:	00062503          	lw	a0,0(a2)
   162e0:	4027d793          	srai	a5,a5,0x2
   162e4:	00100593          	li	a1,1
   162e8:	00f597b3          	sll	a5,a1,a5
   162ec:	00e7e7b3          	or	a5,a5,a4
   162f0:	ff860713          	addi	a4,a2,-8
   162f4:	00e42623          	sw	a4,12(s0)
   162f8:	00a42423          	sw	a0,8(s0)
   162fc:	00f92223          	sw	a5,4(s2)
   16300:	00862023          	sw	s0,0(a2)
   16304:	00852623          	sw	s0,12(a0)
  /* 
     If there are any possibly nonempty big-enough blocks, 
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks)  
   16308:	4026d713          	srai	a4,a3,0x2
   1630c:	00100613          	li	a2,1
   16310:	00e61633          	sll	a2,a2,a4
   16314:	1cc7ea63          	bltu	a5,a2,164e8 <_malloc_r+0x310>
  {

    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
   16318:	00f67733          	and	a4,a2,a5
   1631c:	02071463          	bnez	a4,16344 <_malloc_r+0x16c>
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
   16320:	00161613          	slli	a2,a2,0x1
    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
   16324:	ffc6f693          	andi	a3,a3,-4
      block <<= 1;
      while ((block & binblocks) == 0)
   16328:	00f67733          	and	a4,a2,a5
    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
   1632c:	00468693          	addi	a3,a3,4
      block <<= 1;
      while ((block & binblocks) == 0)
   16330:	00071a63          	bnez	a4,16344 <_malloc_r+0x16c>
      {
        idx += BINBLOCKWIDTH;
        block <<= 1;
   16334:	00161613          	slli	a2,a2,0x1
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
   16338:	00f67733          	and	a4,a2,a5
      {
        idx += BINBLOCKWIDTH;
   1633c:	00468693          	addi	a3,a3,4
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
   16340:	fe070ae3          	beqz	a4,16334 <_malloc_r+0x15c>
        for (victim = last(bin); victim != bin; victim = victim->bk)
        {
          victim_size = chunksize(victim);
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
   16344:	00f00513          	li	a0,15
      
    /* For each possibly nonempty block ... */
    for (;;)  
    {
      startidx = idx;          /* (track incomplete blocks) */
      q = bin = bin_at(idx);
   16348:	00369893          	slli	a7,a3,0x3
   1634c:	012888b3          	add	a7,a7,s2
   16350:	00088593          	mv	a1,a7
   16354:	00068293          	mv	t0,a3
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
   16358:	00c5a403          	lw	s0,12(a1)
   1635c:	00859a63          	bne	a1,s0,16370 <_malloc_r+0x198>
   16360:	3e80006f          	j	16748 <_malloc_r+0x570>
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
   16364:	40075463          	bgez	a4,1676c <_malloc_r+0x594>
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
   16368:	00c42403          	lw	s0,12(s0)
   1636c:	3c858e63          	beq	a1,s0,16748 <_malloc_r+0x570>
        {
          victim_size = chunksize(victim);
   16370:	00442783          	lw	a5,4(s0)
   16374:	ffc7f793          	andi	a5,a5,-4
          remainder_size = long_sub_size_t(victim_size, nb);
   16378:	40978733          	sub	a4,a5,s1

          if (remainder_size >= (long)MINSIZE) /* split */
   1637c:	fee554e3          	ble	a4,a0,16364 <_malloc_r+0x18c>
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
   16380:	00c42683          	lw	a3,12(s0)
   16384:	00842603          	lw	a2,8(s0)
          victim_size = chunksize(victim);
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
   16388:	009407b3          	add	a5,s0,s1
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
            link_last_remainder(remainder);
            set_head(remainder, remainder_size | PREV_INUSE);
   1638c:	00176893          	ori	a7,a4,1
            set_foot(remainder, remainder_size);
   16390:	00e785b3          	add	a1,a5,a4
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
   16394:	0014e493          	ori	s1,s1,1
   16398:	00942223          	sw	s1,4(s0)
            unlink(victim, bck, fwd);
            link_last_remainder(remainder);
            set_head(remainder, remainder_size | PREV_INUSE);
            set_foot(remainder, remainder_size);
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   1639c:	00098513          	mv	a0,s3

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
   163a0:	00d62623          	sw	a3,12(a2)
   163a4:	00c6a423          	sw	a2,8(a3)
            link_last_remainder(remainder);
   163a8:	00f92a23          	sw	a5,20(s2)
   163ac:	00f92823          	sw	a5,16(s2)
   163b0:	0107a623          	sw	a6,12(a5)
   163b4:	0107a423          	sw	a6,8(a5)
            set_head(remainder, remainder_size | PREV_INUSE);
   163b8:	0117a223          	sw	a7,4(a5)
            set_foot(remainder, remainder_size);
   163bc:	00e5a023          	sw	a4,0(a1)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   163c0:	185000ef          	jal	16d44 <__malloc_unlock>
            return chunk2mem(victim);
   163c4:	00840513          	addi	a0,s0,8
   163c8:	0680006f          	j	16430 <_malloc_r+0x258>
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   163cc:	01000493          	li	s1,16
   163d0:	08b4ea63          	bltu	s1,a1,16464 <_malloc_r+0x28c>
  {
    RERRNO = ENOMEM;
    return 0;
  }

  MALLOC_LOCK;
   163d4:	16d000ef          	jal	16d40 <__malloc_lock>
   163d8:	00600793          	li	a5,6
   163dc:	00200693          	li	a3,2
  {
    idx = smallbin_index(nb); 

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
   163e0:	0001e937          	lui	s2,0x1e
   163e4:	a3890913          	addi	s2,s2,-1480 # 1da38 <__malloc_av_>
   163e8:	00279793          	slli	a5,a5,0x2
   163ec:	00f907b3          	add	a5,s2,a5
    victim = last(q);
   163f0:	0047a403          	lw	s0,4(a5)

#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
   163f4:	ff878713          	addi	a4,a5,-8
   163f8:	36e40263          	beq	s0,a4,1675c <_malloc_r+0x584>
      victim = last(q);
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
   163fc:	00442783          	lw	a5,4(s0)
      unlink(victim, bck, fwd);
   16400:	00c42683          	lw	a3,12(s0)
   16404:	00842603          	lw	a2,8(s0)
      victim = last(q);
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
   16408:	ffc7f793          	andi	a5,a5,-4
      unlink(victim, bck, fwd);
      set_inuse_bit_at_offset(victim, victim_size);
   1640c:	00f407b3          	add	a5,s0,a5
   16410:	0047a703          	lw	a4,4(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   16414:	00098513          	mv	a0,s3
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
      unlink(victim, bck, fwd);
   16418:	00d62623          	sw	a3,12(a2)
      set_inuse_bit_at_offset(victim, victim_size);
   1641c:	00176713          	ori	a4,a4,1
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
      unlink(victim, bck, fwd);
   16420:	00c6a423          	sw	a2,8(a3)
      set_inuse_bit_at_offset(victim, victim_size);
   16424:	00e7a223          	sw	a4,4(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   16428:	11d000ef          	jal	16d44 <__malloc_unlock>
      return chunk2mem(victim);
   1642c:	00840513          	addi	a0,s0,8
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
  return chunk2mem(victim);

#endif /* MALLOC_PROVIDED */
}
   16430:	02c12083          	lw	ra,44(sp)
   16434:	02812403          	lw	s0,40(sp)
   16438:	02412483          	lw	s1,36(sp)
   1643c:	02012903          	lw	s2,32(sp)
   16440:	01c12983          	lw	s3,28(sp)
   16444:	01812a03          	lw	s4,24(sp)
   16448:	01412a83          	lw	s5,20(sp)
   1644c:	01012b03          	lw	s6,16(sp)
   16450:	00c12b83          	lw	s7,12(sp)
   16454:	00812c03          	lw	s8,8(sp)
   16458:	00412c83          	lw	s9,4(sp)
   1645c:	03010113          	addi	sp,sp,48
   16460:	00008067          	ret
  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
  {
    RERRNO = ENOMEM;
   16464:	00c00793          	li	a5,12
   16468:	00f9a023          	sw	a5,0(s3) # ffffe000 <_gp+0xfffdf9c0>
    return 0;
   1646c:	00000513          	li	a0,0
   16470:	fc1ff06f          	j	16430 <_malloc_r+0x258>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   16474:	00400713          	li	a4,4
   16478:	20f76263          	bltu	a4,a5,1667c <_malloc_r+0x4a4>
   1647c:	0064d593          	srli	a1,s1,0x6
   16480:	03958513          	addi	a0,a1,57
   16484:	00151693          	slli	a3,a0,0x1
   16488:	03858593          	addi	a1,a1,56
   1648c:	db9ff06f          	j	16244 <_malloc_r+0x6c>
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
   16490:	00050693          	mv	a3,a0
   16494:	e01ff06f          	j	16294 <_malloc_r+0xbc>
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
        set_inuse_bit_at_offset(victim, victim_size);
   16498:	00f407b3          	add	a5,s0,a5
   1649c:	0047a703          	lw	a4,4(a5)
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
   164a0:	00c42683          	lw	a3,12(s0)
   164a4:	00842603          	lw	a2,8(s0)
        set_inuse_bit_at_offset(victim, victim_size);
   164a8:	00176713          	ori	a4,a4,1
        check_malloced_chunk(victim, nb);
	MALLOC_UNLOCK;
   164ac:	00098513          	mv	a0,s3
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
   164b0:	00d62623          	sw	a3,12(a2)
   164b4:	00c6a423          	sw	a2,8(a3)
        set_inuse_bit_at_offset(victim, victim_size);
   164b8:	00e7a223          	sw	a4,4(a5)
        check_malloced_chunk(victim, nb);
	MALLOC_UNLOCK;
   164bc:	089000ef          	jal	16d44 <__malloc_unlock>
        return chunk2mem(victim);
   164c0:	00840513          	addi	a0,s0,8
   164c4:	f6dff06f          	j	16430 <_malloc_r+0x258>

    clear_last_remainder;

    if (remainder_size >= 0)  /* exhaust */
    {
      set_inuse_bit_at_offset(victim, victim_size);
   164c8:	00f407b3          	add	a5,s0,a5
   164cc:	0047a703          	lw	a4,4(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   164d0:	00098513          	mv	a0,s3

    clear_last_remainder;

    if (remainder_size >= 0)  /* exhaust */
    {
      set_inuse_bit_at_offset(victim, victim_size);
   164d4:	00176713          	ori	a4,a4,1
   164d8:	00e7a223          	sw	a4,4(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   164dc:	069000ef          	jal	16d44 <__malloc_unlock>
      return chunk2mem(victim);
   164e0:	00840513          	addi	a0,s0,8
   164e4:	f4dff06f          	j	16430 <_malloc_r+0x258>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  remainder_size = long_sub_size_t(chunksize(top), nb);
   164e8:	00892403          	lw	s0,8(s2)
   164ec:	00442a03          	lw	s4,4(s0)
   164f0:	ffca7a93          	andi	s5,s4,-4
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   164f4:	009ae863          	bltu	s5,s1,16504 <_malloc_r+0x32c>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  remainder_size = long_sub_size_t(chunksize(top), nb);
   164f8:	409a87b3          	sub	a5,s5,s1
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   164fc:	00f00713          	li	a4,15
   16500:	14f74a63          	blt	a4,a5,16654 <_malloc_r+0x47c>
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
   16504:	8981a703          	lw	a4,-1896(gp) # 1ded8 <__malloc_top_pad>

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
   16508:	8181a683          	lw	a3,-2024(gp) # 1de58 <__malloc_sbrk_base>
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
   1650c:	00e48733          	add	a4,s1,a4

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
   16510:	fff00793          	li	a5,-1
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
   16514:	01540b33          	add	s6,s0,s5

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
   16518:	01070a13          	addi	s4,a4,16

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
   1651c:	00f68c63          	beq	a3,a5,16534 <_malloc_r+0x35c>
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
   16520:	000016b7          	lui	a3,0x1
   16524:	00f68a13          	addi	s4,a3,15 # 100f <_reset+0xe0f>
   16528:	014706b3          	add	a3,a4,s4
   1652c:	fffff737          	lui	a4,0xfffff
   16530:	00e6fa33          	and	s4,a3,a4

  brk = (char*)(MORECORE (sbrk_size));
   16534:	000a0513          	mv	a0,s4
   16538:	e89f90ef          	jal	103c0 <sbrk>

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
   1653c:	fff00793          	li	a5,-1
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));
   16540:	00050b93          	mv	s7,a0

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
   16544:	28f50063          	beq	a0,a5,167c4 <_malloc_r+0x5ec>
   16548:	27656c63          	bltu	a0,s6,167c0 <_malloc_r+0x5e8>
      (brk < old_end && old_top != initial_top))
    return;

  sbrked_mem += sbrk_size;
   1654c:	8bc18c13          	addi	s8,gp,-1860 # 1defc <__malloc_current_mallinfo>
   16550:	000c2703          	lw	a4,0(s8)
   16554:	00ea0733          	add	a4,s4,a4
   16558:	00ec2023          	sw	a4,0(s8)

  if (brk == old_end /* can just add bytes to current top, unless
   1655c:	357b0c63          	beq	s6,s7,168b4 <_malloc_r+0x6dc>
    top_size = sbrk_size + old_top_size;
    set_head(top, top_size | PREV_INUSE);
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
   16560:	8181a683          	lw	a3,-2024(gp) # 1de58 <__malloc_sbrk_base>
   16564:	fff00793          	li	a5,-1
   16568:	36f68a63          	beq	a3,a5,168dc <_malloc_r+0x704>
      sbrk_base = brk;
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
   1656c:	416b8b33          	sub	s6,s7,s6
   16570:	00eb0733          	add	a4,s6,a4
   16574:	00ec2023          	sw	a4,0(s8)

    /* Guarantee alignment of first new chunk made from this space */
    front_misalign = (POINTER_UINT)chunk2mem(brk) & MALLOC_ALIGN_MASK;
   16578:	007bf713          	andi	a4,s7,7
    if (front_misalign > 0) 
   1657c:	000017b7          	lui	a5,0x1
   16580:	00070a63          	beqz	a4,16594 <_malloc_r+0x3bc>
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
      brk += correction;
   16584:	40eb8bb3          	sub	s7,s7,a4
   16588:	00878793          	addi	a5,a5,8 # 1008 <_reset+0xe08>
   1658c:	008b8b93          	addi	s7,s7,8
   16590:	40e787b3          	sub	a5,a5,a4
    }
    else
      correction = 0;

    /* Guarantee the next brk will be at a page boundary */
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));
   16594:	00001737          	lui	a4,0x1
   16598:	fff70713          	addi	a4,a4,-1 # fff <_reset+0xdff>
   1659c:	014b8a33          	add	s4,s7,s4
   165a0:	00ea7a33          	and	s4,s4,a4
   165a4:	41478a33          	sub	s4,a5,s4

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
   165a8:	000a0513          	mv	a0,s4
   165ac:	e15f90ef          	jal	103c0 <sbrk>
    if (new_brk == (char*)(MORECORE_FAILURE))
   165b0:	fff00793          	li	a5,-1
   165b4:	30f50e63          	beq	a0,a5,168d0 <_malloc_r+0x6f8>
   165b8:	417507b3          	sub	a5,a0,s7
   165bc:	014787b3          	add	a5,a5,s4
   165c0:	0017e793          	ori	a5,a5,1
	correction = 0;
	correction_failed = 1;
	new_brk = brk;
      }

    sbrked_mem += correction;
   165c4:	000c2703          	lw	a4,0(s8)

    top = (mchunkptr)brk;
   165c8:	01792423          	sw	s7,8(s2)
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);
   165cc:	00fba223          	sw	a5,4(s7)
	correction = 0;
	correction_failed = 1;
	new_brk = brk;
      }

    sbrked_mem += correction;
   165d0:	00ea0733          	add	a4,s4,a4
   165d4:	00ec2023          	sw	a4,0(s8)

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);

    if (old_top != initial_top)
   165d8:	03240c63          	beq	s0,s2,16610 <_malloc_r+0x438>

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE) 
   165dc:	00f00613          	li	a2,15
   165e0:	29567263          	bleu	s5,a2,16864 <_malloc_r+0x68c>
        return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
   165e4:	00442683          	lw	a3,4(s0)
        set_head(top, PREV_INUSE); /* will force null return from malloc */
        return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
   165e8:	ff4a8793          	addi	a5,s5,-12
   165ec:	ff87f793          	andi	a5,a5,-8
      set_head_size(old_top, old_top_size);
   165f0:	0016f693          	andi	a3,a3,1
      chunk_at_offset(old_top, old_top_size          )->size =
   165f4:	00f405b3          	add	a1,s0,a5
   165f8:	00500513          	li	a0,5
        return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
   165fc:	00f6e6b3          	or	a3,a3,a5
   16600:	00d42223          	sw	a3,4(s0)
      chunk_at_offset(old_top, old_top_size          )->size =
   16604:	00a5a223          	sw	a0,4(a1)
        SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
   16608:	00a5a423          	sw	a0,8(a1)
        SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE) 
   1660c:	2cf66c63          	bltu	a2,a5,168e4 <_malloc_r+0x70c>
        fREe(RCALL chunk2mem(old_top));
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem) 
   16610:	8941a683          	lw	a3,-1900(gp) # 1ded4 <__malloc_max_sbrked_mem>
   16614:	00e6f463          	bleu	a4,a3,1661c <_malloc_r+0x444>
    max_sbrked_mem = sbrked_mem;
   16618:	88e1aa23          	sw	a4,-1900(gp) # 1ded4 <__malloc_max_sbrked_mem>
#if HAVE_MMAP
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem) 
    max_total_mem = mmapped_mem + sbrked_mem;
#else
  if ((unsigned long)(sbrked_mem) > (unsigned long)max_total_mem) 
   1661c:	8901a683          	lw	a3,-1904(gp) # 1ded0 <__malloc_max_total_mem>
   16620:	00892403          	lw	s0,8(s2)
   16624:	00e6f463          	bleu	a4,a3,1662c <_malloc_r+0x454>
    max_total_mem = sbrked_mem;
   16628:	88e1a823          	sw	a4,-1904(gp) # 1ded0 <__malloc_max_total_mem>
   1662c:	00442703          	lw	a4,4(s0)
   16630:	ffc77713          	andi	a4,a4,-4
    }
#endif

    /* Try to extend */
    malloc_extend_top(RCALL nb);
    remainder_size = long_sub_size_t(chunksize(top), nb);
   16634:	409707b3          	sub	a5,a4,s1
    if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   16638:	00976663          	bltu	a4,s1,16644 <_malloc_r+0x46c>
   1663c:	00f00713          	li	a4,15
   16640:	00f74a63          	blt	a4,a5,16654 <_malloc_r+0x47c>
    {
      MALLOC_UNLOCK;
   16644:	00098513          	mv	a0,s3
   16648:	6fc000ef          	jal	16d44 <__malloc_unlock>
      return 0; /* propagate failure */
   1664c:	00000513          	li	a0,0
   16650:	de1ff06f          	j	16430 <_malloc_r+0x258>
    }
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
   16654:	00940733          	add	a4,s0,s1
  set_head(top, remainder_size | PREV_INUSE);
   16658:	0017e793          	ori	a5,a5,1
      return 0; /* propagate failure */
    }
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
   1665c:	0014e493          	ori	s1,s1,1
   16660:	00942223          	sw	s1,4(s0)
  top = chunk_at_offset(victim, nb);
  set_head(top, remainder_size | PREV_INUSE);
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
   16664:	00098513          	mv	a0,s3
    }
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
   16668:	00e92423          	sw	a4,8(s2)
  set_head(top, remainder_size | PREV_INUSE);
   1666c:	00f72223          	sw	a5,4(a4)
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
   16670:	6d4000ef          	jal	16d44 <__malloc_unlock>
  return chunk2mem(victim);
   16674:	00840513          	addi	a0,s0,8
   16678:	db9ff06f          	j	16430 <_malloc_r+0x258>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   1667c:	01400713          	li	a4,20
   16680:	10f77e63          	bleu	a5,a4,1679c <_malloc_r+0x5c4>
   16684:	05400713          	li	a4,84
   16688:	1af76063          	bltu	a4,a5,16828 <_malloc_r+0x650>
   1668c:	00c4d593          	srli	a1,s1,0xc
   16690:	06f58513          	addi	a0,a1,111
   16694:	00151693          	slli	a3,a0,0x1
   16698:	06e58593          	addi	a1,a1,110
   1669c:	ba9ff06f          	j	16244 <_malloc_r+0x6c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   166a0:	0097d713          	srli	a4,a5,0x9
   166a4:	00400613          	li	a2,4
   166a8:	10e67263          	bleu	a4,a2,167ac <_malloc_r+0x5d4>
   166ac:	01400613          	li	a2,20
   166b0:	1ee66463          	bltu	a2,a4,16898 <_malloc_r+0x6c0>
   166b4:	05c70593          	addi	a1,a4,92
   166b8:	05b70613          	addi	a2,a4,91
   166bc:	00159593          	slli	a1,a1,0x1
   166c0:	00259593          	slli	a1,a1,0x2
   166c4:	00b905b3          	add	a1,s2,a1
   166c8:	0005a703          	lw	a4,0(a1)
   166cc:	ff858593          	addi	a1,a1,-8
   166d0:	16e58a63          	beq	a1,a4,16844 <_malloc_r+0x66c>
   166d4:	00472603          	lw	a2,4(a4)
   166d8:	ffc67613          	andi	a2,a2,-4
   166dc:	00c7f663          	bleu	a2,a5,166e8 <_malloc_r+0x510>
   166e0:	00872703          	lw	a4,8(a4)
   166e4:	fee598e3          	bne	a1,a4,166d4 <_malloc_r+0x4fc>
   166e8:	00c72583          	lw	a1,12(a4)
   166ec:	00492783          	lw	a5,4(s2)
   166f0:	00b42623          	sw	a1,12(s0)
   166f4:	00e42423          	sw	a4,8(s0)
   166f8:	0085a423          	sw	s0,8(a1)
   166fc:	00872623          	sw	s0,12(a4)
   16700:	c09ff06f          	j	16308 <_malloc_r+0x130>
    victim_size = chunksize(victim);
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
   16704:	009407b3          	add	a5,s0,s1
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
   16708:	00176613          	ori	a2,a4,1
      set_foot(remainder, remainder_size);
   1670c:	00e786b3          	add	a3,a5,a4
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
   16710:	0014e493          	ori	s1,s1,1
   16714:	00942223          	sw	s1,4(s0)
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
      set_foot(remainder, remainder_size);
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   16718:	00098513          	mv	a0,s3

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
   1671c:	00f92a23          	sw	a5,20(s2)
   16720:	00f92823          	sw	a5,16(s2)
   16724:	0107a623          	sw	a6,12(a5)
   16728:	0107a423          	sw	a6,8(a5)
      set_head(remainder, remainder_size | PREV_INUSE);
   1672c:	00c7a223          	sw	a2,4(a5)
      set_foot(remainder, remainder_size);
   16730:	00e6a023          	sw	a4,0(a3)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   16734:	610000ef          	jal	16d44 <__malloc_unlock>
      return chunk2mem(victim);
   16738:	00840513          	addi	a0,s0,8
   1673c:	cf5ff06f          	j	16430 <_malloc_r+0x258>
   16740:	00492783          	lw	a5,4(s2)
   16744:	bc5ff06f          	j	16308 <_malloc_r+0x130>
         {
           bin = next_bin(bin);
           ++idx;
         }
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
   16748:	00128293          	addi	t0,t0,1
   1674c:	0032f793          	andi	a5,t0,3
            return chunk2mem(victim);
          }

        }

       bin = next_bin(bin);
   16750:	00858593          	addi	a1,a1,8
         {
           bin = next_bin(bin);
           ++idx;
         }
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
   16754:	c00792e3          	bnez	a5,16358 <_malloc_r+0x180>
   16758:	0880006f          	j	167e0 <_malloc_r+0x608>
#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
    {
      q = next_bin(q);
      victim = last(q);
   1675c:	00c7a403          	lw	s0,12(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
      return chunk2mem(victim);
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
   16760:	00268693          	addi	a3,a3,2
    {
      q = next_bin(q);
      victim = last(q);
    }
#endif
    if (victim != q)
   16764:	b28788e3          	beq	a5,s0,16294 <_malloc_r+0xbc>
   16768:	c95ff06f          	j	163fc <_malloc_r+0x224>
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
   1676c:	00f407b3          	add	a5,s0,a5
   16770:	0047a703          	lw	a4,4(a5)
            unlink(victim, bck, fwd);
   16774:	00c42683          	lw	a3,12(s0)
   16778:	00842603          	lw	a2,8(s0)
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
   1677c:	00176713          	ori	a4,a4,1
   16780:	00e7a223          	sw	a4,4(a5)
            unlink(victim, bck, fwd);
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   16784:	00098513          	mv	a0,s3
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
            unlink(victim, bck, fwd);
   16788:	00d62623          	sw	a3,12(a2)
   1678c:	00c6a423          	sw	a2,8(a3)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   16790:	5b4000ef          	jal	16d44 <__malloc_unlock>
            return chunk2mem(victim);
   16794:	00840513          	addi	a0,s0,8
   16798:	c99ff06f          	j	16430 <_malloc_r+0x258>
   1679c:	05c78513          	addi	a0,a5,92
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   167a0:	05b78593          	addi	a1,a5,91
   167a4:	00151693          	slli	a3,a0,0x1
   167a8:	a9dff06f          	j	16244 <_malloc_r+0x6c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   167ac:	0067d613          	srli	a2,a5,0x6
   167b0:	03960593          	addi	a1,a2,57
   167b4:	00159593          	slli	a1,a1,0x1
   167b8:	03860613          	addi	a2,a2,56
   167bc:	f05ff06f          	j	166c0 <_malloc_r+0x4e8>

  brk = (char*)(MORECORE (sbrk_size));

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
      (brk < old_end && old_top != initial_top))
   167c0:	d92406e3          	beq	s0,s2,1654c <_malloc_r+0x374>
   167c4:	00892403          	lw	s0,8(s2)
   167c8:	00442703          	lw	a4,4(s0)
   167cc:	ffc77713          	andi	a4,a4,-4
   167d0:	e65ff06f          	j	16634 <_malloc_r+0x45c>
          binblocks &= ~block;
          break;
        }
        --startidx;
       q = prev_bin(q);
      } while (first(q) == q);
   167d4:	0088a783          	lw	a5,8(a7)
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
        {
          binblocks &= ~block;
          break;
        }
        --startidx;
   167d8:	fff68693          	addi	a3,a3,-1
       q = prev_bin(q);
      } while (first(q) == q);
   167dc:	14f89e63          	bne	a7,a5,16938 <_malloc_r+0x760>

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
   167e0:	0036f793          	andi	a5,a3,3
        {
          binblocks &= ~block;
          break;
        }
        --startidx;
       q = prev_bin(q);
   167e4:	ff888893          	addi	a7,a7,-8

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
   167e8:	fe0796e3          	bnez	a5,167d4 <_malloc_r+0x5fc>
        {
          binblocks &= ~block;
   167ec:	00492783          	lw	a5,4(s2)
   167f0:	fff64713          	not	a4,a2
   167f4:	00f777b3          	and	a5,a4,a5
   167f8:	00f92223          	sw	a5,4(s2)
       q = prev_bin(q);
      } while (first(q) == q);

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
   167fc:	00161613          	slli	a2,a2,0x1
   16800:	cec7e4e3          	bltu	a5,a2,164e8 <_malloc_r+0x310>
   16804:	ce0602e3          	beqz	a2,164e8 <_malloc_r+0x310>
      {
        while ((block & binblocks) == 0)
   16808:	00f67733          	and	a4,a2,a5
   1680c:	00028693          	mv	a3,t0
   16810:	b2071ce3          	bnez	a4,16348 <_malloc_r+0x170>
        {
          idx += BINBLOCKWIDTH;
          block <<= 1;
   16814:	00161613          	slli	a2,a2,0x1

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
   16818:	00f67733          	and	a4,a2,a5
        {
          idx += BINBLOCKWIDTH;
   1681c:	00468693          	addi	a3,a3,4

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
   16820:	fe070ae3          	beqz	a4,16814 <_malloc_r+0x63c>
   16824:	b25ff06f          	j	16348 <_malloc_r+0x170>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   16828:	15400713          	li	a4,340
   1682c:	04f76263          	bltu	a4,a5,16870 <_malloc_r+0x698>
   16830:	00f4d593          	srli	a1,s1,0xf
   16834:	07858513          	addi	a0,a1,120
   16838:	00151693          	slli	a3,a0,0x1
   1683c:	07758593          	addi	a1,a1,119
   16840:	a05ff06f          	j	16244 <_malloc_r+0x6c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   16844:	00492703          	lw	a4,4(s2)
   16848:	40265613          	srai	a2,a2,0x2
   1684c:	00100793          	li	a5,1
   16850:	00c797b3          	sll	a5,a5,a2
   16854:	00e7e7b3          	or	a5,a5,a4
   16858:	00f92223          	sw	a5,4(s2)
   1685c:	00058713          	mv	a4,a1
   16860:	e91ff06f          	j	166f0 <_malloc_r+0x518>
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE) 
      {
        set_head(top, PREV_INUSE); /* will force null return from malloc */
   16864:	00100793          	li	a5,1
   16868:	00fba223          	sw	a5,4(s7)
   1686c:	dd9ff06f          	j	16644 <_malloc_r+0x46c>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   16870:	55400713          	li	a4,1364
   16874:	0fe00693          	li	a3,254
   16878:	07f00513          	li	a0,127
   1687c:	07e00593          	li	a1,126
   16880:	9cf762e3          	bltu	a4,a5,16244 <_malloc_r+0x6c>
   16884:	0124d593          	srli	a1,s1,0x12
   16888:	07d58513          	addi	a0,a1,125
   1688c:	00151693          	slli	a3,a0,0x1
   16890:	07c58593          	addi	a1,a1,124
   16894:	9b1ff06f          	j	16244 <_malloc_r+0x6c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   16898:	05400613          	li	a2,84
   1689c:	04e66e63          	bltu	a2,a4,168f8 <_malloc_r+0x720>
   168a0:	00c7d613          	srli	a2,a5,0xc
   168a4:	06f60593          	addi	a1,a2,111
   168a8:	00159593          	slli	a1,a1,0x1
   168ac:	06e60613          	addi	a2,a2,110
   168b0:	e11ff06f          	j	166c0 <_malloc_r+0x4e8>

  sbrked_mem += sbrk_size;

  if (brk == old_end /* can just add bytes to current top, unless
			previous correction failed */
      && ((POINTER_UINT)old_end & (pagesz - 1)) == 0)
   168b4:	014b1793          	slli	a5,s6,0x14
   168b8:	ca0794e3          	bnez	a5,16560 <_malloc_r+0x388>
  {
    top_size = sbrk_size + old_top_size;
    set_head(top, top_size | PREV_INUSE);
   168bc:	00892783          	lw	a5,8(s2)
   168c0:	014a8a33          	add	s4,s5,s4
   168c4:	001a6a13          	ori	s4,s4,1
   168c8:	0147a223          	sw	s4,4(a5)
   168cc:	d45ff06f          	j	16610 <_malloc_r+0x438>
    /* Guarantee the next brk will be at a page boundary */
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE))
   168d0:	00100793          	li	a5,1
      {
	correction = 0;
   168d4:	00000a13          	li	s4,0
   168d8:	cedff06f          	j	165c4 <_malloc_r+0x3ec>
    set_head(top, top_size | PREV_INUSE);
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
      sbrk_base = brk;
   168dc:	8171ac23          	sw	s7,-2024(gp) # 1de58 <__malloc_sbrk_base>
   168e0:	c99ff06f          	j	16578 <_malloc_r+0x3a0>
        SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
        SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE) 
        fREe(RCALL chunk2mem(old_top));
   168e4:	00840593          	addi	a1,s0,8
   168e8:	00098513          	mv	a0,s3
   168ec:	db1fe0ef          	jal	1569c <_free_r>
   168f0:	000c2703          	lw	a4,0(s8)
   168f4:	d1dff06f          	j	16610 <_malloc_r+0x438>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   168f8:	15400613          	li	a2,340
   168fc:	00e66c63          	bltu	a2,a4,16914 <_malloc_r+0x73c>
   16900:	00f7d613          	srli	a2,a5,0xf
   16904:	07860593          	addi	a1,a2,120
   16908:	00159593          	slli	a1,a1,0x1
   1690c:	07760613          	addi	a2,a2,119
   16910:	db1ff06f          	j	166c0 <_malloc_r+0x4e8>
   16914:	55400513          	li	a0,1364
   16918:	0fe00593          	li	a1,254
   1691c:	07e00613          	li	a2,126
   16920:	dae560e3          	bltu	a0,a4,166c0 <_malloc_r+0x4e8>
   16924:	0127d613          	srli	a2,a5,0x12
   16928:	07d60593          	addi	a1,a2,125
   1692c:	00159593          	slli	a1,a1,0x1
   16930:	07c60613          	addi	a2,a2,124
   16934:	d8dff06f          	j	166c0 <_malloc_r+0x4e8>
   16938:	00492783          	lw	a5,4(s2)
   1693c:	ec1ff06f          	j	167fc <_malloc_r+0x624>
   16940:	0034d693          	srli	a3,s1,0x3
   16944:	00168793          	addi	a5,a3,1
   16948:	00179793          	slli	a5,a5,0x1
   1694c:	a95ff06f          	j	163e0 <_malloc_r+0x208>

00016950 <memchr>:
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   16950:	00357793          	andi	a5,a0,3
	_CONST _PTR src_void _AND
	int c _AND
	size_t length)
{
  _CONST unsigned char *src = (_CONST unsigned char *) src_void;
  unsigned char d = c;
   16954:	0ff5f693          	andi	a3,a1,255
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   16958:	0c078063          	beqz	a5,16a18 <memchr+0xc8>
    {
      if (!length--)
   1695c:	fff60793          	addi	a5,a2,-1
   16960:	06060063          	beqz	a2,169c0 <memchr+0x70>
        return NULL;
      if (*src == d)
   16964:	00054703          	lbu	a4,0(a0)
   16968:	00d71c63          	bne	a4,a3,16980 <memchr+0x30>
   1696c:	0b40006f          	j	16a20 <memchr+0xd0>
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
    {
      if (!length--)
   16970:	04078863          	beqz	a5,169c0 <memchr+0x70>
        return NULL;
      if (*src == d)
   16974:	00054703          	lbu	a4,0(a0)
   16978:	fff78793          	addi	a5,a5,-1
   1697c:	04d70463          	beq	a4,a3,169c4 <memchr+0x74>
        return (void *) src;
      src++;
   16980:	00150513          	addi	a0,a0,1
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   16984:	00357713          	andi	a4,a0,3
   16988:	fe0714e3          	bnez	a4,16970 <memchr+0x20>
      if (*src == d)
        return (void *) src;
      src++;
    }

  if (!TOO_SMALL (length))
   1698c:	00300813          	li	a6,3
   16990:	02f86c63          	bltu	a6,a5,169c8 <memchr+0x78>
      src = (unsigned char *) asrc;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
   16994:	02078663          	beqz	a5,169c0 <memchr+0x70>
    {
      if (*src == d)
   16998:	00054703          	lbu	a4,0(a0)
   1699c:	02d70463          	beq	a4,a3,169c4 <memchr+0x74>
   169a0:	00150713          	addi	a4,a0,1
   169a4:	00f507b3          	add	a5,a0,a5
   169a8:	0100006f          	j	169b8 <memchr+0x68>
   169ac:	00170713          	addi	a4,a4,1
   169b0:	fff74603          	lbu	a2,-1(a4)
   169b4:	00d60863          	beq	a2,a3,169c4 <memchr+0x74>
        return (void *) src;
      src++;
   169b8:	00070513          	mv	a0,a4
      src = (unsigned char *) asrc;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
   169bc:	fee798e3          	bne	a5,a4,169ac <memchr+0x5c>
  unsigned int i;

  while (UNALIGNED (src))
    {
      if (!length--)
        return NULL;
   169c0:	00000513          	li	a0,0
        return (void *) src;
      src++;
    }

  return NULL;
}
   169c4:	00008067          	ret
   169c8:	0ff5f593          	andi	a1,a1,255
         contain the search character, which is detected by XORing
         the word-sized segment with a word-sized block of the search
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
      mask = d << 8 | d;
   169cc:	00859713          	slli	a4,a1,0x8
   169d0:	00b765b3          	or	a1,a4,a1
      mask = mask << 16 | mask;
   169d4:	01059713          	slli	a4,a1,0x10
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
        {
          if (DETECTCHAR (*asrc, mask))
   169d8:	feff02b7          	lui	t0,0xfeff0
   169dc:	808088b7          	lui	a7,0x80808
         the word-sized segment with a word-sized block of the search
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
      mask = d << 8 | d;
      mask = mask << 16 | mask;
   169e0:	00e5e5b3          	or	a1,a1,a4
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
        {
          if (DETECTCHAR (*asrc, mask))
   169e4:	eff28293          	addi	t0,t0,-257 # fefefeff <_gp+0xfefd18bf>
   169e8:	08088893          	addi	a7,a7,128 # 80808080 <_gp+0x807e9a40>
   169ec:	00052703          	lw	a4,0(a0)
   169f0:	00e5c733          	xor	a4,a1,a4
   169f4:	00570633          	add	a2,a4,t0
   169f8:	fff74713          	not	a4,a4
   169fc:	00e67733          	and	a4,a2,a4
   16a00:	01177733          	and	a4,a4,a7
   16a04:	f8071ae3          	bnez	a4,16998 <memchr+0x48>
            break;
          length -= LBLOCKSIZE;
   16a08:	ffc78793          	addi	a5,a5,-4
          asrc++;
   16a0c:	00450513          	addi	a0,a0,4
      mask = d << 8 | d;
      mask = mask << 16 | mask;
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
   16a10:	fcf86ee3          	bltu	a6,a5,169ec <memchr+0x9c>
   16a14:	f81ff06f          	j	16994 <memchr+0x44>
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   16a18:	00060793          	mv	a5,a2
   16a1c:	f71ff06f          	j	1698c <memchr+0x3c>
   16a20:	00008067          	ret

00016a24 <memcpy>:

  char* a = (char*)aa;
  const char* b = (const char*)bb;
  char* end = a+n;
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
   16a24:	00a5c7b3          	xor	a5,a1,a0
   16a28:	0037f793          	andi	a5,a5,3
    *(a-1) = tt; \
  }

  char* a = (char*)aa;
  const char* b = (const char*)bb;
  char* end = a+n;
   16a2c:	00c508b3          	add	a7,a0,a2
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
   16a30:	0e079263          	bnez	a5,16b14 <memcpy+0xf0>
   16a34:	00300793          	li	a5,3
   16a38:	0ec7fe63          	bleu	a2,a5,16b34 <memcpy+0x110>
      while (a < end)
        BODY(a, b, char);
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
   16a3c:	00357793          	andi	a5,a0,3
   16a40:	04079a63          	bnez	a5,16a94 <memcpy+0x70>
    while ((uintptr_t)a & msk)
      BODY(a, b, char);

  long* la = (long*)a;
  const long* lb = (const long*)b;
  long* lend = (long*)((uintptr_t)end & ~msk);
   16a44:	ffc8f813          	andi	a6,a7,-4

  if (__builtin_expect(la < lend-8, 0))
   16a48:	fe080793          	addi	a5,a6,-32
   16a4c:	00050713          	mv	a4,a0
   16a50:	06f56663          	bltu	a0,a5,16abc <memcpy+0x98>
      *la++ = b7;
      *la++ = b8;
    }
  }

  while (la < lend)
   16a54:	00058693          	mv	a3,a1
   16a58:	00070793          	mv	a5,a4
   16a5c:	03077863          	bleu	a6,a4,16a8c <memcpy+0x68>
    BODY(la, lb, long);
   16a60:	0006a603          	lw	a2,0(a3)
   16a64:	00478793          	addi	a5,a5,4
   16a68:	00468693          	addi	a3,a3,4
   16a6c:	fec7ae23          	sw	a2,-4(a5)
      *la++ = b7;
      *la++ = b8;
    }
  }

  while (la < lend)
   16a70:	ff07e8e3          	bltu	a5,a6,16a60 <memcpy+0x3c>
   16a74:	fff74793          	not	a5,a4
   16a78:	01078833          	add	a6,a5,a6
   16a7c:	ffc87813          	andi	a6,a6,-4
   16a80:	00480813          	addi	a6,a6,4
   16a84:	01070733          	add	a4,a4,a6
   16a88:	010585b3          	add	a1,a1,a6
    BODY(la, lb, long);

  a = (char*)la;
  b = (const char*)lb;
  if (__builtin_expect(a < end, 0))
   16a8c:	09176863          	bltu	a4,a7,16b1c <memcpy+0xf8>
    goto small;
  return aa;
}
   16a90:	00008067          	ret
   16a94:	00050713          	mv	a4,a0
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
    while ((uintptr_t)a & msk)
      BODY(a, b, char);
   16a98:	0005c683          	lbu	a3,0(a1)
   16a9c:	00170713          	addi	a4,a4,1
        BODY(a, b, char);
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
    while ((uintptr_t)a & msk)
   16aa0:	00377793          	andi	a5,a4,3
      BODY(a, b, char);
   16aa4:	00158593          	addi	a1,a1,1
   16aa8:	fed70fa3          	sb	a3,-1(a4)
        BODY(a, b, char);
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
    while ((uintptr_t)a & msk)
   16aac:	fe0796e3          	bnez	a5,16a98 <memcpy+0x74>
      BODY(a, b, char);

  long* la = (long*)a;
  const long* lb = (const long*)b;
  long* lend = (long*)((uintptr_t)end & ~msk);
   16ab0:	ffc8f813          	andi	a6,a7,-4

  if (__builtin_expect(la < lend-8, 0))
   16ab4:	fe080793          	addi	a5,a6,-32
   16ab8:	f8f77ee3          	bleu	a5,a4,16a54 <memcpy+0x30>
  {
    while (la < lend-8)
    {
      long b0 = *lb++;
   16abc:	0005af83          	lw	t6,0(a1)
      long b1 = *lb++;
   16ac0:	0045af03          	lw	t5,4(a1)
      long b2 = *lb++;
   16ac4:	0085ae83          	lw	t4,8(a1)
      long b3 = *lb++;
   16ac8:	00c5ae03          	lw	t3,12(a1)
      long b4 = *lb++;
   16acc:	0105a383          	lw	t2,16(a1)
      long b5 = *lb++;
   16ad0:	0145a303          	lw	t1,20(a1)
      long b6 = *lb++;
   16ad4:	0185a283          	lw	t0,24(a1)
      long b7 = *lb++;
   16ad8:	01c5a603          	lw	a2,28(a1)
   16adc:	02458593          	addi	a1,a1,36
   16ae0:	02470713          	addi	a4,a4,36
      long b8 = *lb++;
   16ae4:	ffc5a683          	lw	a3,-4(a1)
      *la++ = b0;
   16ae8:	fdf72e23          	sw	t6,-36(a4)
      *la++ = b1;
   16aec:	ffe72023          	sw	t5,-32(a4)
      *la++ = b2;
   16af0:	ffd72223          	sw	t4,-28(a4)
      *la++ = b3;
   16af4:	ffc72423          	sw	t3,-24(a4)
      *la++ = b4;
   16af8:	fe772623          	sw	t2,-20(a4)
      *la++ = b5;
   16afc:	fe672823          	sw	t1,-16(a4)
      *la++ = b6;
   16b00:	fe572a23          	sw	t0,-12(a4)
      *la++ = b7;
   16b04:	fec72c23          	sw	a2,-8(a4)
      *la++ = b8;
   16b08:	fed72e23          	sw	a3,-4(a4)
  const long* lb = (const long*)b;
  long* lend = (long*)((uintptr_t)end & ~msk);

  if (__builtin_expect(la < lend-8, 0))
  {
    while (la < lend-8)
   16b0c:	faf768e3          	bltu	a4,a5,16abc <memcpy+0x98>
   16b10:	f45ff06f          	j	16a54 <memcpy+0x30>
  char* end = a+n;
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
  {
small:
    if (__builtin_expect(a < end, 1))
   16b14:	00050713          	mv	a4,a0
   16b18:	03157463          	bleu	a7,a0,16b40 <memcpy+0x11c>
      while (a < end)
        BODY(a, b, char);
   16b1c:	0005c783          	lbu	a5,0(a1)
   16b20:	00170713          	addi	a4,a4,1
   16b24:	00158593          	addi	a1,a1,1
   16b28:	fef70fa3          	sb	a5,-1(a4)
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
  {
small:
    if (__builtin_expect(a < end, 1))
      while (a < end)
   16b2c:	ff1768e3          	bltu	a4,a7,16b1c <memcpy+0xf8>
   16b30:	00008067          	ret
   16b34:	00050713          	mv	a4,a0
  char* end = a+n;
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
  {
small:
    if (__builtin_expect(a < end, 1))
   16b38:	ff1562e3          	bltu	a0,a7,16b1c <memcpy+0xf8>
   16b3c:	f55ff06f          	j	16a90 <memcpy+0x6c>
   16b40:	00008067          	ret

00016b44 <memmove>:
  char *dst = dst_void;
  _CONST char *src = src_void;
  long *aligned_dst;
  _CONST long *aligned_src;

  if (src < dst && dst < src + length)
   16b44:	02a5f863          	bleu	a0,a1,16b74 <memmove+0x30>
   16b48:	00c58733          	add	a4,a1,a2
   16b4c:	02e57463          	bleu	a4,a0,16b74 <memmove+0x30>
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
      dst += length;
   16b50:	00c507b3          	add	a5,a0,a2
   16b54:	40c785b3          	sub	a1,a5,a2
      while (length--)
   16b58:	0e060263          	beqz	a2,16c3c <memmove+0xf8>
	{
	  *--dst = *--src;
   16b5c:	fff70713          	addi	a4,a4,-1
   16b60:	00074683          	lbu	a3,0(a4)
   16b64:	fff78793          	addi	a5,a5,-1
   16b68:	00d78023          	sb	a3,0(a5)
  if (src < dst && dst < src + length)
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
      dst += length;
      while (length--)
   16b6c:	fef598e3          	bne	a1,a5,16b5c <memmove+0x18>
   16b70:	00008067          	ret
  else
    {
      /* Use optimizing algorithm for a non-destructive copy to closely 
         match memcpy. If the size is small or either SRC or DST is unaligned,
         then punt into the byte copy loop.  This should be rare.  */
      if (!TOO_SMALL(length) && !UNALIGNED (src, dst))
   16b74:	00f00893          	li	a7,15
   16b78:	0cc8f463          	bleu	a2,a7,16c40 <memmove+0xfc>
   16b7c:	00a5e7b3          	or	a5,a1,a0
   16b80:	0037f793          	andi	a5,a5,3
   16b84:	0c079463          	bnez	a5,16c4c <memmove+0x108>
   16b88:	00058713          	mv	a4,a1
   16b8c:	00050793          	mv	a5,a0
   16b90:	00060693          	mv	a3,a2
          aligned_src = (long*)src;

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
            {
              *aligned_dst++ = *aligned_src++;
   16b94:	00072803          	lw	a6,0(a4)
   16b98:	01078793          	addi	a5,a5,16
   16b9c:	01070713          	addi	a4,a4,16
   16ba0:	ff07a823          	sw	a6,-16(a5)
              *aligned_dst++ = *aligned_src++;
   16ba4:	ff472803          	lw	a6,-12(a4)
              *aligned_dst++ = *aligned_src++;
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
   16ba8:	ff068693          	addi	a3,a3,-16

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
            {
              *aligned_dst++ = *aligned_src++;
              *aligned_dst++ = *aligned_src++;
   16bac:	ff07aa23          	sw	a6,-12(a5)
              *aligned_dst++ = *aligned_src++;
   16bb0:	ff872803          	lw	a6,-8(a4)
   16bb4:	ff07ac23          	sw	a6,-8(a5)
              *aligned_dst++ = *aligned_src++;
   16bb8:	ffc72803          	lw	a6,-4(a4)
   16bbc:	ff07ae23          	sw	a6,-4(a5)
        {
          aligned_dst = (long*)dst;
          aligned_src = (long*)src;

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
   16bc0:	fcd8eae3          	bltu	a7,a3,16b94 <memmove+0x50>
   16bc4:	ff060713          	addi	a4,a2,-16
   16bc8:	ff077713          	andi	a4,a4,-16
   16bcc:	01070713          	addi	a4,a4,16
   16bd0:	00f67313          	andi	t1,a2,15
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   16bd4:	00300293          	li	t0,3
   16bd8:	00e507b3          	add	a5,a0,a4
   16bdc:	00e585b3          	add	a1,a1,a4
   16be0:	0662fc63          	bleu	t1,t0,16c58 <memmove+0x114>
   16be4:	00058813          	mv	a6,a1
   16be8:	00078693          	mv	a3,a5
   16bec:	00030713          	mv	a4,t1
            {
              *aligned_dst++ = *aligned_src++;
   16bf0:	00480813          	addi	a6,a6,4
   16bf4:	ffc82883          	lw	a7,-4(a6)
   16bf8:	00468693          	addi	a3,a3,4
              length -= LITTLEBLOCKSIZE;
   16bfc:	ffc70713          	addi	a4,a4,-4
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
            {
              *aligned_dst++ = *aligned_src++;
   16c00:	ff16ae23          	sw	a7,-4(a3)
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   16c04:	fee2e6e3          	bltu	t0,a4,16bf0 <memmove+0xac>
   16c08:	ffc30713          	addi	a4,t1,-4
   16c0c:	ffc77713          	andi	a4,a4,-4
   16c10:	00470713          	addi	a4,a4,4
   16c14:	00367613          	andi	a2,a2,3
   16c18:	00e787b3          	add	a5,a5,a4
   16c1c:	00e585b3          	add	a1,a1,a4
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   16c20:	02060a63          	beqz	a2,16c54 <memmove+0x110>
   16c24:	00c78633          	add	a2,a5,a2
        {
          *dst++ = *src++;
   16c28:	00158593          	addi	a1,a1,1
   16c2c:	fff5c703          	lbu	a4,-1(a1)
   16c30:	00178793          	addi	a5,a5,1
   16c34:	fee78fa3          	sb	a4,-1(a5)
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   16c38:	fec798e3          	bne	a5,a2,16c28 <memmove+0xe4>
        }
    }

  return dst_void;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   16c3c:	00008067          	ret
   16c40:	00050793          	mv	a5,a0
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   16c44:	fe0610e3          	bnez	a2,16c24 <memmove+0xe0>
   16c48:	00c0006f          	j	16c54 <memmove+0x110>
   16c4c:	00050793          	mv	a5,a0
   16c50:	fd5ff06f          	j	16c24 <memmove+0xe0>
   16c54:	00008067          	ret
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   16c58:	00030613          	mv	a2,t1
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   16c5c:	fc0614e3          	bnez	a2,16c24 <memmove+0xe0>
   16c60:	ff5ff06f          	j	16c54 <memmove+0x110>

00016c64 <memset>:
   16c64:	00f00813          	li	a6,15
   16c68:	00050713          	mv	a4,a0
   16c6c:	02c87e63          	bleu	a2,a6,16ca8 <memset+0x44>
   16c70:	00f77793          	andi	a5,a4,15
   16c74:	0a079063          	bnez	a5,16d14 <memset+0xb0>
   16c78:	08059263          	bnez	a1,16cfc <memset+0x98>
   16c7c:	ff067693          	andi	a3,a2,-16
   16c80:	00f67613          	andi	a2,a2,15
   16c84:	00e686b3          	add	a3,a3,a4
   16c88:	00b72023          	sw	a1,0(a4)
   16c8c:	00b72223          	sw	a1,4(a4)
   16c90:	00b72423          	sw	a1,8(a4)
   16c94:	00b72623          	sw	a1,12(a4)
   16c98:	01070713          	addi	a4,a4,16
   16c9c:	fed766e3          	bltu	a4,a3,16c88 <memset+0x24>
   16ca0:	00061463          	bnez	a2,16ca8 <memset+0x44>
   16ca4:	00008067          	ret
   16ca8:	40c806b3          	sub	a3,a6,a2
   16cac:	00269693          	slli	a3,a3,0x2
   16cb0:	00000297          	auipc	t0,0x0
   16cb4:	005686b3          	add	a3,a3,t0
   16cb8:	00c68067          	jr	a3,12
   16cbc:	00b70723          	sb	a1,14(a4)
   16cc0:	00b706a3          	sb	a1,13(a4)
   16cc4:	00b70623          	sb	a1,12(a4)
   16cc8:	00b705a3          	sb	a1,11(a4)
   16ccc:	00b70523          	sb	a1,10(a4)
   16cd0:	00b704a3          	sb	a1,9(a4)
   16cd4:	00b70423          	sb	a1,8(a4)
   16cd8:	00b703a3          	sb	a1,7(a4)
   16cdc:	00b70323          	sb	a1,6(a4)
   16ce0:	00b702a3          	sb	a1,5(a4)
   16ce4:	00b70223          	sb	a1,4(a4)
   16ce8:	00b701a3          	sb	a1,3(a4)
   16cec:	00b70123          	sb	a1,2(a4)
   16cf0:	00b700a3          	sb	a1,1(a4)
   16cf4:	00b70023          	sb	a1,0(a4)
   16cf8:	00008067          	ret
   16cfc:	0ff5f593          	andi	a1,a1,255
   16d00:	00859693          	slli	a3,a1,0x8
   16d04:	00d5e5b3          	or	a1,a1,a3
   16d08:	01059693          	slli	a3,a1,0x10
   16d0c:	00d5e5b3          	or	a1,a1,a3
   16d10:	f6dff06f          	j	16c7c <memset+0x18>
   16d14:	00279693          	slli	a3,a5,0x2
   16d18:	00000297          	auipc	t0,0x0
   16d1c:	005686b3          	add	a3,a3,t0
   16d20:	00008293          	mv	t0,ra
   16d24:	fa0680e7          	jalr	a3,-96
   16d28:	00028093          	mv	ra,t0
   16d2c:	ff078793          	addi	a5,a5,-16
   16d30:	40f70733          	sub	a4,a4,a5
   16d34:	00f60633          	add	a2,a2,a5
   16d38:	f6c878e3          	bleu	a2,a6,16ca8 <memset+0x44>
   16d3c:	f3dff06f          	j	16c78 <memset+0x14>

00016d40 <__malloc_lock>:
   16d40:	00008067          	ret

00016d44 <__malloc_unlock>:
}

void
__malloc_unlock (ptr)
     struct _reent *ptr;
{
   16d44:	00008067          	ret

00016d48 <_Balloc>:
{
  int x;
  _Bigint *rv ;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_FREELIST(ptr) == NULL)
   16d48:	04c52783          	lw	a5,76(a0)
#define _Kmax 15
*/

_Bigint *
_DEFUN (Balloc, (ptr, k), struct _reent *ptr _AND int k)
{
   16d4c:	ff010113          	addi	sp,sp,-16
   16d50:	00812423          	sw	s0,8(sp)
   16d54:	00912223          	sw	s1,4(sp)
   16d58:	00112623          	sw	ra,12(sp)
   16d5c:	01212023          	sw	s2,0(sp)
   16d60:	00050413          	mv	s0,a0
   16d64:	00058493          	mv	s1,a1
  int x;
  _Bigint *rv ;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_FREELIST(ptr) == NULL)
   16d68:	02078e63          	beqz	a5,16da4 <_Balloc+0x5c>
	{
	  return NULL;
	}
    }

  if ((rv = _REENT_MP_FREELIST(ptr)[k]) != 0)
   16d6c:	00249713          	slli	a4,s1,0x2
   16d70:	00e787b3          	add	a5,a5,a4
   16d74:	0007a503          	lw	a0,0(a5)
   16d78:	04050663          	beqz	a0,16dc4 <_Balloc+0x7c>
    {
      _REENT_MP_FREELIST(ptr)[k] = rv->_next;
   16d7c:	00052703          	lw	a4,0(a0)
   16d80:	00e7a023          	sw	a4,0(a5)
				  (x-1) * sizeof(rv->_x));
      if (rv == NULL) return NULL;
      rv->_k = k;
      rv->_maxwds = x;
    }
  rv->_sign = rv->_wds = 0;
   16d84:	00052823          	sw	zero,16(a0)
   16d88:	00052623          	sw	zero,12(a0)
  return rv;
}
   16d8c:	00c12083          	lw	ra,12(sp)
   16d90:	00812403          	lw	s0,8(sp)
   16d94:	00412483          	lw	s1,4(sp)
   16d98:	00012903          	lw	s2,0(sp)
   16d9c:	01010113          	addi	sp,sp,16
   16da0:	00008067          	ret

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_FREELIST(ptr) == NULL)
    {
      /* Allocate a list of pointers to the mprec objects */
      _REENT_MP_FREELIST(ptr) = (struct _Bigint **) _calloc_r (ptr, 
   16da4:	02100613          	li	a2,33
   16da8:	00400593          	li	a1,4
   16dac:	209020ef          	jal	197b4 <_calloc_r>
   16db0:	00050793          	mv	a5,a0
   16db4:	04a42623          	sw	a0,76(s0)
						      sizeof (struct _Bigint *),
						      _Kmax + 1);
      if (_REENT_MP_FREELIST(ptr) == NULL)
   16db8:	fa051ae3          	bnez	a0,16d6c <_Balloc+0x24>
	{
	  return NULL;
   16dbc:	00000513          	li	a0,0
   16dc0:	fcdff06f          	j	16d8c <_Balloc+0x44>
    {
      _REENT_MP_FREELIST(ptr)[k] = rv->_next;
    }
  else
    {
      x = 1 << k;
   16dc4:	00100593          	li	a1,1
   16dc8:	00959933          	sll	s2,a1,s1
      /* Allocate an mprec Bigint and stick in in the freelist */
      rv = (_Bigint *) _calloc_r (ptr,
   16dcc:	00590613          	addi	a2,s2,5
   16dd0:	00261613          	slli	a2,a2,0x2
   16dd4:	00040513          	mv	a0,s0
   16dd8:	1dd020ef          	jal	197b4 <_calloc_r>
				  1,
				  sizeof (_Bigint) +
				  (x-1) * sizeof(rv->_x));
      if (rv == NULL) return NULL;
   16ddc:	fe0500e3          	beqz	a0,16dbc <_Balloc+0x74>
      rv->_k = k;
   16de0:	00952223          	sw	s1,4(a0)
      rv->_maxwds = x;
   16de4:	01252423          	sw	s2,8(a0)
   16de8:	f9dff06f          	j	16d84 <_Balloc+0x3c>

00016dec <_Bfree>:

void
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
   16dec:	02058063          	beqz	a1,16e0c <_Bfree+0x20>
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   16df0:	0045a783          	lw	a5,4(a1)
   16df4:	04c52703          	lw	a4,76(a0)
   16df8:	00279793          	slli	a5,a5,0x2
   16dfc:	00f707b3          	add	a5,a4,a5
   16e00:	0007a703          	lw	a4,0(a5)
   16e04:	00e5a023          	sw	a4,0(a1)
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   16e08:	00b7a023          	sw	a1,0(a5)
   16e0c:	00008067          	ret

00016e10 <__multadd>:
_DEFUN (multadd, (ptr, b, m, a),
	struct _reent *ptr _AND
	_Bigint * b _AND
	int m _AND
	int a)
{
   16e10:	fd010113          	addi	sp,sp,-48
  i = 0;
  do
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
   16e14:	00010837          	lui	a6,0x10
_DEFUN (multadd, (ptr, b, m, a),
	struct _reent *ptr _AND
	_Bigint * b _AND
	int m _AND
	int a)
{
   16e18:	02812423          	sw	s0,40(sp)
   16e1c:	02912223          	sw	s1,36(sp)
   16e20:	03212023          	sw	s2,32(sp)
   16e24:	00058493          	mv	s1,a1
#ifdef Pack_32
  __ULong xi, z;
#endif
  _Bigint *b1;

  wds = b->_wds;
   16e28:	0105a403          	lw	s0,16(a1)
_DEFUN (multadd, (ptr, b, m, a),
	struct _reent *ptr _AND
	_Bigint * b _AND
	int m _AND
	int a)
{
   16e2c:	00050913          	mv	s2,a0
   16e30:	02112623          	sw	ra,44(sp)
   16e34:	01312e23          	sw	s3,28(sp)
  __ULong xi, z;
#endif
  _Bigint *b1;

  wds = b->_wds;
  x = b->_x;
   16e38:	01458593          	addi	a1,a1,20
  i = 0;
   16e3c:	00000513          	li	a0,0
  do
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
   16e40:	fff80813          	addi	a6,a6,-1 # ffff <_reset+0xfdff>
  x = b->_x;
  i = 0;
  do
    {
#ifdef Pack_32
      xi = *x;
   16e44:	0005a783          	lw	a5,0(a1)
      y = *x * m + a;
      a = (int) (y >> 16);
      *x++ = y & 0xffff;
#endif
    }
  while (++i < wds);
   16e48:	00150513          	addi	a0,a0,1
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
      z = (xi >> 16) * m + (y >> 16);
      a = (int) (z >> 16);
      *x++ = (z << 16) + (y & 0xffff);
   16e4c:	00458593          	addi	a1,a1,4
  i = 0;
  do
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
   16e50:	0107f733          	and	a4,a5,a6
   16e54:	02c70733          	mul	a4,a4,a2
      z = (xi >> 16) * m + (y >> 16);
   16e58:	0107d793          	srli	a5,a5,0x10
   16e5c:	02c787b3          	mul	a5,a5,a2
  i = 0;
  do
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
   16e60:	00d70733          	add	a4,a4,a3
      z = (xi >> 16) * m + (y >> 16);
   16e64:	01075693          	srli	a3,a4,0x10
      a = (int) (z >> 16);
      *x++ = (z << 16) + (y & 0xffff);
   16e68:	01077733          	and	a4,a4,a6
  do
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
      z = (xi >> 16) * m + (y >> 16);
   16e6c:	00d786b3          	add	a3,a5,a3
      a = (int) (z >> 16);
      *x++ = (z << 16) + (y & 0xffff);
   16e70:	01069793          	slli	a5,a3,0x10
   16e74:	00e78733          	add	a4,a5,a4
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
      z = (xi >> 16) * m + (y >> 16);
      a = (int) (z >> 16);
   16e78:	0106d693          	srli	a3,a3,0x10
      *x++ = (z << 16) + (y & 0xffff);
   16e7c:	fee5ae23          	sw	a4,-4(a1)
      y = *x * m + a;
      a = (int) (y >> 16);
      *x++ = y & 0xffff;
#endif
    }
  while (++i < wds);
   16e80:	fc8542e3          	blt	a0,s0,16e44 <__multadd+0x34>
  if (a)
   16e84:	02068263          	beqz	a3,16ea8 <__multadd+0x98>
    {
      if (wds >= b->_maxwds)
   16e88:	0084a783          	lw	a5,8(s1)
   16e8c:	02f45e63          	ble	a5,s0,16ec8 <__multadd+0xb8>
	  b1 = Balloc (ptr, b->_k + 1);
	  Bcopy (b1, b);
	  Bfree (ptr, b);
	  b = b1;
	}
      b->_x[wds++] = a;
   16e90:	00440793          	addi	a5,s0,4
   16e94:	00279793          	slli	a5,a5,0x2
   16e98:	00f487b3          	add	a5,s1,a5
      b->_wds = wds;
   16e9c:	00140413          	addi	s0,s0,1
	  b1 = Balloc (ptr, b->_k + 1);
	  Bcopy (b1, b);
	  Bfree (ptr, b);
	  b = b1;
	}
      b->_x[wds++] = a;
   16ea0:	00d7a223          	sw	a3,4(a5)
      b->_wds = wds;
   16ea4:	0084a823          	sw	s0,16(s1)
    }
  return b;
}
   16ea8:	02c12083          	lw	ra,44(sp)
   16eac:	00048513          	mv	a0,s1
   16eb0:	02812403          	lw	s0,40(sp)
   16eb4:	02412483          	lw	s1,36(sp)
   16eb8:	02012903          	lw	s2,32(sp)
   16ebc:	01c12983          	lw	s3,28(sp)
   16ec0:	03010113          	addi	sp,sp,48
   16ec4:	00008067          	ret
  while (++i < wds);
  if (a)
    {
      if (wds >= b->_maxwds)
	{
	  b1 = Balloc (ptr, b->_k + 1);
   16ec8:	0044a583          	lw	a1,4(s1)
   16ecc:	00090513          	mv	a0,s2
   16ed0:	00d12623          	sw	a3,12(sp)
   16ed4:	00158593          	addi	a1,a1,1
   16ed8:	e71ff0ef          	jal	16d48 <_Balloc>
	  Bcopy (b1, b);
   16edc:	0104a603          	lw	a2,16(s1)
  while (++i < wds);
  if (a)
    {
      if (wds >= b->_maxwds)
	{
	  b1 = Balloc (ptr, b->_k + 1);
   16ee0:	00050993          	mv	s3,a0
	  Bcopy (b1, b);
   16ee4:	00c48593          	addi	a1,s1,12
   16ee8:	00260613          	addi	a2,a2,2
   16eec:	00c50513          	addi	a0,a0,12
   16ef0:	00261613          	slli	a2,a2,0x2
   16ef4:	b31ff0ef          	jal	16a24 <memcpy>
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   16ef8:	0044a783          	lw	a5,4(s1)
   16efc:	04c92703          	lw	a4,76(s2)
      if (wds >= b->_maxwds)
	{
	  b1 = Balloc (ptr, b->_k + 1);
	  Bcopy (b1, b);
	  Bfree (ptr, b);
	  b = b1;
   16f00:	00c12683          	lw	a3,12(sp)
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   16f04:	00279793          	slli	a5,a5,0x2
   16f08:	00f707b3          	add	a5,a4,a5
   16f0c:	0007a703          	lw	a4,0(a5)
   16f10:	00e4a023          	sw	a4,0(s1)
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   16f14:	0097a023          	sw	s1,0(a5)
      if (wds >= b->_maxwds)
	{
	  b1 = Balloc (ptr, b->_k + 1);
	  Bcopy (b1, b);
	  Bfree (ptr, b);
	  b = b1;
   16f18:	00098493          	mv	s1,s3
   16f1c:	f75ff06f          	j	16e90 <__multadd+0x80>

00016f20 <__s2b>:
	struct _reent * ptr _AND
	_CONST char *s _AND
	int nd0 _AND
	int nd _AND
	__ULong y9)
{
   16f20:	fe010113          	addi	sp,sp,-32
  _Bigint *b;
  int i, k;
  __Long x, y;

  x = (nd + 8) / 9;
   16f24:	00868793          	addi	a5,a3,8
	struct _reent * ptr _AND
	_CONST char *s _AND
	int nd0 _AND
	int nd _AND
	__ULong y9)
{
   16f28:	01312623          	sw	s3,12(sp)
   16f2c:	00068993          	mv	s3,a3
  _Bigint *b;
  int i, k;
  __Long x, y;

  x = (nd + 8) / 9;
   16f30:	00900693          	li	a3,9
   16f34:	02d7c6b3          	div	a3,a5,a3
  for (k = 0, y = 1; x > y; y <<= 1, k++);
   16f38:	00100793          	li	a5,1
	struct _reent * ptr _AND
	_CONST char *s _AND
	int nd0 _AND
	int nd _AND
	__ULong y9)
{
   16f3c:	00812c23          	sw	s0,24(sp)
   16f40:	00912a23          	sw	s1,20(sp)
   16f44:	01212823          	sw	s2,16(sp)
   16f48:	01412423          	sw	s4,8(sp)
   16f4c:	00058413          	mv	s0,a1
   16f50:	00112e23          	sw	ra,28(sp)
   16f54:	01512223          	sw	s5,4(sp)
   16f58:	00050913          	mv	s2,a0
   16f5c:	00060a13          	mv	s4,a2
   16f60:	00070493          	mv	s1,a4
  _Bigint *b;
  int i, k;
  __Long x, y;

  x = (nd + 8) / 9;
  for (k = 0, y = 1; x > y; y <<= 1, k++);
   16f64:	00000593          	li	a1,0
   16f68:	00d7d863          	ble	a3,a5,16f78 <__s2b+0x58>
   16f6c:	00179793          	slli	a5,a5,0x1
   16f70:	00158593          	addi	a1,a1,1
   16f74:	fed7cce3          	blt	a5,a3,16f6c <__s2b+0x4c>
#ifdef Pack_32
  b = Balloc (ptr, k);
   16f78:	00090513          	mv	a0,s2
   16f7c:	dcdff0ef          	jal	16d48 <_Balloc>
  b->_x[0] = y9;
  b->_wds = 1;
   16f80:	00100713          	li	a4,1
  b->_x[0] = y9 & 0xffff;
  b->_wds = (b->_x[1] = y9 >> 16) ? 2 : 1;
#endif

  i = 9;
  if (9 < nd0)
   16f84:	00900793          	li	a5,9

  x = (nd + 8) / 9;
  for (k = 0, y = 1; x > y; y <<= 1, k++);
#ifdef Pack_32
  b = Balloc (ptr, k);
  b->_x[0] = y9;
   16f88:	00952a23          	sw	s1,20(a0)
  b->_wds = 1;
   16f8c:	00e52823          	sw	a4,16(a0)
  b->_x[0] = y9 & 0xffff;
  b->_wds = (b->_x[1] = y9 >> 16) ? 2 : 1;
#endif

  i = 9;
  if (9 < nd0)
   16f90:	0947d463          	ble	s4,a5,17018 <__s2b+0xf8>
    {
      s += 9;
   16f94:	00f40ab3          	add	s5,s0,a5
   16f98:	000a8493          	mv	s1,s5
   16f9c:	01440433          	add	s0,s0,s4
      do
	b = multadd (ptr, b, 10, *s++ - '0');
   16fa0:	00148493          	addi	s1,s1,1
   16fa4:	fff4c683          	lbu	a3,-1(s1)
   16fa8:	00050593          	mv	a1,a0
   16fac:	00a00613          	li	a2,10
   16fb0:	fd068693          	addi	a3,a3,-48
   16fb4:	00090513          	mv	a0,s2
   16fb8:	e59ff0ef          	jal	16e10 <__multadd>
      while (++i < nd0);
   16fbc:	fe8492e3          	bne	s1,s0,16fa0 <__s2b+0x80>
   16fc0:	014a8433          	add	s0,s5,s4
      s++;
   16fc4:	ff840413          	addi	s0,s0,-8
    }
  else
    s += 10;
  for (; i < nd; i++)
   16fc8:	033a5663          	ble	s3,s4,16ff4 <__s2b+0xd4>
   16fcc:	414984b3          	sub	s1,s3,s4
   16fd0:	009404b3          	add	s1,s0,s1
    b = multadd (ptr, b, 10, *s++ - '0');
   16fd4:	00140413          	addi	s0,s0,1
   16fd8:	fff44683          	lbu	a3,-1(s0)
   16fdc:	00050593          	mv	a1,a0
   16fe0:	00a00613          	li	a2,10
   16fe4:	fd068693          	addi	a3,a3,-48
   16fe8:	00090513          	mv	a0,s2
   16fec:	e25ff0ef          	jal	16e10 <__multadd>
      while (++i < nd0);
      s++;
    }
  else
    s += 10;
  for (; i < nd; i++)
   16ff0:	fe8492e3          	bne	s1,s0,16fd4 <__s2b+0xb4>
    b = multadd (ptr, b, 10, *s++ - '0');
  return b;
}
   16ff4:	01c12083          	lw	ra,28(sp)
   16ff8:	01812403          	lw	s0,24(sp)
   16ffc:	01412483          	lw	s1,20(sp)
   17000:	01012903          	lw	s2,16(sp)
   17004:	00c12983          	lw	s3,12(sp)
   17008:	00812a03          	lw	s4,8(sp)
   1700c:	00412a83          	lw	s5,4(sp)
   17010:	02010113          	addi	sp,sp,32
   17014:	00008067          	ret
	b = multadd (ptr, b, 10, *s++ - '0');
      while (++i < nd0);
      s++;
    }
  else
    s += 10;
   17018:	00a40413          	addi	s0,s0,10
  b = Balloc (ptr, k + 1);
  b->_x[0] = y9 & 0xffff;
  b->_wds = (b->_x[1] = y9 >> 16) ? 2 : 1;
#endif

  i = 9;
   1701c:	00078a13          	mv	s4,a5
   17020:	fa9ff06f          	j	16fc8 <__s2b+0xa8>

00017024 <__hi0bits>:
_DEFUN (hi0bits,
	(x), register __ULong x)
{
  register int k = 0;

  if (!(x & 0xffff0000))
   17024:	ffff06b7          	lui	a3,0xffff0
   17028:	00d576b3          	and	a3,a0,a3
}

int
_DEFUN (hi0bits,
	(x), register __ULong x)
{
   1702c:	00050793          	mv	a5,a0
  register int k = 0;
   17030:	00000713          	li	a4,0

  if (!(x & 0xffff0000))
   17034:	00069663          	bnez	a3,17040 <__hi0bits+0x1c>
    {
      k = 16;
      x <<= 16;
   17038:	01051793          	slli	a5,a0,0x10
{
  register int k = 0;

  if (!(x & 0xffff0000))
    {
      k = 16;
   1703c:	01000713          	li	a4,16
      x <<= 16;
    }
  if (!(x & 0xff000000))
   17040:	ff0006b7          	lui	a3,0xff000
   17044:	00d7f6b3          	and	a3,a5,a3
   17048:	00069663          	bnez	a3,17054 <__hi0bits+0x30>
    {
      k += 8;
   1704c:	00870713          	addi	a4,a4,8
      x <<= 8;
   17050:	00879793          	slli	a5,a5,0x8
    }
  if (!(x & 0xf0000000))
   17054:	f00006b7          	lui	a3,0xf0000
   17058:	00d7f6b3          	and	a3,a5,a3
   1705c:	00069663          	bnez	a3,17068 <__hi0bits+0x44>
    {
      k += 4;
   17060:	00470713          	addi	a4,a4,4
      x <<= 4;
   17064:	00479793          	slli	a5,a5,0x4
    }
  if (!(x & 0xc0000000))
   17068:	c00006b7          	lui	a3,0xc0000
   1706c:	00d7f6b3          	and	a3,a5,a3
   17070:	00069663          	bnez	a3,1707c <__hi0bits+0x58>
    {
      k += 2;
   17074:	00270713          	addi	a4,a4,2
      x <<= 2;
   17078:	00279793          	slli	a5,a5,0x2
    }
  if (!(x & 0x80000000))
   1707c:	0007ce63          	bltz	a5,17098 <__hi0bits+0x74>
    {
      k++;
      if (!(x & 0x40000000))
   17080:	00179693          	slli	a3,a5,0x1
	return 32;
   17084:	02000513          	li	a0,32
      x <<= 2;
    }
  if (!(x & 0x80000000))
    {
      k++;
      if (!(x & 0x40000000))
   17088:	0006c463          	bltz	a3,17090 <__hi0bits+0x6c>
	return 32;
    }
  return k;
}
   1708c:	00008067          	ret
      k += 2;
      x <<= 2;
    }
  if (!(x & 0x80000000))
    {
      k++;
   17090:	00170513          	addi	a0,a4,1
   17094:	00008067          	ret
   17098:	00070513          	mv	a0,a4
      if (!(x & 0x40000000))
	return 32;
    }
  return k;
}
   1709c:	00008067          	ret

000170a0 <__lo0bits>:

int
_DEFUN (lo0bits, (y), __ULong *y)
{
  register int k;
  register __ULong x = *y;
   170a0:	00052783          	lw	a5,0(a0)
  return k;
}

int
_DEFUN (lo0bits, (y), __ULong *y)
{
   170a4:	00050693          	mv	a3,a0
  register int k;
  register __ULong x = *y;

  if (x & 7)
   170a8:	0077f713          	andi	a4,a5,7
   170ac:	02070463          	beqz	a4,170d4 <__lo0bits+0x34>
    {
      if (x & 1)
   170b0:	0017f713          	andi	a4,a5,1
	return 0;
   170b4:	00000513          	li	a0,0
  register int k;
  register __ULong x = *y;

  if (x & 7)
    {
      if (x & 1)
   170b8:	08071263          	bnez	a4,1713c <__lo0bits+0x9c>
	return 0;
      if (x & 2)
   170bc:	0027f713          	andi	a4,a5,2
   170c0:	08071063          	bnez	a4,17140 <__lo0bits+0xa0>
	{
	  *y = x >> 1;
	  return 1;
	}
      *y = x >> 2;
   170c4:	0027d793          	srli	a5,a5,0x2
   170c8:	00f6a023          	sw	a5,0(a3) # c0000000 <_gp+0xbffe19c0>
      return 2;
   170cc:	00200513          	li	a0,2
   170d0:	00008067          	ret
    }
  k = 0;
  if (!(x & 0xffff))
   170d4:	01079613          	slli	a2,a5,0x10
   170d8:	01065613          	srli	a2,a2,0x10
	  return 1;
	}
      *y = x >> 2;
      return 2;
    }
  k = 0;
   170dc:	00000713          	li	a4,0
  if (!(x & 0xffff))
   170e0:	00061663          	bnez	a2,170ec <__lo0bits+0x4c>
    {
      k = 16;
      x >>= 16;
   170e4:	0107d793          	srli	a5,a5,0x10
      return 2;
    }
  k = 0;
  if (!(x & 0xffff))
    {
      k = 16;
   170e8:	01000713          	li	a4,16
      x >>= 16;
    }
  if (!(x & 0xff))
   170ec:	0ff7f613          	andi	a2,a5,255
   170f0:	00061663          	bnez	a2,170fc <__lo0bits+0x5c>
    {
      k += 8;
   170f4:	00870713          	addi	a4,a4,8
      x >>= 8;
   170f8:	0087d793          	srli	a5,a5,0x8
    }
  if (!(x & 0xf))
   170fc:	00f7f613          	andi	a2,a5,15
   17100:	00061663          	bnez	a2,1710c <__lo0bits+0x6c>
    {
      k += 4;
   17104:	00470713          	addi	a4,a4,4
      x >>= 4;
   17108:	0047d793          	srli	a5,a5,0x4
    }
  if (!(x & 0x3))
   1710c:	0037f613          	andi	a2,a5,3
   17110:	00061663          	bnez	a2,1711c <__lo0bits+0x7c>
    {
      k += 2;
   17114:	00270713          	addi	a4,a4,2
      x >>= 2;
   17118:	0027d793          	srli	a5,a5,0x2
    }
  if (!(x & 1))
   1711c:	0017f613          	andi	a2,a5,1
   17120:	00061a63          	bnez	a2,17134 <__lo0bits+0x94>
    {
      k++;
      x >>= 1;
   17124:	0017d793          	srli	a5,a5,0x1
      if (!x & 1)
	return 32;
   17128:	02000513          	li	a0,32
    }
  if (!(x & 1))
    {
      k++;
      x >>= 1;
      if (!x & 1)
   1712c:	00078863          	beqz	a5,1713c <__lo0bits+0x9c>
      k += 2;
      x >>= 2;
    }
  if (!(x & 1))
    {
      k++;
   17130:	00170713          	addi	a4,a4,1
      x >>= 1;
      if (!x & 1)
	return 32;
    }
  *y = x;
   17134:	00f6a023          	sw	a5,0(a3)
  return k;
   17138:	00070513          	mv	a0,a4
}
   1713c:	00008067          	ret
    {
      if (x & 1)
	return 0;
      if (x & 2)
	{
	  *y = x >> 1;
   17140:	0017d793          	srli	a5,a5,0x1
   17144:	00f6a023          	sw	a5,0(a3)
	  return 1;
   17148:	00100513          	li	a0,1
   1714c:	00008067          	ret

00017150 <__i2b>:
  return k;
}

_Bigint *
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
   17150:	ff010113          	addi	sp,sp,-16
   17154:	00812423          	sw	s0,8(sp)
   17158:	00058413          	mv	s0,a1
  _Bigint *b;

  b = Balloc (ptr, 1);
   1715c:	00100593          	li	a1,1
  return k;
}

_Bigint *
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
   17160:	00112623          	sw	ra,12(sp)
  _Bigint *b;

  b = Balloc (ptr, 1);
   17164:	be5ff0ef          	jal	16d48 <_Balloc>
  b->_x[0] = i;
  b->_wds = 1;
  return b;
}
   17168:	00c12083          	lw	ra,12(sp)
{
  _Bigint *b;

  b = Balloc (ptr, 1);
  b->_x[0] = i;
  b->_wds = 1;
   1716c:	00100713          	li	a4,1
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
  _Bigint *b;

  b = Balloc (ptr, 1);
  b->_x[0] = i;
   17170:	00852a23          	sw	s0,20(a0)
  b->_wds = 1;
   17174:	00e52823          	sw	a4,16(a0)
  return b;
}
   17178:	00812403          	lw	s0,8(sp)
   1717c:	01010113          	addi	sp,sp,16
   17180:	00008067          	ret

00017184 <__multiply>:

_Bigint *
_DEFUN (mult, (ptr, a, b), struct _reent * ptr _AND _Bigint * a _AND _Bigint * b)
{
   17184:	fe010113          	addi	sp,sp,-32
   17188:	01312623          	sw	s3,12(sp)
   1718c:	01412423          	sw	s4,8(sp)
  __ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;
#ifdef Pack_32
  __ULong z2;
#endif

  if (a->_wds < b->_wds)
   17190:	0105a983          	lw	s3,16(a1)
   17194:	01062a03          	lw	s4,16(a2)
  return b;
}

_Bigint *
_DEFUN (mult, (ptr, a, b), struct _reent * ptr _AND _Bigint * a _AND _Bigint * b)
{
   17198:	00912a23          	sw	s1,20(sp)
   1719c:	01212823          	sw	s2,16(sp)
   171a0:	00112e23          	sw	ra,28(sp)
   171a4:	00812c23          	sw	s0,24(sp)
   171a8:	00058913          	mv	s2,a1
   171ac:	00060493          	mv	s1,a2
  __ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;
#ifdef Pack_32
  __ULong z2;
#endif

  if (a->_wds < b->_wds)
   171b0:	0149dc63          	ble	s4,s3,171c8 <__multiply+0x44>
   171b4:	00098713          	mv	a4,s3
   171b8:	00060913          	mv	s2,a2
   171bc:	000a0993          	mv	s3,s4
   171c0:	00058493          	mv	s1,a1
   171c4:	00070a13          	mv	s4,a4
    }
  k = a->_k;
  wa = a->_wds;
  wb = b->_wds;
  wc = wa + wb;
  if (wc > a->_maxwds)
   171c8:	00892783          	lw	a5,8(s2)
    {
      c = a;
      a = b;
      b = c;
    }
  k = a->_k;
   171cc:	00492583          	lw	a1,4(s2)
  wa = a->_wds;
  wb = b->_wds;
  wc = wa + wb;
   171d0:	01498433          	add	s0,s3,s4
  if (wc > a->_maxwds)
    k++;
   171d4:	0087a7b3          	slt	a5,a5,s0
  c = Balloc (ptr, k);
   171d8:	00f585b3          	add	a1,a1,a5
   171dc:	b6dff0ef          	jal	16d48 <_Balloc>
  for (x = c->_x, xa = x + wc; x < xa; x++)
   171e0:	01450293          	addi	t0,a0,20
   171e4:	00241893          	slli	a7,s0,0x2
   171e8:	011288b3          	add	a7,t0,a7
   171ec:	00028793          	mv	a5,t0
   171f0:	0112f863          	bleu	a7,t0,17200 <__multiply+0x7c>
    *x = 0;
   171f4:	0007a023          	sw	zero,0(a5)
  wb = b->_wds;
  wc = wa + wb;
  if (wc > a->_maxwds)
    k++;
  c = Balloc (ptr, k);
  for (x = c->_x, xa = x + wc; x < xa; x++)
   171f8:	00478793          	addi	a5,a5,4
   171fc:	ff17ece3          	bltu	a5,a7,171f4 <__multiply+0x70>
    *x = 0;
  xa = a->_x;
  xae = xa + wa;
  xb = b->_x;
   17200:	01448613          	addi	a2,s1,20
  xbe = xb + wb;
   17204:	002a1313          	slli	t1,s4,0x2
  if (wc > a->_maxwds)
    k++;
  c = Balloc (ptr, k);
  for (x = c->_x, xa = x + wc; x < xa; x++)
    *x = 0;
  xa = a->_x;
   17208:	01490393          	addi	t2,s2,20
  xae = xa + wa;
   1720c:	00299813          	slli	a6,s3,0x2
  xbe = xb + wb;
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
    {
      if ((y = *xb & 0xffff) != 0)
   17210:	000105b7          	lui	a1,0x10
  for (x = c->_x, xa = x + wc; x < xa; x++)
    *x = 0;
  xa = a->_x;
  xae = xa + wa;
  xb = b->_x;
  xbe = xb + wb;
   17214:	00660333          	add	t1,a2,t1
    k++;
  c = Balloc (ptr, k);
  for (x = c->_x, xa = x + wc; x < xa; x++)
    *x = 0;
  xa = a->_x;
  xae = xa + wa;
   17218:	01038833          	add	a6,t2,a6
  xbe = xb + wb;
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
    {
      if ((y = *xb & 0xffff) != 0)
   1721c:	fff58593          	addi	a1,a1,-1 # ffff <_reset+0xfdff>
  xae = xa + wa;
  xb = b->_x;
  xbe = xb + wb;
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
   17220:	10667463          	bleu	t1,a2,17328 <__multiply+0x1a4>
    {
      if ((y = *xb & 0xffff) != 0)
   17224:	00062f83          	lw	t6,0(a2)
   17228:	00bff933          	and	s2,t6,a1
   1722c:	06090a63          	beqz	s2,172a0 <__multiply+0x11c>
   17230:	00028f93          	mv	t6,t0
   17234:	00038f13          	mv	t5,t2
   17238:	00000693          	li	a3,0
   1723c:	0080006f          	j	17244 <__multiply+0xc0>
   17240:	00048f93          	mv	t6,s1
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   17244:	000f2e03          	lw	t3,0(t5)
   17248:	000fae83          	lw	t4,0(t6)
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
	      carry = z2 >> 16;
	      Storeinc (xc, z2, z);
   1724c:	004f8493          	addi	s1,t6,4
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   17250:	00be7733          	and	a4,t3,a1
   17254:	03270733          	mul	a4,a4,s2
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   17258:	010e5e13          	srli	t3,t3,0x10
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   1725c:	00bef7b3          	and	a5,t4,a1
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   17260:	010ede93          	srli	t4,t4,0x10
   17264:	004f0f13          	addi	t5,t5,4
   17268:	032e0e33          	mul	t3,t3,s2
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   1726c:	00f70733          	add	a4,a4,a5
   17270:	00d707b3          	add	a5,a4,a3
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   17274:	0107d693          	srli	a3,a5,0x10
	      carry = z2 >> 16;
	      Storeinc (xc, z2, z);
   17278:	00b7f7b3          	and	a5,a5,a1
	  carry = 0;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   1727c:	01de0e33          	add	t3,t3,t4
   17280:	00de06b3          	add	a3,t3,a3
	      carry = z2 >> 16;
	      Storeinc (xc, z2, z);
   17284:	01069713          	slli	a4,a3,0x10
   17288:	00f76733          	or	a4,a4,a5
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
	      carry = z2 >> 16;
   1728c:	0106d693          	srli	a3,a3,0x10
	      Storeinc (xc, z2, z);
   17290:	fee4ae23          	sw	a4,-4(s1)
	    }
	  while (x < xae);
   17294:	fb0f66e3          	bltu	t5,a6,17240 <__multiply+0xbc>
	  *xc = carry;
   17298:	00dfa223          	sw	a3,4(t6)
   1729c:	00062f83          	lw	t6,0(a2)
	}
      if ((y = *xb >> 16) != 0)
   172a0:	010fdf93          	srli	t6,t6,0x10
   172a4:	060f8c63          	beqz	t6,1731c <__multiply+0x198>
	{
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  z2 = *xc;
   172a8:	0002a783          	lw	a5,0(t0) # 16d18 <memset+0xb4>
   172ac:	00028f13          	mv	t5,t0
	  while (x < xae);
	  *xc = carry;
	}
      if ((y = *xb >> 16) != 0)
	{
	  x = xa;
   172b0:	00038e93          	mv	t4,t2
	  xc = xc0;
	  carry = 0;
	  z2 = *xc;
   172b4:	00078e13          	mv	t3,a5
	}
      if ((y = *xb >> 16) != 0)
	{
	  x = xa;
	  xc = xc0;
	  carry = 0;
   172b8:	00000913          	li	s2,0
   172bc:	0080006f          	j	172c4 <__multiply+0x140>
   172c0:	00048f13          	mv	t5,s1
	  z2 = *xc;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
   172c4:	000ea703          	lw	a4,0(t4)
   172c8:	010e5693          	srli	a3,t3,0x10
	      carry = z >> 16;
	      Storeinc (xc, z, z2);
   172cc:	00b7f7b3          	and	a5,a5,a1
	  xc = xc0;
	  carry = 0;
	  z2 = *xc;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
   172d0:	00b77733          	and	a4,a4,a1
   172d4:	03f70733          	mul	a4,a4,t6
	      carry = z >> 16;
	      Storeinc (xc, z, z2);
   172d8:	004f0493          	addi	s1,t5,4
	      z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
   172dc:	004e8e93          	addi	t4,t4,4
	  xc = xc0;
	  carry = 0;
	  z2 = *xc;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
   172e0:	00d706b3          	add	a3,a4,a3
   172e4:	012686b3          	add	a3,a3,s2
	      carry = z >> 16;
	      Storeinc (xc, z, z2);
   172e8:	01069713          	slli	a4,a3,0x10
   172ec:	00f767b3          	or	a5,a4,a5
   172f0:	fef4ae23          	sw	a5,-4(s1)
	      z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
   172f4:	ffeed703          	lhu	a4,-2(t4)
   172f8:	004f2e03          	lw	t3,4(t5)
   172fc:	0106d693          	srli	a3,a3,0x10
   17300:	03f70733          	mul	a4,a4,t6
   17304:	00be77b3          	and	a5,t3,a1
   17308:	00f707b3          	add	a5,a4,a5
   1730c:	00d787b3          	add	a5,a5,a3
	      carry = z2 >> 16;
   17310:	0107d913          	srli	s2,a5,0x10
	    }
	  while (x < xae);
   17314:	fb0ee6e3          	bltu	t4,a6,172c0 <__multiply+0x13c>
	  *xc = z2;
   17318:	00ff2223          	sw	a5,4(t5)
  xae = xa + wa;
  xb = b->_x;
  xbe = xb + wb;
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
   1731c:	00460613          	addi	a2,a2,4
   17320:	00428293          	addi	t0,t0,4
   17324:	f06660e3          	bltu	a2,t1,17224 <__multiply+0xa0>
	  while (x < xae);
	  *xc = carry;
	}
    }
#endif
  for (xc0 = c->_x, xc = xc0 + wc; wc > 0 && !*--xc; --wc);
   17328:	02805463          	blez	s0,17350 <__multiply+0x1cc>
   1732c:	ffc8a783          	lw	a5,-4(a7)
   17330:	ffc88893          	addi	a7,a7,-4
   17334:	00078863          	beqz	a5,17344 <__multiply+0x1c0>
   17338:	0180006f          	j	17350 <__multiply+0x1cc>
   1733c:	0008a783          	lw	a5,0(a7)
   17340:	00079863          	bnez	a5,17350 <__multiply+0x1cc>
   17344:	fff40413          	addi	s0,s0,-1
   17348:	ffc88893          	addi	a7,a7,-4
   1734c:	fe0418e3          	bnez	s0,1733c <__multiply+0x1b8>
  c->_wds = wc;
  return c;
}
   17350:	01c12083          	lw	ra,28(sp)
	  *xc = carry;
	}
    }
#endif
  for (xc0 = c->_x, xc = xc0 + wc; wc > 0 && !*--xc; --wc);
  c->_wds = wc;
   17354:	00852823          	sw	s0,16(a0)
  return c;
}
   17358:	01412483          	lw	s1,20(sp)
   1735c:	01812403          	lw	s0,24(sp)
   17360:	01012903          	lw	s2,16(sp)
   17364:	00c12983          	lw	s3,12(sp)
   17368:	00812a03          	lw	s4,8(sp)
   1736c:	02010113          	addi	sp,sp,32
   17370:	00008067          	ret

00017374 <__pow5mult>:

_Bigint *
_DEFUN (pow5mult,
	(ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   17374:	fe010113          	addi	sp,sp,-32
  _Bigint *b1, *p5, *p51;
  int i;
  static _CONST int p05[3] = {5, 25, 125};

  if ((i = k & 3) != 0)
   17378:	00367793          	andi	a5,a2,3
}

_Bigint *
_DEFUN (pow5mult,
	(ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   1737c:	00812c23          	sw	s0,24(sp)
   17380:	01212823          	sw	s2,16(sp)
   17384:	01312623          	sw	s3,12(sp)
   17388:	00112e23          	sw	ra,28(sp)
   1738c:	00912a23          	sw	s1,20(sp)
   17390:	00060413          	mv	s0,a2
   17394:	00050993          	mv	s3,a0
   17398:	00058913          	mv	s2,a1
  _Bigint *b1, *p5, *p51;
  int i;
  static _CONST int p05[3] = {5, 25, 125};

  if ((i = k & 3) != 0)
   1739c:	0a079e63          	bnez	a5,17458 <__pow5mult+0xe4>
    b = multadd (ptr, b, p05[i - 1], 0);

  if (!(k >>= 2))
   173a0:	40245413          	srai	s0,s0,0x2
   173a4:	06040663          	beqz	s0,17410 <__pow5mult+0x9c>
    return b;
  _REENT_CHECK_MP(ptr);
  if (!(p5 = _REENT_MP_P5S(ptr)))
   173a8:	0489a483          	lw	s1,72(s3)
   173ac:	0c048a63          	beqz	s1,17480 <__pow5mult+0x10c>
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
      p5->_next = 0;
    }
  for (;;)
    {
      if (k & 1)
   173b0:	00147793          	andi	a5,s0,1
   173b4:	02079063          	bnez	a5,173d4 <__pow5mult+0x60>
	{
	  b1 = mult (ptr, b, p5);
	  Bfree (ptr, b);
	  b = b1;
	}
      if (!(k >>= 1))
   173b8:	40145413          	srai	s0,s0,0x1
   173bc:	04040a63          	beqz	s0,17410 <__pow5mult+0x9c>
	break;
      if (!(p51 = p5->_next))
   173c0:	0004a503          	lw	a0,0(s1)
   173c4:	06050663          	beqz	a0,17430 <__pow5mult+0xbc>
}

_Bigint *
_DEFUN (pow5mult,
	(ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   173c8:	00050493          	mv	s1,a0
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
      p5->_next = 0;
    }
  for (;;)
    {
      if (k & 1)
   173cc:	00147793          	andi	a5,s0,1
   173d0:	fe0784e3          	beqz	a5,173b8 <__pow5mult+0x44>
	{
	  b1 = mult (ptr, b, p5);
   173d4:	00048613          	mv	a2,s1
   173d8:	00090593          	mv	a1,s2
   173dc:	00098513          	mv	a0,s3
   173e0:	da5ff0ef          	jal	17184 <__multiply>

void
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
   173e4:	06090663          	beqz	s2,17450 <__pow5mult+0xdc>
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   173e8:	00492783          	lw	a5,4(s2)
   173ec:	04c9a703          	lw	a4,76(s3)
	{
	  b1 = mult (ptr, b, p5);
	  Bfree (ptr, b);
	  b = b1;
	}
      if (!(k >>= 1))
   173f0:	40145413          	srai	s0,s0,0x1
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   173f4:	00279793          	slli	a5,a5,0x2
   173f8:	00f707b3          	add	a5,a4,a5
   173fc:	0007a703          	lw	a4,0(a5)
   17400:	00e92023          	sw	a4,0(s2)
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   17404:	0127a023          	sw	s2,0(a5)
    {
      if (k & 1)
	{
	  b1 = mult (ptr, b, p5);
	  Bfree (ptr, b);
	  b = b1;
   17408:	00050913          	mv	s2,a0
	}
      if (!(k >>= 1))
   1740c:	fa041ae3          	bnez	s0,173c0 <__pow5mult+0x4c>
	  p51->_next = 0;
	}
      p5 = p51;
    }
  return b;
}
   17410:	01c12083          	lw	ra,28(sp)
   17414:	00090513          	mv	a0,s2
   17418:	01812403          	lw	s0,24(sp)
   1741c:	01412483          	lw	s1,20(sp)
   17420:	01012903          	lw	s2,16(sp)
   17424:	00c12983          	lw	s3,12(sp)
   17428:	02010113          	addi	sp,sp,32
   1742c:	00008067          	ret
	}
      if (!(k >>= 1))
	break;
      if (!(p51 = p5->_next))
	{
	  p51 = p5->_next = mult (ptr, p5, p5);
   17430:	00048613          	mv	a2,s1
   17434:	00048593          	mv	a1,s1
   17438:	00098513          	mv	a0,s3
   1743c:	d49ff0ef          	jal	17184 <__multiply>
   17440:	00a4a023          	sw	a0,0(s1)
	  p51->_next = 0;
   17444:	00052023          	sw	zero,0(a0)
}

_Bigint *
_DEFUN (pow5mult,
	(ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   17448:	00050493          	mv	s1,a0
   1744c:	f81ff06f          	j	173cc <__pow5mult+0x58>
    {
      if (k & 1)
	{
	  b1 = mult (ptr, b, p5);
	  Bfree (ptr, b);
	  b = b1;
   17450:	00050913          	mv	s2,a0
   17454:	f65ff06f          	j	173b8 <__pow5mult+0x44>
  _Bigint *b1, *p5, *p51;
  int i;
  static _CONST int p05[3] = {5, 25, 125};

  if ((i = k & 3) != 0)
    b = multadd (ptr, b, p05[i - 1], 0);
   17458:	fff78793          	addi	a5,a5,-1
   1745c:	0001c737          	lui	a4,0x1c
   17460:	e4870713          	addi	a4,a4,-440 # 1be48 <p05.2565>
   17464:	00279793          	slli	a5,a5,0x2
   17468:	00f707b3          	add	a5,a4,a5
   1746c:	0007a603          	lw	a2,0(a5)
   17470:	00000693          	li	a3,0
   17474:	99dff0ef          	jal	16e10 <__multadd>
   17478:	00050913          	mv	s2,a0
   1747c:	f25ff06f          	j	173a0 <__pow5mult+0x2c>
_Bigint *
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
  _Bigint *b;

  b = Balloc (ptr, 1);
   17480:	00100593          	li	a1,1
   17484:	00098513          	mv	a0,s3
   17488:	8c1ff0ef          	jal	16d48 <_Balloc>
  b->_x[0] = i;
   1748c:	27100793          	li	a5,625
   17490:	00f52a23          	sw	a5,20(a0)
  b->_wds = 1;
   17494:	00100793          	li	a5,1
   17498:	00f52823          	sw	a5,16(a0)
_Bigint *
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
  _Bigint *b;

  b = Balloc (ptr, 1);
   1749c:	00050493          	mv	s1,a0
    return b;
  _REENT_CHECK_MP(ptr);
  if (!(p5 = _REENT_MP_P5S(ptr)))
    {
      /* first time */
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
   174a0:	04a9a423          	sw	a0,72(s3)
      p5->_next = 0;
   174a4:	00052023          	sw	zero,0(a0)
   174a8:	f09ff06f          	j	173b0 <__pow5mult+0x3c>

000174ac <__lshift>:
  return b;
}

_Bigint *
_DEFUN (lshift, (ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   174ac:	fe010113          	addi	sp,sp,-32
   174b0:	01412423          	sw	s4,8(sp)
  n = k >> 5;
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
   174b4:	0105aa03          	lw	s4,16(a1)
  return b;
}

_Bigint *
_DEFUN (lshift, (ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   174b8:	00812c23          	sw	s0,24(sp)
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
   174bc:	0085a783          	lw	a5,8(a1)
  int i, k1, n, n1;
  _Bigint *b1;
  __ULong *x, *x1, *xe, z;

#ifdef Pack_32
  n = k >> 5;
   174c0:	40565413          	srai	s0,a2,0x5
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
   174c4:	01440a33          	add	s4,s0,s4
  return b;
}

_Bigint *
_DEFUN (lshift, (ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   174c8:	00912a23          	sw	s1,20(sp)
  n = k >> 5;
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
   174cc:	001a0493          	addi	s1,s4,1
  return b;
}

_Bigint *
_DEFUN (lshift, (ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   174d0:	01212823          	sw	s2,16(sp)
   174d4:	01312623          	sw	s3,12(sp)
   174d8:	01512223          	sw	s5,4(sp)
   174dc:	00058993          	mv	s3,a1
   174e0:	00112e23          	sw	ra,28(sp)
   174e4:	00060913          	mv	s2,a2
   174e8:	00050a93          	mv	s5,a0
#ifdef Pack_32
  n = k >> 5;
#else
  n = k >> 4;
#endif
  k1 = b->_k;
   174ec:	0045a583          	lw	a1,4(a1)
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
   174f0:	0097d863          	ble	s1,a5,17500 <__lshift+0x54>
   174f4:	00179793          	slli	a5,a5,0x1
    k1++;
   174f8:	00158593          	addi	a1,a1,1
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
   174fc:	fe97cce3          	blt	a5,s1,174f4 <__lshift+0x48>
    k1++;
  b1 = Balloc (ptr, k1);
   17500:	000a8513          	mv	a0,s5
   17504:	845ff0ef          	jal	16d48 <_Balloc>
  x1 = b1->_x;
   17508:	01450793          	addi	a5,a0,20
  for (i = 0; i < n; i++)
   1750c:	0e805463          	blez	s0,175f4 <__lshift+0x148>
   17510:	00241713          	slli	a4,s0,0x2
   17514:	00e78733          	add	a4,a5,a4
    *x1++ = 0;
   17518:	00478793          	addi	a5,a5,4
   1751c:	fe07ae23          	sw	zero,-4(a5)
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
    k1++;
  b1 = Balloc (ptr, k1);
  x1 = b1->_x;
  for (i = 0; i < n; i++)
   17520:	fee79ce3          	bne	a5,a4,17518 <__lshift+0x6c>
    *x1++ = 0;
  x = b->_x;
  xe = x + b->_wds;
   17524:	0109a883          	lw	a7,16(s3)
    k1++;
  b1 = Balloc (ptr, k1);
  x1 = b1->_x;
  for (i = 0; i < n; i++)
    *x1++ = 0;
  x = b->_x;
   17528:	01498793          	addi	a5,s3,20
  xe = x + b->_wds;
#ifdef Pack_32
  if (k &= 0x1f)
   1752c:	01f97613          	andi	a2,s2,31
  b1 = Balloc (ptr, k1);
  x1 = b1->_x;
  for (i = 0; i < n; i++)
    *x1++ = 0;
  x = b->_x;
  xe = x + b->_wds;
   17530:	00289893          	slli	a7,a7,0x2
   17534:	011788b3          	add	a7,a5,a7
#ifdef Pack_32
  if (k &= 0x1f)
   17538:	08060863          	beqz	a2,175c8 <__lshift+0x11c>
    {
      k1 = 32 - k;
   1753c:	02000293          	li	t0,32
   17540:	40c282b3          	sub	t0,t0,a2
      z = 0;
   17544:	00000693          	li	a3,0
   17548:	0080006f          	j	17550 <__lshift+0xa4>
   1754c:	00080713          	mv	a4,a6
      do
	{
	  *x1++ = *x << k | z;
   17550:	0007a583          	lw	a1,0(a5)
   17554:	00470813          	addi	a6,a4,4
	  z = *x++ >> k1;
   17558:	00478793          	addi	a5,a5,4
    {
      k1 = 32 - k;
      z = 0;
      do
	{
	  *x1++ = *x << k | z;
   1755c:	00c595b3          	sll	a1,a1,a2
   17560:	00d5e6b3          	or	a3,a1,a3
   17564:	fed82e23          	sw	a3,-4(a6)
	  z = *x++ >> k1;
   17568:	ffc7a683          	lw	a3,-4(a5)
   1756c:	0056d6b3          	srl	a3,a3,t0
	}
      while (x < xe);
   17570:	fd17eee3          	bltu	a5,a7,1754c <__lshift+0xa0>
      if ((*x1 = z) != 0)
   17574:	00d72223          	sw	a3,4(a4)
   17578:	00068463          	beqz	a3,17580 <__lshift+0xd4>
	++n1;
   1757c:	002a0493          	addi	s1,s4,2
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   17580:	0049a783          	lw	a5,4(s3)
   17584:	04caa703          	lw	a4,76(s5)
      *x1++ = *x++;
    while (x < xe);
  b1->_wds = n1 - 1;
  Bfree (ptr, b);
  return b1;
}
   17588:	01c12083          	lw	ra,28(sp)
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   1758c:	00279793          	slli	a5,a5,0x2
   17590:	00f707b3          	add	a5,a4,a5
   17594:	0007a703          	lw	a4,0(a5)
#endif
  else
    do
      *x1++ = *x++;
    while (x < xe);
  b1->_wds = n1 - 1;
   17598:	fff48493          	addi	s1,s1,-1
   1759c:	00952823          	sw	s1,16(a0)
  Bfree (ptr, b);
  return b1;
}
   175a0:	01812403          	lw	s0,24(sp)
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   175a4:	00e9a023          	sw	a4,0(s3)
      *x1++ = *x++;
    while (x < xe);
  b1->_wds = n1 - 1;
  Bfree (ptr, b);
  return b1;
}
   175a8:	01412483          	lw	s1,20(sp)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   175ac:	0137a023          	sw	s3,0(a5)
      *x1++ = *x++;
    while (x < xe);
  b1->_wds = n1 - 1;
  Bfree (ptr, b);
  return b1;
}
   175b0:	01012903          	lw	s2,16(sp)
   175b4:	00c12983          	lw	s3,12(sp)
   175b8:	00812a03          	lw	s4,8(sp)
   175bc:	00412a83          	lw	s5,4(sp)
   175c0:	02010113          	addi	sp,sp,32
   175c4:	00008067          	ret
	++n1;
    }
#endif
  else
    do
      *x1++ = *x++;
   175c8:	00478793          	addi	a5,a5,4
   175cc:	ffc7a683          	lw	a3,-4(a5)
   175d0:	00470713          	addi	a4,a4,4
   175d4:	fed72e23          	sw	a3,-4(a4)
    while (x < xe);
   175d8:	fb17f4e3          	bleu	a7,a5,17580 <__lshift+0xd4>
	++n1;
    }
#endif
  else
    do
      *x1++ = *x++;
   175dc:	00478793          	addi	a5,a5,4
   175e0:	ffc7a683          	lw	a3,-4(a5)
   175e4:	00470713          	addi	a4,a4,4
   175e8:	fed72e23          	sw	a3,-4(a4)
    while (x < xe);
   175ec:	fd17eee3          	bltu	a5,a7,175c8 <__lshift+0x11c>
   175f0:	f91ff06f          	j	17580 <__lshift+0xd4>
  k1 = b->_k;
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
    k1++;
  b1 = Balloc (ptr, k1);
  x1 = b1->_x;
   175f4:	00078713          	mv	a4,a5
   175f8:	f2dff06f          	j	17524 <__lshift+0x78>

000175fc <__mcmp>:
_DEFUN (cmp, (a, b), _Bigint * a _AND _Bigint * b)
{
  __ULong *xa, *xa0, *xb, *xb0;
  int i, j;

  i = a->_wds;
   175fc:	01052703          	lw	a4,16(a0)
  j = b->_wds;
   17600:	0105a783          	lw	a5,16(a1)
  if (i > 1 && !a->_x[i - 1])
    Bug ("cmp called with a->_x[a->_wds-1] == 0");
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
   17604:	40f70733          	sub	a4,a4,a5
   17608:	04071263          	bnez	a4,1764c <__mcmp+0x50>
    return i;
  xa0 = a->_x;
  xa = xa0 + j;
   1760c:	00279713          	slli	a4,a5,0x2
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
    return i;
  xa0 = a->_x;
   17610:	01450513          	addi	a0,a0,20
  xa = xa0 + j;
  xb0 = b->_x;
   17614:	01458593          	addi	a1,a1,20
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
    return i;
  xa0 = a->_x;
  xa = xa0 + j;
   17618:	00e507b3          	add	a5,a0,a4
  xb0 = b->_x;
  xb = xb0 + j;
   1761c:	00e585b3          	add	a1,a1,a4
   17620:	0080006f          	j	17628 <__mcmp+0x2c>
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
      if (xa <= xa0)
   17624:	02f57863          	bleu	a5,a0,17654 <__mcmp+0x58>
  xa = xa0 + j;
  xb0 = b->_x;
  xb = xb0 + j;
  for (;;)
    {
      if (*--xa != *--xb)
   17628:	ffc78793          	addi	a5,a5,-4
   1762c:	ffc58593          	addi	a1,a1,-4
   17630:	0007a703          	lw	a4,0(a5)
   17634:	0005a683          	lw	a3,0(a1)
   17638:	fed706e3          	beq	a4,a3,17624 <__mcmp+0x28>
	return *xa < *xb ? -1 : 1;
   1763c:	00d73733          	sltu	a4,a4,a3
   17640:	40e00733          	neg	a4,a4
   17644:	00176513          	ori	a0,a4,1
   17648:	00008067          	ret
   1764c:	00070513          	mv	a0,a4
      if (xa <= xa0)
	break;
    }
  return 0;
}
   17650:	00008067          	ret
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
      if (xa <= xa0)
	break;
    }
  return 0;
   17654:	00000513          	li	a0,0
   17658:	00008067          	ret

0001765c <__mdiff>:
_DEFUN (cmp, (a, b), _Bigint * a _AND _Bigint * b)
{
  __ULong *xa, *xa0, *xb, *xb0;
  int i, j;

  i = a->_wds;
   1765c:	0105a783          	lw	a5,16(a1)
  j = b->_wds;
   17660:	01062703          	lw	a4,16(a2)
}

_Bigint *
_DEFUN (diff, (ptr, a, b), struct _reent * ptr _AND
	_Bigint * a _AND _Bigint * b)
{
   17664:	fd010113          	addi	sp,sp,-48
   17668:	03212023          	sw	s2,32(sp)
  if (i > 1 && !a->_x[i - 1])
    Bug ("cmp called with a->_x[a->_wds-1] == 0");
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
   1766c:	40e787b3          	sub	a5,a5,a4
}

_Bigint *
_DEFUN (diff, (ptr, a, b), struct _reent * ptr _AND
	_Bigint * a _AND _Bigint * b)
{
   17670:	02112623          	sw	ra,44(sp)
   17674:	02812423          	sw	s0,40(sp)
   17678:	02912223          	sw	s1,36(sp)
   1767c:	01312e23          	sw	s3,28(sp)
   17680:	00058913          	mv	s2,a1
  if (i > 1 && !a->_x[i - 1])
    Bug ("cmp called with a->_x[a->_wds-1] == 0");
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
   17684:	04079863          	bnez	a5,176d4 <__mdiff+0x78>
    return i;
  xa0 = a->_x;
  xa = xa0 + j;
   17688:	00271713          	slli	a4,a4,0x2
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
    return i;
  xa0 = a->_x;
   1768c:	01458813          	addi	a6,a1,20
  xa = xa0 + j;
  xb0 = b->_x;
   17690:	01460413          	addi	s0,a2,20
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
    return i;
  xa0 = a->_x;
  xa = xa0 + j;
   17694:	00e807b3          	add	a5,a6,a4
  xb0 = b->_x;
  xb = xb0 + j;
   17698:	00e40733          	add	a4,s0,a4
   1769c:	0080006f          	j	176a4 <__mdiff+0x48>
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
      if (xa <= xa0)
   176a0:	16f87463          	bleu	a5,a6,17808 <__mdiff+0x1ac>
  xa = xa0 + j;
  xb0 = b->_x;
  xb = xb0 + j;
  for (;;)
    {
      if (*--xa != *--xb)
   176a4:	ffc78793          	addi	a5,a5,-4
   176a8:	ffc70713          	addi	a4,a4,-4
   176ac:	0007a583          	lw	a1,0(a5)
   176b0:	00072683          	lw	a3,0(a4)
   176b4:	fed586e3          	beq	a1,a3,176a0 <__mdiff+0x44>
	return *xa < *xb ? -1 : 1;
   176b8:	16d5f463          	bleu	a3,a1,17820 <__mdiff+0x1c4>
   176bc:	00090793          	mv	a5,s2
   176c0:	00080493          	mv	s1,a6
   176c4:	00060913          	mv	s2,a2
  if (i < 0)
    {
      c = a;
      a = b;
      b = c;
      i = 1;
   176c8:	00100993          	li	s3,1
  xb0 = b->_x;
  xb = xb0 + j;
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
   176cc:	00078613          	mv	a2,a5
   176d0:	0140006f          	j	176e4 <__mdiff+0x88>
      c = Balloc (ptr, 0);
      c->_wds = 1;
      c->_x[0] = 0;
      return c;
    }
  if (i < 0)
   176d4:	1407ce63          	bltz	a5,17830 <__mdiff+0x1d4>
   176d8:	01460493          	addi	s1,a2,20
   176dc:	01458413          	addi	s0,a1,20
      a = b;
      b = c;
      i = 1;
    }
  else
    i = 0;
   176e0:	00000993          	li	s3,0
  c = Balloc (ptr, a->_k);
   176e4:	00492583          	lw	a1,4(s2)
   176e8:	00c12623          	sw	a2,12(sp)
   176ec:	e5cff0ef          	jal	16d48 <_Balloc>
  wa = a->_wds;
  xa = a->_x;
  xae = xa + wa;
  wb = b->_wds;
  xb = b->_x;
  xbe = xb + wb;
   176f0:	00c12603          	lw	a2,12(sp)
    }
  else
    i = 0;
  c = Balloc (ptr, a->_k);
  c->_sign = i;
  wa = a->_wds;
   176f4:	01092303          	lw	t1,16(s2)
  xc = c->_x;
  borrow = 0;
#ifdef Pack_32
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
   176f8:	000102b7          	lui	t0,0x10
  wa = a->_wds;
  xa = a->_x;
  xae = xa + wa;
  wb = b->_wds;
  xb = b->_x;
  xbe = xb + wb;
   176fc:	01062e03          	lw	t3,16(a2)
    i = 0;
  c = Balloc (ptr, a->_k);
  c->_sign = i;
  wa = a->_wds;
  xa = a->_x;
  xae = xa + wa;
   17700:	00231393          	slli	t2,t1,0x2
      i = 1;
    }
  else
    i = 0;
  c = Balloc (ptr, a->_k);
  c->_sign = i;
   17704:	01352623          	sw	s3,12(a0)
  wa = a->_wds;
  xa = a->_x;
  xae = xa + wa;
  wb = b->_wds;
  xb = b->_x;
  xbe = xb + wb;
   17708:	002e1e13          	slli	t3,t3,0x2
    i = 0;
  c = Balloc (ptr, a->_k);
  c->_sign = i;
  wa = a->_wds;
  xa = a->_x;
  xae = xa + wa;
   1770c:	007403b3          	add	t2,s0,t2
  wb = b->_wds;
  xb = b->_x;
  xbe = xb + wb;
   17710:	01c48e33          	add	t3,s1,t3
  xc = c->_x;
   17714:	01450813          	addi	a6,a0,20
  borrow = 0;
   17718:	00000693          	li	a3,0
#ifdef Pack_32
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
   1771c:	fff28293          	addi	t0,t0,-1 # ffff <_reset+0xfdff>
   17720:	00042583          	lw	a1,0(s0)
   17724:	0004a883          	lw	a7,0(s1)
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   17728:	00480813          	addi	a6,a6,4
  xc = c->_x;
  borrow = 0;
#ifdef Pack_32
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
   1772c:	0055f633          	and	a2,a1,t0
   17730:	00d606b3          	add	a3,a2,a3
   17734:	0058f733          	and	a4,a7,t0
   17738:	40e68733          	sub	a4,a3,a4
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
   1773c:	0105d593          	srli	a1,a1,0x10
   17740:	0108d693          	srli	a3,a7,0x10
   17744:	40d585b3          	sub	a1,a1,a3
   17748:	41075693          	srai	a3,a4,0x10
   1774c:	00d586b3          	add	a3,a1,a3
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   17750:	01069793          	slli	a5,a3,0x10
   17754:	00577733          	and	a4,a4,t0
   17758:	00e7e7b3          	or	a5,a5,a4
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
   1775c:	00448493          	addi	s1,s1,4
   17760:	00440413          	addi	s0,s0,4
      borrow = z >> 16;
   17764:	4106d693          	srai	a3,a3,0x10
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   17768:	fef82e23          	sw	a5,-4(a6)
    }
  while (xb < xbe);
   1776c:	fbc4eae3          	bltu	s1,t3,17720 <__mdiff+0xc4>
  while (xa < xae)
   17770:	06747063          	bleu	t2,s0,177d0 <__mdiff+0x174>
    {
      y = (*xa & 0xffff) + borrow;
   17774:	00010e37          	lui	t3,0x10
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   17778:	00080293          	mv	t0,a6
    }
  while (xb < xbe);
  while (xa < xae)
   1777c:	00040893          	mv	a7,s0
    {
      y = (*xa & 0xffff) + borrow;
   17780:	fffe0e13          	addi	t3,t3,-1 # ffff <_reset+0xfdff>
   17784:	0008a583          	lw	a1,0(a7)
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   17788:	00428293          	addi	t0,t0,4
  while (xa < xae)
    {
      y = (*xa & 0xffff) + borrow;
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
   1778c:	00488893          	addi	a7,a7,4
      Storeinc (xc, z, y);
    }
  while (xb < xbe);
  while (xa < xae)
    {
      y = (*xa & 0xffff) + borrow;
   17790:	01c5f633          	and	a2,a1,t3
   17794:	00d606b3          	add	a3,a2,a3
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
   17798:	4106d713          	srai	a4,a3,0x10
   1779c:	0105d593          	srli	a1,a1,0x10
   177a0:	00e58733          	add	a4,a1,a4
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   177a4:	01c6f6b3          	and	a3,a3,t3
   177a8:	01071793          	slli	a5,a4,0x10
   177ac:	00d7e7b3          	or	a5,a5,a3
   177b0:	fef2ae23          	sw	a5,-4(t0)
    {
      y = (*xa & 0xffff) + borrow;
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
      borrow = z >> 16;
   177b4:	41075693          	srai	a3,a4,0x10
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
    }
  while (xb < xbe);
  while (xa < xae)
   177b8:	fc78e6e3          	bltu	a7,t2,17784 <__mdiff+0x128>
   177bc:	fff44413          	not	s0,s0
   177c0:	007403b3          	add	t2,s0,t2
   177c4:	ffc3f393          	andi	t2,t2,-4
   177c8:	00438393          	addi	t2,t2,4
   177cc:	00780833          	add	a6,a6,t2
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      *xc++ = y & 0xffff;
    }
#endif
  while (!*--xc)
   177d0:	ffc80813          	addi	a6,a6,-4
   177d4:	00079a63          	bnez	a5,177e8 <__mdiff+0x18c>
   177d8:	ffc80813          	addi	a6,a6,-4
   177dc:	00082783          	lw	a5,0(a6)
    wa--;
   177e0:	fff30313          	addi	t1,t1,-1
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      *xc++ = y & 0xffff;
    }
#endif
  while (!*--xc)
   177e4:	fe078ae3          	beqz	a5,177d8 <__mdiff+0x17c>
    wa--;
  c->_wds = wa;
   177e8:	00652823          	sw	t1,16(a0)
  return c;
}
   177ec:	02c12083          	lw	ra,44(sp)
   177f0:	02812403          	lw	s0,40(sp)
   177f4:	02412483          	lw	s1,36(sp)
   177f8:	02012903          	lw	s2,32(sp)
   177fc:	01c12983          	lw	s3,28(sp)
   17800:	03010113          	addi	sp,sp,48
   17804:	00008067          	ret
#endif

  i = cmp (a, b);
  if (!i)
    {
      c = Balloc (ptr, 0);
   17808:	00000593          	li	a1,0
   1780c:	d3cff0ef          	jal	16d48 <_Balloc>
      c->_wds = 1;
   17810:	00100793          	li	a5,1
   17814:	00f52823          	sw	a5,16(a0)
      c->_x[0] = 0;
   17818:	00052a23          	sw	zero,20(a0)
      return c;
   1781c:	fd1ff06f          	j	177ec <__mdiff+0x190>
  xb0 = b->_x;
  xb = xb0 + j;
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
   17820:	00040493          	mv	s1,s0
      a = b;
      b = c;
      i = 1;
    }
  else
    i = 0;
   17824:	00000993          	li	s3,0
  xb0 = b->_x;
  xb = xb0 + j;
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
   17828:	00080413          	mv	s0,a6
   1782c:	eb9ff06f          	j	176e4 <__mdiff+0x88>
   17830:	00090793          	mv	a5,s2
   17834:	01490493          	addi	s1,s2,20
   17838:	01460413          	addi	s0,a2,20
   1783c:	00060913          	mv	s2,a2
  if (i < 0)
    {
      c = a;
      a = b;
      b = c;
      i = 1;
   17840:	00100993          	li	s3,1
   17844:	00078613          	mv	a2,a5
   17848:	e9dff06f          	j	176e4 <__mdiff+0x88>

0001784c <__ulp>:
  union double_union x, a;
  register __Long L;

  x.d = _x;

  L = (word0 (x) & Exp_mask) - (P - 1) * Exp_msk1;
   1784c:	7ff007b7          	lui	a5,0x7ff00
   17850:	00f5f5b3          	and	a1,a1,a5
   17854:	fcc007b7          	lui	a5,0xfcc00
   17858:	00f585b3          	add	a1,a1,a5
#ifndef Sudden_Underflow
  if (L > 0)
   1785c:	00b05c63          	blez	a1,17874 <__ulp+0x28>
    {
#endif
#ifdef IBM
      L |= Exp_msk1 >> 4;
#endif
      word0 (a) = L;
   17860:	00000713          	li	a4,0
   17864:	00058793          	mv	a5,a1
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
#endif
	}
    }
#endif
  return a.d;
   17868:	00070513          	mv	a0,a4
   1786c:	00078593          	mv	a1,a5
}
   17870:	00008067          	ret

#ifndef Sudden_Underflow
    }
  else
    {
      L = -L >> Exp_shift;
   17874:	40b005b3          	neg	a1,a1
   17878:	4145d593          	srai	a1,a1,0x14
      if (L < Exp_shift)
   1787c:	01300793          	li	a5,19
   17880:	02b7d863          	ble	a1,a5,178b0 <__ulp+0x64>
#endif
	}
      else
	{
	  word0 (a) = 0;
	  L -= Exp_shift;
   17884:	fec58593          	addi	a1,a1,-20
#ifndef _DOUBLE_IS_32BITS
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
   17888:	01e00613          	li	a2,30
	  word1 (a) = 0;
#endif
	}
      else
	{
	  word0 (a) = 0;
   1788c:	00000793          	li	a5,0
	  L -= Exp_shift;
#ifndef _DOUBLE_IS_32BITS
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
   17890:	00100693          	li	a3,1
   17894:	00b64663          	blt	a2,a1,178a0 <__ulp+0x54>
   17898:	fff5c593          	not	a1,a1
   1789c:	00b696b3          	sll	a3,a3,a1
   178a0:	00068713          	mv	a4,a3
#endif
	}
    }
#endif
  return a.d;
   178a4:	00070513          	mv	a0,a4
   178a8:	00078593          	mv	a1,a5
}
   178ac:	00008067          	ret
  else
    {
      L = -L >> Exp_shift;
      if (L < Exp_shift)
	{
	  word0 (a) = 0x80000 >> L;
   178b0:	000806b7          	lui	a3,0x80
   178b4:	00000713          	li	a4,0
   178b8:	40b6d7b3          	sra	a5,a3,a1
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
#endif
	}
    }
#endif
  return a.d;
   178bc:	00070513          	mv	a0,a4
   178c0:	00078593          	mv	a1,a5
}
   178c4:	00008067          	ret

000178c8 <__b2d>:

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   178c8:	fe010113          	addi	sp,sp,-32
   178cc:	00812c23          	sw	s0,24(sp)
#define d0 word0(d)
#define d1 word1(d)
#endif

  xa0 = a->_x;
  xa = xa0 + a->_wds;
   178d0:	01052403          	lw	s0,16(a0)
}

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   178d4:	00912a23          	sw	s1,20(sp)
#else
#define d0 word0(d)
#define d1 word1(d)
#endif

  xa0 = a->_x;
   178d8:	01450493          	addi	s1,a0,20
  xa = xa0 + a->_wds;
   178dc:	00241413          	slli	s0,s0,0x2
   178e0:	00848433          	add	s0,s1,s0
}

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   178e4:	01212823          	sw	s2,16(sp)
#define d1 word1(d)
#endif

  xa0 = a->_x;
  xa = xa0 + a->_wds;
  y = *--xa;
   178e8:	ffc42903          	lw	s2,-4(s0)
}

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   178ec:	01312623          	sw	s3,12(sp)
   178f0:	01412423          	sw	s4,8(sp)
  y = *--xa;
#ifdef DEBUG
  if (!y)
    Bug ("zero y in b2d");
#endif
  k = hi0bits (y);
   178f4:	00090513          	mv	a0,s2
}

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   178f8:	00058a13          	mv	s4,a1
   178fc:	00112e23          	sw	ra,28(sp)
  y = *--xa;
#ifdef DEBUG
  if (!y)
    Bug ("zero y in b2d");
#endif
  k = hi0bits (y);
   17900:	f24ff0ef          	jal	17024 <__hi0bits>
  *e = 32 - k;
   17904:	02000793          	li	a5,32
   17908:	40a78733          	sub	a4,a5,a0
   1790c:	00ea2023          	sw	a4,0(s4)
#ifdef Pack_32
  if (k < Ebits)
   17910:	00a00713          	li	a4,10
#define d1 word1(d)
#endif

  xa0 = a->_x;
  xa = xa0 + a->_wds;
  y = *--xa;
   17914:	ffc40993          	addi	s3,s0,-4
    Bug ("zero y in b2d");
#endif
  k = hi0bits (y);
  *e = 32 - k;
#ifdef Pack_32
  if (k < Ebits)
   17918:	04a74e63          	blt	a4,a0,17974 <__b2d+0xac>
    {
      d0 = Exp_1 | y >> (Ebits - k);
   1791c:	00b00793          	li	a5,11
   17920:	40a787b3          	sub	a5,a5,a0
   17924:	3ff00737          	lui	a4,0x3ff00
   17928:	00f955b3          	srl	a1,s2,a5
   1792c:	00e5e6b3          	or	a3,a1,a4
   17930:	00000713          	li	a4,0
      w = xa > xa0 ? *--xa : 0;
   17934:	0134f663          	bleu	s3,s1,17940 <__b2d+0x78>
   17938:	ff842703          	lw	a4,-8(s0)
   1793c:	00f75733          	srl	a4,a4,a5
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
   17940:	01550793          	addi	a5,a0,21
   17944:	00f917b3          	sll	a5,s2,a5
   17948:	00e7e633          	or	a2,a5,a4
#else
#undef d0
#undef d1
#endif
  return d.d;
}
   1794c:	01c12083          	lw	ra,28(sp)
  word1 (d) = d1 >> 16 | d1 << 16;
#else
#undef d0
#undef d1
#endif
  return d.d;
   17950:	00060513          	mv	a0,a2
   17954:	00068593          	mv	a1,a3
}
   17958:	01812403          	lw	s0,24(sp)
   1795c:	01412483          	lw	s1,20(sp)
   17960:	01012903          	lw	s2,16(sp)
   17964:	00c12983          	lw	s3,12(sp)
   17968:	00812a03          	lw	s4,8(sp)
   1796c:	02010113          	addi	sp,sp,32
   17970:	00008067          	ret
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
#endif
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
   17974:	0534f463          	bleu	s3,s1,179bc <__b2d+0xf4>
  if (k -= Ebits)
   17978:	ff550713          	addi	a4,a0,-11
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
#endif
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
   1797c:	ff842503          	lw	a0,-8(s0)
  if (k -= Ebits)
   17980:	04070263          	beqz	a4,179c4 <__b2d+0xfc>
    {
      d0 = Exp_1 | y << k | z >> (32 - k);
   17984:	3ff006b7          	lui	a3,0x3ff00
   17988:	40e787b3          	sub	a5,a5,a4
   1798c:	00e91933          	sll	s2,s2,a4
   17990:	00d96933          	or	s2,s2,a3
   17994:	00f55833          	srl	a6,a0,a5
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
#endif
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
   17998:	ff840593          	addi	a1,s0,-8
  if (k -= Ebits)
    {
      d0 = Exp_1 | y << k | z >> (32 - k);
   1799c:	010966b3          	or	a3,s2,a6
      y = xa > xa0 ? *--xa : 0;
   179a0:	04b4f663          	bleu	a1,s1,179ec <__b2d+0x124>
   179a4:	ff442583          	lw	a1,-12(s0)
   179a8:	00e51533          	sll	a0,a0,a4
   179ac:	00f5d7b3          	srl	a5,a1,a5
   179b0:	00a7e533          	or	a0,a5,a0
    }
  else
    {
      d0 = Exp_1 | y;
#ifndef _DOUBLE_IS_32BITS
      d1 = z;
   179b4:	00050613          	mv	a2,a0
   179b8:	f95ff06f          	j	1794c <__b2d+0x84>
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
#endif
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
  if (k -= Ebits)
   179bc:	ff550513          	addi	a0,a0,-11
   179c0:	00051a63          	bnez	a0,179d4 <__b2d+0x10c>
      d1 = z << k | y >> (32 - k);
#endif
    }
  else
    {
      d0 = Exp_1 | y;
   179c4:	3ff007b7          	lui	a5,0x3ff00
   179c8:	00f966b3          	or	a3,s2,a5
#ifndef _DOUBLE_IS_32BITS
      d1 = z;
   179cc:	00050613          	mv	a2,a0
   179d0:	f7dff06f          	j	1794c <__b2d+0x84>
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
  if (k -= Ebits)
    {
      d0 = Exp_1 | y << k | z >> (32 - k);
   179d4:	00a91933          	sll	s2,s2,a0
   179d8:	3ff007b7          	lui	a5,0x3ff00
   179dc:	00000513          	li	a0,0
   179e0:	00f966b3          	or	a3,s2,a5
    }
  else
    {
      d0 = Exp_1 | y;
#ifndef _DOUBLE_IS_32BITS
      d1 = z;
   179e4:	00050613          	mv	a2,a0
   179e8:	f65ff06f          	j	1794c <__b2d+0x84>
   179ec:	00e51533          	sll	a0,a0,a4
   179f0:	00050613          	mv	a2,a0
   179f4:	f59ff06f          	j	1794c <__b2d+0x84>

000179f8 <__d2b>:
	struct _reent * ptr _AND
	double _d _AND
	int *e _AND
	int *bits)

{
   179f8:	fd010113          	addi	sp,sp,-48
   179fc:	02812423          	sw	s0,40(sp)
#define d1 word1(d)
  d.d = _d;
#endif

#ifdef Pack_32
  b = Balloc (ptr, 1);
   17a00:	00100593          	li	a1,1
  int de, i, k;
  __ULong *x, y, z;
#ifdef VAX
  __ULong d0, d1;
#endif
  d.d = _d;
   17a04:	00068413          	mv	s0,a3
	struct _reent * ptr _AND
	double _d _AND
	int *e _AND
	int *bits)

{
   17a08:	02912223          	sw	s1,36(sp)
   17a0c:	03212023          	sw	s2,32(sp)
   17a10:	01312e23          	sw	s3,28(sp)
   17a14:	01412c23          	sw	s4,24(sp)
   17a18:	01512a23          	sw	s5,20(sp)
   17a1c:	00078993          	mv	s3,a5
  de = (int) (d0 >> Exp_shift);
#ifndef IBM
  z |= Exp_msk11;
#endif
#else
  if ((de = (int) (d0 >> Exp_shift)) != 0)
   17a20:	00141493          	slli	s1,s0,0x1
	struct _reent * ptr _AND
	double _d _AND
	int *e _AND
	int *bits)

{
   17a24:	02112623          	sw	ra,44(sp)
   17a28:	00070a13          	mv	s4,a4
  int de, i, k;
  __ULong *x, y, z;
#ifdef VAX
  __ULong d0, d1;
#endif
  d.d = _d;
   17a2c:	00060a93          	mv	s5,a2
#define d1 word1(d)
  d.d = _d;
#endif

#ifdef Pack_32
  b = Balloc (ptr, 1);
   17a30:	b18ff0ef          	jal	16d48 <_Balloc>
#else
  b = Balloc (ptr, 2);
#endif
  x = b->_x;

  z = d0 & Frac_mask;
   17a34:	001007b7          	lui	a5,0x100
   17a38:	fff78693          	addi	a3,a5,-1 # fffff <_gp+0xe19bf>
  de = (int) (d0 >> Exp_shift);
#ifndef IBM
  z |= Exp_msk11;
#endif
#else
  if ((de = (int) (d0 >> Exp_shift)) != 0)
   17a3c:	0154d493          	srli	s1,s1,0x15
#define d1 word1(d)
  d.d = _d;
#endif

#ifdef Pack_32
  b = Balloc (ptr, 1);
   17a40:	00050913          	mv	s2,a0
#else
  b = Balloc (ptr, 2);
#endif
  x = b->_x;

  z = d0 & Frac_mask;
   17a44:	00d47433          	and	s0,s0,a3
  de = (int) (d0 >> Exp_shift);
#ifndef IBM
  z |= Exp_msk11;
#endif
#else
  if ((de = (int) (d0 >> Exp_shift)) != 0)
   17a48:	00048463          	beqz	s1,17a50 <__d2b+0x58>
    z |= Exp_msk1;
   17a4c:	00f46433          	or	s0,s0,a5
   17a50:	00812623          	sw	s0,12(sp)
#endif
#ifdef Pack_32
#ifndef _DOUBLE_IS_32BITS
  if (d1)
   17a54:	080a8463          	beqz	s5,17adc <__d2b+0xe4>
    {
      y = d1;
      k = lo0bits (&y);
   17a58:	00810513          	addi	a0,sp,8
#endif
#ifdef Pack_32
#ifndef _DOUBLE_IS_32BITS
  if (d1)
    {
      y = d1;
   17a5c:	01512423          	sw	s5,8(sp)
      k = lo0bits (&y);
   17a60:	e40ff0ef          	jal	170a0 <__lo0bits>
   17a64:	00050793          	mv	a5,a0
      if (k)
	{
         x[0] = y | z << (32 - k);
   17a68:	00c12703          	lw	a4,12(sp)
#ifndef _DOUBLE_IS_32BITS
  if (d1)
    {
      y = d1;
      k = lo0bits (&y);
      if (k)
   17a6c:	0a051663          	bnez	a0,17b18 <__d2b+0x120>
	{
         x[0] = y | z << (32 - k);
	  z >>= k;
	}
      else
	x[0] = y;
   17a70:	00812683          	lw	a3,8(sp)
   17a74:	00d92a23          	sw	a3,20(s2)
      i = b->_wds = (x[1] = z) ? 2 : 1;
   17a78:	00173413          	seqz	s0,a4
   17a7c:	00200693          	li	a3,2
   17a80:	40868433          	sub	s0,a3,s0
   17a84:	00e92c23          	sw	a4,24(s2)
   17a88:	00892823          	sw	s0,16(s2)
  while (!x[i])
    --i;
  b->_wds = i + 1;
#endif
#ifndef Sudden_Underflow
  if (de)
   17a8c:	06049863          	bnez	s1,17afc <__d2b+0x104>
    }
  else
    {
      *e = de - Bias - (P - 1) + 1 + k;
#ifdef Pack_32
      *bits = 32 * i - hi0bits (x[i - 1]);
   17a90:	00241713          	slli	a4,s0,0x2
   17a94:	00e90733          	add	a4,s2,a4
   17a98:	01072503          	lw	a0,16(a4) # 3ff00010 <_gp+0x3fee19d0>
#endif
#ifndef Sudden_Underflow
    }
  else
    {
      *e = de - Bias - (P - 1) + 1 + k;
   17a9c:	bce78793          	addi	a5,a5,-1074
   17aa0:	00fa2023          	sw	a5,0(s4)
#ifdef Pack_32
      *bits = 32 * i - hi0bits (x[i - 1]);
   17aa4:	d80ff0ef          	jal	17024 <__hi0bits>
   17aa8:	00541413          	slli	s0,s0,0x5
   17aac:	40a40533          	sub	a0,s0,a0
   17ab0:	00a9a023          	sw	a0,0(s3)
      *bits = (i + 2) * 16 - hi0bits (x[i]);
#endif
    }
#endif
  return b;
}
   17ab4:	02c12083          	lw	ra,44(sp)
   17ab8:	00090513          	mv	a0,s2
   17abc:	02812403          	lw	s0,40(sp)
   17ac0:	02412483          	lw	s1,36(sp)
   17ac4:	02012903          	lw	s2,32(sp)
   17ac8:	01c12983          	lw	s3,28(sp)
   17acc:	01812a03          	lw	s4,24(sp)
   17ad0:	01412a83          	lw	s5,20(sp)
   17ad4:	03010113          	addi	sp,sp,48
   17ad8:	00008067          	ret
    {
#ifdef DEBUG
      if (!z)
	Bug ("Zero passed to d2b");
#endif
      k = lo0bits (&z);
   17adc:	00c10513          	addi	a0,sp,12
   17ae0:	dc0ff0ef          	jal	170a0 <__lo0bits>
      x[0] = z;
   17ae4:	00c12783          	lw	a5,12(sp)
      i = b->_wds = 1;
   17ae8:	00100413          	li	s0,1
   17aec:	00892823          	sw	s0,16(s2)
#ifdef DEBUG
      if (!z)
	Bug ("Zero passed to d2b");
#endif
      k = lo0bits (&z);
      x[0] = z;
   17af0:	00f92a23          	sw	a5,20(s2)
      i = b->_wds = 1;
#ifndef _DOUBLE_IS_32BITS
      k += 32;
   17af4:	02050793          	addi	a5,a0,32
  while (!x[i])
    --i;
  b->_wds = i + 1;
#endif
#ifndef Sudden_Underflow
  if (de)
   17af8:	f8048ce3          	beqz	s1,17a90 <__d2b+0x98>
#endif
#ifdef IBM
      *e = (de - Bias - (P - 1) << 2) + k;
      *bits = 4 * P + 8 - k - hi0bits (word0 (d) & Frac_mask);
#else
      *e = de - Bias - (P - 1) + k;
   17afc:	bcd48493          	addi	s1,s1,-1075
      *bits = P - k;
   17b00:	03500713          	li	a4,53
#endif
#ifdef IBM
      *e = (de - Bias - (P - 1) << 2) + k;
      *bits = 4 * P + 8 - k - hi0bits (word0 (d) & Frac_mask);
#else
      *e = de - Bias - (P - 1) + k;
   17b04:	00f484b3          	add	s1,s1,a5
      *bits = P - k;
   17b08:	40f707b3          	sub	a5,a4,a5
#endif
#ifdef IBM
      *e = (de - Bias - (P - 1) << 2) + k;
      *bits = 4 * P + 8 - k - hi0bits (word0 (d) & Frac_mask);
#else
      *e = de - Bias - (P - 1) + k;
   17b0c:	009a2023          	sw	s1,0(s4)
      *bits = P - k;
   17b10:	00f9a023          	sw	a5,0(s3)
   17b14:	fa1ff06f          	j	17ab4 <__d2b+0xbc>
    {
      y = d1;
      k = lo0bits (&y);
      if (k)
	{
         x[0] = y | z << (32 - k);
   17b18:	02000693          	li	a3,32
   17b1c:	00812603          	lw	a2,8(sp)
   17b20:	40a686b3          	sub	a3,a3,a0
   17b24:	00d716b3          	sll	a3,a4,a3
   17b28:	00c6e6b3          	or	a3,a3,a2
	  z >>= k;
   17b2c:	00a75733          	srl	a4,a4,a0
    {
      y = d1;
      k = lo0bits (&y);
      if (k)
	{
         x[0] = y | z << (32 - k);
   17b30:	00d92a23          	sw	a3,20(s2)
	  z >>= k;
   17b34:	00e12623          	sw	a4,12(sp)
   17b38:	f41ff06f          	j	17a78 <__d2b+0x80>

00017b3c <__ratio>:
#undef d1

double
_DEFUN (ratio, (a, b), _Bigint * a _AND _Bigint * b)

{
   17b3c:	fd010113          	addi	sp,sp,-48
   17b40:	03212023          	sw	s2,32(sp)
   17b44:	00058913          	mv	s2,a1
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
   17b48:	00810593          	addi	a1,sp,8
#undef d1

double
_DEFUN (ratio, (a, b), _Bigint * a _AND _Bigint * b)

{
   17b4c:	02112623          	sw	ra,44(sp)
   17b50:	02812423          	sw	s0,40(sp)
   17b54:	02912223          	sw	s1,36(sp)
   17b58:	01312e23          	sw	s3,28(sp)
   17b5c:	00050993          	mv	s3,a0
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
   17b60:	d69ff0ef          	jal	178c8 <__b2d>
   17b64:	00050413          	mv	s0,a0
   17b68:	00058493          	mv	s1,a1
  db.d = b2d (b, &kb);
   17b6c:	00090513          	mv	a0,s2
   17b70:	00c10593          	addi	a1,sp,12
   17b74:	d55ff0ef          	jal	178c8 <__b2d>
#ifdef Pack_32
  k = ka - kb + 32 * (a->_wds - b->_wds);
   17b78:	01092703          	lw	a4,16(s2)
   17b7c:	0109a783          	lw	a5,16(s3)
{
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
  db.d = b2d (b, &kb);
   17b80:	00058693          	mv	a3,a1
#ifdef Pack_32
  k = ka - kb + 32 * (a->_wds - b->_wds);
   17b84:	00c12583          	lw	a1,12(sp)
   17b88:	40e787b3          	sub	a5,a5,a4
   17b8c:	00579713          	slli	a4,a5,0x5
   17b90:	00812783          	lw	a5,8(sp)
{
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
  db.d = b2d (b, &kb);
   17b94:	00050613          	mv	a2,a0
#ifdef Pack_32
  k = ka - kb + 32 * (a->_wds - b->_wds);
   17b98:	40b787b3          	sub	a5,a5,a1
   17b9c:	00f707b3          	add	a5,a4,a5
      word0 (db) += (k >> 2) * Exp_msk1;
      if (k &= 3)
	db.d *= 1 << k;
    }
#else
  if (k > 0)
   17ba0:	02f05c63          	blez	a5,17bd8 <__ratio+0x9c>
    word0 (da) += k * Exp_msk1;
   17ba4:	01479793          	slli	a5,a5,0x14
   17ba8:	009785b3          	add	a1,a5,s1
   17bac:	00058493          	mv	s1,a1
    {
      k = -k;
      word0 (db) += k * Exp_msk1;
    }
#endif
  return da.d / db.d;
   17bb0:	00040513          	mv	a0,s0
   17bb4:	00048593          	mv	a1,s1
   17bb8:	4ad020ef          	jal	1a864 <__divdf3>
}
   17bbc:	02c12083          	lw	ra,44(sp)
   17bc0:	02812403          	lw	s0,40(sp)
   17bc4:	02412483          	lw	s1,36(sp)
   17bc8:	02012903          	lw	s2,32(sp)
   17bcc:	01c12983          	lw	s3,28(sp)
   17bd0:	03010113          	addi	sp,sp,48
   17bd4:	00008067          	ret
  if (k > 0)
    word0 (da) += k * Exp_msk1;
  else
    {
      k = -k;
      word0 (db) += k * Exp_msk1;
   17bd8:	01479793          	slli	a5,a5,0x14
   17bdc:	40f688b3          	sub	a7,a3,a5
   17be0:	00088693          	mv	a3,a7
   17be4:	fcdff06f          	j	17bb0 <__ratio+0x74>

00017be8 <_mprec_log10>:


double
_DEFUN (_mprec_log10, (dig),
	int dig)
{
   17be8:	ff010113          	addi	sp,sp,-16
  double v = 1.0;
  if (dig < 24)
   17bec:	01700793          	li	a5,23


double
_DEFUN (_mprec_log10, (dig),
	int dig)
{
   17bf0:	00812423          	sw	s0,8(sp)
   17bf4:	00112623          	sw	ra,12(sp)
   17bf8:	01212223          	sw	s2,4(sp)
   17bfc:	01312023          	sw	s3,0(sp)
   17c00:	00050413          	mv	s0,a0
  double v = 1.0;
  if (dig < 24)
   17c04:	04a7d063          	ble	a0,a5,17c44 <_mprec_log10+0x5c>
   17c08:	8481a503          	lw	a0,-1976(gp) # 1de88 <__wctomb+0x28>
   17c0c:	84c1a583          	lw	a1,-1972(gp) # 1de8c <__wctomb+0x2c>
    return tens[dig];
  while (dig > 0)
    {
      v *= 10;
   17c10:	8501a903          	lw	s2,-1968(gp) # 1de90 <__wctomb+0x30>
   17c14:	8541a983          	lw	s3,-1964(gp) # 1de94 <__wctomb+0x34>
      dig--;
   17c18:	fff40413          	addi	s0,s0,-1
  double v = 1.0;
  if (dig < 24)
    return tens[dig];
  while (dig > 0)
    {
      v *= 10;
   17c1c:	00090613          	mv	a2,s2
   17c20:	00098693          	mv	a3,s3
   17c24:	1dd020ef          	jal	1a600 <__muldf3>
	int dig)
{
  double v = 1.0;
  if (dig < 24)
    return tens[dig];
  while (dig > 0)
   17c28:	fe0418e3          	bnez	s0,17c18 <_mprec_log10+0x30>
    {
      v *= 10;
      dig--;
    }
  return v;
}
   17c2c:	00c12083          	lw	ra,12(sp)
   17c30:	00812403          	lw	s0,8(sp)
   17c34:	00412903          	lw	s2,4(sp)
   17c38:	00012983          	lw	s3,0(sp)
   17c3c:	01010113          	addi	sp,sp,16
   17c40:	00008067          	ret
_DEFUN (_mprec_log10, (dig),
	int dig)
{
  double v = 1.0;
  if (dig < 24)
    return tens[dig];
   17c44:	0001c7b7          	lui	a5,0x1c
   17c48:	00351413          	slli	s0,a0,0x3
   17c4c:	e4878793          	addi	a5,a5,-440 # 1be48 <p05.2565>
   17c50:	00878433          	add	s0,a5,s0
   17c54:	01042503          	lw	a0,16(s0)
   17c58:	01442583          	lw	a1,20(s0)
   17c5c:	fd1ff06f          	j	17c2c <_mprec_log10+0x44>

00017c60 <__copybits>:
#endif

	ce = c + ((n-1) >> kshift) + 1;
	x = b->_x;
#ifdef Pack_32
	xe = x + b->_wds;
   17c60:	01062683          	lw	a3,16(a2)
	__ULong *ce, *x, *xe;
#ifdef Pack_16
	int nw, nw1;
#endif

	ce = c + ((n-1) >> kshift) + 1;
   17c64:	fff58593          	addi	a1,a1,-1
   17c68:	4055d813          	srai	a6,a1,0x5
   17c6c:	00180813          	addi	a6,a6,1
	x = b->_x;
   17c70:	01460793          	addi	a5,a2,20
#ifdef Pack_32
	xe = x + b->_wds;
   17c74:	00269693          	slli	a3,a3,0x2
	__ULong *ce, *x, *xe;
#ifdef Pack_16
	int nw, nw1;
#endif

	ce = c + ((n-1) >> kshift) + 1;
   17c78:	00281813          	slli	a6,a6,0x2
	x = b->_x;
#ifdef Pack_32
	xe = x + b->_wds;
   17c7c:	00d786b3          	add	a3,a5,a3
	__ULong *ce, *x, *xe;
#ifdef Pack_16
	int nw, nw1;
#endif

	ce = c + ((n-1) >> kshift) + 1;
   17c80:	01050833          	add	a6,a0,a6
	x = b->_x;
#ifdef Pack_32
	xe = x + b->_wds;
	while(x < xe)
   17c84:	02d7f863          	bleu	a3,a5,17cb4 <__copybits+0x54>
   17c88:	00050713          	mv	a4,a0
		*c++ = *x++;
   17c8c:	00478793          	addi	a5,a5,4
   17c90:	ffc7a583          	lw	a1,-4(a5)
   17c94:	00470713          	addi	a4,a4,4
   17c98:	feb72e23          	sw	a1,-4(a4)

	ce = c + ((n-1) >> kshift) + 1;
	x = b->_x;
#ifdef Pack_32
	xe = x + b->_wds;
	while(x < xe)
   17c9c:	fed7e8e3          	bltu	a5,a3,17c8c <__copybits+0x2c>
   17ca0:	40c687b3          	sub	a5,a3,a2
   17ca4:	feb78793          	addi	a5,a5,-21
   17ca8:	ffc7f793          	andi	a5,a5,-4
   17cac:	00478793          	addi	a5,a5,4
   17cb0:	00f50533          	add	a0,a0,a5
	for(xe = x + (nw - nw1); x < xe; x += 2)
		Storeinc(c, x[1], x[0]);
	if (nw1)
		*c++ = *x;
#endif
	while(c < ce)
   17cb4:	01057863          	bleu	a6,a0,17cc4 <__copybits+0x64>
		*c++ = 0;
   17cb8:	00450513          	addi	a0,a0,4
   17cbc:	fe052e23          	sw	zero,-4(a0)
	for(xe = x + (nw - nw1); x < xe; x += 2)
		Storeinc(c, x[1], x[0]);
	if (nw1)
		*c++ = *x;
#endif
	while(c < ce)
   17cc0:	ff056ce3          	bltu	a0,a6,17cb8 <__copybits+0x58>
   17cc4:	00008067          	ret

00017cc8 <__any_on>:
{
	int n, nwds;
	__ULong *x, *x0, x1, x2;

	x = b->_x;
	nwds = b->_wds;
   17cc8:	01052783          	lw	a5,16(a0)
	n = k >> kshift;
   17ccc:	4055d713          	srai	a4,a1,0x5
	int k)
{
	int n, nwds;
	__ULong *x, *x0, x1, x2;

	x = b->_x;
   17cd0:	01450693          	addi	a3,a0,20
	nwds = b->_wds;
	n = k >> kshift;
	if (n > nwds)
   17cd4:	02e7da63          	ble	a4,a5,17d08 <__any_on+0x40>
   17cd8:	00279793          	slli	a5,a5,0x2
   17cdc:	00f687b3          	add	a5,a3,a5
		if (x1 != x2)
			return 1;
		}
	x0 = x;
	x += n;
	while(x > x0)
   17ce0:	06f6f263          	bleu	a5,a3,17d44 <__any_on+0x7c>
		if (*--x)
   17ce4:	ffc7a503          	lw	a0,-4(a5)
   17ce8:	ffc78793          	addi	a5,a5,-4
   17cec:	00051a63          	bnez	a0,17d00 <__any_on+0x38>
		if (x1 != x2)
			return 1;
		}
	x0 = x;
	x += n;
	while(x > x0)
   17cf0:	04f6f863          	bleu	a5,a3,17d40 <__any_on+0x78>
		if (*--x)
   17cf4:	ffc78793          	addi	a5,a5,-4
   17cf8:	0007a703          	lw	a4,0(a5)
   17cfc:	fe070ae3          	beqz	a4,17cf0 <__any_on+0x28>
	else if (n < nwds && (k &= kmask)) {
		x1 = x2 = x[n];
		x1 >>= k;
		x1 <<= k;
		if (x1 != x2)
			return 1;
   17d00:	00100513          	li	a0,1
	x += n;
	while(x > x0)
		if (*--x)
			return 1;
	return 0;
}
   17d04:	00008067          	ret
	x = b->_x;
	nwds = b->_wds;
	n = k >> kshift;
	if (n > nwds)
		n = nwds;
	else if (n < nwds && (k &= kmask)) {
   17d08:	02f75663          	ble	a5,a4,17d34 <__any_on+0x6c>
		x1 = x2 = x[n];
   17d0c:	00271793          	slli	a5,a4,0x2
	x = b->_x;
	nwds = b->_wds;
	n = k >> kshift;
	if (n > nwds)
		n = nwds;
	else if (n < nwds && (k &= kmask)) {
   17d10:	01f5f593          	andi	a1,a1,31
		x1 = x2 = x[n];
   17d14:	00f687b3          	add	a5,a3,a5
	x = b->_x;
	nwds = b->_wds;
	n = k >> kshift;
	if (n > nwds)
		n = nwds;
	else if (n < nwds && (k &= kmask)) {
   17d18:	fc0584e3          	beqz	a1,17ce0 <__any_on+0x18>
		x1 = x2 = x[n];
   17d1c:	0007a603          	lw	a2,0(a5)
		x1 >>= k;
		x1 <<= k;
		if (x1 != x2)
			return 1;
   17d20:	00100513          	li	a0,1
	n = k >> kshift;
	if (n > nwds)
		n = nwds;
	else if (n < nwds && (k &= kmask)) {
		x1 = x2 = x[n];
		x1 >>= k;
   17d24:	00b65733          	srl	a4,a2,a1
		x1 <<= k;
		if (x1 != x2)
   17d28:	00b715b3          	sll	a1,a4,a1
   17d2c:	fab60ae3          	beq	a2,a1,17ce0 <__any_on+0x18>
	x += n;
	while(x > x0)
		if (*--x)
			return 1;
	return 0;
}
   17d30:	00008067          	ret
   17d34:	00271793          	slli	a5,a4,0x2
   17d38:	00f687b3          	add	a5,a3,a5
   17d3c:	fa5ff06f          	j	17ce0 <__any_on+0x18>
   17d40:	00008067          	ret
	x0 = x;
	x += n;
	while(x > x0)
		if (*--x)
			return 1;
	return 0;
   17d44:	00000513          	li	a0,0
   17d48:	00008067          	ret

00017d4c <_realloc_r>:
#if __STD_C
Void_t* rEALLOc(RARG Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(RARG oldmem, bytes) RDECL Void_t* oldmem; size_t bytes;
#endif
{
   17d4c:	fd010113          	addi	sp,sp,-48
   17d50:	01312e23          	sw	s3,28(sp)
   17d54:	02112623          	sw	ra,44(sp)
   17d58:	02812423          	sw	s0,40(sp)
   17d5c:	02912223          	sw	s1,36(sp)
   17d60:	03212023          	sw	s2,32(sp)
   17d64:	01412c23          	sw	s4,24(sp)
   17d68:	01512a23          	sw	s5,20(sp)
   17d6c:	01612823          	sw	s6,16(sp)
   17d70:	01712623          	sw	s7,12(sp)
   17d74:	01812423          	sw	s8,8(sp)
   17d78:	01912223          	sw	s9,4(sp)
   17d7c:	00060993          	mv	s3,a2
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
   17d80:	1c058863          	beqz	a1,17f50 <_realloc_r+0x204>
   17d84:	00058a13          	mv	s4,a1
   17d88:	00050493          	mv	s1,a0

  MALLOC_LOCK;
   17d8c:	fb5fe0ef          	jal	16d40 <__malloc_lock>

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
   17d90:	ffca2783          	lw	a5,-4(s4)


  nb = request2size(bytes);
   17d94:	00b98713          	addi	a4,s3,11
   17d98:	01600693          	li	a3,22
  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);

  MALLOC_LOCK;

  newp    = oldp    = mem2chunk(oldmem);
   17d9c:	ff8a0b13          	addi	s6,s4,-8
  newsize = oldsize = chunksize(oldp);
   17da0:	ffc7fa93          	andi	s5,a5,-4


  nb = request2size(bytes);
   17da4:	0ce6f263          	bleu	a4,a3,17e68 <_realloc_r+0x11c>
   17da8:	ff877913          	andi	s2,a4,-8

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   17dac:	00090713          	mv	a4,s2
   17db0:	14094c63          	bltz	s2,17f08 <_realloc_r+0x1bc>
   17db4:	15396a63          	bltu	s2,s3,17f08 <_realloc_r+0x1bc>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
   17db8:	0aeade63          	ble	a4,s5,17e74 <_realloc_r+0x128>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next)) 
   17dbc:	0001ec37          	lui	s8,0x1e
   17dc0:	a38c0c13          	addi	s8,s8,-1480 # 1da38 <__malloc_av_>
   17dc4:	008c2683          	lw	a3,8(s8)
  if ((long)(oldsize) < (long)(nb))  
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
   17dc8:	015b0533          	add	a0,s6,s5
    if (next == top || !inuse(next)) 
   17dcc:	30d50263          	beq	a0,a3,180d0 <_realloc_r+0x384>
   17dd0:	00452683          	lw	a3,4(a0)
   17dd4:	ffe6f613          	andi	a2,a3,-2
   17dd8:	00c50633          	add	a2,a0,a2
   17ddc:	00462603          	lw	a2,4(a2)
   17de0:	00167613          	andi	a2,a2,1
   17de4:	0e060e63          	beqz	a2,17ee0 <_realloc_r+0x194>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   17de8:	0017f793          	andi	a5,a5,1
   17dec:	26078463          	beqz	a5,18054 <_realloc_r+0x308>
      }
    }

    /* Must allocate */

    newmem = mALLOc (RCALL bytes);
   17df0:	00098593          	mv	a1,s3
   17df4:	00048513          	mv	a0,s1
   17df8:	be0fe0ef          	jal	161d8 <_malloc_r>
   17dfc:	00050413          	mv	s0,a0

    if (newmem == 0)  /* propagate failure */
   17e00:	4a050463          	beqz	a0,182a8 <_realloc_r+0x55c>
    }

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
   17e04:	ffca2783          	lw	a5,-4(s4)
   17e08:	ff850693          	addi	a3,a0,-8
   17e0c:	ffe7f713          	andi	a4,a5,-2
   17e10:	00eb0733          	add	a4,s6,a4
   17e14:	42e68463          	beq	a3,a4,1823c <_realloc_r+0x4f0>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   17e18:	ffca8613          	addi	a2,s5,-4
   17e1c:	02400793          	li	a5,36
   17e20:	3cc7ea63          	bltu	a5,a2,181f4 <_realloc_r+0x4a8>
   17e24:	01300713          	li	a4,19
   17e28:	36c76a63          	bltu	a4,a2,1819c <_realloc_r+0x450>
   17e2c:	00050793          	mv	a5,a0
   17e30:	000a0713          	mv	a4,s4
   17e34:	00072683          	lw	a3,0(a4)
   17e38:	00d7a023          	sw	a3,0(a5)
   17e3c:	00472683          	lw	a3,4(a4)
   17e40:	00d7a223          	sw	a3,4(a5)
   17e44:	00872703          	lw	a4,8(a4)
   17e48:	00e7a423          	sw	a4,8(a5)
    fREe(RCALL oldmem);
   17e4c:	000a0593          	mv	a1,s4
   17e50:	00048513          	mv	a0,s1
   17e54:	849fd0ef          	jal	1569c <_free_r>
    MALLOC_UNLOCK;
   17e58:	00048513          	mv	a0,s1
   17e5c:	ee9fe0ef          	jal	16d44 <__malloc_unlock>
    return newmem;
   17e60:	00040513          	mv	a0,s0
   17e64:	0480006f          	j	17eac <_realloc_r+0x160>


  nb = request2size(bytes);

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   17e68:	01000713          	li	a4,16

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);


  nb = request2size(bytes);
   17e6c:	00070913          	mv	s2,a4
   17e70:	f45ff06f          	j	17db4 <_realloc_r+0x68>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
   17e74:	000a0993          	mv	s3,s4
  }


 split:  /* split off extra room in old or expanded chunk */

  remainder_size = long_sub_size_t(newsize, nb);
   17e78:	412a86b3          	sub	a3,s5,s2

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
   17e7c:	00f00713          	li	a4,15
   17e80:	08d76c63          	bltu	a4,a3,17f18 <_realloc_r+0x1cc>
    set_inuse_bit_at_offset(remainder, remainder_size);
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
  }
  else
  {
    set_head_size(newp, newsize);
   17e84:	0017f793          	andi	a5,a5,1
   17e88:	0157e7b3          	or	a5,a5,s5
   17e8c:	00fb2223          	sw	a5,4(s6)
    set_inuse_bit_at_offset(newp, newsize);
   17e90:	015b0633          	add	a2,s6,s5
   17e94:	00462783          	lw	a5,4(a2)
   17e98:	0017e793          	ori	a5,a5,1
   17e9c:	00f62223          	sw	a5,4(a2)
  }

  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
   17ea0:	00048513          	mv	a0,s1
   17ea4:	ea1fe0ef          	jal	16d44 <__malloc_unlock>
  return chunk2mem(newp);
   17ea8:	00098513          	mv	a0,s3

#endif /* MALLOC_PROVIDED */
}
   17eac:	02c12083          	lw	ra,44(sp)
   17eb0:	02812403          	lw	s0,40(sp)
   17eb4:	02412483          	lw	s1,36(sp)
   17eb8:	02012903          	lw	s2,32(sp)
   17ebc:	01c12983          	lw	s3,28(sp)
   17ec0:	01812a03          	lw	s4,24(sp)
   17ec4:	01412a83          	lw	s5,20(sp)
   17ec8:	01012b03          	lw	s6,16(sp)
   17ecc:	00c12b83          	lw	s7,12(sp)
   17ed0:	00812c03          	lw	s8,8(sp)
   17ed4:	00412c83          	lw	s9,4(sp)
   17ed8:	03010113          	addi	sp,sp,48
   17edc:	00008067          	ret
          return chunk2mem(oldp);
        }
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
   17ee0:	ffc6f693          	andi	a3,a3,-4
   17ee4:	015686b3          	add	a3,a3,s5
   17ee8:	0ae6c063          	blt	a3,a4,17f88 <_realloc_r+0x23c>
      { 
        unlink(next, bck, fwd);
   17eec:	00c52703          	lw	a4,12(a0)
   17ef0:	00852603          	lw	a2,8(a0)
        newsize  += nextsize;
        goto split;
   17ef4:	000a0993          	mv	s3,s4

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
      { 
        unlink(next, bck, fwd);
        newsize  += nextsize;
   17ef8:	00068a93          	mv	s5,a3
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
      { 
        unlink(next, bck, fwd);
   17efc:	00e62623          	sw	a4,12(a2)
   17f00:	00c72423          	sw	a2,8(a4)
        newsize  += nextsize;
        goto split;
   17f04:	f75ff06f          	j	17e78 <_realloc_r+0x12c>
  nb = request2size(bytes);

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
  {
    RERRNO = ENOMEM;
   17f08:	00c00793          	li	a5,12
   17f0c:	00f4a023          	sw	a5,0(s1)
    return 0;
   17f10:	00000513          	li	a0,0
   17f14:	f99ff06f          	j	17eac <_realloc_r+0x160>
  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
   17f18:	0017f713          	andi	a4,a5,1

  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
   17f1c:	012b05b3          	add	a1,s6,s2
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
   17f20:	0016e793          	ori	a5,a3,1
  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
   17f24:	01276733          	or	a4,a4,s2
   17f28:	00eb2223          	sw	a4,4(s6)
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
   17f2c:	00d586b3          	add	a3,a1,a3

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
   17f30:	00f5a223          	sw	a5,4(a1)
    set_inuse_bit_at_offset(remainder, remainder_size);
   17f34:	0046a783          	lw	a5,4(a3) # 3ff00004 <_gp+0x3fee19c4>
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
   17f38:	00858593          	addi	a1,a1,8
   17f3c:	00048513          	mv	a0,s1
  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
   17f40:	0017e793          	ori	a5,a5,1
   17f44:	00f6a223          	sw	a5,4(a3)
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
   17f48:	f54fd0ef          	jal	1569c <_free_r>
   17f4c:	f55ff06f          	j	17ea0 <_realloc_r+0x154>
  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
  return chunk2mem(newp);

#endif /* MALLOC_PROVIDED */
}
   17f50:	02c12083          	lw	ra,44(sp)
   17f54:	02812403          	lw	s0,40(sp)
   17f58:	02412483          	lw	s1,36(sp)
   17f5c:	02012903          	lw	s2,32(sp)
   17f60:	01c12983          	lw	s3,28(sp)
   17f64:	01812a03          	lw	s4,24(sp)
   17f68:	01412a83          	lw	s5,20(sp)
   17f6c:	01012b03          	lw	s6,16(sp)
   17f70:	00c12b83          	lw	s7,12(sp)
   17f74:	00812c03          	lw	s8,8(sp)
   17f78:	00412c83          	lw	s9,4(sp)
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
   17f7c:	00060593          	mv	a1,a2
  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
  return chunk2mem(newp);

#endif /* MALLOC_PROVIDED */
}
   17f80:	03010113          	addi	sp,sp,48
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
   17f84:	a54fe06f          	j	161d8 <_malloc_r>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   17f88:	0017f793          	andi	a5,a5,1
   17f8c:	e60792e3          	bnez	a5,17df0 <_realloc_r+0xa4>
    {
      prev = prev_chunk(oldp);
   17f90:	ff8a2b83          	lw	s7,-8(s4)
   17f94:	417b0bb3          	sub	s7,s6,s7
      prevsize = chunksize(prev);
   17f98:	004ba783          	lw	a5,4(s7)
   17f9c:	ffc7f793          	andi	a5,a5,-4
            return newmem;
          }
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
   17fa0:	00f68433          	add	s0,a3,a5
   17fa4:	0ce44063          	blt	s0,a4,18064 <_realloc_r+0x318>
        {
          unlink(next, bck, fwd);
   17fa8:	00c52783          	lw	a5,12(a0)
   17fac:	00852703          	lw	a4,8(a0)
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   17fb0:	ffca8613          	addi	a2,s5,-4
        {
          unlink(next, bck, fwd);
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
   17fb4:	008b8993          	addi	s3,s7,8
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
        {
          unlink(next, bck, fwd);
   17fb8:	00f72623          	sw	a5,12(a4)
   17fbc:	00e7a423          	sw	a4,8(a5)
          unlink(prev, bck, fwd);
   17fc0:	008ba703          	lw	a4,8(s7)
   17fc4:	00cba783          	lw	a5,12(s7)
   17fc8:	00f72623          	sw	a5,12(a4)
   17fcc:	00e7a423          	sw	a4,8(a5)
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   17fd0:	02400793          	li	a5,36
   17fd4:	22c7e663          	bltu	a5,a2,18200 <_realloc_r+0x4b4>
   17fd8:	01300713          	li	a4,19
   17fdc:	00098793          	mv	a5,s3
   17fe0:	04c77663          	bleu	a2,a4,1802c <_realloc_r+0x2e0>
   17fe4:	000a2783          	lw	a5,0(s4)
   17fe8:	00fba423          	sw	a5,8(s7)
   17fec:	004a2783          	lw	a5,4(s4)
   17ff0:	00fba623          	sw	a5,12(s7)
   17ff4:	01b00793          	li	a5,27
   17ff8:	24c7fc63          	bleu	a2,a5,18250 <_realloc_r+0x504>
   17ffc:	008a2783          	lw	a5,8(s4)
   18000:	00fba823          	sw	a5,16(s7)
   18004:	00ca2783          	lw	a5,12(s4)
   18008:	00fbaa23          	sw	a5,20(s7)
   1800c:	02400793          	li	a5,36
   18010:	0af61a63          	bne	a2,a5,180c4 <_realloc_r+0x378>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18014:	010a2703          	lw	a4,16(s4)
   18018:	020b8793          	addi	a5,s7,32
   1801c:	018a0a13          	addi	s4,s4,24
   18020:	00ebac23          	sw	a4,24(s7)
   18024:	ffca2703          	lw	a4,-4(s4)
   18028:	00ebae23          	sw	a4,28(s7)
   1802c:	000a2703          	lw	a4,0(s4)
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
   18030:	00040a93          	mv	s5,s0
   18034:	000b8b13          	mv	s6,s7
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18038:	00e7a023          	sw	a4,0(a5)
   1803c:	004a2703          	lw	a4,4(s4)
   18040:	00e7a223          	sw	a4,4(a5)
   18044:	008a2703          	lw	a4,8(s4)
   18048:	00e7a423          	sw	a4,8(a5)
   1804c:	004ba783          	lw	a5,4(s7)
   18050:	e29ff06f          	j	17e78 <_realloc_r+0x12c>

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
    {
      prev = prev_chunk(oldp);
   18054:	ff8a2b83          	lw	s7,-8(s4)
   18058:	417b0bb3          	sub	s7,s6,s7
      prevsize = chunksize(prev);
   1805c:	004ba783          	lw	a5,4(s7)
   18060:	ffc7f793          	andi	a5,a5,-4
          goto split;
        }
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
   18064:	00fa8433          	add	s0,s5,a5
   18068:	d8e444e3          	blt	s0,a4,17df0 <_realloc_r+0xa4>
      {
        unlink(prev, bck, fwd);
   1806c:	00cba783          	lw	a5,12(s7)
   18070:	008ba703          	lw	a4,8(s7)
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18074:	ffca8613          	addi	a2,s5,-4
   18078:	02400693          	li	a3,36
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
   1807c:	00f72623          	sw	a5,12(a4)
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
   18080:	008b8993          	addi	s3,s7,8
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
   18084:	00e7a423          	sw	a4,8(a5)
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18088:	16c6ec63          	bltu	a3,a2,18200 <_realloc_r+0x4b4>
   1808c:	01300713          	li	a4,19
   18090:	00098793          	mv	a5,s3
   18094:	f8c77ce3          	bleu	a2,a4,1802c <_realloc_r+0x2e0>
   18098:	000a2783          	lw	a5,0(s4)
   1809c:	00fba423          	sw	a5,8(s7)
   180a0:	004a2783          	lw	a5,4(s4)
   180a4:	00fba623          	sw	a5,12(s7)
   180a8:	01b00793          	li	a5,27
   180ac:	1ac7f263          	bleu	a2,a5,18250 <_realloc_r+0x504>
   180b0:	008a2783          	lw	a5,8(s4)
   180b4:	00fba823          	sw	a5,16(s7)
   180b8:	00ca2783          	lw	a5,12(s4)
   180bc:	00fbaa23          	sw	a5,20(s7)
   180c0:	f4d60ae3          	beq	a2,a3,18014 <_realloc_r+0x2c8>
   180c4:	018b8793          	addi	a5,s7,24
   180c8:	010a0a13          	addi	s4,s4,16
   180cc:	f61ff06f          	j	1802c <_realloc_r+0x2e0>
      nextsize = chunksize(next);

      /* Forward into top only if a remainder */
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
   180d0:	00452683          	lw	a3,4(a0)
   180d4:	01090613          	addi	a2,s2,16
   180d8:	ffc6f693          	andi	a3,a3,-4
   180dc:	015686b3          	add	a3,a3,s5
   180e0:	0ec6d063          	ble	a2,a3,181c0 <_realloc_r+0x474>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   180e4:	0017f793          	andi	a5,a5,1
   180e8:	d00794e3          	bnez	a5,17df0 <_realloc_r+0xa4>
    {
      prev = prev_chunk(oldp);
   180ec:	ff8a2b83          	lw	s7,-8(s4)
   180f0:	417b0bb3          	sub	s7,s6,s7
      prevsize = chunksize(prev);
   180f4:	004ba783          	lw	a5,4(s7)
   180f8:	ffc7f793          	andi	a5,a5,-4
      if (next != 0)
      {
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
   180fc:	00d78cb3          	add	s9,a5,a3
   18100:	f6ccc2e3          	blt	s9,a2,18064 <_realloc_r+0x318>
          {
            unlink(prev, bck, fwd);
   18104:	00cba783          	lw	a5,12(s7)
   18108:	008ba703          	lw	a4,8(s7)
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1810c:	ffca8613          	addi	a2,s5,-4
   18110:	02400693          	li	a3,36
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
          {
            unlink(prev, bck, fwd);
   18114:	00f72623          	sw	a5,12(a4)
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
   18118:	008b8413          	addi	s0,s7,8
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
          {
            unlink(prev, bck, fwd);
   1811c:	00e7a423          	sw	a4,8(a5)
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18120:	14c6ec63          	bltu	a3,a2,18278 <_realloc_r+0x52c>
   18124:	01300713          	li	a4,19
   18128:	00040793          	mv	a5,s0
   1812c:	02c77263          	bleu	a2,a4,18150 <_realloc_r+0x404>
   18130:	000a2783          	lw	a5,0(s4)
   18134:	00fba423          	sw	a5,8(s7)
   18138:	004a2783          	lw	a5,4(s4)
   1813c:	00fba623          	sw	a5,12(s7)
   18140:	01b00793          	li	a5,27
   18144:	14c7e263          	bltu	a5,a2,18288 <_realloc_r+0x53c>
   18148:	010b8793          	addi	a5,s7,16
   1814c:	008a0a13          	addi	s4,s4,8
   18150:	000a2703          	lw	a4,0(s4)
   18154:	00e7a023          	sw	a4,0(a5)
   18158:	004a2703          	lw	a4,4(s4)
   1815c:	00e7a223          	sw	a4,4(a5)
   18160:	008a2703          	lw	a4,8(s4)
   18164:	00e7a423          	sw	a4,8(a5)
            top = chunk_at_offset(newp, nb);
            set_head(top, (newsize - nb) | PREV_INUSE);
   18168:	412c86b3          	sub	a3,s9,s2
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
   1816c:	012b87b3          	add	a5,s7,s2
            set_head(top, (newsize - nb) | PREV_INUSE);
   18170:	0016e693          	ori	a3,a3,1
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
   18174:	00fc2423          	sw	a5,8(s8)
            set_head(top, (newsize - nb) | PREV_INUSE);
   18178:	00d7a223          	sw	a3,4(a5)
            set_head_size(newp, nb);
   1817c:	004ba703          	lw	a4,4(s7)
	    MALLOC_UNLOCK;
   18180:	00048513          	mv	a0,s1
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
            set_head(top, (newsize - nb) | PREV_INUSE);
            set_head_size(newp, nb);
   18184:	00177713          	andi	a4,a4,1
   18188:	01276733          	or	a4,a4,s2
   1818c:	00eba223          	sw	a4,4(s7)
	    MALLOC_UNLOCK;
   18190:	bb5fe0ef          	jal	16d44 <__malloc_unlock>
            return newmem;
   18194:	00040513          	mv	a0,s0
   18198:	d15ff06f          	j	17eac <_realloc_r+0x160>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1819c:	000a2703          	lw	a4,0(s4)
   181a0:	00e52023          	sw	a4,0(a0)
   181a4:	004a2703          	lw	a4,4(s4)
   181a8:	00e52223          	sw	a4,4(a0)
   181ac:	01b00713          	li	a4,27
   181b0:	06c76663          	bltu	a4,a2,1821c <_realloc_r+0x4d0>
   181b4:	00850793          	addi	a5,a0,8
   181b8:	008a0713          	addi	a4,s4,8
   181bc:	c79ff06f          	j	17e34 <_realloc_r+0xe8>
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
          set_head(top, (newsize - nb) | PREV_INUSE);
   181c0:	412686b3          	sub	a3,a3,s2
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
   181c4:	012b0b33          	add	s6,s6,s2
          set_head(top, (newsize - nb) | PREV_INUSE);
   181c8:	0016e693          	ori	a3,a3,1
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
   181cc:	016c2423          	sw	s6,8(s8)
          set_head(top, (newsize - nb) | PREV_INUSE);
   181d0:	00db2223          	sw	a3,4(s6)
          set_head_size(oldp, nb);
   181d4:	ffca2703          	lw	a4,-4(s4)
	  MALLOC_UNLOCK;
   181d8:	00048513          	mv	a0,s1
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
          set_head(top, (newsize - nb) | PREV_INUSE);
          set_head_size(oldp, nb);
   181dc:	00177713          	andi	a4,a4,1
   181e0:	01276733          	or	a4,a4,s2
   181e4:	feea2e23          	sw	a4,-4(s4)
	  MALLOC_UNLOCK;
   181e8:	b5dfe0ef          	jal	16d44 <__malloc_unlock>
          return chunk2mem(oldp);
   181ec:	000a0513          	mv	a0,s4
   181f0:	cbdff06f          	j	17eac <_realloc_r+0x160>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   181f4:	000a0593          	mv	a1,s4
   181f8:	94dfe0ef          	jal	16b44 <memmove>
   181fc:	c51ff06f          	j	17e4c <_realloc_r+0x100>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18200:	000a0593          	mv	a1,s4
   18204:	00098513          	mv	a0,s3
   18208:	93dfe0ef          	jal	16b44 <memmove>
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
   1820c:	00040a93          	mv	s5,s0
   18210:	004ba783          	lw	a5,4(s7)
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18214:	000b8b13          	mv	s6,s7
   18218:	c61ff06f          	j	17e78 <_realloc_r+0x12c>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1821c:	008a2703          	lw	a4,8(s4)
   18220:	00e52423          	sw	a4,8(a0)
   18224:	00ca2703          	lw	a4,12(s4)
   18228:	00e52623          	sw	a4,12(a0)
   1822c:	02f60863          	beq	a2,a5,1825c <_realloc_r+0x510>
   18230:	01050793          	addi	a5,a0,16
   18234:	010a0713          	addi	a4,s4,16
   18238:	bfdff06f          	j	17e34 <_realloc_r+0xe8>
    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
    {
      newsize += chunksize(newp);
   1823c:	ffc52703          	lw	a4,-4(a0)
      newp = oldp;
      goto split;
   18240:	000a0993          	mv	s3,s4
    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
    {
      newsize += chunksize(newp);
   18244:	ffc77713          	andi	a4,a4,-4
   18248:	00ea8ab3          	add	s5,s5,a4
      newp = oldp;
      goto split;
   1824c:	c2dff06f          	j	17e78 <_realloc_r+0x12c>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18250:	010b8793          	addi	a5,s7,16
   18254:	008a0a13          	addi	s4,s4,8
   18258:	dd5ff06f          	j	1802c <_realloc_r+0x2e0>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1825c:	010a2683          	lw	a3,16(s4)
   18260:	01850793          	addi	a5,a0,24
   18264:	018a0713          	addi	a4,s4,24
   18268:	00d52823          	sw	a3,16(a0)
   1826c:	014a2683          	lw	a3,20(s4)
   18270:	00d52a23          	sw	a3,20(a0)
   18274:	bc1ff06f          	j	17e34 <_realloc_r+0xe8>
          {
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   18278:	000a0593          	mv	a1,s4
   1827c:	00040513          	mv	a0,s0
   18280:	8c5fe0ef          	jal	16b44 <memmove>
   18284:	ee5ff06f          	j	18168 <_realloc_r+0x41c>
   18288:	008a2783          	lw	a5,8(s4)
   1828c:	00fba823          	sw	a5,16(s7)
   18290:	00ca2783          	lw	a5,12(s4)
   18294:	00fbaa23          	sw	a5,20(s7)
   18298:	02d60063          	beq	a2,a3,182b8 <_realloc_r+0x56c>
   1829c:	018b8793          	addi	a5,s7,24
   182a0:	010a0a13          	addi	s4,s4,16
   182a4:	eadff06f          	j	18150 <_realloc_r+0x404>

    newmem = mALLOc (RCALL bytes);

    if (newmem == 0)  /* propagate failure */
    {
      MALLOC_UNLOCK;
   182a8:	00048513          	mv	a0,s1
   182ac:	a99fe0ef          	jal	16d44 <__malloc_unlock>
      return 0;
   182b0:	00000513          	li	a0,0
   182b4:	bf9ff06f          	j	17eac <_realloc_r+0x160>
          {
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   182b8:	010a2703          	lw	a4,16(s4)
   182bc:	020b8793          	addi	a5,s7,32
   182c0:	018a0a13          	addi	s4,s4,24
   182c4:	00ebac23          	sw	a4,24(s7)
   182c8:	ffca2703          	lw	a4,-4(s4)
   182cc:	00ebae23          	sw	a4,28(s7)
   182d0:	e81ff06f          	j	18150 <_realloc_r+0x404>

000182d4 <__fpclassifyd>:
{
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
   182d4:	00a5e733          	or	a4,a1,a0
int
__fpclassifyd (double x)
{
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);
   182d8:	00050793          	mv	a5,a0

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
   182dc:	00200513          	li	a0,2
{
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
   182e0:	00071463          	bnez	a4,182e8 <__fpclassifyd+0x14>
  else if ((msw == 0x7ff00000 && lsw == 0x00000000) ||
           (msw == 0xfff00000 && lsw == 0x00000000))
    return FP_INFINITE;
  else
    return FP_NAN;
}
   182e4:	00008067          	ret
{
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
   182e8:	80000737          	lui	a4,0x80000
   182ec:	04e58863          	beq	a1,a4,1833c <__fpclassifyd+0x68>
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
   182f0:	fff00737          	lui	a4,0xfff00
   182f4:	00e58733          	add	a4,a1,a4
   182f8:	7fe006b7          	lui	a3,0x7fe00
           (msw >= 0x80100000 && msw <= 0xffefffff))
    return FP_NORMAL;
   182fc:	00400513          	li	a0,4
  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
   18300:	fed762e3          	bltu	a4,a3,182e4 <__fpclassifyd+0x10>
   18304:	7ff00737          	lui	a4,0x7ff00
   18308:	00e58733          	add	a4,a1,a4
   1830c:	fcd76ce3          	bltu	a4,a3,182e4 <__fpclassifyd+0x10>
           (msw >= 0x80100000 && msw <= 0xffefffff))
    return FP_NORMAL;
  else if ((msw >= 0x00000000 && msw <= 0x000fffff) ||
   18310:	80000737          	lui	a4,0x80000
   18314:	fff74713          	not	a4,a4
   18318:	00e5f5b3          	and	a1,a1,a4
   1831c:	00100737          	lui	a4,0x100
           (msw >= 0x80000000 && msw <= 0x800fffff))
    /* zero is already handled above */
    return FP_SUBNORMAL;
   18320:	00300513          	li	a0,3
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
           (msw >= 0x80100000 && msw <= 0xffefffff))
    return FP_NORMAL;
  else if ((msw >= 0x00000000 && msw <= 0x000fffff) ||
   18324:	fce5e0e3          	bltu	a1,a4,182e4 <__fpclassifyd+0x10>
           (msw >= 0x80000000 && msw <= 0x800fffff))
    /* zero is already handled above */
    return FP_SUBNORMAL;
  else if ((msw == 0x7ff00000 && lsw == 0x00000000) ||
   18328:	7ff00737          	lui	a4,0x7ff00
           (msw == 0xfff00000 && lsw == 0x00000000))
    return FP_INFINITE;
  else
    return FP_NAN;
   1832c:	00000513          	li	a0,0
    return FP_NORMAL;
  else if ((msw >= 0x00000000 && msw <= 0x000fffff) ||
           (msw >= 0x80000000 && msw <= 0x800fffff))
    /* zero is already handled above */
    return FP_SUBNORMAL;
  else if ((msw == 0x7ff00000 && lsw == 0x00000000) ||
   18330:	fae59ae3          	bne	a1,a4,182e4 <__fpclassifyd+0x10>
  if ((msw == 0x00000000 && lsw == 0x00000000) ||
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
           (msw >= 0x80100000 && msw <= 0xffefffff))
    return FP_NORMAL;
   18334:	0017b513          	seqz	a0,a5
   18338:	00008067          	ret

  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
   1833c:	00200513          	li	a0,2
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
      (msw == 0x80000000 && lsw == 0x00000000))
   18340:	fc0798e3          	bnez	a5,18310 <__fpclassifyd+0x3c>
  else if ((msw == 0x7ff00000 && lsw == 0x00000000) ||
           (msw == 0xfff00000 && lsw == 0x00000000))
    return FP_INFINITE;
  else
    return FP_NAN;
}
   18344:	00008067          	ret

00018348 <__sread>:
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   18348:	00e59503          	lh	a0,14(a1)
_DEFUN(__sread, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   1834c:	ff010113          	addi	sp,sp,-16
   18350:	00812423          	sw	s0,8(sp)
   18354:	00058413          	mv	s0,a1
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   18358:	00060593          	mv	a1,a2
   1835c:	00068613          	mv	a2,a3
_DEFUN(__sread, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   18360:	00112623          	sw	ra,12(sp)
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   18364:	fa1f70ef          	jal	10304 <read>
    setmode (fp->_file, oldmode);
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
   18368:	02054c63          	bltz	a0,183a0 <__sread+0x58>
    fp->_offset += ret;
   1836c:	05042783          	lw	a5,80(s0)
   18370:	05442683          	lw	a3,84(s0)
   18374:	41f55613          	srai	a2,a0,0x1f
   18378:	00a785b3          	add	a1,a5,a0
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
  return ret;
}
   1837c:	00c12083          	lw	ra,12(sp)
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
    fp->_offset += ret;
   18380:	00f5b733          	sltu	a4,a1,a5
   18384:	00c687b3          	add	a5,a3,a2
   18388:	00f707b3          	add	a5,a4,a5
   1838c:	04b42823          	sw	a1,80(s0)
   18390:	04f42a23          	sw	a5,84(s0)
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
  return ret;
}
   18394:	00812403          	lw	s0,8(sp)
   18398:	01010113          	addi	sp,sp,16
   1839c:	00008067          	ret
  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
    fp->_offset += ret;
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
   183a0:	00c45703          	lhu	a4,12(s0)
   183a4:	fffff7b7          	lui	a5,0xfffff
  return ret;
}
   183a8:	00c12083          	lw	ra,12(sp)
  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
    fp->_offset += ret;
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
   183ac:	fff78793          	addi	a5,a5,-1 # ffffefff <_gp+0xfffe09bf>
   183b0:	00f777b3          	and	a5,a4,a5
   183b4:	00f41623          	sh	a5,12(s0)
  return ret;
}
   183b8:	00812403          	lw	s0,8(sp)
   183bc:	01010113          	addi	sp,sp,16
   183c0:	00008067          	ret

000183c4 <__seofread>:
       _PTR cookie _AND
       char *buf   _AND
       _READ_WRITE_BUFSIZE_TYPE len)
{
  return 0;
}
   183c4:	00000513          	li	a0,0
   183c8:	00008067          	ret

000183cc <__swrite>:
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   183cc:	00c59703          	lh	a4,12(a1)
_DEFUN(__swrite, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char const *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   183d0:	ff010113          	addi	sp,sp,-16
   183d4:	00812423          	sw	s0,8(sp)
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   183d8:	10077793          	andi	a5,a4,256
_DEFUN(__swrite, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char const *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   183dc:	00912223          	sw	s1,4(sp)
   183e0:	01212023          	sw	s2,0(sp)
   183e4:	00112623          	sw	ra,12(sp)
   183e8:	00058413          	mv	s0,a1
   183ec:	00060493          	mv	s1,a2
   183f0:	00068913          	mv	s2,a3
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   183f4:	00078e63          	beqz	a5,18410 <__swrite+0x44>
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
   183f8:	00e59503          	lh	a0,14(a1)
   183fc:	00200713          	li	a4,2
   18400:	00000613          	li	a2,0
   18404:	00000693          	li	a3,0
   18408:	ea5f70ef          	jal	102ac <lseek>
   1840c:	00c41703          	lh	a4,12(s0)
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
   18410:	fffff7b7          	lui	a5,0xfffff
   18414:	fff78793          	addi	a5,a5,-1 # ffffefff <_gp+0xfffe09bf>
   18418:	00f777b3          	and	a5,a4,a5
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   1841c:	00e41503          	lh	a0,14(s0)
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
   18420:	00f41623          	sh	a5,12(s0)
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   18424:	00090613          	mv	a2,s2
   18428:	00048593          	mv	a1,s1
  if (oldmode)
    setmode (fp->_file, oldmode);
#endif

  return w;
}
   1842c:	00c12083          	lw	ra,12(sp)
   18430:	00812403          	lw	s0,8(sp)
   18434:	00412483          	lw	s1,4(sp)
   18438:	00012903          	lw	s2,0(sp)
   1843c:	01010113          	addi	sp,sp,16
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   18440:	8a0f806f          	j	104e0 <write>

00018444 <__sseek>:
       int whence)
{
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
   18444:	00e59503          	lh	a0,14(a1)
_DEFUN(__sseek, (ptr, cookie, offset, whence),
       struct _reent *ptr _AND
       void *cookie _AND
       _fpos_t offset _AND
       int whence)
{
   18448:	ff010113          	addi	sp,sp,-16
   1844c:	00812423          	sw	s0,8(sp)
   18450:	00112623          	sw	ra,12(sp)
   18454:	00058413          	mv	s0,a1
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
   18458:	e55f70ef          	jal	102ac <lseek>
  if (ret == -1L)
   1845c:	fff00793          	li	a5,-1
    fp->_flags &= ~__SOFF;
   18460:	00c45703          	lhu	a4,12(s0)
{
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
   18464:	02f50463          	beq	a0,a5,1848c <__sseek+0x48>
    {
      fp->_flags |= __SOFF;
      fp->_offset = ret;
    }
  return ret;
}
   18468:	00c12083          	lw	ra,12(sp)
  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
    fp->_flags &= ~__SOFF;
  else
    {
      fp->_flags |= __SOFF;
   1846c:	000017b7          	lui	a5,0x1
   18470:	00f767b3          	or	a5,a4,a5
      fp->_offset = ret;
   18474:	04a42823          	sw	a0,80(s0)
  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
    fp->_flags &= ~__SOFF;
  else
    {
      fp->_flags |= __SOFF;
   18478:	00f41623          	sh	a5,12(s0)
      fp->_offset = ret;
   1847c:	04b42a23          	sw	a1,84(s0)
    }
  return ret;
}
   18480:	00812403          	lw	s0,8(sp)
   18484:	01010113          	addi	sp,sp,16
   18488:	00008067          	ret
{
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
   1848c:	fca59ee3          	bne	a1,a0,18468 <__sseek+0x24>
    fp->_flags &= ~__SOFF;
   18490:	fffff7b7          	lui	a5,0xfffff
    {
      fp->_flags |= __SOFF;
      fp->_offset = ret;
    }
  return ret;
}
   18494:	00c12083          	lw	ra,12(sp)
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
    fp->_flags &= ~__SOFF;
   18498:	fff78793          	addi	a5,a5,-1 # ffffefff <_gp+0xfffe09bf>
   1849c:	00f777b3          	and	a5,a4,a5
   184a0:	00f41623          	sh	a5,12(s0)
    {
      fp->_flags |= __SOFF;
      fp->_offset = ret;
    }
  return ret;
}
   184a4:	00812403          	lw	s0,8(sp)
   184a8:	01010113          	addi	sp,sp,16
   184ac:	00008067          	ret

000184b0 <__sclose>:
       struct _reent *ptr _AND
       void *cookie)
{
  FILE *fp = (FILE *) cookie;

  return _close_r (ptr, fp->_file);
   184b0:	00e59503          	lh	a0,14(a1)
   184b4:	ca1f706f          	j	10154 <close>

000184b8 <strcmp>:
   184b8:	00b56733          	or	a4,a0,a1
   184bc:	fff00393          	li	t2,-1
   184c0:	00377713          	andi	a4,a4,3
   184c4:	0c071063          	bnez	a4,18584 <strcmp+0xcc>
   184c8:	7f7f8e37          	lui	t3,0x7f7f8
   184cc:	f7fe0e13          	addi	t3,t3,-129 # 7f7f7f7f <_gp+0x7f7d993f>
   184d0:	00052603          	lw	a2,0(a0)
   184d4:	0005a683          	lw	a3,0(a1)
   184d8:	01c672b3          	and	t0,a2,t3
   184dc:	01c66333          	or	t1,a2,t3
   184e0:	01c282b3          	add	t0,t0,t3
   184e4:	0062e2b3          	or	t0,t0,t1
   184e8:	0c729263          	bne	t0,t2,185ac <strcmp+0xf4>
   184ec:	04d61663          	bne	a2,a3,18538 <strcmp+0x80>
   184f0:	00452603          	lw	a2,4(a0)
   184f4:	0045a683          	lw	a3,4(a1)
   184f8:	01c672b3          	and	t0,a2,t3
   184fc:	01c66333          	or	t1,a2,t3
   18500:	01c282b3          	add	t0,t0,t3
   18504:	0062e2b3          	or	t0,t0,t1
   18508:	08729e63          	bne	t0,t2,185a4 <strcmp+0xec>
   1850c:	02d61663          	bne	a2,a3,18538 <strcmp+0x80>
   18510:	00852603          	lw	a2,8(a0)
   18514:	0085a683          	lw	a3,8(a1)
   18518:	01c672b3          	and	t0,a2,t3
   1851c:	01c66333          	or	t1,a2,t3
   18520:	01c282b3          	add	t0,t0,t3
   18524:	0062e2b3          	or	t0,t0,t1
   18528:	08729863          	bne	t0,t2,185b8 <strcmp+0x100>
   1852c:	00c50513          	addi	a0,a0,12
   18530:	00c58593          	addi	a1,a1,12
   18534:	f8d60ee3          	beq	a2,a3,184d0 <strcmp+0x18>
   18538:	01061713          	slli	a4,a2,0x10
   1853c:	01069793          	slli	a5,a3,0x10
   18540:	00f71e63          	bne	a4,a5,1855c <strcmp+0xa4>
   18544:	01065713          	srli	a4,a2,0x10
   18548:	0106d793          	srli	a5,a3,0x10
   1854c:	40f70533          	sub	a0,a4,a5
   18550:	0ff57593          	andi	a1,a0,255
   18554:	02059063          	bnez	a1,18574 <strcmp+0xbc>
   18558:	00008067          	ret
   1855c:	01075713          	srli	a4,a4,0x10
   18560:	0107d793          	srli	a5,a5,0x10
   18564:	40f70533          	sub	a0,a4,a5
   18568:	0ff57593          	andi	a1,a0,255
   1856c:	00059463          	bnez	a1,18574 <strcmp+0xbc>
   18570:	00008067          	ret
   18574:	0ff77713          	andi	a4,a4,255
   18578:	0ff7f793          	andi	a5,a5,255
   1857c:	40f70533          	sub	a0,a4,a5
   18580:	00008067          	ret
   18584:	00054603          	lbu	a2,0(a0)
   18588:	0005c683          	lbu	a3,0(a1)
   1858c:	00150513          	addi	a0,a0,1
   18590:	00158593          	addi	a1,a1,1
   18594:	00d61463          	bne	a2,a3,1859c <strcmp+0xe4>
   18598:	fe0616e3          	bnez	a2,18584 <strcmp+0xcc>
   1859c:	40d60533          	sub	a0,a2,a3
   185a0:	00008067          	ret
   185a4:	00450513          	addi	a0,a0,4
   185a8:	00458593          	addi	a1,a1,4
   185ac:	fcd61ce3          	bne	a2,a3,18584 <strcmp+0xcc>
   185b0:	00000513          	li	a0,0
   185b4:	00008067          	ret
   185b8:	00850513          	addi	a0,a0,8
   185bc:	00858593          	addi	a1,a1,8
   185c0:	fcd612e3          	bne	a2,a3,18584 <strcmp+0xcc>
   185c4:	00000513          	li	a0,0
   185c8:	00008067          	ret

000185cc <__sprint_r.part.0>:
	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
		return (0);
	}
#ifdef _WIDE_ORIENT
	if (fp->_flags2 & __SWID) {
   185cc:	0685a783          	lw	a5,104(a1)
/*
 * Flush out all the vectors defined by the given uio,
 * then reset it so that it can be reused.
 */
int
_DEFUN(__sprint_r, (ptr, fp, uio),
   185d0:	fd010113          	addi	sp,sp,-48
   185d4:	01612823          	sw	s6,16(sp)
	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
		return (0);
	}
#ifdef _WIDE_ORIENT
	if (fp->_flags2 & __SWID) {
   185d8:	01279713          	slli	a4,a5,0x12
/*
 * Flush out all the vectors defined by the given uio,
 * then reset it so that it can be reused.
 */
int
_DEFUN(__sprint_r, (ptr, fp, uio),
   185dc:	02112623          	sw	ra,44(sp)
   185e0:	02812423          	sw	s0,40(sp)
   185e4:	02912223          	sw	s1,36(sp)
   185e8:	03212023          	sw	s2,32(sp)
   185ec:	01312e23          	sw	s3,28(sp)
   185f0:	01412c23          	sw	s4,24(sp)
   185f4:	01512a23          	sw	s5,20(sp)
   185f8:	01712623          	sw	s7,12(sp)
   185fc:	00060b13          	mv	s6,a2
	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
		return (0);
	}
#ifdef _WIDE_ORIENT
	if (fp->_flags2 & __SWID) {
   18600:	0a075663          	bgez	a4,186ac <__sprint_r.part.0+0xe0>
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
   18604:	00862783          	lw	a5,8(a2)
   18608:	00058a13          	mv	s4,a1
   1860c:	00050a93          	mv	s5,a0
	if (fp->_flags2 & __SWID) {
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
   18610:	00062b83          	lw	s7,0(a2)
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
			len = iov->iov_len / sizeof (wchar_t);
			for (i = 0; i < len; i++) {
				if (_fputwc_r (ptr, p[i], fp) == WEOF) {
   18614:	fff00993          	li	s3,-1
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
   18618:	08078663          	beqz	a5,186a4 <__sprint_r.part.0+0xd8>
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
			len = iov->iov_len / sizeof (wchar_t);
   1861c:	004ba903          	lw	s2,4(s7)
   18620:	000ba483          	lw	s1,0(s7)
			for (i = 0; i < len; i++) {
   18624:	00000413          	li	s0,0

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
			len = iov->iov_len / sizeof (wchar_t);
   18628:	00295913          	srli	s2,s2,0x2
			for (i = 0; i < len; i++) {
   1862c:	00091863          	bnez	s2,1863c <__sprint_r.part.0+0x70>
   18630:	0600006f          	j	18690 <__sprint_r.part.0+0xc4>
   18634:	00448493          	addi	s1,s1,4
   18638:	04890a63          	beq	s2,s0,1868c <__sprint_r.part.0+0xc0>
				if (_fputwc_r (ptr, p[i], fp) == WEOF) {
   1863c:	0004a583          	lw	a1,0(s1)
   18640:	000a0613          	mv	a2,s4
   18644:	000a8513          	mv	a0,s5
   18648:	47c010ef          	jal	19ac4 <_fputwc_r>
		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
			len = iov->iov_len / sizeof (wchar_t);
			for (i = 0; i < len; i++) {
   1864c:	00140413          	addi	s0,s0,1
				if (_fputwc_r (ptr, p[i], fp) == WEOF) {
   18650:	ff3512e3          	bne	a0,s3,18634 <__sprint_r.part.0+0x68>
					err = -1;
   18654:	00098513          	mv	a0,s3
		err = __sfvwrite_r(ptr, fp, uio);
out:
	uio->uio_resid = 0;
	uio->uio_iovcnt = 0;
	return (err);
}
   18658:	02c12083          	lw	ra,44(sp)
		}
	} else
#endif
		err = __sfvwrite_r(ptr, fp, uio);
out:
	uio->uio_resid = 0;
   1865c:	000b2423          	sw	zero,8(s6)
	uio->uio_iovcnt = 0;
   18660:	000b2223          	sw	zero,4(s6)
	return (err);
}
   18664:	02812403          	lw	s0,40(sp)
   18668:	02412483          	lw	s1,36(sp)
   1866c:	02012903          	lw	s2,32(sp)
   18670:	01c12983          	lw	s3,28(sp)
   18674:	01812a03          	lw	s4,24(sp)
   18678:	01412a83          	lw	s5,20(sp)
   1867c:	01012b03          	lw	s6,16(sp)
   18680:	00c12b83          	lw	s7,12(sp)
   18684:	03010113          	addi	sp,sp,48
   18688:	00008067          	ret
   1868c:	008b2783          	lw	a5,8(s6)
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
   18690:	00291913          	slli	s2,s2,0x2
   18694:	412787b3          	sub	a5,a5,s2
   18698:	00fb2423          	sw	a5,8(s6)
   1869c:	008b8b93          	addi	s7,s7,8
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
   186a0:	f6079ee3          	bnez	a5,1861c <__sprint_r.part.0+0x50>
_DEFUN(__sprint_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;
   186a4:	00000513          	li	a0,0
   186a8:	fb1ff06f          	j	18658 <__sprint_r.part.0+0x8c>
				}
			}
		}
	} else
#endif
		err = __sfvwrite_r(ptr, fp, uio);
   186ac:	accfd0ef          	jal	15978 <__sfvwrite_r>
   186b0:	fa9ff06f          	j	18658 <__sprint_r.part.0+0x8c>

000186b4 <__sprint_r>:
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   186b4:	00862703          	lw	a4,8(a2)
   186b8:	00070463          	beqz	a4,186c0 <__sprint_r+0xc>
   186bc:	f11ff06f          	j	185cc <__sprint_r.part.0>
		uio->uio_iovcnt = 0;
   186c0:	00062223          	sw	zero,4(a2)
		err = __sfvwrite_r(ptr, fp, uio);
out:
	uio->uio_resid = 0;
	uio->uio_iovcnt = 0;
	return (err);
}
   186c4:	00000513          	li	a0,0
   186c8:	00008067          	ret

000186cc <_vfiprintf_r>:
_DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
       struct _reent *data _AND
       FILE * fp           _AND
       _CONST char *fmt0   _AND
       va_list ap)
{
   186cc:	f1010113          	addi	sp,sp,-240
   186d0:	0e912223          	sw	s1,228(sp)
   186d4:	0d512a23          	sw	s5,212(sp)
   186d8:	0da12023          	sw	s10,192(sp)
   186dc:	0e112623          	sw	ra,236(sp)
   186e0:	0e812423          	sw	s0,232(sp)
   186e4:	0f212023          	sw	s2,224(sp)
   186e8:	0d312e23          	sw	s3,220(sp)
   186ec:	0d412c23          	sw	s4,216(sp)
   186f0:	0d612823          	sw	s6,208(sp)
   186f4:	0d712623          	sw	s7,204(sp)
   186f8:	0d812423          	sw	s8,200(sp)
   186fc:	0d912223          	sw	s9,196(sp)
   18700:	0bb12e23          	sw	s11,188(sp)
   18704:	00050a93          	mv	s5,a0
   18708:	00058d13          	mv	s10,a1
   1870c:	00060493          	mv	s1,a2
   18710:	00d12823          	sw	a3,16(sp)
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
   18714:	00050663          	beqz	a0,18720 <_vfiprintf_r+0x54>
   18718:	03852783          	lw	a5,56(a0)
   1871c:	1e078863          	beqz	a5,1890c <_vfiprintf_r+0x240>
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);
   18720:	00cd1683          	lh	a3,12(s10)
   18724:	01069793          	slli	a5,a3,0x10
   18728:	0107d793          	srli	a5,a5,0x10
   1872c:	01279593          	slli	a1,a5,0x12
   18730:	0205c663          	bltz	a1,1875c <_vfiprintf_r+0x90>
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
	_newlib_flockfile_start (fp);
   18734:	068d2603          	lw	a2,104(s10)

	ORIENT(fp, -1);
   18738:	000027b7          	lui	a5,0x2
   1873c:	ffffe737          	lui	a4,0xffffe
   18740:	00f6e7b3          	or	a5,a3,a5
   18744:	fff70713          	addi	a4,a4,-1 # ffffdfff <_gp+0xfffdf9bf>
   18748:	00e67733          	and	a4,a2,a4
   1874c:	00fd1623          	sh	a5,12(s10)
   18750:	01079793          	slli	a5,a5,0x10
   18754:	06ed2423          	sw	a4,104(s10)
   18758:	0107d793          	srli	a5,a5,0x10

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   1875c:	0087f713          	andi	a4,a5,8
   18760:	12070a63          	beqz	a4,18894 <_vfiprintf_r+0x1c8>
   18764:	010d2703          	lw	a4,16(s10)
   18768:	12070663          	beqz	a4,18894 <_vfiprintf_r+0x1c8>
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   1876c:	01a7f793          	andi	a5,a5,26
   18770:	00a00713          	li	a4,10
   18774:	14e78063          	beq	a5,a4,188b4 <_vfiprintf_r+0x1e8>
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   18778:	07010c93          	addi	s9,sp,112
   1877c:	06f10713          	addi	a4,sp,111
   18780:	0001c337          	lui	t1,0x1c
   18784:	0001c8b7          	lui	a7,0x1c
   18788:	40ec87b3          	sub	a5,s9,a4
   1878c:	00e12623          	sw	a4,12(sp)
   18790:	03912e23          	sw	s9,60(sp)
	uio.uio_resid = 0;
   18794:	04012223          	sw	zero,68(sp)
	uio.uio_iovcnt = 0;
   18798:	04012023          	sw	zero,64(sp)
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
   1879c:	00012e23          	sw	zero,28(sp)
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
	uio.uio_resid = 0;
	uio.uio_iovcnt = 0;
#endif
	ret = 0;
   187a0:	00012a23          	sw	zero,20(sp)
   187a4:	0d430b13          	addi	s6,t1,212 # 1c0d4 <blanks.4133>
   187a8:	0e488c13          	addi	s8,a7,228 # 1c0e4 <zeroes.4134>
   187ac:	02f12223          	sw	a5,36(sp)
   187b0:	000c8693          	mv	a3,s9
   187b4:	00048d93          	mv	s11,s1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   187b8:	000dc783          	lbu	a5,0(s11)
   187bc:	4a078ce3          	beqz	a5,19474 <_vfiprintf_r+0xda8>
   187c0:	02500713          	li	a4,37
   187c4:	000d8913          	mv	s2,s11
   187c8:	00e79663          	bne	a5,a4,187d4 <_vfiprintf_r+0x108>
   187cc:	0540006f          	j	18820 <_vfiprintf_r+0x154>
   187d0:	00e78863          	beq	a5,a4,187e0 <_vfiprintf_r+0x114>
                    fmt += 1;
   187d4:	00190913          	addi	s2,s2,1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   187d8:	00094783          	lbu	a5,0(s2)
   187dc:	fe079ae3          	bnez	a5,187d0 <_vfiprintf_r+0x104>
   187e0:	41b90433          	sub	s0,s2,s11
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
   187e4:	02040e63          	beqz	s0,18820 <_vfiprintf_r+0x154>
			PRINT (cp, m);
   187e8:	04412703          	lw	a4,68(sp)
   187ec:	04012783          	lw	a5,64(sp)
   187f0:	00700613          	li	a2,7
   187f4:	00e40733          	add	a4,s0,a4
   187f8:	00178793          	addi	a5,a5,1 # 2001 <_reset+0x1e01>
   187fc:	01b6a023          	sw	s11,0(a3) # 7fe00000 <_gp+0x7fde19c0>
   18800:	0086a223          	sw	s0,4(a3)
   18804:	04e12223          	sw	a4,68(sp)
   18808:	04f12023          	sw	a5,64(sp)
   1880c:	00868693          	addi	a3,a3,8
   18810:	06f64463          	blt	a2,a5,18878 <_vfiprintf_r+0x1ac>
			ret += m;
   18814:	01412883          	lw	a7,20(sp)
   18818:	008888b3          	add	a7,a7,s0
   1881c:	01112a23          	sw	a7,20(sp)
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
   18820:	00094783          	lbu	a5,0(s2)
   18824:	060788e3          	beqz	a5,19094 <_vfiprintf_r+0x9c8>
                    goto done;
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */
   18828:	00190493          	addi	s1,s2,1

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
   1882c:	02010ba3          	sb	zero,55(sp)
   18830:	00000813          	li	a6,0
   18834:	00000313          	li	t1,0
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
   18838:	fff00713          	li	a4,-1
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
   1883c:	00000913          	li	s2,0
                    goto done;
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
   18840:	00000b93          	li	s7,0
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   18844:	05800593          	li	a1,88
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			} while (is_digit (ch));
   18848:	00900513          	li	a0,9
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
   1884c:	02a00393          	li	t2,42
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
   18850:	0004c603          	lbu	a2,0(s1)
   18854:	00148d93          	addi	s11,s1,1
reswitch:	switch (ch) {
   18858:	fe060793          	addi	a5,a2,-32
   1885c:	6af5e263          	bltu	a1,a5,18f00 <_vfiprintf_r+0x834>
   18860:	0001c8b7          	lui	a7,0x1c
   18864:	00279793          	slli	a5,a5,0x2
   18868:	f7088893          	addi	a7,a7,-144 # 1bf70 <__mprec_bigtens+0x28>
   1886c:	011787b3          	add	a5,a5,a7
   18870:	0007a783          	lw	a5,0(a5)
   18874:	00078067          	jr	a5
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   18878:	300710e3          	bnez	a4,19378 <_vfiprintf_r+0xcac>
		uio->uio_iovcnt = 0;
   1887c:	04012023          	sw	zero,64(sp)
#else
                while (*fmt != '\0' && *fmt != '%')
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
			PRINT (cp, m);
   18880:	000c8693          	mv	a3,s9
   18884:	f91ff06f          	j	18814 <_vfiprintf_r+0x148>
			} else
#endif
				flags |= LONGINT;
			goto rflag;
		case 'q': /* extension */
			flags |= QUADINT;
   18888:	010beb93          	ori	s7,s7,16
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   1888c:	000d8493          	mv	s1,s11
   18890:	fc1ff06f          	j	18850 <_vfiprintf_r+0x184>
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   18894:	000d0593          	mv	a1,s10
   18898:	000a8513          	mv	a0,s5
   1889c:	d39fa0ef          	jal	135d4 <__swsetup_r>
   188a0:	48051ae3          	bnez	a0,19534 <_vfiprintf_r+0xe68>
   188a4:	00cd5783          	lhu	a5,12(s10)
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   188a8:	00a00713          	li	a4,10
   188ac:	01a7f793          	andi	a5,a5,26
   188b0:	ece794e3          	bne	a5,a4,18778 <_vfiprintf_r+0xac>
   188b4:	00ed1783          	lh	a5,14(s10)
   188b8:	ec07c0e3          	bltz	a5,18778 <_vfiprintf_r+0xac>
	    fp->_file >= 0) {
		_newlib_flockfile_exit (fp);
		return (__sbprintf (data, fp, fmt0, ap));
   188bc:	01012683          	lw	a3,16(sp)
   188c0:	00048613          	mv	a2,s1
   188c4:	000d0593          	mv	a1,s10
   188c8:	000a8513          	mv	a0,s5
   188cc:	629000ef          	jal	196f4 <__sbprintf>
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
	/* NOTREACHED */
}
   188d0:	0ec12083          	lw	ra,236(sp)
   188d4:	0e812403          	lw	s0,232(sp)
   188d8:	0e412483          	lw	s1,228(sp)
   188dc:	0e012903          	lw	s2,224(sp)
   188e0:	0dc12983          	lw	s3,220(sp)
   188e4:	0d812a03          	lw	s4,216(sp)
   188e8:	0d412a83          	lw	s5,212(sp)
   188ec:	0d012b03          	lw	s6,208(sp)
   188f0:	0cc12b83          	lw	s7,204(sp)
   188f4:	0c812c03          	lw	s8,200(sp)
   188f8:	0c412c83          	lw	s9,196(sp)
   188fc:	0c012d03          	lw	s10,192(sp)
   18900:	0bc12d83          	lw	s11,188(sp)
   18904:	0f010113          	addi	sp,sp,240
   18908:	00008067          	ret
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
   1890c:	c51fc0ef          	jal	1555c <__sinit>
   18910:	e11ff06f          	j	18720 <_vfiprintf_r+0x54>
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   18914:	01012783          	lw	a5,16(sp)
   18918:	0007a903          	lw	s2,0(a5)
   1891c:	00478793          	addi	a5,a5,4
   18920:	00f12823          	sw	a5,16(sp)
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
   18924:	f60954e3          	bgez	s2,1888c <_vfiprintf_r+0x1c0>
				goto rflag;
			width = -width;
   18928:	41200933          	neg	s2,s2
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
   1892c:	004beb93          	ori	s7,s7,4
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   18930:	000d8493          	mv	s1,s11
   18934:	f1dff06f          	j	18850 <_vfiprintf_r+0x184>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   18938:	01012883          	lw	a7,16(sp)
			base = HEX;
			xdigs = "0123456789abcdef";
			flags |= HEXPREFIX;
			ox[0] = '0';
   1893c:	03000593          	li	a1,48
   18940:	02b10c23          	sb	a1,56(sp)
			ox[1] = ch = 'x';
   18944:	07800593          	li	a1,120
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   18948:	00488613          	addi	a2,a7,4
   1894c:	0008a783          	lw	a5,0(a7)
			base = HEX;
			xdigs = "0123456789abcdef";
			flags |= HEXPREFIX;
   18950:	002be513          	ori	a0,s7,2
			ox[0] = '0';
			ox[1] = ch = 'x';
   18954:	02b10ca3          	sb	a1,57(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   18958:	02010ba3          	sb	zero,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   1895c:	2e074ae3          	bltz	a4,19450 <_vfiprintf_r+0xd84>
   18960:	f7fbf293          	andi	t0,s7,-129
				flags &= ~ZEROPAD;
   18964:	0022eb93          	ori	s7,t0,2
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   18968:	00c12823          	sw	a2,16(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   1896c:	300798e3          	bnez	a5,1947c <_vfiprintf_r+0xdb0>
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   18970:	0001c7b7          	lui	a5,0x1c
   18974:	14878793          	addi	a5,a5,328 # 1c148 <__thenan_sf+0x38>
   18978:	00f12e23          	sw	a5,28(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   1897c:	00000593          	li	a1,0
   18980:	20071ae3          	bnez	a4,19394 <_vfiprintf_r+0xcc8>
   18984:	00000713          	li	a4,0
   18988:	00000a13          	li	s4,0
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   1898c:	000c8413          	mv	s0,s9
		 * If flags&FPT, ch must be in [aAeEfg].
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
   18990:	00070993          	mv	s3,a4
   18994:	01475463          	ble	s4,a4,1899c <_vfiprintf_r+0x2d0>
   18998:	000a0993          	mv	s3,s4
		if (sign)
			realsz++;
   1899c:	00b035b3          	snez	a1,a1
   189a0:	00b989b3          	add	s3,s3,a1
		if (flags & HEXPREFIX)
   189a4:	002bfe13          	andi	t3,s7,2
   189a8:	000e0463          	beqz	t3,189b0 <_vfiprintf_r+0x2e4>
			realsz+= 2;
   189ac:	00298993          	addi	s3,s3,2

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   189b0:	084bf393          	andi	t2,s7,132
   189b4:	5c039263          	bnez	t2,18f78 <_vfiprintf_r+0x8ac>
			PAD (width - realsz, blanks);
   189b8:	413904b3          	sub	s1,s2,s3
   189bc:	5a905e63          	blez	s1,18f78 <_vfiprintf_r+0x8ac>
   189c0:	01000813          	li	a6,16
   189c4:	04412783          	lw	a5,68(sp)
   189c8:	3e9850e3          	ble	s1,a6,195a8 <_vfiprintf_r+0xedc>
   189cc:	02812023          	sw	s0,32(sp)
   189d0:	04012503          	lw	a0,64(sp)
   189d4:	00048413          	mv	s0,s1
   189d8:	01612c23          	sw	s6,24(sp)
   189dc:	00700e93          	li	t4,7
   189e0:	02e12423          	sw	a4,40(sp)
   189e4:	03c12623          	sw	t3,44(sp)
   189e8:	00038493          	mv	s1,t2
   189ec:	0180006f          	j	18a04 <_vfiprintf_r+0x338>
   189f0:	00250613          	addi	a2,a0,2
   189f4:	00868693          	addi	a3,a3,8
   189f8:	00070513          	mv	a0,a4
   189fc:	ff040413          	addi	s0,s0,-16
   18a00:	02885c63          	ble	s0,a6,18a38 <_vfiprintf_r+0x36c>
   18a04:	01078793          	addi	a5,a5,16
   18a08:	00150713          	addi	a4,a0,1
   18a0c:	0166a023          	sw	s6,0(a3)
   18a10:	0106a223          	sw	a6,4(a3)
   18a14:	04f12223          	sw	a5,68(sp)
   18a18:	04e12023          	sw	a4,64(sp)
   18a1c:	fceedae3          	ble	a4,t4,189f0 <_vfiprintf_r+0x324>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   18a20:	52079063          	bnez	a5,18f40 <_vfiprintf_r+0x874>
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   18a24:	ff040413          	addi	s0,s0,-16
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   18a28:	00000513          	li	a0,0
   18a2c:	00100613          	li	a2,1
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   18a30:	000c8693          	mv	a3,s9
   18a34:	fc8848e3          	blt	a6,s0,18a04 <_vfiprintf_r+0x338>
   18a38:	00048393          	mv	t2,s1
   18a3c:	02812703          	lw	a4,40(sp)
   18a40:	00040493          	mv	s1,s0
   18a44:	02c12e03          	lw	t3,44(sp)
   18a48:	02012403          	lw	s0,32(sp)
   18a4c:	01812883          	lw	a7,24(sp)
   18a50:	00f487b3          	add	a5,s1,a5
   18a54:	00700593          	li	a1,7
   18a58:	0116a023          	sw	a7,0(a3)
   18a5c:	0096a223          	sw	s1,4(a3)
   18a60:	04f12223          	sw	a5,68(sp)
   18a64:	04c12023          	sw	a2,64(sp)
   18a68:	7cc5c863          	blt	a1,a2,19238 <_vfiprintf_r+0xb6c>

		/* prefix */
		if (sign)
   18a6c:	03714503          	lbu	a0,55(sp)
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   18a70:	00868693          	addi	a3,a3,8
   18a74:	00160593          	addi	a1,a2,1

		/* prefix */
		if (sign)
   18a78:	50051a63          	bnez	a0,18f8c <_vfiprintf_r+0x8c0>
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
   18a7c:	540e0463          	beqz	t3,18fc4 <_vfiprintf_r+0x8f8>
			PRINT (ox, 2);
   18a80:	03810613          	addi	a2,sp,56
   18a84:	00c6a023          	sw	a2,0(a3)
   18a88:	00200613          	li	a2,2
   18a8c:	00278793          	addi	a5,a5,2
   18a90:	00c6a223          	sw	a2,4(a3)
   18a94:	00700613          	li	a2,7
   18a98:	04f12223          	sw	a5,68(sp)
   18a9c:	04b12023          	sw	a1,64(sp)
   18aa0:	7eb65463          	ble	a1,a2,19288 <_vfiprintf_r+0xbbc>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   18aa4:	12079ce3          	bnez	a5,193dc <_vfiprintf_r+0xd10>
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   18aa8:	08000513          	li	a0,128
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   18aac:	00100593          	li	a1,1
   18ab0:	00000613          	li	a2,0

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
			PRINT (ox, 2);
   18ab4:	000c8693          	mv	a3,s9

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   18ab8:	50a39a63          	bne	t2,a0,18fcc <_vfiprintf_r+0x900>
			PAD (width - realsz, zeroes);
   18abc:	413904b3          	sub	s1,s2,s3
   18ac0:	50905663          	blez	s1,18fcc <_vfiprintf_r+0x900>
   18ac4:	01000813          	li	a6,16
   18ac8:	369858e3          	ble	s1,a6,19638 <_vfiprintf_r+0xf6c>
   18acc:	02812023          	sw	s0,32(sp)
   18ad0:	01812c23          	sw	s8,24(sp)
   18ad4:	00048413          	mv	s0,s1
   18ad8:	00700393          	li	t2,7
   18adc:	00070493          	mv	s1,a4
   18ae0:	0180006f          	j	18af8 <_vfiprintf_r+0x42c>
   18ae4:	00260513          	addi	a0,a2,2
   18ae8:	00868693          	addi	a3,a3,8
   18aec:	00070613          	mv	a2,a4
   18af0:	ff040413          	addi	s0,s0,-16
   18af4:	02885c63          	ble	s0,a6,18b2c <_vfiprintf_r+0x460>
   18af8:	01078793          	addi	a5,a5,16
   18afc:	00160713          	addi	a4,a2,1
   18b00:	0186a023          	sw	s8,0(a3)
   18b04:	0106a223          	sw	a6,4(a3)
   18b08:	04f12223          	sw	a5,68(sp)
   18b0c:	04e12023          	sw	a4,64(sp)
   18b10:	fce3dae3          	ble	a4,t2,18ae4 <_vfiprintf_r+0x418>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   18b14:	6e079663          	bnez	a5,19200 <_vfiprintf_r+0xb34>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   18b18:	ff040413          	addi	s0,s0,-16
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   18b1c:	00100513          	li	a0,1
   18b20:	00000613          	li	a2,0
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   18b24:	000c8693          	mv	a3,s9
   18b28:	fc8848e3          	blt	a6,s0,18af8 <_vfiprintf_r+0x42c>
   18b2c:	00048713          	mv	a4,s1
   18b30:	00040493          	mv	s1,s0
   18b34:	02012403          	lw	s0,32(sp)
   18b38:	01812883          	lw	a7,24(sp)
   18b3c:	009787b3          	add	a5,a5,s1
   18b40:	00700613          	li	a2,7
   18b44:	0116a023          	sw	a7,0(a3)
   18b48:	0096a223          	sw	s1,4(a3)
   18b4c:	04f12223          	sw	a5,68(sp)
   18b50:	04a12023          	sw	a0,64(sp)
   18b54:	0ca640e3          	blt	a2,a0,19414 <_vfiprintf_r+0xd48>

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   18b58:	414704b3          	sub	s1,a4,s4
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   18b5c:	00868693          	addi	a3,a3,8
   18b60:	00150593          	addi	a1,a0,1
   18b64:	00050613          	mv	a2,a0

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   18b68:	46904663          	bgtz	s1,18fd4 <_vfiprintf_r+0x908>
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   18b6c:	00fa07b3          	add	a5,s4,a5
   18b70:	00700713          	li	a4,7
   18b74:	0086a023          	sw	s0,0(a3)
   18b78:	0146a223          	sw	s4,4(a3)
   18b7c:	04f12223          	sw	a5,68(sp)
   18b80:	04b12023          	sw	a1,64(sp)
   18b84:	54b75e63          	ble	a1,a4,190e0 <_vfiprintf_r+0xa14>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   18b88:	7a079a63          	bnez	a5,1933c <_vfiprintf_r+0xc70>
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   18b8c:	004bf293          	andi	t0,s7,4
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   18b90:	04012023          	sw	zero,64(sp)
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   18b94:	5e028263          	beqz	t0,19178 <_vfiprintf_r+0xaac>
			PAD (width - realsz, blanks);
   18b98:	413904b3          	sub	s1,s2,s3
   18b9c:	1a9048e3          	bgtz	s1,1954c <_vfiprintf_r+0xe80>

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   18ba0:	01395463          	ble	s3,s2,18ba8 <_vfiprintf_r+0x4dc>
   18ba4:	00098913          	mv	s2,s3
   18ba8:	01412783          	lw	a5,20(sp)
   18bac:	012787b3          	add	a5,a5,s2
   18bb0:	00f12a23          	sw	a5,20(sp)

		FLUSH ();	/* copy out the I/O vectors */
   18bb4:	04012023          	sw	zero,64(sp)
   18bb8:	000c8693          	mv	a3,s9
   18bbc:	bfdff06f          	j	187b8 <_vfiprintf_r+0xec>
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   18bc0:	00100813          	li	a6,1
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
			goto rflag;
		case '+':
			sign = '+';
   18bc4:	02b00313          	li	t1,43
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   18bc8:	000d8493          	mv	s1,s11
   18bcc:	c85ff06f          	j	18850 <_vfiprintf_r+0x184>
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
   18bd0:	080beb93          	ori	s7,s7,128
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   18bd4:	000d8493          	mv	s1,s11
   18bd8:	c79ff06f          	j	18850 <_vfiprintf_r+0x184>
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   18bdc:	00000913          	li	s2,0
   18be0:	fd060793          	addi	a5,a2,-48
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
   18be4:	001d8d93          	addi	s11,s11,1
   18be8:	fffdc603          	lbu	a2,-1(s11)
			goto rflag;
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
   18bec:	00191893          	slli	a7,s2,0x1
   18bf0:	00391913          	slli	s2,s2,0x3
   18bf4:	01288933          	add	s2,a7,s2
   18bf8:	01278933          	add	s2,a5,s2
				ch = *fmt++;
			} while (is_digit (ch));
   18bfc:	fd060793          	addi	a5,a2,-48
   18c00:	fef572e3          	bleu	a5,a0,18be4 <_vfiprintf_r+0x518>
   18c04:	c55ff06f          	j	18858 <_vfiprintf_r+0x18c>
   18c08:	2c0814e3          	bnez	a6,196d0 <_vfiprintf_r+0x1004>
				size = 1;
			}
			sign = '\0';
			break;
		case 'D':  /* extension */
			flags |= LONGINT;
   18c0c:	010beb93          	ori	s7,s7,16
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   18c10:	010bf793          	andi	a5,s7,16
   18c14:	74078463          	beqz	a5,1935c <_vfiprintf_r+0xc90>
   18c18:	01012883          	lw	a7,16(sp)
   18c1c:	0008a783          	lw	a5,0(a7)
   18c20:	00488893          	addi	a7,a7,4
   18c24:	01112823          	sw	a7,16(sp)
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
#else
			if ((long) _uquad < 0)
   18c28:	0807c8e3          	bltz	a5,194b8 <_vfiprintf_r+0xdec>
   18c2c:	03714583          	lbu	a1,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   18c30:	68074263          	bltz	a4,192b4 <_vfiprintf_r+0xbe8>
				flags &= ~ZEROPAD;
   18c34:	f7fbfb93          	andi	s7,s7,-129
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   18c38:	12078263          	beqz	a5,18d5c <_vfiprintf_r+0x690>
						*--cp = '0';
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   18c3c:	00900613          	li	a2,9
   18c40:	000c8413          	mv	s0,s9
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   18c44:	00a00513          	li	a0,10
						*--cp = '0';
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   18c48:	10f67e63          	bleu	a5,a2,18d64 <_vfiprintf_r+0x698>
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   18c4c:	02a7f633          	remu	a2,a5,a0
   18c50:	fff40413          	addi	s0,s0,-1
					       next cases. */
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
   18c54:	02a7d7b3          	divu	a5,a5,a0
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   18c58:	03060613          	addi	a2,a2,48
   18c5c:	00c40023          	sb	a2,0(s0)
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
					} while (_uquad != 0);
   18c60:	fe0796e3          	bnez	a5,18c4c <_vfiprintf_r+0x580>
   18c64:	408c8a33          	sub	s4,s9,s0
   18c68:	d29ff06f          	j	18990 <_vfiprintf_r+0x2c4>
   18c6c:	24081ee3          	bnez	a6,196c8 <_vfiprintf_r+0xffc>
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
   18c70:	010beb93          	ori	s7,s7,16
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   18c74:	010bf793          	andi	a5,s7,16
   18c78:	64079e63          	bnez	a5,192d4 <_vfiprintf_r+0xc08>
   18c7c:	040bf793          	andi	a5,s7,64
   18c80:	64078a63          	beqz	a5,192d4 <_vfiprintf_r+0xc08>
   18c84:	01012883          	lw	a7,16(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   18c88:	02010ba3          	sb	zero,55(sp)
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   18c8c:	00488613          	addi	a2,a7,4
   18c90:	0008d783          	lhu	a5,0(a7)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   18c94:	64074a63          	bltz	a4,192e8 <_vfiprintf_r+0xc1c>
				flags &= ~ZEROPAD;
   18c98:	f7fbfb93          	andi	s7,s7,-129
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   18c9c:	00c12823          	sw	a2,16(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   18ca0:	64079a63          	bnez	a5,192f4 <_vfiprintf_r+0xc28>
   18ca4:	00000593          	li	a1,0
   18ca8:	00000793          	li	a5,0
   18cac:	1e0700e3          	beqz	a4,1968c <_vfiprintf_r+0xfc0>
   18cb0:	000c8413          	mv	s0,s9
				 * a variable; hence this switch.
				 */
				switch (base) {
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   18cb4:	0077f613          	andi	a2,a5,7
   18cb8:	fff40413          	addi	s0,s0,-1
   18cbc:	03060613          	addi	a2,a2,48
						_uquad >>= 3;
   18cc0:	0037d793          	srli	a5,a5,0x3
				 * a variable; hence this switch.
				 */
				switch (base) {
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   18cc4:	00c40023          	sb	a2,0(s0)
						_uquad >>= 3;
					} while (_uquad);
   18cc8:	fe0796e3          	bnez	a5,18cb4 <_vfiprintf_r+0x5e8>
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
   18ccc:	001bf793          	andi	a5,s7,1
   18cd0:	f8078ae3          	beqz	a5,18c64 <_vfiprintf_r+0x598>
   18cd4:	03000793          	li	a5,48
   18cd8:	f8f606e3          	beq	a2,a5,18c64 <_vfiprintf_r+0x598>
						*--cp = '0';
   18cdc:	fff40613          	addi	a2,s0,-1
   18ce0:	fef40fa3          	sb	a5,-1(s0)
   18ce4:	40cc8a33          	sub	s4,s9,a2
   18ce8:	00060413          	mv	s0,a2
   18cec:	ca5ff06f          	j	18990 <_vfiprintf_r+0x2c4>
   18cf0:	18081ae3          	bnez	a6,19684 <_vfiprintf_r+0xfb8>
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
				*GET_ARG (N, ap, quad_ptr_t) = ret;
			else
#endif
			if (flags & LONGINT)
   18cf4:	010bf793          	andi	a5,s7,16
   18cf8:	22079663          	bnez	a5,18f24 <_vfiprintf_r+0x858>
				*GET_ARG (N, ap, long_ptr_t) = ret;
			else if (flags & SHORTINT)
   18cfc:	040bf293          	andi	t0,s7,64
   18d00:	22028263          	beqz	t0,18f24 <_vfiprintf_r+0x858>
				*GET_ARG (N, ap, short_ptr_t) = ret;
   18d04:	01012703          	lw	a4,16(sp)
   18d08:	01412883          	lw	a7,20(sp)
   18d0c:	00072783          	lw	a5,0(a4)
   18d10:	00470713          	addi	a4,a4,4
   18d14:	00e12823          	sw	a4,16(sp)
   18d18:	01179023          	sh	a7,0(a5)
   18d1c:	a9dff06f          	j	187b8 <_vfiprintf_r+0xec>
   18d20:	18081ce3          	bnez	a6,196b8 <_vfiprintf_r+0xfec>
			} else
				size = strlen (cp);

			break;
		case 'U': /* extension */
			flags |= LONGINT;
   18d24:	010beb93          	ori	s7,s7,16
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   18d28:	010bf793          	andi	a5,s7,16
   18d2c:	56079663          	bnez	a5,19298 <_vfiprintf_r+0xbcc>
   18d30:	040bf793          	andi	a5,s7,64
   18d34:	56078263          	beqz	a5,19298 <_vfiprintf_r+0xbcc>
   18d38:	01012783          	lw	a5,16(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   18d3c:	02010ba3          	sb	zero,55(sp)
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   18d40:	00478613          	addi	a2,a5,4
   18d44:	0007d783          	lhu	a5,0(a5)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   18d48:	56074263          	bltz	a4,192ac <_vfiprintf_r+0xbe0>
				flags &= ~ZEROPAD;
   18d4c:	f7fbfb93          	andi	s7,s7,-129
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   18d50:	00c12823          	sw	a2,16(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   18d54:	00000593          	li	a1,0
   18d58:	ee0792e3          	bnez	a5,18c3c <_vfiprintf_r+0x570>
   18d5c:	c20704e3          	beqz	a4,18984 <_vfiprintf_r+0x2b8>
   18d60:	00000793          	li	a5,0
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
						*--cp = to_char(_uquad);
   18d64:	03078793          	addi	a5,a5,48
   18d68:	06f107a3          	sb	a5,111(sp)
   18d6c:	02412a03          	lw	s4,36(sp)
   18d70:	06f10413          	addi	s0,sp,111
						break;
   18d74:	c1dff06f          	j	18990 <_vfiprintf_r+0x2c4>
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
   18d78:	b0031ae3          	bnez	t1,1888c <_vfiprintf_r+0x1c0>
   18d7c:	00100813          	li	a6,1
				sign = ' ';
   18d80:	02000313          	li	t1,32
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   18d84:	000d8493          	mv	s1,s11
   18d88:	ac9ff06f          	j	18850 <_vfiprintf_r+0x184>
			 */
			if (!sign)
				sign = ' ';
			goto rflag;
		case '#':
			flags |= ALT;
   18d8c:	001beb93          	ori	s7,s7,1
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   18d90:	000d8493          	mv	s1,s11
   18d94:	abdff06f          	j	18850 <_vfiprintf_r+0x184>
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   18d98:	01012783          	lw	a5,16(sp)
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
   18d9c:	02010ba3          	sb	zero,55(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   18da0:	0007a403          	lw	s0,0(a5)
   18da4:	00478493          	addi	s1,a5,4
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
   18da8:	040400e3          	beqz	s0,195e8 <_vfiprintf_r+0xf1c>
				}
				cp[size] = '\0';
			}
			else
#endif /* _MB_CAPABLE */
			if (prec >= 0) {
   18dac:	7a074463          	bltz	a4,19554 <_vfiprintf_r+0xe88>
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);
   18db0:	00070613          	mv	a2,a4
   18db4:	00000593          	li	a1,0
   18db8:	00040513          	mv	a0,s0
   18dbc:	00d12423          	sw	a3,8(sp)
   18dc0:	00e12223          	sw	a4,4(sp)
   18dc4:	b8dfd0ef          	jal	16950 <memchr>

				if (p != NULL)
   18dc8:	00812683          	lw	a3,8(sp)
   18dcc:	00412703          	lw	a4,4(sp)
   18dd0:	04050ae3          	beqz	a0,19624 <_vfiprintf_r+0xf58>
					size = p - cp;
   18dd4:	40850a33          	sub	s4,a0,s0
   18dd8:	03714583          	lbu	a1,55(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   18ddc:	00912823          	sw	s1,16(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   18de0:	00000713          	li	a4,0
   18de4:	badff06f          	j	18990 <_vfiprintf_r+0x2c4>
   18de8:	f40800e3          	beqz	a6,18d28 <_vfiprintf_r+0x65c>
   18dec:	02610ba3          	sb	t1,55(sp)
   18df0:	f39ff06f          	j	18d28 <_vfiprintf_r+0x65c>
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   18df4:	01012703          	lw	a4,16(sp)
				size = 1;
			}
			sign = '\0';
			break;
   18df8:	00100993          	li	s3,1
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
				size = 1;
			}
			sign = '\0';
   18dfc:	02010ba3          	sb	zero,55(sp)
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   18e00:	00072783          	lw	a5,0(a4)
   18e04:	00470713          	addi	a4,a4,4
   18e08:	00e12823          	sw	a4,16(sp)
   18e0c:	04f10423          	sb	a5,72(sp)
				size = 1;
   18e10:	00098a13          	mv	s4,s3
		    flags |= QUADINT;
		  goto rflag;
		case 'C':
#endif /* _WANT_IO_C99_FORMATS */
		case 'c':
			cp = buf;
   18e14:	04810413          	addi	s0,sp,72
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   18e18:	00000713          	li	a4,0
   18e1c:	b89ff06f          	j	189a4 <_vfiprintf_r+0x2d8>
   18e20:	de0808e3          	beqz	a6,18c10 <_vfiprintf_r+0x544>
   18e24:	02610ba3          	sb	t1,55(sp)
   18e28:	de9ff06f          	j	18c10 <_vfiprintf_r+0x544>
   18e2c:	0a0816e3          	bnez	a6,196d8 <_vfiprintf_r+0x100c>
		case 'u':
			_uquad = UARG ();
			base = DEC;
			goto nosign;
		case 'X':
			xdigs = "0123456789ABCDEF";
   18e30:	0001c7b7          	lui	a5,0x1c
   18e34:	13478793          	addi	a5,a5,308 # 1c134 <__thenan_sf+0x24>
   18e38:	00f12e23          	sw	a5,28(sp)
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
   18e3c:	010bf793          	andi	a5,s7,16
   18e40:	06078063          	beqz	a5,18ea0 <_vfiprintf_r+0x7d4>
   18e44:	01012883          	lw	a7,16(sp)
   18e48:	0008a783          	lw	a5,0(a7)
   18e4c:	00488893          	addi	a7,a7,4
   18e50:	01112823          	sw	a7,16(sp)
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
   18e54:	001bf593          	andi	a1,s7,1
   18e58:	4a058263          	beqz	a1,192fc <_vfiprintf_r+0xc30>
   18e5c:	62079a63          	bnez	a5,19490 <_vfiprintf_r+0xdc4>

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   18e60:	02010ba3          	sb	zero,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   18e64:	60074263          	bltz	a4,19468 <_vfiprintf_r+0xd9c>
				flags &= ~ZEROPAD;
   18e68:	f7fbfb93          	andi	s7,s7,-129
   18e6c:	b11ff06f          	j	1897c <_vfiprintf_r+0x2b0>
   18e70:	e00802e3          	beqz	a6,18c74 <_vfiprintf_r+0x5a8>
   18e74:	02610ba3          	sb	t1,55(sp)
   18e78:	dfdff06f          	j	18c74 <_vfiprintf_r+0x5a8>
			if (*fmt == 'h') {
				fmt++;
				flags |= CHARINT;
			} else
#endif
				flags |= SHORTINT;
   18e7c:	040beb93          	ori	s7,s7,64
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   18e80:	000d8493          	mv	s1,s11
   18e84:	9cdff06f          	j	18850 <_vfiprintf_r+0x184>
   18e88:	7e081a63          	bnez	a6,1967c <_vfiprintf_r+0xfb0>
			goto nosign;
		case 'X':
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
   18e8c:	0001c7b7          	lui	a5,0x1c
   18e90:	14878793          	addi	a5,a5,328 # 1c148 <__thenan_sf+0x38>
   18e94:	00f12e23          	sw	a5,28(sp)
hex:			_uquad = UARG ();
   18e98:	010bf793          	andi	a5,s7,16
   18e9c:	fa0794e3          	bnez	a5,18e44 <_vfiprintf_r+0x778>
   18ea0:	040bf793          	andi	a5,s7,64
   18ea4:	01012883          	lw	a7,16(sp)
   18ea8:	62078663          	beqz	a5,194d4 <_vfiprintf_r+0xe08>
   18eac:	0008d783          	lhu	a5,0(a7)
   18eb0:	00488893          	addi	a7,a7,4
   18eb4:	01112823          	sw	a7,16(sp)
   18eb8:	f9dff06f          	j	18e54 <_vfiprintf_r+0x788>
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
   18ebc:	000dc603          	lbu	a2,0(s11)
   18ec0:	001d8d93          	addi	s11,s11,1
   18ec4:	78760c63          	beq	a2,t2,1965c <_vfiprintf_r+0xf90>
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   18ec8:	fd060793          	addi	a5,a2,-48
   18ecc:	00000713          	li	a4,0
   18ed0:	98f564e3          	bltu	a0,a5,18858 <_vfiprintf_r+0x18c>
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
   18ed4:	001d8d93          	addi	s11,s11,1
   18ed8:	fffdc603          	lbu	a2,-1(s11)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
				n = 10 * n + to_digit (ch);
   18edc:	00171893          	slli	a7,a4,0x1
   18ee0:	00371713          	slli	a4,a4,0x3
   18ee4:	00e88733          	add	a4,a7,a4
   18ee8:	00f70733          	add	a4,a4,a5
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   18eec:	fd060793          	addi	a5,a2,-48
   18ef0:	fef572e3          	bleu	a5,a0,18ed4 <_vfiprintf_r+0x808>
   18ef4:	960752e3          	bgez	a4,18858 <_vfiprintf_r+0x18c>
   18ef8:	fff00713          	li	a4,-1
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			}
			prec = n < 0 ? -1 : n;
			goto reswitch;
   18efc:	95dff06f          	j	18858 <_vfiprintf_r+0x18c>
   18f00:	7c081063          	bnez	a6,196c0 <_vfiprintf_r+0xff4>

			size = buf + BUF - cp;
		skipsize:
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
   18f04:	18060863          	beqz	a2,19094 <_vfiprintf_r+0x9c8>
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
   18f08:	00100993          	li	s3,1
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
   18f0c:	04c10423          	sb	a2,72(sp)
			size = 1;
			sign = '\0';
   18f10:	02010ba3          	sb	zero,55(sp)
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
   18f14:	00098a13          	mv	s4,s3
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
   18f18:	04810413          	addi	s0,sp,72
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   18f1c:	00000713          	li	a4,0
   18f20:	a85ff06f          	j	189a4 <_vfiprintf_r+0x2d8>
#ifdef _WANT_IO_C99_FORMATS
			else if (flags & CHARINT)
				*GET_ARG (N, ap, char_ptr_t) = ret;
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
   18f24:	01012703          	lw	a4,16(sp)
   18f28:	01412883          	lw	a7,20(sp)
   18f2c:	00072783          	lw	a5,0(a4)
   18f30:	00470713          	addi	a4,a4,4
   18f34:	00e12823          	sw	a4,16(sp)
   18f38:	0117a023          	sw	a7,0(a5)
   18f3c:	87dff06f          	j	187b8 <_vfiprintf_r+0xec>
   18f40:	03c10613          	addi	a2,sp,60
   18f44:	000d0593          	mv	a1,s10
   18f48:	000a8513          	mv	a0,s5
   18f4c:	01012223          	sw	a6,4(sp)
   18f50:	01d12423          	sw	t4,8(sp)
   18f54:	e78ff0ef          	jal	185cc <__sprint_r.part.0>
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   18f58:	00412803          	lw	a6,4(sp)
   18f5c:	00812e83          	lw	t4,8(sp)
   18f60:	14051663          	bnez	a0,190ac <_vfiprintf_r+0x9e0>
   18f64:	04012503          	lw	a0,64(sp)
   18f68:	04412783          	lw	a5,68(sp)
   18f6c:	000c8693          	mv	a3,s9
   18f70:	00150613          	addi	a2,a0,1
   18f74:	a89ff06f          	j	189fc <_vfiprintf_r+0x330>
   18f78:	04012603          	lw	a2,64(sp)
   18f7c:	04412783          	lw	a5,68(sp)
   18f80:	00160593          	addi	a1,a2,1

		/* prefix */
		if (sign)
   18f84:	03714503          	lbu	a0,55(sp)
   18f88:	ae050ae3          	beqz	a0,18a7c <_vfiprintf_r+0x3b0>
			PRINT (&sign, 1);
   18f8c:	00100513          	li	a0,1
   18f90:	03710613          	addi	a2,sp,55
   18f94:	00a787b3          	add	a5,a5,a0
   18f98:	00c6a023          	sw	a2,0(a3)
   18f9c:	00700613          	li	a2,7
   18fa0:	00a6a223          	sw	a0,4(a3)
   18fa4:	04f12223          	sw	a5,68(sp)
   18fa8:	04b12023          	sw	a1,64(sp)
   18fac:	2ab65863          	ble	a1,a2,1925c <_vfiprintf_r+0xb90>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   18fb0:	3e079663          	bnez	a5,1939c <_vfiprintf_r+0xcd0>
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
   18fb4:	2a0e1e63          	bnez	t3,19270 <_vfiprintf_r+0xba4>
   18fb8:	00000613          	li	a2,0
   18fbc:	00050593          	mv	a1,a0
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
   18fc0:	000c8693          	mv	a3,s9
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   18fc4:	08000513          	li	a0,128
   18fc8:	aea38ae3          	beq	t2,a0,18abc <_vfiprintf_r+0x3f0>
			PAD (width - realsz, zeroes);

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   18fcc:	414704b3          	sub	s1,a4,s4
   18fd0:	b8905ee3          	blez	s1,18b6c <_vfiprintf_r+0x4a0>
   18fd4:	01000813          	li	a6,16
   18fd8:	01812c23          	sw	s8,24(sp)
   18fdc:	04985a63          	ble	s1,a6,19030 <_vfiprintf_r+0x964>
   18fe0:	00700393          	li	t2,7
   18fe4:	0180006f          	j	18ffc <_vfiprintf_r+0x930>
   18fe8:	00260593          	addi	a1,a2,2
   18fec:	00868693          	addi	a3,a3,8
   18ff0:	00070613          	mv	a2,a4
   18ff4:	ff048493          	addi	s1,s1,-16
   18ff8:	02985c63          	ble	s1,a6,19030 <_vfiprintf_r+0x964>
   18ffc:	01078793          	addi	a5,a5,16
   19000:	00160713          	addi	a4,a2,1
   19004:	0186a023          	sw	s8,0(a3)
   19008:	0106a223          	sw	a6,4(a3)
   1900c:	04f12223          	sw	a5,68(sp)
   19010:	04e12023          	sw	a4,64(sp)
   19014:	fce3dae3          	ble	a4,t2,18fe8 <_vfiprintf_r+0x91c>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   19018:	04079263          	bnez	a5,1905c <_vfiprintf_r+0x990>
		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   1901c:	ff048493          	addi	s1,s1,-16
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   19020:	00100593          	li	a1,1
   19024:	00000613          	li	a2,0
		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   19028:	000c8693          	mv	a3,s9
   1902c:	fc9848e3          	blt	a6,s1,18ffc <_vfiprintf_r+0x930>
   19030:	01812703          	lw	a4,24(sp)
   19034:	009787b3          	add	a5,a5,s1
   19038:	0096a223          	sw	s1,4(a3)
   1903c:	00e6a023          	sw	a4,0(a3)
   19040:	00700713          	li	a4,7
   19044:	04f12223          	sw	a5,68(sp)
   19048:	04b12023          	sw	a1,64(sp)
   1904c:	06b74a63          	blt	a4,a1,190c0 <_vfiprintf_r+0x9f4>
   19050:	00868693          	addi	a3,a3,8
   19054:	00158593          	addi	a1,a1,1
   19058:	b15ff06f          	j	18b6c <_vfiprintf_r+0x4a0>
   1905c:	03c10613          	addi	a2,sp,60
   19060:	000d0593          	mv	a1,s10
   19064:	000a8513          	mv	a0,s5
   19068:	00712023          	sw	t2,0(sp)
   1906c:	01012223          	sw	a6,4(sp)
   19070:	d5cff0ef          	jal	185cc <__sprint_r.part.0>
   19074:	00012383          	lw	t2,0(sp)
   19078:	00412803          	lw	a6,4(sp)
   1907c:	02051863          	bnez	a0,190ac <_vfiprintf_r+0x9e0>
   19080:	04012603          	lw	a2,64(sp)
   19084:	04412783          	lw	a5,68(sp)
   19088:	000c8693          	mv	a3,s9
   1908c:	00160593          	addi	a1,a2,1
   19090:	f65ff06f          	j	18ff4 <_vfiprintf_r+0x928>
			_free_r (data, malloc_buf);
			malloc_buf = NULL;
		}
	}
done:
	FLUSH ();
   19094:	04412783          	lw	a5,68(sp)
   19098:	00078a63          	beqz	a5,190ac <_vfiprintf_r+0x9e0>
   1909c:	03c10613          	addi	a2,sp,60
   190a0:	000d0593          	mv	a1,s10
   190a4:	000a8513          	mv	a0,s5
   190a8:	d24ff0ef          	jal	185cc <__sprint_r.part.0>
	if (malloc_buf != NULL)
		_free_r (data, malloc_buf);
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
   190ac:	00cd5783          	lhu	a5,12(s10)
   190b0:	0407f793          	andi	a5,a5,64
   190b4:	48079063          	bnez	a5,19534 <_vfiprintf_r+0xe68>
   190b8:	01412503          	lw	a0,20(sp)
   190bc:	815ff06f          	j	188d0 <_vfiprintf_r+0x204>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   190c0:	36079463          	bnez	a5,19428 <_vfiprintf_r+0xd5c>
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   190c4:	00100713          	li	a4,1
   190c8:	000a0793          	mv	a5,s4
   190cc:	06812823          	sw	s0,112(sp)
   190d0:	07412a23          	sw	s4,116(sp)
   190d4:	05412223          	sw	s4,68(sp)
   190d8:	04e12023          	sw	a4,64(sp)
   190dc:	000c8693          	mv	a3,s9
   190e0:	00868693          	addi	a3,a3,8
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   190e4:	004bf293          	andi	t0,s7,4
   190e8:	0e028463          	beqz	t0,191d0 <_vfiprintf_r+0xb04>
			PAD (width - realsz, blanks);
   190ec:	413904b3          	sub	s1,s2,s3
   190f0:	0e905063          	blez	s1,191d0 <_vfiprintf_r+0xb04>
   190f4:	01000a13          	li	s4,16
   190f8:	509a5e63          	ble	s1,s4,19614 <_vfiprintf_r+0xf48>
   190fc:	04012603          	lw	a2,64(sp)
   19100:	01612c23          	sw	s6,24(sp)
   19104:	00700413          	li	s0,7
   19108:	0180006f          	j	19120 <_vfiprintf_r+0xa54>
   1910c:	00260593          	addi	a1,a2,2
   19110:	00868693          	addi	a3,a3,8
   19114:	00070613          	mv	a2,a4
   19118:	ff048493          	addi	s1,s1,-16
   1911c:	029a5c63          	ble	s1,s4,19154 <_vfiprintf_r+0xa88>
   19120:	01078793          	addi	a5,a5,16
   19124:	00160713          	addi	a4,a2,1
   19128:	0166a023          	sw	s6,0(a3)
   1912c:	0146a223          	sw	s4,4(a3)
   19130:	04f12223          	sw	a5,68(sp)
   19134:	04e12023          	sw	a4,64(sp)
   19138:	fce45ae3          	ble	a4,s0,1910c <_vfiprintf_r+0xa40>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   1913c:	04079a63          	bnez	a5,19190 <_vfiprintf_r+0xac4>
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
			PAD (width - realsz, blanks);
   19140:	ff048493          	addi	s1,s1,-16
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   19144:	00100593          	li	a1,1
   19148:	00000613          	li	a2,0
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
			PAD (width - realsz, blanks);
   1914c:	000c8693          	mv	a3,s9
   19150:	fc9a48e3          	blt	s4,s1,19120 <_vfiprintf_r+0xa54>
   19154:	01812883          	lw	a7,24(sp)
   19158:	009787b3          	add	a5,a5,s1
   1915c:	00700713          	li	a4,7
   19160:	0116a023          	sw	a7,0(a3)
   19164:	0096a223          	sw	s1,4(a3)
   19168:	04f12223          	sw	a5,68(sp)
   1916c:	04b12023          	sw	a1,64(sp)
   19170:	06b75063          	ble	a1,a4,191d0 <_vfiprintf_r+0xb04>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   19174:	04079263          	bnez	a5,191b8 <_vfiprintf_r+0xaec>
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
			PAD (width - realsz, blanks);

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   19178:	01395463          	ble	s3,s2,19180 <_vfiprintf_r+0xab4>
   1917c:	00098913          	mv	s2,s3
   19180:	01412703          	lw	a4,20(sp)
   19184:	01270733          	add	a4,a4,s2
   19188:	00e12a23          	sw	a4,20(sp)
   1918c:	a29ff06f          	j	18bb4 <_vfiprintf_r+0x4e8>
   19190:	03c10613          	addi	a2,sp,60
   19194:	000d0593          	mv	a1,s10
   19198:	000a8513          	mv	a0,s5
   1919c:	c30ff0ef          	jal	185cc <__sprint_r.part.0>
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
			PAD (width - realsz, blanks);
   191a0:	f00516e3          	bnez	a0,190ac <_vfiprintf_r+0x9e0>
   191a4:	04012603          	lw	a2,64(sp)
   191a8:	04412783          	lw	a5,68(sp)
   191ac:	000c8693          	mv	a3,s9
   191b0:	00160593          	addi	a1,a2,1
   191b4:	f65ff06f          	j	19118 <_vfiprintf_r+0xa4c>
   191b8:	03c10613          	addi	a2,sp,60
   191bc:	000d0593          	mv	a1,s10
   191c0:	000a8513          	mv	a0,s5
   191c4:	c08ff0ef          	jal	185cc <__sprint_r.part.0>
   191c8:	ee0512e3          	bnez	a0,190ac <_vfiprintf_r+0x9e0>
   191cc:	04412783          	lw	a5,68(sp)

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   191d0:	01395463          	ble	s3,s2,191d8 <_vfiprintf_r+0xb0c>
   191d4:	00098913          	mv	s2,s3
   191d8:	01412883          	lw	a7,20(sp)
   191dc:	012888b3          	add	a7,a7,s2
   191e0:	01112a23          	sw	a7,20(sp)

		FLUSH ();	/* copy out the I/O vectors */
   191e4:	9c0788e3          	beqz	a5,18bb4 <_vfiprintf_r+0x4e8>
   191e8:	03c10613          	addi	a2,sp,60
   191ec:	000d0593          	mv	a1,s10
   191f0:	000a8513          	mv	a0,s5
   191f4:	bd8ff0ef          	jal	185cc <__sprint_r.part.0>
   191f8:	9a050ee3          	beqz	a0,18bb4 <_vfiprintf_r+0x4e8>
   191fc:	eb1ff06f          	j	190ac <_vfiprintf_r+0x9e0>
   19200:	03c10613          	addi	a2,sp,60
   19204:	000d0593          	mv	a1,s10
   19208:	000a8513          	mv	a0,s5
   1920c:	00712023          	sw	t2,0(sp)
   19210:	01012223          	sw	a6,4(sp)
   19214:	bb8ff0ef          	jal	185cc <__sprint_r.part.0>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   19218:	00012383          	lw	t2,0(sp)
   1921c:	00412803          	lw	a6,4(sp)
   19220:	e80516e3          	bnez	a0,190ac <_vfiprintf_r+0x9e0>
   19224:	04012603          	lw	a2,64(sp)
   19228:	04412783          	lw	a5,68(sp)
   1922c:	000c8693          	mv	a3,s9
   19230:	00160513          	addi	a0,a2,1
   19234:	8bdff06f          	j	18af0 <_vfiprintf_r+0x424>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   19238:	2a079e63          	bnez	a5,194f4 <_vfiprintf_r+0xe28>
		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
   1923c:	03714683          	lbu	a3,55(sp)
   19240:	02068663          	beqz	a3,1926c <_vfiprintf_r+0xba0>
			PRINT (&sign, 1);
   19244:	00100793          	li	a5,1
   19248:	03710693          	addi	a3,sp,55
   1924c:	06d12823          	sw	a3,112(sp)
   19250:	00078593          	mv	a1,a5
   19254:	06f12a23          	sw	a5,116(sp)
   19258:	000c8693          	mv	a3,s9
   1925c:	00058613          	mv	a2,a1
   19260:	00868693          	addi	a3,a3,8
   19264:	00158593          	addi	a1,a1,1
   19268:	815ff06f          	j	18a7c <_vfiprintf_r+0x3b0>
		if (flags & HEXPREFIX)
   1926c:	2c0e0863          	beqz	t3,1953c <_vfiprintf_r+0xe70>
			PRINT (ox, 2);
   19270:	03810693          	addi	a3,sp,56
   19274:	00200793          	li	a5,2
   19278:	06d12823          	sw	a3,112(sp)
   1927c:	06f12a23          	sw	a5,116(sp)
   19280:	00100593          	li	a1,1
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   19284:	000c8693          	mv	a3,s9

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
			PRINT (ox, 2);
   19288:	00058613          	mv	a2,a1
   1928c:	00868693          	addi	a3,a3,8
   19290:	00158593          	addi	a1,a1,1
   19294:	d31ff06f          	j	18fc4 <_vfiprintf_r+0x8f8>
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   19298:	01012883          	lw	a7,16(sp)
   1929c:	0008a783          	lw	a5,0(a7)
   192a0:	00488613          	addi	a2,a7,4

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   192a4:	02010ba3          	sb	zero,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   192a8:	aa0752e3          	bgez	a4,18d4c <_vfiprintf_r+0x680>
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   192ac:	00c12823          	sw	a2,16(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   192b0:	00000593          	li	a1,0
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   192b4:	980794e3          	bnez	a5,18c3c <_vfiprintf_r+0x570>
   192b8:	00100793          	li	a5,1
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   192bc:	00100613          	li	a2,1
   192c0:	aac780e3          	beq	a5,a2,18d60 <_vfiprintf_r+0x694>
   192c4:	00200613          	li	a2,2
   192c8:	0cc78663          	beq	a5,a2,19394 <_vfiprintf_r+0xcc8>
   192cc:	00000793          	li	a5,0
   192d0:	9e1ff06f          	j	18cb0 <_vfiprintf_r+0x5e4>
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   192d4:	01012783          	lw	a5,16(sp)
   192d8:	00478613          	addi	a2,a5,4
   192dc:	0007a783          	lw	a5,0(a5)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   192e0:	02010ba3          	sb	zero,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   192e4:	9a075ae3          	bgez	a4,18c98 <_vfiprintf_r+0x5cc>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   192e8:	00c12823          	sw	a2,16(sp)
   192ec:	00000593          	li	a1,0
   192f0:	fc0786e3          	beqz	a5,192bc <_vfiprintf_r+0xbf0>
   192f4:	00000593          	li	a1,0
   192f8:	9b9ff06f          	j	18cb0 <_vfiprintf_r+0x5e4>

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   192fc:	02010ba3          	sb	zero,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   19300:	16074263          	bltz	a4,19464 <_vfiprintf_r+0xd98>
				flags &= ~ZEROPAD;
   19304:	f7fbfb93          	andi	s7,s7,-129
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   19308:	e6078a63          	beqz	a5,1897c <_vfiprintf_r+0x2b0>
   1930c:	00000593          	li	a1,0
   19310:	01c12503          	lw	a0,28(sp)
   19314:	000c8413          	mv	s0,s9
					} while (_uquad != 0);
					break;

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   19318:	00f7f613          	andi	a2,a5,15
   1931c:	00c50633          	add	a2,a0,a2
   19320:	00064603          	lbu	a2,0(a2)
   19324:	fff40413          	addi	s0,s0,-1
						_uquad >>= 4;
   19328:	0047d793          	srli	a5,a5,0x4
					} while (_uquad != 0);
					break;

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   1932c:	00c40023          	sb	a2,0(s0)
						_uquad >>= 4;
					} while (_uquad);
   19330:	fe0794e3          	bnez	a5,19318 <_vfiprintf_r+0xc4c>
   19334:	408c8a33          	sub	s4,s9,s0
   19338:	e58ff06f          	j	18990 <_vfiprintf_r+0x2c4>
   1933c:	03c10613          	addi	a2,sp,60
   19340:	000d0593          	mv	a1,s10
   19344:	000a8513          	mv	a0,s5
   19348:	a84ff0ef          	jal	185cc <__sprint_r.part.0>
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   1934c:	d60510e3          	bnez	a0,190ac <_vfiprintf_r+0x9e0>
   19350:	04412783          	lw	a5,68(sp)
   19354:	000c8693          	mv	a3,s9
   19358:	d8dff06f          	j	190e4 <_vfiprintf_r+0xa18>
		case 'D':  /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   1935c:	040bf793          	andi	a5,s7,64
   19360:	01012883          	lw	a7,16(sp)
   19364:	18078063          	beqz	a5,194e4 <_vfiprintf_r+0xe18>
   19368:	00089783          	lh	a5,0(a7)
   1936c:	00488893          	addi	a7,a7,4
   19370:	01112823          	sw	a7,16(sp)
   19374:	8b5ff06f          	j	18c28 <_vfiprintf_r+0x55c>
   19378:	03c10613          	addi	a2,sp,60
   1937c:	000d0593          	mv	a1,s10
   19380:	000a8513          	mv	a0,s5
   19384:	a48ff0ef          	jal	185cc <__sprint_r.part.0>
#else
                while (*fmt != '\0' && *fmt != '%')
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
			PRINT (cp, m);
   19388:	d20512e3          	bnez	a0,190ac <_vfiprintf_r+0x9e0>
   1938c:	000c8693          	mv	a3,s9
   19390:	c84ff06f          	j	18814 <_vfiprintf_r+0x148>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   19394:	00000793          	li	a5,0
   19398:	f79ff06f          	j	19310 <_vfiprintf_r+0xc44>
   1939c:	03c10613          	addi	a2,sp,60
   193a0:	000d0593          	mv	a1,s10
   193a4:	000a8513          	mv	a0,s5
   193a8:	00712023          	sw	t2,0(sp)
   193ac:	00e12223          	sw	a4,4(sp)
   193b0:	01c12423          	sw	t3,8(sp)
   193b4:	a18ff0ef          	jal	185cc <__sprint_r.part.0>
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
   193b8:	00012383          	lw	t2,0(sp)
   193bc:	00412703          	lw	a4,4(sp)
   193c0:	00812e03          	lw	t3,8(sp)
   193c4:	ce0514e3          	bnez	a0,190ac <_vfiprintf_r+0x9e0>
   193c8:	04012603          	lw	a2,64(sp)
   193cc:	04412783          	lw	a5,68(sp)
   193d0:	000c8693          	mv	a3,s9
   193d4:	00160593          	addi	a1,a2,1
   193d8:	ea4ff06f          	j	18a7c <_vfiprintf_r+0x3b0>
   193dc:	03c10613          	addi	a2,sp,60
   193e0:	000d0593          	mv	a1,s10
   193e4:	000a8513          	mv	a0,s5
   193e8:	00712023          	sw	t2,0(sp)
   193ec:	00e12223          	sw	a4,4(sp)
   193f0:	9dcff0ef          	jal	185cc <__sprint_r.part.0>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);
   193f4:	00012383          	lw	t2,0(sp)
   193f8:	00412703          	lw	a4,4(sp)
   193fc:	ca0518e3          	bnez	a0,190ac <_vfiprintf_r+0x9e0>
   19400:	04012603          	lw	a2,64(sp)
   19404:	04412783          	lw	a5,68(sp)
   19408:	000c8693          	mv	a3,s9
   1940c:	00160593          	addi	a1,a2,1
   19410:	bb5ff06f          	j	18fc4 <_vfiprintf_r+0x8f8>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   19414:	16079263          	bnez	a5,19578 <_vfiprintf_r+0xeac>
		uio->uio_iovcnt = 0;
   19418:	00100593          	li	a1,1
   1941c:	00000613          	li	a2,0
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   19420:	000c8693          	mv	a3,s9
   19424:	ba9ff06f          	j	18fcc <_vfiprintf_r+0x900>
   19428:	03c10613          	addi	a2,sp,60
   1942c:	000d0593          	mv	a1,s10
   19430:	000a8513          	mv	a0,s5
   19434:	998ff0ef          	jal	185cc <__sprint_r.part.0>

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   19438:	c6051ae3          	bnez	a0,190ac <_vfiprintf_r+0x9e0>
   1943c:	04012583          	lw	a1,64(sp)
   19440:	04412783          	lw	a5,68(sp)
   19444:	000c8693          	mv	a3,s9
   19448:	00158593          	addi	a1,a1,1
   1944c:	f20ff06f          	j	18b6c <_vfiprintf_r+0x4a0>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   19450:	00c12823          	sw	a2,16(sp)
			base = HEX;
			xdigs = "0123456789abcdef";
   19454:	0001c637          	lui	a2,0x1c
   19458:	14860613          	addi	a2,a2,328 # 1c148 <__thenan_sf+0x38>
			flags |= HEXPREFIX;
   1945c:	00050b93          	mv	s7,a0
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   19460:	00c12e23          	sw	a2,28(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   19464:	ea0794e3          	bnez	a5,1930c <_vfiprintf_r+0xc40>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   19468:	00000593          	li	a1,0
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
   1946c:	00200793          	li	a5,2
   19470:	e4dff06f          	j	192bc <_vfiprintf_r+0xbf0>
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   19474:	000d8913          	mv	s2,s11
   19478:	ba8ff06f          	j	18820 <_vfiprintf_r+0x154>
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   1947c:	0001c637          	lui	a2,0x1c
   19480:	14860613          	addi	a2,a2,328 # 1c148 <__thenan_sf+0x38>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   19484:	00000593          	li	a1,0
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   19488:	00c12e23          	sw	a2,28(sp)
   1948c:	e85ff06f          	j	19310 <_vfiprintf_r+0xc44>
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
				ox[0] = '0';
   19490:	03000593          	li	a1,48
				ox[1] = ch;
   19494:	02c10ca3          	sb	a2,57(sp)
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
				ox[0] = '0';
   19498:	02b10c23          	sb	a1,56(sp)
				ox[1] = ch;
				flags |= HEXPREFIX;
   1949c:	002be613          	ori	a2,s7,2

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   194a0:	02010ba3          	sb	zero,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   194a4:	10074a63          	bltz	a4,195b8 <_vfiprintf_r+0xeec>
   194a8:	f7fbf293          	andi	t0,s7,-129
				flags &= ~ZEROPAD;
   194ac:	0022eb93          	ori	s7,t0,2
   194b0:	00000593          	li	a1,0
   194b4:	e5dff06f          	j	19310 <_vfiprintf_r+0xc44>
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
				sign = '-';
   194b8:	02d00613          	li	a2,45
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
   194bc:	40f007b3          	neg	a5,a5
				sign = '-';
   194c0:	02c10ba3          	sb	a2,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   194c4:	10074a63          	bltz	a4,195d8 <_vfiprintf_r+0xf0c>
				flags &= ~ZEROPAD;
   194c8:	f7fbfb93          	andi	s7,s7,-129
   194cc:	02d00593          	li	a1,45
   194d0:	f6cff06f          	j	18c3c <_vfiprintf_r+0x570>
		case 'X':
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
   194d4:	0008a783          	lw	a5,0(a7)
   194d8:	00488893          	addi	a7,a7,4
   194dc:	01112823          	sw	a7,16(sp)
   194e0:	975ff06f          	j	18e54 <_vfiprintf_r+0x788>
		case 'D':  /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   194e4:	0008a783          	lw	a5,0(a7)
   194e8:	00488893          	addi	a7,a7,4
   194ec:	01112823          	sw	a7,16(sp)
   194f0:	f38ff06f          	j	18c28 <_vfiprintf_r+0x55c>
   194f4:	03c10613          	addi	a2,sp,60
   194f8:	000d0593          	mv	a1,s10
   194fc:	000a8513          	mv	a0,s5
   19500:	00712023          	sw	t2,0(sp)
   19504:	00e12223          	sw	a4,4(sp)
   19508:	01c12423          	sw	t3,8(sp)
   1950c:	8c0ff0ef          	jal	185cc <__sprint_r.part.0>
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   19510:	00012383          	lw	t2,0(sp)
   19514:	00412703          	lw	a4,4(sp)
   19518:	00812e03          	lw	t3,8(sp)
   1951c:	b80518e3          	bnez	a0,190ac <_vfiprintf_r+0x9e0>
   19520:	04012603          	lw	a2,64(sp)
   19524:	04412783          	lw	a5,68(sp)
   19528:	000c8693          	mv	a3,s9
   1952c:	00160593          	addi	a1,a2,1
   19530:	a55ff06f          	j	18f84 <_vfiprintf_r+0x8b8>
	ORIENT(fp, -1);

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
		_newlib_flockfile_exit (fp);
		return (EOF);
   19534:	fff00513          	li	a0,-1
   19538:	b98ff06f          	j	188d0 <_vfiprintf_r+0x204>
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
   1953c:	00000613          	li	a2,0
   19540:	00100593          	li	a1,1
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   19544:	000c8693          	mv	a3,s9
   19548:	a7dff06f          	j	18fc4 <_vfiprintf_r+0x8f8>
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   1954c:	000c8693          	mv	a3,s9
   19550:	ba5ff06f          	j	190f4 <_vfiprintf_r+0xa28>
				if (p != NULL)
					size = p - cp;
				else
					size = prec;
			} else
				size = strlen (cp);
   19554:	00040513          	mv	a0,s0
   19558:	00d12423          	sw	a3,8(sp)
   1955c:	9e8f80ef          	jal	11744 <strlen>
   19560:	00050a13          	mv	s4,a0
   19564:	03714583          	lbu	a1,55(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   19568:	00912823          	sw	s1,16(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   1956c:	00000713          	li	a4,0
   19570:	00812683          	lw	a3,8(sp)
   19574:	c1cff06f          	j	18990 <_vfiprintf_r+0x2c4>
   19578:	03c10613          	addi	a2,sp,60
   1957c:	000d0593          	mv	a1,s10
   19580:	000a8513          	mv	a0,s5
   19584:	00e12223          	sw	a4,4(sp)
   19588:	844ff0ef          	jal	185cc <__sprint_r.part.0>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   1958c:	00412703          	lw	a4,4(sp)
   19590:	b0051ee3          	bnez	a0,190ac <_vfiprintf_r+0x9e0>
   19594:	04012603          	lw	a2,64(sp)
   19598:	04412783          	lw	a5,68(sp)
   1959c:	000c8693          	mv	a3,s9
   195a0:	00160593          	addi	a1,a2,1
   195a4:	a29ff06f          	j	18fcc <_vfiprintf_r+0x900>
   195a8:	04012603          	lw	a2,64(sp)
   195ac:	01612c23          	sw	s6,24(sp)
   195b0:	00160613          	addi	a2,a2,1
   195b4:	c98ff06f          	j	18a4c <_vfiprintf_r+0x380>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   195b8:	00000593          	li	a1,0
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
   195bc:	00200513          	li	a0,2
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   195c0:	00100813          	li	a6,1
   195c4:	09050063          	beq	a0,a6,19644 <_vfiprintf_r+0xf78>
   195c8:	00200813          	li	a6,2
   195cc:	09051063          	bne	a0,a6,1964c <_vfiprintf_r+0xf80>
   195d0:	00060b93          	mv	s7,a2
   195d4:	d3dff06f          	j	19310 <_vfiprintf_r+0xc44>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   195d8:	000b8613          	mv	a2,s7
   195dc:	02d00593          	li	a1,45
			{

				_uquad = -_uquad;
				sign = '-';
			}
			base = DEC;
   195e0:	00100513          	li	a0,1
   195e4:	fddff06f          	j	195c0 <_vfiprintf_r+0xef4>
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
				size = ((unsigned) prec > 6U) ? 6 : prec;
   195e8:	00600793          	li	a5,6
   195ec:	00e7f463          	bleu	a4,a5,195f4 <_vfiprintf_r+0xf28>
   195f0:	00078713          	mv	a4,a5
   195f4:	00070a13          	mv	s4,a4
   195f8:	00070993          	mv	s3,a4
   195fc:	04074c63          	bltz	a4,19654 <_vfiprintf_r+0xf88>
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
   19600:	0001c337          	lui	t1,0x1c
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   19604:	00912823          	sw	s1,16(sp)
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
   19608:	15c30413          	addi	s0,t1,348 # 1c15c <__thenan_sf+0x4c>
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   1960c:	00000713          	li	a4,0
   19610:	b94ff06f          	j	189a4 <_vfiprintf_r+0x2d8>
   19614:	04012583          	lw	a1,64(sp)
   19618:	01612c23          	sw	s6,24(sp)
   1961c:	00158593          	addi	a1,a1,1
   19620:	b35ff06f          	j	19154 <_vfiprintf_r+0xa88>
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);

				if (p != NULL)
   19624:	00070a13          	mv	s4,a4
   19628:	03714583          	lbu	a1,55(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   1962c:	00912823          	sw	s1,16(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   19630:	00000713          	li	a4,0
   19634:	b5cff06f          	j	18990 <_vfiprintf_r+0x2c4>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   19638:	00058513          	mv	a0,a1
   1963c:	01812c23          	sw	s8,24(sp)
   19640:	cf8ff06f          	j	18b38 <_vfiprintf_r+0x46c>
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   19644:	00060b93          	mv	s7,a2
   19648:	df4ff06f          	j	18c3c <_vfiprintf_r+0x570>
   1964c:	00060b93          	mv	s7,a2
   19650:	e60ff06f          	j	18cb0 <_vfiprintf_r+0x5e4>
   19654:	00000993          	li	s3,0
   19658:	fa9ff06f          	j	19600 <_vfiprintf_r+0xf34>
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
   1965c:	01012883          	lw	a7,16(sp)
   19660:	0008a703          	lw	a4,0(a7)
   19664:	00488793          	addi	a5,a7,4
   19668:	00f12823          	sw	a5,16(sp)
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
   1966c:	a2075063          	bgez	a4,1888c <_vfiprintf_r+0x1c0>
					prec = -1;
   19670:	fff00713          	li	a4,-1
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   19674:	000d8493          	mv	s1,s11
   19678:	9d8ff06f          	j	18850 <_vfiprintf_r+0x184>
   1967c:	02610ba3          	sb	t1,55(sp)
   19680:	80dff06f          	j	18e8c <_vfiprintf_r+0x7c0>
   19684:	02610ba3          	sb	t1,55(sp)
   19688:	e6cff06f          	j	18cf4 <_vfiprintf_r+0x628>
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   1968c:	001bf793          	andi	a5,s7,1
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   19690:	00070593          	mv	a1,a4
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   19694:	00078c63          	beqz	a5,196ac <_vfiprintf_r+0xfe0>
                         *--cp = '0';
   19698:	03000793          	li	a5,48
   1969c:	06f107a3          	sb	a5,111(sp)
   196a0:	02412a03          	lw	s4,36(sp)
   196a4:	06f10413          	addi	s0,sp,111
   196a8:	ae8ff06f          	j	18990 <_vfiprintf_r+0x2c4>
   196ac:	00000a13          	li	s4,0
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   196b0:	000c8413          	mv	s0,s9
   196b4:	adcff06f          	j	18990 <_vfiprintf_r+0x2c4>
   196b8:	02610ba3          	sb	t1,55(sp)
   196bc:	e68ff06f          	j	18d24 <_vfiprintf_r+0x658>
   196c0:	02610ba3          	sb	t1,55(sp)
   196c4:	841ff06f          	j	18f04 <_vfiprintf_r+0x838>
   196c8:	02610ba3          	sb	t1,55(sp)
   196cc:	da4ff06f          	j	18c70 <_vfiprintf_r+0x5a4>
   196d0:	02610ba3          	sb	t1,55(sp)
   196d4:	d38ff06f          	j	18c0c <_vfiprintf_r+0x540>
   196d8:	02610ba3          	sb	t1,55(sp)
   196dc:	f54ff06f          	j	18e30 <_vfiprintf_r+0x764>

000196e0 <vfiprintf>:
       FILE * fp         _AND
       _CONST char *fmt0 _AND
       va_list ap)
{
  int result;
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
   196e0:	00060693          	mv	a3,a2
   196e4:	00058613          	mv	a2,a1
   196e8:	00050593          	mv	a1,a0
   196ec:	8101a503          	lw	a0,-2032(gp) # 1de50 <_impure_ptr>
   196f0:	fddfe06f          	j	186cc <_vfiprintf_r>

000196f4 <__sbprintf>:
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   196f4:	00c5d783          	lhu	a5,12(a1)
	fake._flags2 = fp->_flags2;
   196f8:	0685a303          	lw	t1,104(a1)
	fake._file = fp->_file;
   196fc:	00e5d283          	lhu	t0,14(a1)
	fake._cookie = fp->_cookie;
   19700:	01c5a883          	lw	a7,28(a1)
	fake._write = fp->_write;
   19704:	0245a803          	lw	a6,36(a1)
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   19708:	b8010113          	addi	sp,sp,-1152
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   1970c:	ffd7f793          	andi	a5,a5,-3
	fake._cookie = fp->_cookie;
	fake._write = fp->_write;

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
	fake._bf._size = fake._w = sizeof (buf);
   19710:	40000713          	li	a4,1024
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   19714:	46812c23          	sw	s0,1144(sp)
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   19718:	00f11623          	sh	a5,12(sp)
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   1971c:	00058413          	mv	s0,a1
	fake._file = fp->_file;
	fake._cookie = fp->_cookie;
	fake._write = fp->_write;

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
   19720:	07010793          	addi	a5,sp,112
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   19724:	00010593          	mv	a1,sp
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   19728:	46912a23          	sw	s1,1140(sp)
   1972c:	47212823          	sw	s2,1136(sp)
   19730:	46112e23          	sw	ra,1148(sp)
   19734:	00050913          	mv	s2,a0
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
	fake._flags2 = fp->_flags2;
   19738:	06612423          	sw	t1,104(sp)
	fake._file = fp->_file;
   1973c:	00511723          	sh	t0,14(sp)
	fake._cookie = fp->_cookie;
   19740:	01112e23          	sw	a7,28(sp)
	fake._write = fp->_write;
   19744:	03012223          	sw	a6,36(sp)

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
   19748:	00f12023          	sw	a5,0(sp)
   1974c:	00f12823          	sw	a5,16(sp)
	fake._bf._size = fake._w = sizeof (buf);
   19750:	00e12423          	sw	a4,8(sp)
   19754:	00e12a23          	sw	a4,20(sp)
	fake._lbfsize = 0;	/* not actually used, but Just In Case */
   19758:	00012c23          	sw	zero,24(sp)
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   1975c:	f71fe0ef          	jal	186cc <_vfiprintf_r>
   19760:	00050493          	mv	s1,a0
	if (ret >= 0 && _fflush_r (rptr, &fake))
   19764:	00054a63          	bltz	a0,19778 <__sbprintf+0x84>
   19768:	00010593          	mv	a1,sp
   1976c:	00090513          	mv	a0,s2
   19770:	a3dfb0ef          	jal	151ac <_fflush_r>
   19774:	02051c63          	bnez	a0,197ac <__sbprintf+0xb8>
		ret = EOF;
	if (fake._flags & __SERR)
   19778:	00c15783          	lhu	a5,12(sp)
   1977c:	0407f793          	andi	a5,a5,64
   19780:	00078863          	beqz	a5,19790 <__sbprintf+0x9c>
		fp->_flags |= __SERR;
   19784:	00c45783          	lhu	a5,12(s0)
   19788:	0407e793          	ori	a5,a5,64
   1978c:	00f41623          	sh	a5,12(s0)

#ifndef __SINGLE_THREAD__
	__lock_close_recursive (fake._lock);
#endif
	return (ret);
}
   19790:	47c12083          	lw	ra,1148(sp)
   19794:	00048513          	mv	a0,s1
   19798:	47812403          	lw	s0,1144(sp)
   1979c:	47412483          	lw	s1,1140(sp)
   197a0:	47012903          	lw	s2,1136(sp)
   197a4:	48010113          	addi	sp,sp,1152
   197a8:	00008067          	ret
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
	if (ret >= 0 && _fflush_r (rptr, &fake))
		ret = EOF;
   197ac:	fff00493          	li	s1,-1
   197b0:	fc9ff06f          	j	19778 <__sbprintf+0x84>

000197b4 <_calloc_r>:
  MALLOC_LOCK;
  oldtop = top;
  oldtopsize = chunksize(top);
#endif

  mem = mALLOc (RCALL sz);
   197b4:	02c585b3          	mul	a1,a1,a2
#if __STD_C
Void_t* cALLOc(RARG size_t n, size_t elem_size)
#else
Void_t* cALLOc(RARG n, elem_size) RDECL size_t n; size_t elem_size;
#endif
{
   197b8:	ff010113          	addi	sp,sp,-16
   197bc:	00112623          	sw	ra,12(sp)
   197c0:	00812423          	sw	s0,8(sp)
  MALLOC_LOCK;
  oldtop = top;
  oldtopsize = chunksize(top);
#endif

  mem = mALLOc (RCALL sz);
   197c4:	a15fc0ef          	jal	161d8 <_malloc_r>

  if (mem == 0) 
   197c8:	08050c63          	beqz	a0,19860 <_calloc_r+0xac>
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
   197cc:	ffc52603          	lw	a2,-4(a0)
   197d0:	02400713          	li	a4,36
   197d4:	00050413          	mv	s0,a0
   197d8:	ffc67613          	andi	a2,a2,-4
   197dc:	ffc60613          	addi	a2,a2,-4
   197e0:	04c76e63          	bltu	a4,a2,1983c <_calloc_r+0x88>
   197e4:	01300693          	li	a3,19
   197e8:	00050793          	mv	a5,a0
   197ec:	02c6f863          	bleu	a2,a3,1981c <_calloc_r+0x68>
   197f0:	01b00793          	li	a5,27
   197f4:	00052023          	sw	zero,0(a0)
   197f8:	00052223          	sw	zero,4(a0)
   197fc:	04c7fe63          	bleu	a2,a5,19858 <_calloc_r+0xa4>
   19800:	00052423          	sw	zero,8(a0)
   19804:	00052623          	sw	zero,12(a0)
   19808:	01050793          	addi	a5,a0,16
   1980c:	00e61863          	bne	a2,a4,1981c <_calloc_r+0x68>
   19810:	00052823          	sw	zero,16(a0)
   19814:	01850793          	addi	a5,a0,24
   19818:	00052a23          	sw	zero,20(a0)
   1981c:	0007a023          	sw	zero,0(a5)
   19820:	0007a223          	sw	zero,4(a5)
   19824:	0007a423          	sw	zero,8(a5)
   19828:	00040513          	mv	a0,s0
    return mem;
  }
}
   1982c:	00c12083          	lw	ra,12(sp)
   19830:	00812403          	lw	s0,8(sp)
   19834:	01010113          	addi	sp,sp,16
   19838:	00008067          	ret
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
   1983c:	00000593          	li	a1,0
   19840:	c24fd0ef          	jal	16c64 <memset>
    return mem;
  }
}
   19844:	00c12083          	lw	ra,12(sp)
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
   19848:	00040513          	mv	a0,s0
    return mem;
  }
}
   1984c:	00812403          	lw	s0,8(sp)
   19850:	01010113          	addi	sp,sp,16
   19854:	00008067          	ret
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
   19858:	00850793          	addi	a5,a0,8
   1985c:	fc1ff06f          	j	1981c <_calloc_r+0x68>
  if (mem == 0) 
  {
#if MORECORE_CLEARS
    MALLOC_UNLOCK;
#endif
    return 0;
   19860:	00000513          	li	a0,0
   19864:	fc9ff06f          	j	1982c <_calloc_r+0x78>

00019868 <_fclose_r>:
      struct _reent *rptr _AND
      register FILE * fp)
{
  int r;

  if (fp == NULL)
   19868:	0e058463          	beqz	a1,19950 <_fclose_r+0xe8>

int
_DEFUN(_fclose_r, (rptr, fp),
      struct _reent *rptr _AND
      register FILE * fp)
{
   1986c:	ff010113          	addi	sp,sp,-16
   19870:	00812423          	sw	s0,8(sp)
   19874:	00912223          	sw	s1,4(sp)
   19878:	00112623          	sw	ra,12(sp)
   1987c:	01212023          	sw	s2,0(sp)
   19880:	00050493          	mv	s1,a0
   19884:	00058413          	mv	s0,a1
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */

  CHECK_INIT (rptr, fp);
   19888:	00050663          	beqz	a0,19894 <_fclose_r+0x2c>
   1988c:	03852783          	lw	a5,56(a0)
   19890:	0a078063          	beqz	a5,19930 <_fclose_r+0xc8>
  int __oldcancel;
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  _flockfile (fp);

  if (fp->_flags == 0)		/* not open! */
   19894:	00c41783          	lh	a5,12(s0)
      register FILE * fp)
{
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */
   19898:	00000513          	li	a0,0
  int __oldcancel;
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  _flockfile (fp);

  if (fp->_flags == 0)		/* not open! */
   1989c:	00079e63          	bnez	a5,198b8 <_fclose_r+0x50>
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
}
   198a0:	00c12083          	lw	ra,12(sp)
   198a4:	00812403          	lw	s0,8(sp)
   198a8:	00412483          	lw	s1,4(sp)
   198ac:	00012903          	lw	s2,0(sp)
   198b0:	01010113          	addi	sp,sp,16
   198b4:	00008067          	ret
  r = (fp->_flags & __SWR) ? __sflush_r (rptr, fp) : 0;
#else
  /* Follow POSIX semantics exactly.  Unconditionally flush to allow
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
   198b8:	00040593          	mv	a1,s0
   198bc:	00048513          	mv	a0,s1
   198c0:	e5cfb0ef          	jal	14f1c <__sflush_r>
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
   198c4:	02c42783          	lw	a5,44(s0)
  r = (fp->_flags & __SWR) ? __sflush_r (rptr, fp) : 0;
#else
  /* Follow POSIX semantics exactly.  Unconditionally flush to allow
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
   198c8:	00050913          	mv	s2,a0
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
   198cc:	00078a63          	beqz	a5,198e0 <_fclose_r+0x78>
   198d0:	01c42583          	lw	a1,28(s0)
   198d4:	00048513          	mv	a0,s1
   198d8:	000780e7          	jalr	a5
   198dc:	04054e63          	bltz	a0,19938 <_fclose_r+0xd0>
    r = EOF;
  if (fp->_flags & __SMBF)
   198e0:	00c45783          	lhu	a5,12(s0)
   198e4:	0807f793          	andi	a5,a5,128
   198e8:	04079c63          	bnez	a5,19940 <_fclose_r+0xd8>
    _free_r (rptr, (char *) fp->_bf._base);
  if (HASUB (fp))
   198ec:	03042583          	lw	a1,48(s0)
   198f0:	00058c63          	beqz	a1,19908 <_fclose_r+0xa0>
    FREEUB (rptr, fp);
   198f4:	04040793          	addi	a5,s0,64
   198f8:	00f58663          	beq	a1,a5,19904 <_fclose_r+0x9c>
   198fc:	00048513          	mv	a0,s1
   19900:	d9dfb0ef          	jal	1569c <_free_r>
   19904:	02042823          	sw	zero,48(s0)
  if (HASLB (fp))
   19908:	04442583          	lw	a1,68(s0)
   1990c:	00058863          	beqz	a1,1991c <_fclose_r+0xb4>
    FREELB (rptr, fp);
   19910:	00048513          	mv	a0,s1
   19914:	d89fb0ef          	jal	1569c <_free_r>
   19918:	04042223          	sw	zero,68(s0)
  __sfp_lock_acquire ();
   1991c:	c51fb0ef          	jal	1556c <__sfp_lock_acquire>
  fp->_flags = 0;		/* release this FILE for reuse */
   19920:	00041623          	sh	zero,12(s0)
  _funlockfile (fp);
#ifndef __SINGLE_THREAD__
  __lock_close_recursive (fp->_lock);
#endif

  __sfp_lock_release ();
   19924:	c4dfb0ef          	jal	15570 <__sfp_lock_release>
   19928:	00090513          	mv	a0,s2
   1992c:	f75ff06f          	j	198a0 <_fclose_r+0x38>
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */

  CHECK_INIT (rptr, fp);
   19930:	c2dfb0ef          	jal	1555c <__sinit>
   19934:	f61ff06f          	j	19894 <_fclose_r+0x2c>
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
    r = EOF;
   19938:	fff00913          	li	s2,-1
   1993c:	fa5ff06f          	j	198e0 <_fclose_r+0x78>
  if (fp->_flags & __SMBF)
    _free_r (rptr, (char *) fp->_bf._base);
   19940:	01042583          	lw	a1,16(s0)
   19944:	00048513          	mv	a0,s1
   19948:	d55fb0ef          	jal	1569c <_free_r>
   1994c:	fa1ff06f          	j	198ec <_fclose_r+0x84>
      register FILE * fp)
{
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */
   19950:	00000513          	li	a0,0
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
}
   19954:	00008067          	ret

00019958 <fclose>:

int
_DEFUN(fclose, (fp),
       register FILE * fp)
{
  return _fclose_r(_REENT, fp);
   19958:	00050593          	mv	a1,a0
   1995c:	8101a503          	lw	a0,-2032(gp) # 1de50 <_impure_ptr>
   19960:	f09ff06f          	j	19868 <_fclose_r>

00019964 <__fputwc>:
wint_t
_DEFUN(__fputwc, (ptr, wc, fp),
	struct _reent *ptr _AND
	wchar_t wc _AND
	FILE *fp)
{
   19964:	fd010113          	addi	sp,sp,-48
   19968:	02812423          	sw	s0,40(sp)
   1996c:	01412c23          	sw	s4,24(sp)
   19970:	01512a23          	sw	s5,20(sp)
   19974:	02112623          	sw	ra,44(sp)
   19978:	02912223          	sw	s1,36(sp)
   1997c:	03212023          	sw	s2,32(sp)
   19980:	01312e23          	sw	s3,28(sp)
   19984:	01612823          	sw	s6,16(sp)
   19988:	00050a93          	mv	s5,a0
   1998c:	00058a13          	mv	s4,a1
   19990:	00060413          	mv	s0,a2
  char buf[MB_LEN_MAX];
  size_t i, len;

  if (MB_CUR_MAX == 1 && wc > 0 && wc <= UCHAR_MAX)
   19994:	e70fc0ef          	jal	16004 <__locale_mb_cur_max>
   19998:	00100793          	li	a5,1
   1999c:	10f50063          	beq	a0,a5,19a9c <__fputwc+0x138>
      *buf = (unsigned char)wc;
      len = 1;
    }
  else
    {
      if ((len = _wcrtomb_r (ptr, buf, wc, &fp->_mbstate)) == (size_t) -1)
   199a0:	00c10493          	addi	s1,sp,12
   199a4:	06040693          	addi	a3,s0,96
   199a8:	000a0613          	mv	a2,s4
   199ac:	00048593          	mv	a1,s1
   199b0:	000a8513          	mv	a0,s5
   199b4:	324000ef          	jal	19cd8 <_wcrtomb_r>
   199b8:	fff00793          	li	a5,-1
   199bc:	00050993          	mv	s3,a0
   199c0:	08f50863          	beq	a0,a5,19a50 <__fputwc+0xec>
	  fp->_flags |= __SERR;
	  return WEOF;
	}
    }

  for (i = 0; i < len; i++)
   199c4:	0e050c63          	beqz	a0,19abc <__fputwc+0x158>
   199c8:	00c14583          	lbu	a1,12(sp)
       * Assume single-byte locale with no special encoding.
       * A more careful test would be to check
       * _CurrentRuneLocale->encoding.
       */
      *buf = (unsigned char)wc;
      len = 1;
   199cc:	00000913          	li	s2,0
	  return WEOF;
	}
    }

  for (i = 0; i < len; i++)
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
   199d0:	00a00b13          	li	s6,10
   199d4:	0280006f          	j	199fc <__fputwc+0x98>
   199d8:	00042783          	lw	a5,0(s0)
   199dc:	00b78023          	sb	a1,0(a5)
   199e0:	00042783          	lw	a5,0(s0)
   199e4:	00178793          	addi	a5,a5,1
   199e8:	00f42023          	sw	a5,0(s0)
	  fp->_flags |= __SERR;
	  return WEOF;
	}
    }

  for (i = 0; i < len; i++)
   199ec:	00190913          	addi	s2,s2,1
   199f0:	00148493          	addi	s1,s1,1
   199f4:	0d397463          	bleu	s3,s2,19abc <__fputwc+0x158>
   199f8:	0004c583          	lbu	a1,0(s1)
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
   199fc:	00842783          	lw	a5,8(s0)
   19a00:	fff78793          	addi	a5,a5,-1
   19a04:	00f42423          	sw	a5,8(s0)
   19a08:	fc07d8e3          	bgez	a5,199d8 <__fputwc+0x74>
   19a0c:	01842703          	lw	a4,24(s0)
   19a10:	06e7ca63          	blt	a5,a4,19a84 <__fputwc+0x120>
   19a14:	00042783          	lw	a5,0(s0)
   19a18:	00b78023          	sb	a1,0(a5)
   19a1c:	00042783          	lw	a5,0(s0)
   19a20:	0007c703          	lbu	a4,0(a5)
   19a24:	00178793          	addi	a5,a5,1
   19a28:	fd6710e3          	bne	a4,s6,199e8 <__fputwc+0x84>
   19a2c:	00040613          	mv	a2,s0
   19a30:	000b0593          	mv	a1,s6
   19a34:	000a8513          	mv	a0,s5
   19a38:	130000ef          	jal	19b68 <__swbuf_r>
   19a3c:	00150513          	addi	a0,a0,1
   19a40:	00153513          	seqz	a0,a0
   19a44:	fa0504e3          	beqz	a0,199ec <__fputwc+0x88>
      return WEOF;
   19a48:	fff00513          	li	a0,-1
   19a4c:	0100006f          	j	19a5c <__fputwc+0xf8>
    }
  else
    {
      if ((len = _wcrtomb_r (ptr, buf, wc, &fp->_mbstate)) == (size_t) -1)
	{
	  fp->_flags |= __SERR;
   19a50:	00c45783          	lhu	a5,12(s0)
   19a54:	0407e793          	ori	a5,a5,64
   19a58:	00f41623          	sh	a5,12(s0)
  for (i = 0; i < len; i++)
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
      return WEOF;

  return (wint_t) wc;
}
   19a5c:	02c12083          	lw	ra,44(sp)
   19a60:	02812403          	lw	s0,40(sp)
   19a64:	02412483          	lw	s1,36(sp)
   19a68:	02012903          	lw	s2,32(sp)
   19a6c:	01c12983          	lw	s3,28(sp)
   19a70:	01812a03          	lw	s4,24(sp)
   19a74:	01412a83          	lw	s5,20(sp)
   19a78:	01012b03          	lw	s6,16(sp)
   19a7c:	03010113          	addi	sp,sp,48
   19a80:	00008067          	ret
	  return WEOF;
	}
    }

  for (i = 0; i < len; i++)
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
   19a84:	00040613          	mv	a2,s0
   19a88:	000a8513          	mv	a0,s5
   19a8c:	0dc000ef          	jal	19b68 <__swbuf_r>
   19a90:	00150513          	addi	a0,a0,1
   19a94:	00153513          	seqz	a0,a0
   19a98:	fadff06f          	j	19a44 <__fputwc+0xe0>
	FILE *fp)
{
  char buf[MB_LEN_MAX];
  size_t i, len;

  if (MB_CUR_MAX == 1 && wc > 0 && wc <= UCHAR_MAX)
   19a9c:	fffa0793          	addi	a5,s4,-1
   19aa0:	0fe00713          	li	a4,254
   19aa4:	eef76ee3          	bltu	a4,a5,199a0 <__fputwc+0x3c>
      /*
       * Assume single-byte locale with no special encoding.
       * A more careful test would be to check
       * _CurrentRuneLocale->encoding.
       */
      *buf = (unsigned char)wc;
   19aa8:	0ffa7593          	andi	a1,s4,255
   19aac:	00b10623          	sb	a1,12(sp)
      len = 1;
   19ab0:	00050993          	mv	s3,a0
   19ab4:	00c10493          	addi	s1,sp,12
   19ab8:	f15ff06f          	j	199cc <__fputwc+0x68>

  for (i = 0; i < len; i++)
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
      return WEOF;

  return (wint_t) wc;
   19abc:	000a0513          	mv	a0,s4
   19ac0:	f9dff06f          	j	19a5c <__fputwc+0xf8>

00019ac4 <_fputwc_r>:
	FILE *fp)
{
  wint_t r;

  _newlib_flockfile_start (fp);
  ORIENT(fp, 1);
   19ac4:	00c61783          	lh	a5,12(a2)
   19ac8:	00002737          	lui	a4,0x2
   19acc:	01279693          	slli	a3,a5,0x12
   19ad0:	0006cc63          	bltz	a3,19ae8 <_fputwc_r+0x24>
	wchar_t wc _AND
	FILE *fp)
{
  wint_t r;

  _newlib_flockfile_start (fp);
   19ad4:	06862683          	lw	a3,104(a2)
  ORIENT(fp, 1);
   19ad8:	00e7e7b3          	or	a5,a5,a4
   19adc:	00f61623          	sh	a5,12(a2)
   19ae0:	00e6e733          	or	a4,a3,a4
   19ae4:	06e62423          	sw	a4,104(a2)
  r = __fputwc(ptr, wc, fp);
   19ae8:	e7dff06f          	j	19964 <__fputwc>

00019aec <fputwc>:

wint_t
_DEFUN(fputwc, (wc, fp),
	wchar_t wc _AND
	FILE *fp)
{
   19aec:	fe010113          	addi	sp,sp,-32
   19af0:	00812c23          	sw	s0,24(sp)
  struct _reent *reent = _REENT;
   19af4:	8101a403          	lw	s0,-2032(gp) # 1de50 <_impure_ptr>

wint_t
_DEFUN(fputwc, (wc, fp),
	wchar_t wc _AND
	FILE *fp)
{
   19af8:	00912a23          	sw	s1,20(sp)
   19afc:	00112e23          	sw	ra,28(sp)
   19b00:	00050493          	mv	s1,a0
   19b04:	00058613          	mv	a2,a1
  struct _reent *reent = _REENT;

  CHECK_INIT(reent, fp);
   19b08:	00040663          	beqz	s0,19b14 <fputwc+0x28>
   19b0c:	03842783          	lw	a5,56(s0)
   19b10:	04078263          	beqz	a5,19b54 <fputwc+0x68>
	FILE *fp)
{
  wint_t r;

  _newlib_flockfile_start (fp);
  ORIENT(fp, 1);
   19b14:	00c61783          	lh	a5,12(a2)
   19b18:	00002737          	lui	a4,0x2
   19b1c:	01279693          	slli	a3,a5,0x12
   19b20:	0006cc63          	bltz	a3,19b38 <fputwc+0x4c>
	wchar_t wc _AND
	FILE *fp)
{
  wint_t r;

  _newlib_flockfile_start (fp);
   19b24:	06862683          	lw	a3,104(a2)
  ORIENT(fp, 1);
   19b28:	00e7e7b3          	or	a5,a5,a4
   19b2c:	00f61623          	sh	a5,12(a2)
   19b30:	00e6e733          	or	a4,a3,a4
   19b34:	06e62423          	sw	a4,104(a2)
  r = __fputwc(ptr, wc, fp);
   19b38:	00048593          	mv	a1,s1
   19b3c:	00040513          	mv	a0,s0
{
  struct _reent *reent = _REENT;

  CHECK_INIT(reent, fp);
  return _fputwc_r (reent, wc, fp);
}
   19b40:	01c12083          	lw	ra,28(sp)
   19b44:	01812403          	lw	s0,24(sp)
   19b48:	01412483          	lw	s1,20(sp)
   19b4c:	02010113          	addi	sp,sp,32
{
  wint_t r;

  _newlib_flockfile_start (fp);
  ORIENT(fp, 1);
  r = __fputwc(ptr, wc, fp);
   19b50:	e15ff06f          	j	19964 <__fputwc>
	wchar_t wc _AND
	FILE *fp)
{
  struct _reent *reent = _REENT;

  CHECK_INIT(reent, fp);
   19b54:	00040513          	mv	a0,s0
   19b58:	00b12623          	sw	a1,12(sp)
   19b5c:	a01fb0ef          	jal	1555c <__sinit>
   19b60:	00c12603          	lw	a2,12(sp)
   19b64:	fb1ff06f          	j	19b14 <fputwc+0x28>

00019b68 <__swbuf_r>:
int
_DEFUN(__swbuf_r, (ptr, c, fp),
       struct _reent *ptr _AND
       register int c _AND
       register FILE *fp)
{
   19b68:	fe010113          	addi	sp,sp,-32
   19b6c:	00812c23          	sw	s0,24(sp)
   19b70:	00912a23          	sw	s1,20(sp)
   19b74:	01312623          	sw	s3,12(sp)
   19b78:	00112e23          	sw	ra,28(sp)
   19b7c:	01212823          	sw	s2,16(sp)
   19b80:	00050493          	mv	s1,a0
   19b84:	00058993          	mv	s3,a1
   19b88:	00060413          	mv	s0,a2
  register int n;

  /* Ensure stdio has been initialized.  */

  CHECK_INIT (ptr, fp);
   19b8c:	00050663          	beqz	a0,19b98 <__swbuf_r+0x30>
   19b90:	03852783          	lw	a5,56(a0)
   19b94:	12078263          	beqz	a5,19cb8 <__swbuf_r+0x150>
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
   19b98:	00c41683          	lh	a3,12(s0)
   * (if line buffered) so that we will get called again.
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
   19b9c:	01842603          	lw	a2,24(s0)
  if (cantwrite (ptr, fp))
   19ba0:	01069713          	slli	a4,a3,0x10
   19ba4:	01075713          	srli	a4,a4,0x10
   19ba8:	00877793          	andi	a5,a4,8
   * (if line buffered) so that we will get called again.
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
   19bac:	00c42423          	sw	a2,8(s0)
  if (cantwrite (ptr, fp))
   19bb0:	0e078263          	beqz	a5,19c94 <__swbuf_r+0x12c>
   19bb4:	01042783          	lw	a5,16(s0)
   19bb8:	0c078e63          	beqz	a5,19c94 <__swbuf_r+0x12c>
    return EOF;
  c = (unsigned char) c;

  ORIENT (fp, -1);
   19bbc:	01271613          	slli	a2,a4,0x12
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
  c = (unsigned char) c;
   19bc0:	0ff9f913          	andi	s2,s3,255

  ORIENT (fp, -1);
   19bc4:	06065663          	bgez	a2,19c30 <__swbuf_r+0xc8>
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
   19bc8:	00042703          	lw	a4,0(s0)
  if (n >= fp->_bf._size)
   19bcc:	01442683          	lw	a3,20(s0)
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
   19bd0:	40f707b3          	sub	a5,a4,a5
  if (n >= fp->_bf._size)
   19bd4:	08d7d663          	ble	a3,a5,19c60 <__swbuf_r+0xf8>
   19bd8:	00178793          	addi	a5,a5,1
    {
      if (_fflush_r (ptr, fp))
	return EOF;
      n = 0;
    }
  fp->_w--;
   19bdc:	00842683          	lw	a3,8(s0)
  *fp->_p++ = c;
   19be0:	00170613          	addi	a2,a4,1 # 2001 <_reset+0x1e01>
   19be4:	00c42023          	sw	a2,0(s0)
    {
      if (_fflush_r (ptr, fp))
	return EOF;
      n = 0;
    }
  fp->_w--;
   19be8:	fff68693          	addi	a3,a3,-1
   19bec:	00d42423          	sw	a3,8(s0)
  *fp->_p++ = c;
   19bf0:	01370023          	sb	s3,0(a4)
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
   19bf4:	01442703          	lw	a4,20(s0)
   19bf8:	08f70263          	beq	a4,a5,19c7c <__swbuf_r+0x114>
   19bfc:	00c45783          	lhu	a5,12(s0)
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
  c = (unsigned char) c;
   19c00:	00090513          	mv	a0,s2
	return EOF;
      n = 0;
    }
  fp->_w--;
  *fp->_p++ = c;
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
   19c04:	0017f793          	andi	a5,a5,1
   19c08:	00078663          	beqz	a5,19c14 <__swbuf_r+0xac>
   19c0c:	00a00793          	li	a5,10
   19c10:	06f90663          	beq	s2,a5,19c7c <__swbuf_r+0x114>
    if (_fflush_r (ptr, fp))
      return EOF;
  return c;
}
   19c14:	01c12083          	lw	ra,28(sp)
   19c18:	01812403          	lw	s0,24(sp)
   19c1c:	01412483          	lw	s1,20(sp)
   19c20:	01012903          	lw	s2,16(sp)
   19c24:	00c12983          	lw	s3,12(sp)
   19c28:	02010113          	addi	sp,sp,32
   19c2c:	00008067          	ret
  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
  c = (unsigned char) c;

  ORIENT (fp, -1);
   19c30:	06842583          	lw	a1,104(s0)
   19c34:	ffffe737          	lui	a4,0xffffe
   19c38:	fff70713          	addi	a4,a4,-1 # ffffdfff <_gp+0xfffdf9bf>
   19c3c:	00e5f733          	and	a4,a1,a4
   19c40:	00002637          	lui	a2,0x2
   19c44:	00c6e6b3          	or	a3,a3,a2
   19c48:	06e42423          	sw	a4,104(s0)
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
   19c4c:	00042703          	lw	a4,0(s0)
  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
  c = (unsigned char) c;

  ORIENT (fp, -1);
   19c50:	00d41623          	sh	a3,12(s0)
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
  if (n >= fp->_bf._size)
   19c54:	01442683          	lw	a3,20(s0)
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
   19c58:	40f707b3          	sub	a5,a4,a5
  if (n >= fp->_bf._size)
   19c5c:	f6d7cee3          	blt	a5,a3,19bd8 <__swbuf_r+0x70>
    {
      if (_fflush_r (ptr, fp))
   19c60:	00040593          	mv	a1,s0
   19c64:	00048513          	mv	a0,s1
   19c68:	d44fb0ef          	jal	151ac <_fflush_r>
   19c6c:	04051a63          	bnez	a0,19cc0 <__swbuf_r+0x158>
   19c70:	00042703          	lw	a4,0(s0)
   19c74:	00100793          	li	a5,1
   19c78:	f65ff06f          	j	19bdc <__swbuf_r+0x74>
      n = 0;
    }
  fp->_w--;
  *fp->_p++ = c;
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
    if (_fflush_r (ptr, fp))
   19c7c:	00040593          	mv	a1,s0
   19c80:	00048513          	mv	a0,s1
   19c84:	d28fb0ef          	jal	151ac <_fflush_r>
   19c88:	02051c63          	bnez	a0,19cc0 <__swbuf_r+0x158>
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
  c = (unsigned char) c;
   19c8c:	00090513          	mv	a0,s2
   19c90:	f85ff06f          	j	19c14 <__swbuf_r+0xac>
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
   19c94:	00040593          	mv	a1,s0
   19c98:	00048513          	mv	a0,s1
   19c9c:	939f90ef          	jal	135d4 <__swsetup_r>
   19ca0:	02051063          	bnez	a0,19cc0 <__swbuf_r+0x158>
   19ca4:	00c41683          	lh	a3,12(s0)
   19ca8:	01042783          	lw	a5,16(s0)
   19cac:	01069713          	slli	a4,a3,0x10
   19cb0:	01075713          	srli	a4,a4,0x10
   19cb4:	f09ff06f          	j	19bbc <__swbuf_r+0x54>
{
  register int n;

  /* Ensure stdio has been initialized.  */

  CHECK_INIT (ptr, fp);
   19cb8:	8a5fb0ef          	jal	1555c <__sinit>
   19cbc:	eddff06f          	j	19b98 <__swbuf_r+0x30>
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
   19cc0:	fff00513          	li	a0,-1
   19cc4:	f51ff06f          	j	19c14 <__swbuf_r+0xac>

00019cc8 <__swbuf>:
int
_DEFUN(__swbuf, (c, fp),
       register int c _AND
       register FILE *fp)
{
  return __swbuf_r (_REENT, c, fp);
   19cc8:	00058613          	mv	a2,a1
   19ccc:	00050593          	mv	a1,a0
   19cd0:	8101a503          	lw	a0,-2032(gp) # 1de50 <_impure_ptr>
   19cd4:	e95ff06f          	j	19b68 <__swbuf_r>

00019cd8 <_wcrtomb_r>:
_DEFUN (_wcrtomb_r, (ptr, s, wc, ps),
	struct _reent *ptr _AND
	char *s _AND
	wchar_t wc _AND
	mbstate_t *ps)
{
   19cd8:	fd010113          	addi	sp,sp,-48
   19cdc:	02812423          	sw	s0,40(sp)
   19ce0:	02912223          	sw	s1,36(sp)
   19ce4:	03212023          	sw	s2,32(sp)
   19ce8:	02112623          	sw	ra,44(sp)
   19cec:	00050413          	mv	s0,a0
   19cf0:	00068493          	mv	s1,a3
      ps = &(_REENT_WCRTOMB_STATE(ptr));
    }
#endif

  if (s == NULL)
    retval = __wctomb (ptr, buf, L'\0', __locale_charset (), ps);
   19cf4:	8201a903          	lw	s2,-2016(gp) # 1de60 <__wctomb>
      _REENT_CHECK_MISC(ptr);
      ps = &(_REENT_WCRTOMB_STATE(ptr));
    }
#endif

  if (s == NULL)
   19cf8:	04058a63          	beqz	a1,19d4c <_wcrtomb_r+0x74>
    retval = __wctomb (ptr, buf, L'\0', __locale_charset (), ps);
  else
    retval = __wctomb (ptr, s, wc, __locale_charset (), ps);
   19cfc:	00b12623          	sw	a1,12(sp)
   19d00:	00c12423          	sw	a2,8(sp)
   19d04:	af4fc0ef          	jal	15ff8 <__locale_charset>
   19d08:	00812603          	lw	a2,8(sp)
   19d0c:	00c12583          	lw	a1,12(sp)
   19d10:	00050693          	mv	a3,a0
   19d14:	00048713          	mv	a4,s1
   19d18:	00040513          	mv	a0,s0
   19d1c:	000900e7          	jalr	s2

  if (retval == -1)
   19d20:	fff00793          	li	a5,-1
   19d24:	00f51863          	bne	a0,a5,19d34 <_wcrtomb_r+0x5c>
    {
      ps->__count = 0;
      ptr->_errno = EILSEQ;
   19d28:	08a00793          	li	a5,138
  else
    retval = __wctomb (ptr, s, wc, __locale_charset (), ps);

  if (retval == -1)
    {
      ps->__count = 0;
   19d2c:	0004a023          	sw	zero,0(s1)
      ptr->_errno = EILSEQ;
   19d30:	00f42023          	sw	a5,0(s0)
      return (size_t)(-1);
    }
  else
    return (size_t)retval;
}
   19d34:	02c12083          	lw	ra,44(sp)
   19d38:	02812403          	lw	s0,40(sp)
   19d3c:	02412483          	lw	s1,36(sp)
   19d40:	02012903          	lw	s2,32(sp)
   19d44:	03010113          	addi	sp,sp,48
   19d48:	00008067          	ret
      ps = &(_REENT_WCRTOMB_STATE(ptr));
    }
#endif

  if (s == NULL)
    retval = __wctomb (ptr, buf, L'\0', __locale_charset (), ps);
   19d4c:	aacfc0ef          	jal	15ff8 <__locale_charset>
   19d50:	00050693          	mv	a3,a0
   19d54:	00048713          	mv	a4,s1
   19d58:	00000613          	li	a2,0
   19d5c:	01410593          	addi	a1,sp,20
   19d60:	00040513          	mv	a0,s0
   19d64:	000900e7          	jalr	s2
   19d68:	fb9ff06f          	j	19d20 <_wcrtomb_r+0x48>

00019d6c <wcrtomb>:
size_t
_DEFUN (wcrtomb, (s, wc, ps),
	char *__restrict s _AND
	wchar_t wc _AND
	mbstate_t *__restrict ps)
{
   19d6c:	fd010113          	addi	sp,sp,-48
   19d70:	02912223          	sw	s1,36(sp)
   19d74:	03212023          	sw	s2,32(sp)
   19d78:	02112623          	sw	ra,44(sp)
   19d7c:	02812423          	sw	s0,40(sp)
   19d80:	01312e23          	sw	s3,28(sp)
   19d84:	01412c23          	sw	s4,24(sp)
   19d88:	00060913          	mv	s2,a2
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  return _wcrtomb_r (_REENT, s, wc, ps);
#else
  int retval = 0;
  struct _reent *reent = _REENT;
   19d8c:	8101a483          	lw	s1,-2032(gp) # 1de50 <_impure_ptr>
      _REENT_CHECK_MISC(reent);
      ps = &(_REENT_WCRTOMB_STATE(reent));
    }
#endif

  if (s == NULL)
   19d90:	06050063          	beqz	a0,19df0 <wcrtomb+0x84>
    retval = __wctomb (reent, buf, L'\0', __locale_charset (), ps);
  else
    retval = __wctomb (reent, s, wc, __locale_charset (), ps);
   19d94:	8201aa03          	lw	s4,-2016(gp) # 1de60 <__wctomb>
   19d98:	00058993          	mv	s3,a1
   19d9c:	00050413          	mv	s0,a0
   19da0:	a58fc0ef          	jal	15ff8 <__locale_charset>
   19da4:	00050693          	mv	a3,a0
   19da8:	00090713          	mv	a4,s2
   19dac:	00098613          	mv	a2,s3
   19db0:	00040593          	mv	a1,s0
   19db4:	00048513          	mv	a0,s1
   19db8:	000a00e7          	jalr	s4

  if (retval == -1)
   19dbc:	fff00793          	li	a5,-1
   19dc0:	00f51863          	bne	a0,a5,19dd0 <wcrtomb+0x64>
    {
      ps->__count = 0;
      reent->_errno = EILSEQ;
   19dc4:	08a00793          	li	a5,138
  else
    retval = __wctomb (reent, s, wc, __locale_charset (), ps);

  if (retval == -1)
    {
      ps->__count = 0;
   19dc8:	00092023          	sw	zero,0(s2)
      reent->_errno = EILSEQ;
   19dcc:	00f4a023          	sw	a5,0(s1)
      return (size_t)(-1);
    }
  else
    return (size_t)retval;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   19dd0:	02c12083          	lw	ra,44(sp)
   19dd4:	02812403          	lw	s0,40(sp)
   19dd8:	02412483          	lw	s1,36(sp)
   19ddc:	02012903          	lw	s2,32(sp)
   19de0:	01c12983          	lw	s3,28(sp)
   19de4:	01812a03          	lw	s4,24(sp)
   19de8:	03010113          	addi	sp,sp,48
   19dec:	00008067          	ret
      ps = &(_REENT_WCRTOMB_STATE(reent));
    }
#endif

  if (s == NULL)
    retval = __wctomb (reent, buf, L'\0', __locale_charset (), ps);
   19df0:	8201a403          	lw	s0,-2016(gp) # 1de60 <__wctomb>
   19df4:	a04fc0ef          	jal	15ff8 <__locale_charset>
   19df8:	00050693          	mv	a3,a0
   19dfc:	00090713          	mv	a4,s2
   19e00:	00000613          	li	a2,0
   19e04:	00410593          	addi	a1,sp,4
   19e08:	00048513          	mv	a0,s1
   19e0c:	000400e7          	jalr	s0
   19e10:	fadff06f          	j	19dbc <wcrtomb+0x50>

00019e14 <__ascii_wctomb>:
  /* Avoids compiler warnings about comparisons that are always false
     due to limited range when sizeof(wchar_t) is 2 but sizeof(wint_t)
     is 4, as is the case on cygwin.  */
  wint_t wchar = _wchar;

  if (s == NULL)
   19e14:	00058c63          	beqz	a1,19e2c <__ascii_wctomb+0x18>
    return 0;
 
#ifdef __CYGWIN__
  if ((size_t)wchar >= 0x80)
#else
  if ((size_t)wchar >= 0x100)
   19e18:	0ff00793          	li	a5,255
   19e1c:	00c7ec63          	bltu	a5,a2,19e34 <__ascii_wctomb+0x20>
    {
      r->_errno = EILSEQ;
      return -1;
    }

  *s = (char) wchar;
   19e20:	00c58023          	sb	a2,0(a1)
  return 1;
   19e24:	00100513          	li	a0,1
   19e28:	00008067          	ret
     due to limited range when sizeof(wchar_t) is 2 but sizeof(wint_t)
     is 4, as is the case on cygwin.  */
  wint_t wchar = _wchar;

  if (s == NULL)
    return 0;
   19e2c:	00000513          	li	a0,0
      return -1;
    }

  *s = (char) wchar;
  return 1;
}
   19e30:	00008067          	ret
  if ((size_t)wchar >= 0x80)
#else
  if ((size_t)wchar >= 0x100)
#endif
    {
      r->_errno = EILSEQ;
   19e34:	08a00793          	li	a5,138
   19e38:	00f52023          	sw	a5,0(a0)
      return -1;
   19e3c:	fff00513          	li	a0,-1
   19e40:	00008067          	ret

00019e44 <_wctomb_r>:
_DEFUN (_wctomb_r, (r, s, wchar, state),
        struct _reent *r     _AND 
        char          *s     _AND
        wchar_t        _wchar _AND
        mbstate_t     *state)
{
   19e44:	fe010113          	addi	sp,sp,-32
   19e48:	00812c23          	sw	s0,24(sp)
  return __wctomb (r, s, _wchar, __locale_charset (), state);
   19e4c:	8201a403          	lw	s0,-2016(gp) # 1de60 <__wctomb>
_DEFUN (_wctomb_r, (r, s, wchar, state),
        struct _reent *r     _AND 
        char          *s     _AND
        wchar_t        _wchar _AND
        mbstate_t     *state)
{
   19e50:	00112e23          	sw	ra,28(sp)
   19e54:	00912a23          	sw	s1,20(sp)
   19e58:	01212823          	sw	s2,16(sp)
   19e5c:	00050493          	mv	s1,a0
   19e60:	00068913          	mv	s2,a3
  return __wctomb (r, s, _wchar, __locale_charset (), state);
   19e64:	00b12623          	sw	a1,12(sp)
   19e68:	00c12423          	sw	a2,8(sp)
   19e6c:	98cfc0ef          	jal	15ff8 <__locale_charset>
   19e70:	00050693          	mv	a3,a0
   19e74:	00090713          	mv	a4,s2
   19e78:	00812603          	lw	a2,8(sp)
   19e7c:	00c12583          	lw	a1,12(sp)
   19e80:	00048513          	mv	a0,s1
   19e84:	00040313          	mv	t1,s0
}
   19e88:	01c12083          	lw	ra,28(sp)
   19e8c:	01812403          	lw	s0,24(sp)
   19e90:	01412483          	lw	s1,20(sp)
   19e94:	01012903          	lw	s2,16(sp)
   19e98:	02010113          	addi	sp,sp,32
        struct _reent *r     _AND 
        char          *s     _AND
        wchar_t        _wchar _AND
        mbstate_t     *state)
{
  return __wctomb (r, s, _wchar, __locale_charset (), state);
   19e9c:	00030067          	jr	t1

00019ea0 <_fpadd_parts>:
#if defined(L_addsub_sf) || defined(L_addsub_df) || defined(L_addsub_tf)
static const fp_number_type *
_fpadd_parts (fp_number_type * a,
	      fp_number_type * b,
	      fp_number_type * tmp)
{
   19ea0:	00052783          	lw	a5,0(a0)
  int a_normal_exp;
  int b_normal_exp;
  fractype a_fraction;
  fractype b_fraction;

  if (isnan (a))
   19ea4:	00100693          	li	a3,1
   19ea8:	12f6f263          	bleu	a5,a3,19fcc <_fpadd_parts+0x12c>
   19eac:	0005a703          	lw	a4,0(a1)
    {
      return a;
    }
  if (isnan (b))
   19eb0:	10e6fc63          	bleu	a4,a3,19fc8 <_fpadd_parts+0x128>
    {
      return b;
    }
  if (isinf (a))
   19eb4:	00400693          	li	a3,4
   19eb8:	24d78063          	beq	a5,a3,1a0f8 <_fpadd_parts+0x258>
      /* Adding infinities with opposite signs yields a NaN.  */
      if (isinf (b) && a->sign != b->sign)
	return makenan ();
      return a;
    }
  if (isinf (b))
   19ebc:	10d70663          	beq	a4,a3,19fc8 <_fpadd_parts+0x128>
    {
      return b;
    }
  if (iszero (b))
   19ec0:	00200693          	li	a3,2
   19ec4:	1cd70263          	beq	a4,a3,1a088 <_fpadd_parts+0x1e8>
	  tmp->sign = a->sign & b->sign;
	  return tmp;
	}
      return a;
    }
  if (iszero (a))
   19ec8:	10d78063          	beq	a5,a3,19fc8 <_fpadd_parts+0x128>
     they're the same */
  {
    int diff;
    int sdiff;

    a_normal_exp = a->normal_exp;
   19ecc:	00852303          	lw	t1,8(a0)
    b_normal_exp = b->normal_exp;
   19ed0:	0085a683          	lw	a3,8(a1)
    a_fraction = a->fraction.ll;
   19ed4:	01052883          	lw	a7,16(a0)
   19ed8:	01452e03          	lw	t3,20(a0)
    b_fraction = b->fraction.ll;

    diff = a_normal_exp - b_normal_exp;
   19edc:	40d30833          	sub	a6,t1,a3
   19ee0:	41f85793          	srai	a5,a6,0x1f
   19ee4:	0107c733          	xor	a4,a5,a6
   19ee8:	40f70733          	sub	a4,a4,a5
    sdiff = diff;

    if (diff < 0)
      diff = -diff;
    if (diff < FRAC_NBITS)
   19eec:	03f00793          	li	a5,63
    int sdiff;

    a_normal_exp = a->normal_exp;
    b_normal_exp = b->normal_exp;
    a_fraction = a->fraction.ll;
    b_fraction = b->fraction.ll;
   19ef0:	0105a283          	lw	t0,16(a1)
   19ef4:	0145a383          	lw	t2,20(a1)
    diff = a_normal_exp - b_normal_exp;
    sdiff = diff;

    if (diff < 0)
      diff = -diff;
    if (diff < FRAC_NBITS)
   19ef8:	0ce7dc63          	ble	a4,a5,19fd0 <_fpadd_parts+0x130>
	  }
      }
    else
      {
	/* Somethings's up.. choose the biggest */
	if (a_normal_exp > b_normal_exp)
   19efc:	1e66c863          	blt	a3,t1,1a0ec <_fpadd_parts+0x24c>
   19f00:	00068313          	mv	t1,a3
	    b_fraction = 0;
	  }
	else
	  {
	    a_normal_exp = b_normal_exp;
	    a_fraction = 0;
   19f04:	00000893          	li	a7,0
   19f08:	00000e13          	li	t3,0
	  }
      }
  }

  if (a->sign != b->sign)
   19f0c:	00452503          	lw	a0,4(a0)
   19f10:	0045a783          	lw	a5,4(a1)
   19f14:	10f50863          	beq	a0,a5,1a024 <_fpadd_parts+0x184>
    {
      if (a->sign)
   19f18:	1c050063          	beqz	a0,1a0d8 <_fpadd_parts+0x238>
	{
	  tfraction = -a_fraction + b_fraction;
   19f1c:	411287b3          	sub	a5,t0,a7
   19f20:	00f2b6b3          	sltu	a3,t0,a5
   19f24:	41c38733          	sub	a4,t2,t3
   19f28:	40d706b3          	sub	a3,a4,a3
	}
      else
	{
	  tfraction = a_fraction - b_fraction;
	}
      if (tfraction >= 0)
   19f2c:	1e06c463          	bltz	a3,1a114 <_fpadd_parts+0x274>
	{
	  tmp->sign = 0;
   19f30:	00062223          	sw	zero,4(a2) # 2004 <_reset+0x1e04>
	  tmp->normal_exp = a_normal_exp;
   19f34:	00662423          	sw	t1,8(a2)
	  tmp->fraction.ll = tfraction;
   19f38:	00f62823          	sw	a5,16(a2)
   19f3c:	00d62a23          	sw	a3,20(a2)
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   19f40:	fff78513          	addi	a0,a5,-1
   19f44:	fff68593          	addi	a1,a3,-1
   19f48:	00f53733          	sltu	a4,a0,a5
   19f4c:	00b70733          	add	a4,a4,a1
   19f50:	100005b7          	lui	a1,0x10000
   19f54:	0eb77863          	bleu	a1,a4,1a044 <_fpadd_parts+0x1a4>
   19f58:	fff58593          	addi	a1,a1,-1 # fffffff <_gp+0xffe19bf>
   19f5c:	24b70e63          	beq	a4,a1,1a1b8 <_fpadd_parts+0x318>
   19f60:	00862503          	lw	a0,8(a2)
   19f64:	100002b7          	lui	t0,0x10000
   19f68:	fff28313          	addi	t1,t0,-1 # fffffff <_gp+0xffe19bf>
   19f6c:	fff50513          	addi	a0,a0,-1
   19f70:	ffe00393          	li	t2,-2
   19f74:	0080006f          	j	19f7c <_fpadd_parts+0xdc>
   19f78:	14670c63          	beq	a4,t1,1a0d0 <_fpadd_parts+0x230>
	{
	  tmp->fraction.ll <<= 1;
   19f7c:	01f7d713          	srli	a4,a5,0x1f
   19f80:	00169593          	slli	a1,a3,0x1
   19f84:	00179793          	slli	a5,a5,0x1
   19f88:	00b765b3          	or	a1,a4,a1
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   19f8c:	fff78813          	addi	a6,a5,-1
   19f90:	fff58893          	addi	a7,a1,-1
   19f94:	00f83733          	sltu	a4,a6,a5
   19f98:	01170733          	add	a4,a4,a7
	{
	  tmp->fraction.ll <<= 1;
   19f9c:	00058693          	mv	a3,a1
	  tmp->normal_exp--;
   19fa0:	00050893          	mv	a7,a0
   19fa4:	fff50513          	addi	a0,a0,-1
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   19fa8:	fc5768e3          	bltu	a4,t0,19f78 <_fpadd_parts+0xd8>
   19fac:	00f62823          	sw	a5,16(a2)
    {
      tmp->sign = a->sign;
      tmp->normal_exp = a_normal_exp;
      tmp->fraction.ll = a_fraction + b_fraction;
    }
  tmp->class = CLASS_NUMBER;
   19fb0:	00300793          	li	a5,3
   19fb4:	00b62a23          	sw	a1,20(a2)
   19fb8:	01162423          	sw	a7,8(a2)
   19fbc:	00f62023          	sw	a5,0(a2)
   19fc0:	00060513          	mv	a0,a2
   19fc4:	00008067          	ret
   19fc8:	00058513          	mv	a0,a1
    {
      LSHIFT (tmp->fraction.ll, 1);
      tmp->normal_exp++;
    }
  return tmp;
}
   19fcc:	00008067          	ret

    if (diff < 0)
      diff = -diff;
    if (diff < FRAC_NBITS)
      {
	if (sdiff > 0)
   19fd0:	19005a63          	blez	a6,1a164 <_fpadd_parts+0x2c4>
	  {
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
   19fd4:	02077793          	andi	a5,a4,32
   19fd8:	16078263          	beqz	a5,1a13c <_fpadd_parts+0x29c>
   19fdc:	00100793          	li	a5,1
   19fe0:	00e3deb3          	srl	t4,t2,a4
   19fe4:	00e797b3          	sll	a5,a5,a4
   19fe8:	00000f13          	li	t5,0
   19fec:	00000713          	li	a4,0
   19ff0:	fff70693          	addi	a3,a4,-1
   19ff4:	fff78793          	addi	a5,a5,-1
   19ff8:	00e6b733          	sltu	a4,a3,a4
   19ffc:	00f70733          	add	a4,a4,a5
   1a000:	00777733          	and	a4,a4,t2
   1a004:	0056f7b3          	and	a5,a3,t0
   1a008:	00e7e7b3          	or	a5,a5,a4
   1a00c:	00f037b3          	snez	a5,a5
   1a010:	00fee2b3          	or	t0,t4,a5
	    a_fraction = 0;
	  }
      }
  }

  if (a->sign != b->sign)
   1a014:	00452503          	lw	a0,4(a0)
   1a018:	0045a783          	lw	a5,4(a1)
    if (diff < FRAC_NBITS)
      {
	if (sdiff > 0)
	  {
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
   1a01c:	000f0393          	mv	t2,t5
	    a_fraction = 0;
	  }
      }
  }

  if (a->sign != b->sign)
   1a020:	eef51ce3          	bne	a0,a5,19f18 <_fpadd_parts+0x78>
    }
  else
    {
      tmp->sign = a->sign;
      tmp->normal_exp = a_normal_exp;
      tmp->fraction.ll = a_fraction + b_fraction;
   1a024:	005887b3          	add	a5,a7,t0
   1a028:	0117b8b3          	sltu	a7,a5,a7
   1a02c:	007e0733          	add	a4,t3,t2
   1a030:	00e886b3          	add	a3,a7,a4
	  tmp->normal_exp--;
	}
    }
  else
    {
      tmp->sign = a->sign;
   1a034:	00a62223          	sw	a0,4(a2)
      tmp->normal_exp = a_normal_exp;
   1a038:	00662423          	sw	t1,8(a2)
      tmp->fraction.ll = a_fraction + b_fraction;
   1a03c:	00f62823          	sw	a5,16(a2)
   1a040:	00d62a23          	sw	a3,20(a2)
    }
  tmp->class = CLASS_NUMBER;
   1a044:	00300713          	li	a4,3
   1a048:	00e62023          	sw	a4,0(a2)
  /* Now the fraction is added, we have to shift down to renormalize the
     number */

  if (tmp->fraction.ll >= IMPLICIT_2)
   1a04c:	20000737          	lui	a4,0x20000
   1a050:	02e6e863          	bltu	a3,a4,1a080 <_fpadd_parts+0x1e0>
    {
      LSHIFT (tmp->fraction.ll, 1);
      tmp->normal_exp++;
   1a054:	00862703          	lw	a4,8(a2)
  /* Now the fraction is added, we have to shift down to renormalize the
     number */

  if (tmp->fraction.ll >= IMPLICIT_2)
    {
      LSHIFT (tmp->fraction.ll, 1);
   1a058:	01f69513          	slli	a0,a3,0x1f
   1a05c:	0017d593          	srli	a1,a5,0x1
   1a060:	00b565b3          	or	a1,a0,a1
   1a064:	0017f793          	andi	a5,a5,1
   1a068:	0016d693          	srli	a3,a3,0x1
   1a06c:	00f5e7b3          	or	a5,a1,a5
      tmp->normal_exp++;
   1a070:	00170713          	addi	a4,a4,1 # 20000001 <_gp+0x1ffe19c1>
  /* Now the fraction is added, we have to shift down to renormalize the
     number */

  if (tmp->fraction.ll >= IMPLICIT_2)
    {
      LSHIFT (tmp->fraction.ll, 1);
   1a074:	00f62823          	sw	a5,16(a2)
   1a078:	00d62a23          	sw	a3,20(a2)
      tmp->normal_exp++;
   1a07c:	00e62423          	sw	a4,8(a2)
   1a080:	00060513          	mv	a0,a2
   1a084:	00008067          	ret
    {
      return b;
    }
  if (iszero (b))
    {
      if (iszero (a))
   1a088:	f4e792e3          	bne	a5,a4,19fcc <_fpadd_parts+0x12c>
	{
	  *tmp = *a;
   1a08c:	00f62023          	sw	a5,0(a2)
   1a090:	00452783          	lw	a5,4(a0)
   1a094:	00f62223          	sw	a5,4(a2)
   1a098:	00852703          	lw	a4,8(a0)
	  tmp->sign = a->sign & b->sign;
   1a09c:	00452683          	lw	a3,4(a0)
   1a0a0:	0045a783          	lw	a5,4(a1)
    }
  if (iszero (b))
    {
      if (iszero (a))
	{
	  *tmp = *a;
   1a0a4:	00e62423          	sw	a4,8(a2)
   1a0a8:	00c52703          	lw	a4,12(a0)
	  tmp->sign = a->sign & b->sign;
   1a0ac:	00f6f7b3          	and	a5,a3,a5
    }
  if (iszero (b))
    {
      if (iszero (a))
	{
	  *tmp = *a;
   1a0b0:	00e62623          	sw	a4,12(a2)
   1a0b4:	01052703          	lw	a4,16(a0)
   1a0b8:	00e62823          	sw	a4,16(a2)
   1a0bc:	01452703          	lw	a4,20(a0)
	  tmp->sign = a->sign & b->sign;
   1a0c0:	00f62223          	sw	a5,4(a2)
	  return tmp;
   1a0c4:	00060513          	mv	a0,a2
    }
  if (iszero (b))
    {
      if (iszero (a))
	{
	  *tmp = *a;
   1a0c8:	00e62a23          	sw	a4,20(a2)
	  tmp->sign = a->sign & b->sign;
	  return tmp;
   1a0cc:	00008067          	ret
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1a0d0:	eb03f6e3          	bleu	a6,t2,19f7c <_fpadd_parts+0xdc>
   1a0d4:	ed9ff06f          	j	19fac <_fpadd_parts+0x10c>
	{
	  tfraction = -a_fraction + b_fraction;
	}
      else
	{
	  tfraction = a_fraction - b_fraction;
   1a0d8:	405887b3          	sub	a5,a7,t0
   1a0dc:	00f8b6b3          	sltu	a3,a7,a5
   1a0e0:	407e0733          	sub	a4,t3,t2
   1a0e4:	40d706b3          	sub	a3,a4,a3
   1a0e8:	e45ff06f          	j	19f2c <_fpadd_parts+0x8c>
      {
	/* Somethings's up.. choose the biggest */
	if (a_normal_exp > b_normal_exp)
	  {
	    b_normal_exp = a_normal_exp;
	    b_fraction = 0;
   1a0ec:	00000293          	li	t0,0
   1a0f0:	00000393          	li	t2,0
   1a0f4:	e19ff06f          	j	19f0c <_fpadd_parts+0x6c>
      return b;
    }
  if (isinf (a))
    {
      /* Adding infinities with opposite signs yields a NaN.  */
      if (isinf (b) && a->sign != b->sign)
   1a0f8:	ecf71ae3          	bne	a4,a5,19fcc <_fpadd_parts+0x12c>
   1a0fc:	00452703          	lw	a4,4(a0)
   1a100:	0045a783          	lw	a5,4(a1)
   1a104:	ecf704e3          	beq	a4,a5,19fcc <_fpadd_parts+0x12c>
	return makenan ();
   1a108:	0001c537          	lui	a0,0x1c
   1a10c:	0f850513          	addi	a0,a0,248 # 1c0f8 <__thenan_df>
   1a110:	00008067          	ret
	}
      else
	{
	  tmp->sign = 1;
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
   1a114:	40f007b3          	neg	a5,a5
   1a118:	00f03733          	snez	a4,a5
   1a11c:	40d006b3          	neg	a3,a3
   1a120:	40e686b3          	sub	a3,a3,a4
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = tfraction;
	}
      else
	{
	  tmp->sign = 1;
   1a124:	00100713          	li	a4,1
   1a128:	00e62223          	sw	a4,4(a2)
	  tmp->normal_exp = a_normal_exp;
   1a12c:	00662423          	sw	t1,8(a2)
	  tmp->fraction.ll = -tfraction;
   1a130:	00f62823          	sw	a5,16(a2)
   1a134:	00d62a23          	sw	a3,20(a2)
   1a138:	e09ff06f          	j	19f40 <_fpadd_parts+0xa0>
    if (diff < FRAC_NBITS)
      {
	if (sdiff > 0)
	  {
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
   1a13c:	fff74693          	not	a3,a4
   1a140:	00139793          	slli	a5,t2,0x1
   1a144:	00d797b3          	sll	a5,a5,a3
   1a148:	00e2deb3          	srl	t4,t0,a4
   1a14c:	00100813          	li	a6,1
   1a150:	01d7eeb3          	or	t4,a5,t4
   1a154:	00e3df33          	srl	t5,t2,a4
   1a158:	00000793          	li	a5,0
   1a15c:	00e81733          	sll	a4,a6,a4
   1a160:	e91ff06f          	j	19ff0 <_fpadd_parts+0x150>
	  }
	else if (sdiff < 0)
   1a164:	da0804e3          	beqz	a6,19f0c <_fpadd_parts+0x6c>
	  {
	    a_normal_exp += diff;
	    LSHIFT (a_fraction, diff);
   1a168:	02077793          	andi	a5,a4,32
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
	  }
	else if (sdiff < 0)
	  {
	    a_normal_exp += diff;
   1a16c:	00e30333          	add	t1,t1,a4
	    LSHIFT (a_fraction, diff);
   1a170:	06078263          	beqz	a5,1a1d4 <_fpadd_parts+0x334>
   1a174:	00ee5833          	srl	a6,t3,a4
   1a178:	00000e93          	li	t4,0
   1a17c:	04079463          	bnez	a5,1a1c4 <_fpadd_parts+0x324>
   1a180:	00100793          	li	a5,1
   1a184:	00000693          	li	a3,0
   1a188:	00e79733          	sll	a4,a5,a4
   1a18c:	fff70793          	addi	a5,a4,-1
   1a190:	00e7b733          	sltu	a4,a5,a4
   1a194:	fff68693          	addi	a3,a3,-1
   1a198:	00d70733          	add	a4,a4,a3
   1a19c:	0117f7b3          	and	a5,a5,a7
   1a1a0:	01c77733          	and	a4,a4,t3
   1a1a4:	00e7e7b3          	or	a5,a5,a4
   1a1a8:	00f037b3          	snez	a5,a5
   1a1ac:	00f868b3          	or	a7,a6,a5
   1a1b0:	000e8e13          	mv	t3,t4
   1a1b4:	d59ff06f          	j	19f0c <_fpadd_parts+0x6c>
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1a1b8:	ffe00713          	li	a4,-2
   1a1bc:	daa772e3          	bleu	a0,a4,19f60 <_fpadd_parts+0xc0>
   1a1c0:	e85ff06f          	j	1a044 <_fpadd_parts+0x1a4>
	    LSHIFT (b_fraction, diff);
	  }
	else if (sdiff < 0)
	  {
	    a_normal_exp += diff;
	    LSHIFT (a_fraction, diff);
   1a1c4:	00100693          	li	a3,1
   1a1c8:	00e696b3          	sll	a3,a3,a4
   1a1cc:	00000713          	li	a4,0
   1a1d0:	fbdff06f          	j	1a18c <_fpadd_parts+0x2ec>
   1a1d4:	001e1793          	slli	a5,t3,0x1
   1a1d8:	fff74693          	not	a3,a4
   1a1dc:	00d797b3          	sll	a5,a5,a3
   1a1e0:	00e8d833          	srl	a6,a7,a4
   1a1e4:	0107e833          	or	a6,a5,a6
   1a1e8:	00ee5eb3          	srl	t4,t3,a4
   1a1ec:	f95ff06f          	j	1a180 <_fpadd_parts+0x2e0>

0001a1f0 <__pack_d>:
extern FLO_type pack_d (const fp_number_type * );

#if defined(L_pack_df) || defined(L_pack_sf) || defined(L_pack_tf)
FLO_type
pack_d (const fp_number_type *src)
{
   1a1f0:	00052783          	lw	a5,0(a0)
  FLO_union_type dst;
  fractype fraction = src->fraction.ll;	/* wasn't unsigned before? */
  int sign = src->sign;
  int exp = 0;

  if (isnan (src))
   1a1f4:	00100593          	li	a1,1
#if defined(L_pack_df) || defined(L_pack_sf) || defined(L_pack_tf)
FLO_type
pack_d (const fp_number_type *src)
{
  FLO_union_type dst;
  fractype fraction = src->fraction.ll;	/* wasn't unsigned before? */
   1a1f8:	01052603          	lw	a2,16(a0)
   1a1fc:	01452683          	lw	a3,20(a0)
  int sign = src->sign;
   1a200:	00452803          	lw	a6,4(a0)
  int exp = 0;

  if (isnan (src))
   1a204:	0ef5fa63          	bleu	a5,a1,1a2f8 <__pack_d+0x108>
	  /* Set the quiet/signaling bit.  */
	  fraction |= QUIET_NAN;
#endif
	}
    }
  else if (isinf (src))
   1a208:	00400713          	li	a4,4
   1a20c:	0ce78e63          	beq	a5,a4,1a2e8 <__pack_d+0xf8>
    {
      exp = EXPMAX;
      fraction = 0;
    }
  else if (iszero (src))
   1a210:	00200713          	li	a4,2
   1a214:	06e78263          	beq	a5,a4,1a278 <__pack_d+0x88>
    {
      exp = 0;
      fraction = 0;
    }
  else if (fraction == 0)
   1a218:	00d667b3          	or	a5,a2,a3
   1a21c:	04078e63          	beqz	a5,1a278 <__pack_d+0x88>
    {
      exp = 0;
    }
  else
    {
      if (__builtin_expect (src->normal_exp < NORMAL_EXPMIN, 0))
   1a220:	00852783          	lw	a5,8(a0)
   1a224:	c0200713          	li	a4,-1022
   1a228:	12e7c063          	blt	a5,a4,1a348 <__pack_d+0x158>
	      exp += 1;
	    }
	  fraction >>= NGARDS;
#endif /* NO_DENORMALS */
	}
      else if (__builtin_expect (src->normal_exp > EXPBIAS, 0))
   1a22c:	3ff00713          	li	a4,1023
   1a230:	0af74c63          	blt	a4,a5,1a2e8 <__pack_d+0xf8>
	{
	  exp = src->normal_exp + EXPBIAS;
	  /* IF the gard bits are the all zero, but the first, then we're
	     half way between two numbers, choose the one which makes the
	     lsb of the answer 0.  */
	  if ((fraction & GARDMASK) == GARDMSB)
   1a234:	0ff67713          	andi	a4,a2,255
   1a238:	08000593          	li	a1,128
   1a23c:	0eb70863          	beq	a4,a1,1a32c <__pack_d+0x13c>
		fraction += GARDROUND + 1;
	    }
	  else
	    {
	      /* Add a one to the guards to round up */
	      fraction += GARDROUND;
   1a240:	07f60713          	addi	a4,a2,127
   1a244:	00c73633          	sltu	a2,a4,a2
   1a248:	00d606b3          	add	a3,a2,a3
   1a24c:	00070613          	mv	a2,a4
	    }
	  if (fraction >= IMPLICIT_2)
   1a250:	20000737          	lui	a4,0x20000
   1a254:	06e6fe63          	bleu	a4,a3,1a2d0 <__pack_d+0xe0>
	  exp = EXPMAX;
	  fraction = 0;
	}
      else
	{
	  exp = src->normal_exp + EXPBIAS;
   1a258:	3ff78793          	addi	a5,a5,1023
   1a25c:	01869713          	slli	a4,a3,0x18
   1a260:	00865613          	srli	a2,a2,0x8
   1a264:	00469693          	slli	a3,a3,0x4
   1a268:	00c76633          	or	a2,a4,a2
   1a26c:	00c6d693          	srli	a3,a3,0xc
   1a270:	7ff7f793          	andi	a5,a5,2047
   1a274:	0100006f          	j	1a284 <__pack_d+0x94>
   1a278:	00000793          	li	a5,0
   1a27c:	00000613          	li	a2,0
   1a280:	00000693          	li	a3,0

  /* We previously used bitfields to store the number, but this doesn't
     handle little/big endian systems conveniently, so use shifts and
     masks */
#ifdef FLOAT_BIT_ORDER_MISMATCH
  dst.bits.fraction = fraction;
   1a284:	00100737          	lui	a4,0x100
   1a288:	00000593          	li	a1,0
   1a28c:	00060513          	mv	a0,a2
   1a290:	fff70713          	addi	a4,a4,-1 # fffff <_gp+0xe19bf>
   1a294:	fff00637          	lui	a2,0xfff00
   1a298:	00b67633          	and	a2,a2,a1
   1a29c:	00e6f6b3          	and	a3,a3,a4
  dst.bits.exp = exp;
   1a2a0:	01479713          	slli	a4,a5,0x14
   1a2a4:	801007b7          	lui	a5,0x80100

  /* We previously used bitfields to store the number, but this doesn't
     handle little/big endian systems conveniently, so use shifts and
     masks */
#ifdef FLOAT_BIT_ORDER_MISMATCH
  dst.bits.fraction = fraction;
   1a2a8:	00d666b3          	or	a3,a2,a3
  dst.bits.exp = exp;
   1a2ac:	fff78793          	addi	a5,a5,-1 # 800fffff <_gp+0x800e19bf>
   1a2b0:	00f6f7b3          	and	a5,a3,a5
   1a2b4:	00e7e7b3          	or	a5,a5,a4
  dst.bits.sign = sign;
   1a2b8:	80000737          	lui	a4,0x80000
   1a2bc:	fff74713          	not	a4,a4
   1a2c0:	01f81813          	slli	a6,a6,0x1f
   1a2c4:	00e7f7b3          	and	a5,a5,a4
   1a2c8:	0107e5b3          	or	a1,a5,a6
  }
#endif
#endif

  return dst.value;
}
   1a2cc:	00008067          	ret
	      /* Add a one to the guards to round up */
	      fraction += GARDROUND;
	    }
	  if (fraction >= IMPLICIT_2)
	    {
	      fraction >>= 1;
   1a2d0:	01f69713          	slli	a4,a3,0x1f
   1a2d4:	00165613          	srli	a2,a2,0x1
   1a2d8:	00c76633          	or	a2,a4,a2
   1a2dc:	0016d693          	srli	a3,a3,0x1
	      exp += 1;
   1a2e0:	40078793          	addi	a5,a5,1024
   1a2e4:	f79ff06f          	j	1a25c <__pack_d+0x6c>
   1a2e8:	7ff00793          	li	a5,2047
   1a2ec:	00000613          	li	a2,0
   1a2f0:	00000693          	li	a3,0
   1a2f4:	f91ff06f          	j	1a284 <__pack_d+0x94>
  if (isnan (src))
    {
      exp = EXPMAX;
      /* Restore the NaN's payload.  */
      fraction >>= NGARDS;
      fraction &= QUIET_NAN - 1;
   1a2f8:	00080737          	lui	a4,0x80

  if (isnan (src))
    {
      exp = EXPMAX;
      /* Restore the NaN's payload.  */
      fraction >>= NGARDS;
   1a2fc:	0086d593          	srli	a1,a3,0x8
      fraction &= QUIET_NAN - 1;
   1a300:	fff70793          	addi	a5,a4,-1 # 7ffff <_gp+0x619bf>
   1a304:	00f5f7b3          	and	a5,a1,a5

  if (isnan (src))
    {
      exp = EXPMAX;
      /* Restore the NaN's payload.  */
      fraction >>= NGARDS;
   1a308:	01869593          	slli	a1,a3,0x18
   1a30c:	00e7e6b3          	or	a3,a5,a4
   1a310:	001007b7          	lui	a5,0x100
   1a314:	fff78793          	addi	a5,a5,-1 # fffff <_gp+0xe19bf>
   1a318:	00865613          	srli	a2,a2,0x8
   1a31c:	00f6f6b3          	and	a3,a3,a5
   1a320:	00c5e633          	or	a2,a1,a2
	  /* Make sure the fraction has a non-zero value.  */
	  if (fraction == 0)
	    fraction |= QUIET_NAN - 1;
#else
	  /* Set the quiet/signaling bit.  */
	  fraction |= QUIET_NAN;
   1a324:	7ff00793          	li	a5,2047
   1a328:	f5dff06f          	j	1a284 <__pack_d+0x94>
	  /* IF the gard bits are the all zero, but the first, then we're
	     half way between two numbers, choose the one which makes the
	     lsb of the answer 0.  */
	  if ((fraction & GARDMASK) == GARDMSB)
	    {
	      if (fraction & (1 << NGARDS))
   1a32c:	10067713          	andi	a4,a2,256
   1a330:	f20700e3          	beqz	a4,1a250 <__pack_d+0x60>
		fraction += GARDROUND + 1;
   1a334:	00b60733          	add	a4,a2,a1
   1a338:	00c73633          	sltu	a2,a4,a2
   1a33c:	00d606b3          	add	a3,a2,a3
   1a340:	00070613          	mv	a2,a4
   1a344:	f0dff06f          	j	1a250 <__pack_d+0x60>
#else /* NO_DENORMALS */
	  /* This number's exponent is too low to fit into the bits
	     available in the number, so we'll store 0 in the exponent and
	     shift the fraction to the right to make up for it.  */

	  int shift = NORMAL_EXPMIN - src->normal_exp;
   1a348:	40f707b3          	sub	a5,a4,a5

	  exp = 0;

	  if (shift > FRAC_NBITS - NGARDS)
   1a34c:	03800713          	li	a4,56
   1a350:	f2f744e3          	blt	a4,a5,1a278 <__pack_d+0x88>
	      fraction = 0;
	    }
	  else
	    {
	      int lowbit = (fraction & (((fractype)1 << shift) - 1)) ? 1 : 0;
	      fraction = (fraction >> shift) | lowbit;
   1a354:	0207f713          	andi	a4,a5,32
   1a358:	0a070663          	beqz	a4,1a404 <__pack_d+0x214>
   1a35c:	00f6d8b3          	srl	a7,a3,a5
   1a360:	00f595b3          	sll	a1,a1,a5
   1a364:	00000713          	li	a4,0
   1a368:	00000793          	li	a5,0
   1a36c:	fff78513          	addi	a0,a5,-1
   1a370:	00f537b3          	sltu	a5,a0,a5
   1a374:	fff58593          	addi	a1,a1,-1
   1a378:	00b785b3          	add	a1,a5,a1
   1a37c:	00d5f6b3          	and	a3,a1,a3
   1a380:	00c577b3          	and	a5,a0,a2
   1a384:	00d7e7b3          	or	a5,a5,a3
   1a388:	00f037b3          	snez	a5,a5
   1a38c:	00f8e633          	or	a2,a7,a5
	    }
	  if ((fraction & GARDMASK) == GARDMSB)
   1a390:	0ff67693          	andi	a3,a2,255
   1a394:	08000793          	li	a5,128
   1a398:	02f69a63          	bne	a3,a5,1a3cc <__pack_d+0x1dc>
	    {
	      if ((fraction & (1 << NGARDS)))
   1a39c:	10067793          	andi	a5,a2,256
   1a3a0:	08079663          	bnez	a5,1a42c <__pack_d+0x23c>
   1a3a4:	01871793          	slli	a5,a4,0x18
   1a3a8:	00865613          	srli	a2,a2,0x8
   1a3ac:	00471693          	slli	a3,a4,0x4
   1a3b0:	100005b7          	lui	a1,0x10000
   1a3b4:	00c7e633          	or	a2,a5,a2
   1a3b8:	00c6d693          	srli	a3,a3,0xc
   1a3bc:	00100793          	li	a5,1
   1a3c0:	02b76c63          	bltu	a4,a1,1a3f8 <__pack_d+0x208>
   1a3c4:	0017f793          	andi	a5,a5,1
   1a3c8:	ebdff06f          	j	1a284 <__pack_d+0x94>
   1a3cc:	07f60793          	addi	a5,a2,127 # fff0007f <_gp+0xffee1a3f>
		fraction += GARDROUND + 1;
   1a3d0:	00c7b633          	sltu	a2,a5,a2
   1a3d4:	00e60733          	add	a4,a2,a4
   1a3d8:	01871593          	slli	a1,a4,0x18
   1a3dc:	0087d613          	srli	a2,a5,0x8
   1a3e0:	00471693          	slli	a3,a4,0x4
   1a3e4:	00c5e633          	or	a2,a1,a2
   1a3e8:	100005b7          	lui	a1,0x10000
   1a3ec:	00c6d693          	srli	a3,a3,0xc
   1a3f0:	00100793          	li	a5,1
   1a3f4:	fcb778e3          	bleu	a1,a4,1a3c4 <__pack_d+0x1d4>
   1a3f8:	00000793          	li	a5,0
   1a3fc:	0017f793          	andi	a5,a5,1
   1a400:	e85ff06f          	j	1a284 <__pack_d+0x94>
	      fraction = 0;
	    }
	  else
	    {
	      int lowbit = (fraction & (((fractype)1 << shift) - 1)) ? 1 : 0;
	      fraction = (fraction >> shift) | lowbit;
   1a404:	fff7c593          	not	a1,a5
   1a408:	00169713          	slli	a4,a3,0x1
   1a40c:	00b71733          	sll	a4,a4,a1
   1a410:	00f658b3          	srl	a7,a2,a5
   1a414:	00100513          	li	a0,1
   1a418:	011768b3          	or	a7,a4,a7
   1a41c:	00000593          	li	a1,0
   1a420:	00f6d733          	srl	a4,a3,a5
   1a424:	00f517b3          	sll	a5,a0,a5
   1a428:	f45ff06f          	j	1a36c <__pack_d+0x17c>
	    }
	  if ((fraction & GARDMASK) == GARDMSB)
	    {
	      if ((fraction & (1 << NGARDS)))
		fraction += GARDROUND + 1;
   1a42c:	08060793          	addi	a5,a2,128
   1a430:	fa1ff06f          	j	1a3d0 <__pack_d+0x1e0>

0001a434 <__unpack_d>:
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
  exp = src->bits.exp;
   1a434:	00655683          	lhu	a3,6(a0)
  sign = src->bits.sign;
   1a438:	00754703          	lbu	a4,7(a0)
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1a43c:	00452803          	lw	a6,4(a0)
  exp = src->bits.exp;
   1a440:	0046d693          	srli	a3,a3,0x4
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1a444:	001007b7          	lui	a5,0x100
  exp = ((int)(src->value_raw >> FRACBITS)) & ((1 << EXPBITS) - 1);
  sign = ((int)(src->value_raw >> (FRACBITS + EXPBITS))) & 1;
# endif
#endif

  dst->sign = sign;
   1a448:	00775613          	srli	a2,a4,0x7
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1a44c:	fff78793          	addi	a5,a5,-1 # fffff <_gp+0xe19bf>
  exp = src->bits.exp;
   1a450:	7ff6f693          	andi	a3,a3,2047
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1a454:	00052703          	lw	a4,0(a0)
   1a458:	00f877b3          	and	a5,a6,a5
  exp = ((int)(src->value_raw >> FRACBITS)) & ((1 << EXPBITS) - 1);
  sign = ((int)(src->value_raw >> (FRACBITS + EXPBITS))) & 1;
# endif
#endif

  dst->sign = sign;
   1a45c:	00c5a223          	sw	a2,4(a1) # 10000004 <_gp+0xffe19c4>
  if (exp == 0)
   1a460:	04069c63          	bnez	a3,1a4b8 <__unpack_d+0x84>
    {
      /* Hmm.  Looks like 0 */
      if (fraction == 0
   1a464:	00f766b3          	or	a3,a4,a5
   1a468:	08068663          	beqz	a3,1a4f4 <__unpack_d+0xc0>
	{
	  /* Zero exponent with nonzero fraction - it's denormalized,
	     so there isn't a leading implicit one - we'll shift it so
	     it gets one.  */
	  dst->normal_exp = exp - EXPBIAS + 1;
	  fraction <<= NGARDS;
   1a46c:	01875693          	srli	a3,a4,0x18
   1a470:	00879793          	slli	a5,a5,0x8
   1a474:	00f6e7b3          	or	a5,a3,a5

	  dst->class = CLASS_NUMBER;
   1a478:	00300693          	li	a3,3
   1a47c:	00d5a023          	sw	a3,0(a1)
	{
	  /* Zero exponent with nonzero fraction - it's denormalized,
	     so there isn't a leading implicit one - we'll shift it so
	     it gets one.  */
	  dst->normal_exp = exp - EXPBIAS + 1;
	  fraction <<= NGARDS;
   1a480:	00871713          	slli	a4,a4,0x8

	  dst->class = CLASS_NUMBER;
   1a484:	c0100693          	li	a3,-1023
#if 1
	  while (fraction < IMPLICIT_1)
   1a488:	10000537          	lui	a0,0x10000
	    {
	      fraction <<= 1;
   1a48c:	01f75613          	srli	a2,a4,0x1f
   1a490:	00179793          	slli	a5,a5,0x1
   1a494:	00f667b3          	or	a5,a2,a5
   1a498:	00171713          	slli	a4,a4,0x1
	      dst->normal_exp--;
   1a49c:	00068613          	mv	a2,a3
   1a4a0:	fff68693          	addi	a3,a3,-1
	  dst->normal_exp = exp - EXPBIAS + 1;
	  fraction <<= NGARDS;

	  dst->class = CLASS_NUMBER;
#if 1
	  while (fraction < IMPLICIT_1)
   1a4a4:	fea7e4e3          	bltu	a5,a0,1a48c <__unpack_d+0x58>
   1a4a8:	00c5a423          	sw	a2,8(a1)
	    {
	      fraction <<= 1;
	      dst->normal_exp--;
	    }
#endif
	  dst->fraction.ll = fraction;
   1a4ac:	00e5a823          	sw	a4,16(a1)
   1a4b0:	00f5aa23          	sw	a5,20(a1)
   1a4b4:	00008067          	ret
	}
    }
  else if (__builtin_expect (exp == EXPMAX, 0))
   1a4b8:	7ff00613          	li	a2,2047
   1a4bc:	04c68263          	beq	a3,a2,1a500 <__unpack_d+0xcc>
  else
    {
      /* Nothing strange about this number */
      dst->normal_exp = exp - EXPBIAS;
      dst->class = CLASS_NUMBER;
      dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;
   1a4c0:	01875613          	srli	a2,a4,0x18
   1a4c4:	00879793          	slli	a5,a5,0x8
   1a4c8:	00f667b3          	or	a5,a2,a5
	}
    }
  else
    {
      /* Nothing strange about this number */
      dst->normal_exp = exp - EXPBIAS;
   1a4cc:	c0168693          	addi	a3,a3,-1023
      dst->class = CLASS_NUMBER;
      dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;
   1a4d0:	10000637          	lui	a2,0x10000
   1a4d4:	00871713          	slli	a4,a4,0x8
   1a4d8:	00c7e7b3          	or	a5,a5,a2
	}
    }
  else
    {
      /* Nothing strange about this number */
      dst->normal_exp = exp - EXPBIAS;
   1a4dc:	00d5a423          	sw	a3,8(a1)
      dst->class = CLASS_NUMBER;
   1a4e0:	00300693          	li	a3,3
   1a4e4:	00d5a023          	sw	a3,0(a1)
      dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;
   1a4e8:	00e5a823          	sw	a4,16(a1)
   1a4ec:	00f5aa23          	sw	a5,20(a1)
   1a4f0:	00008067          	ret
	  || 1
#endif
	  )
	{
	  /* tastes like zero */
	  dst->class = CLASS_ZERO;
   1a4f4:	00200793          	li	a5,2
   1a4f8:	00f5a023          	sw	a5,0(a1)
   1a4fc:	00008067          	ret
	}
    }
  else if (__builtin_expect (exp == EXPMAX, 0))
    {
      /* Huge exponent*/
      if (fraction == 0)
   1a500:	00f766b3          	or	a3,a4,a5
   1a504:	02068e63          	beqz	a3,1a540 <__unpack_d+0x10c>
	{
	  /* Nonzero fraction, means nan */
#ifdef QUIET_NAN_NEGATED
	  if ((fraction & QUIET_NAN) == 0)
#else
	  if (fraction & QUIET_NAN)
   1a508:	00c79693          	slli	a3,a5,0xc
   1a50c:	0406d063          	bgez	a3,1a54c <__unpack_d+0x118>
#endif
	    {
	      dst->class = CLASS_QNAN;
   1a510:	00100693          	li	a3,1
   1a514:	00d5a023          	sw	a3,0(a1)
	      dst->class = CLASS_SNAN;
	    }
	  /* Now that we know which kind of NaN we got, discard the
	     quiet/signaling bit, but do preserve the NaN payload.  */
	  fraction &= ~QUIET_NAN;
	  dst->fraction.ll = fraction << NGARDS;
   1a518:	fff806b7          	lui	a3,0xfff80
   1a51c:	fff68693          	addi	a3,a3,-1 # fff7ffff <_gp+0xfff619bf>
   1a520:	00d7f7b3          	and	a5,a5,a3
   1a524:	00879793          	slli	a5,a5,0x8
   1a528:	01875693          	srli	a3,a4,0x18
   1a52c:	00d7e7b3          	or	a5,a5,a3
   1a530:	00871713          	slli	a4,a4,0x8
   1a534:	00f5aa23          	sw	a5,20(a1)
   1a538:	00e5a823          	sw	a4,16(a1)
   1a53c:	00008067          	ret
    {
      /* Huge exponent*/
      if (fraction == 0)
	{
	  /* Attached to a zero fraction - means infinity */
	  dst->class = CLASS_INFINITY;
   1a540:	00400793          	li	a5,4
   1a544:	00f5a023          	sw	a5,0(a1)
   1a548:	00008067          	ret
	    {
	      dst->class = CLASS_QNAN;
	    }
	  else
	    {
	      dst->class = CLASS_SNAN;
   1a54c:	0005a023          	sw	zero,0(a1)
   1a550:	fc9ff06f          	j	1a518 <__unpack_d+0xe4>

0001a554 <__adddf3>:
  return tmp;
}

FLO_type
add (FLO_type arg_a, FLO_type arg_b)
{
   1a554:	f9010113          	addi	sp,sp,-112
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1a558:	00a12423          	sw	a0,8(sp)
   1a55c:	00b12623          	sw	a1,12(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1a560:	00810513          	addi	a0,sp,8
   1a564:	01810593          	addi	a1,sp,24
  return tmp;
}

FLO_type
add (FLO_type arg_a, FLO_type arg_b)
{
   1a568:	06112623          	sw	ra,108(sp)
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1a56c:	00d12a23          	sw	a3,20(sp)
   1a570:	00c12823          	sw	a2,16(sp)

  unpack_d (&au, &a);
   1a574:	ec1ff0ef          	jal	1a434 <__unpack_d>
  unpack_d (&bu, &b);
   1a578:	03010593          	addi	a1,sp,48
   1a57c:	01010513          	addi	a0,sp,16
   1a580:	eb5ff0ef          	jal	1a434 <__unpack_d>

  res = _fpadd_parts (&a, &b, &tmp);
   1a584:	04810613          	addi	a2,sp,72
   1a588:	03010593          	addi	a1,sp,48
   1a58c:	01810513          	addi	a0,sp,24
   1a590:	911ff0ef          	jal	19ea0 <_fpadd_parts>

  return pack_d (res);
   1a594:	c5dff0ef          	jal	1a1f0 <__pack_d>
}
   1a598:	06c12083          	lw	ra,108(sp)
   1a59c:	07010113          	addi	sp,sp,112
   1a5a0:	00008067          	ret

0001a5a4 <__subdf3>:

FLO_type
sub (FLO_type arg_a, FLO_type arg_b)
{
   1a5a4:	f9010113          	addi	sp,sp,-112
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1a5a8:	00a12423          	sw	a0,8(sp)
   1a5ac:	00b12623          	sw	a1,12(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1a5b0:	00810513          	addi	a0,sp,8
   1a5b4:	01810593          	addi	a1,sp,24
  return pack_d (res);
}

FLO_type
sub (FLO_type arg_a, FLO_type arg_b)
{
   1a5b8:	06112623          	sw	ra,108(sp)
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1a5bc:	00d12a23          	sw	a3,20(sp)
   1a5c0:	00c12823          	sw	a2,16(sp)

  unpack_d (&au, &a);
   1a5c4:	e71ff0ef          	jal	1a434 <__unpack_d>
  unpack_d (&bu, &b);
   1a5c8:	03010593          	addi	a1,sp,48
   1a5cc:	01010513          	addi	a0,sp,16
   1a5d0:	e65ff0ef          	jal	1a434 <__unpack_d>

  b.sign ^= 1;
   1a5d4:	03412783          	lw	a5,52(sp)

  res = _fpadd_parts (&a, &b, &tmp);
   1a5d8:	04810613          	addi	a2,sp,72
   1a5dc:	03010593          	addi	a1,sp,48
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  b.sign ^= 1;
   1a5e0:	0017c793          	xori	a5,a5,1

  res = _fpadd_parts (&a, &b, &tmp);
   1a5e4:	01810513          	addi	a0,sp,24
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  b.sign ^= 1;
   1a5e8:	02f12a23          	sw	a5,52(sp)

  res = _fpadd_parts (&a, &b, &tmp);
   1a5ec:	8b5ff0ef          	jal	19ea0 <_fpadd_parts>

  return pack_d (res);
   1a5f0:	c01ff0ef          	jal	1a1f0 <__pack_d>
}
   1a5f4:	06c12083          	lw	ra,108(sp)
   1a5f8:	07010113          	addi	sp,sp,112
   1a5fc:	00008067          	ret

0001a600 <__muldf3>:
  return tmp;
}

FLO_type
multiply (FLO_type arg_a, FLO_type arg_b)
{
   1a600:	f9010113          	addi	sp,sp,-112
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1a604:	00a12423          	sw	a0,8(sp)
   1a608:	00b12623          	sw	a1,12(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1a60c:	00810513          	addi	a0,sp,8
   1a610:	01810593          	addi	a1,sp,24
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1a614:	00d12a23          	sw	a3,20(sp)
  return tmp;
}

FLO_type
multiply (FLO_type arg_a, FLO_type arg_b)
{
   1a618:	06112623          	sw	ra,108(sp)
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1a61c:	00c12823          	sw	a2,16(sp)

  unpack_d (&au, &a);
   1a620:	e15ff0ef          	jal	1a434 <__unpack_d>
  unpack_d (&bu, &b);
   1a624:	03010593          	addi	a1,sp,48
   1a628:	01010513          	addi	a0,sp,16
   1a62c:	e09ff0ef          	jal	1a434 <__unpack_d>
   1a630:	01812783          	lw	a5,24(sp)
	       fp_number_type * tmp)
{
  fractype low = 0;
  fractype high = 0;

  if (isnan (a))
   1a634:	00100693          	li	a3,1
   1a638:	16f6fc63          	bleu	a5,a3,1a7b0 <__muldf3+0x1b0>
   1a63c:	03012703          	lw	a4,48(sp)
    {
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isnan (b))
   1a640:	14e6f063          	bleu	a4,a3,1a780 <__muldf3+0x180>
    {
      b->sign = a->sign != b->sign;
      return b;
    }
  if (isinf (a))
   1a644:	00400693          	li	a3,4
   1a648:	16d78063          	beq	a5,a3,1a7a8 <__muldf3+0x1a8>
      if (iszero (b))
	return makenan ();
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isinf (b))
   1a64c:	12d70663          	beq	a4,a3,1a778 <__muldf3+0x178>
	  return makenan ();
	}
      b->sign = a->sign != b->sign;
      return b;
    }
  if (iszero (a))
   1a650:	00200693          	li	a3,2
   1a654:	14d78e63          	beq	a5,a3,1a7b0 <__muldf3+0x1b0>
    {
      a->sign = a->sign != b->sign;
      return a;
    }
  if (iszero (b))
   1a658:	12d70463          	beq	a4,a3,1a780 <__muldf3+0x180>
#else
    /* fractype is DImode, but we need the result to be twice as wide.
       Assuming a widening multiply from DImode to TImode is not
       available, build one by hand.  */
    {
      USItype nl = a->fraction.ll;
   1a65c:	02812503          	lw	a0,40(sp)
   1a660:	02c12703          	lw	a4,44(sp)
      USItype nh = a->fraction.ll >> BITS_PER_SI;
      USItype ml = b->fraction.ll;
   1a664:	04012783          	lw	a5,64(sp)
   1a668:	04412803          	lw	a6,68(sp)
      UDItype pp_hl = (UDItype) mh * nl;
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
      UDItype res2 = 0;
      UDItype res0 = 0;
      UDItype ps_hh__ = pp_hl + pp_lh;
   1a66c:	02f70633          	mul	a2,a4,a5
      USItype nl = a->fraction.ll;
      USItype nh = a->fraction.ll >> BITS_PER_SI;
      USItype ml = b->fraction.ll;
      USItype mh = b->fraction.ll >> BITS_PER_SI;
      UDItype pp_ll = (UDItype) ml * nl;
      UDItype pp_hl = (UDItype) mh * nl;
   1a670:	02a803b3          	mul	t2,a6,a0
   1a674:	02a832b3          	mulhu	t0,a6,a0
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
      UDItype res2 = 0;
      UDItype res0 = 0;
      UDItype ps_hh__ = pp_hl + pp_lh;
   1a678:	00760333          	add	t1,a2,t2
   1a67c:	00c33633          	sltu	a2,t1,a2
   1a680:	02f735b3          	mulhu	a1,a4,a5
   1a684:	005585b3          	add	a1,a1,t0
   1a688:	00b60633          	add	a2,a2,a1
      USItype ml = b->fraction.ll;
      USItype mh = b->fraction.ll >> BITS_PER_SI;
      UDItype pp_ll = (UDItype) ml * nl;
      UDItype pp_hl = (UDItype) mh * nl;
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
   1a68c:	030708b3          	mul	a7,a4,a6
    {
      USItype nl = a->fraction.ll;
      USItype nh = a->fraction.ll >> BITS_PER_SI;
      USItype ml = b->fraction.ll;
      USItype mh = b->fraction.ll >> BITS_PER_SI;
      UDItype pp_ll = (UDItype) ml * nl;
   1a690:	02a785b3          	mul	a1,a5,a0
      UDItype pp_hl = (UDItype) mh * nl;
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
   1a694:	03073833          	mulhu	a6,a4,a6
    {
      USItype nl = a->fraction.ll;
      USItype nh = a->fraction.ll >> BITS_PER_SI;
      USItype ml = b->fraction.ll;
      USItype mh = b->fraction.ll >> BITS_PER_SI;
      UDItype pp_ll = (UDItype) ml * nl;
   1a698:	02a7b533          	mulhu	a0,a5,a0
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
      UDItype res2 = 0;
      UDItype res0 = 0;
      UDItype ps_hh__ = pp_hl + pp_lh;
      if (ps_hh__ < pp_hl)
   1a69c:	14566063          	bltu	a2,t0,1a7dc <__muldf3+0x1dc>
   1a6a0:	12c28c63          	beq	t0,a2,1a7d8 <__muldf3+0x1d8>
      USItype mh = b->fraction.ll >> BITS_PER_SI;
      UDItype pp_ll = (UDItype) ml * nl;
      UDItype pp_hl = (UDItype) mh * nl;
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
      UDItype res2 = 0;
   1a6a4:	00000793          	li	a5,0
   1a6a8:	00000713          	li	a4,0
      UDItype res0 = 0;
      UDItype ps_hh__ = pp_hl + pp_lh;
      if (ps_hh__ < pp_hl)
	res2 += (UDItype)1 << BITS_PER_SI;
      pp_hl = (UDItype)(USItype)ps_hh__ << BITS_PER_SI;
      res0 = pp_ll + pp_hl;
   1a6ac:	00a306b3          	add	a3,t1,a0
      if (res0 < pp_ll)
   1a6b0:	00a6f463          	bleu	a0,a3,1a6b8 <__muldf3+0xb8>
	res2++;
   1a6b4:	00100793          	li	a5,1
      res2 += (ps_hh__ >> BITS_PER_SI) + pp_hh;
   1a6b8:	011608b3          	add	a7,a2,a7
   1a6bc:	00c8b533          	sltu	a0,a7,a2
   1a6c0:	01050833          	add	a6,a0,a6
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1a6c4:	02012603          	lw	a2,32(sp)
   1a6c8:	03812503          	lw	a0,56(sp)
	res2 += (UDItype)1 << BITS_PER_SI;
      pp_hl = (UDItype)(USItype)ps_hh__ << BITS_PER_SI;
      res0 = pp_ll + pp_hl;
      if (res0 < pp_ll)
	res2++;
      res2 += (ps_hh__ >> BITS_PER_SI) + pp_hh;
   1a6cc:	00f887b3          	add	a5,a7,a5
   1a6d0:	0117b8b3          	sltu	a7,a5,a7
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1a6d4:	00a60533          	add	a0,a2,a0
	res2 += (UDItype)1 << BITS_PER_SI;
      pp_hl = (UDItype)(USItype)ps_hh__ << BITS_PER_SI;
      res0 = pp_ll + pp_hl;
      if (res0 < pp_ll)
	res2++;
      res2 += (ps_hh__ >> BITS_PER_SI) + pp_hh;
   1a6d8:	00e80633          	add	a2,a6,a4
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
   1a6dc:	01c12703          	lw	a4,28(sp)
   1a6e0:	03412803          	lw	a6,52(sp)
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1a6e4:	00450293          	addi	t0,a0,4 # 10000004 <_gp+0xffe19c4>
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
  while (high >= IMPLICIT_2)
   1a6e8:	200003b7          	lui	t2,0x20000
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
   1a6ec:	41070833          	sub	a6,a4,a6
   1a6f0:	01003833          	snez	a6,a6
	res2 += (UDItype)1 << BITS_PER_SI;
      pp_hl = (UDItype)(USItype)ps_hh__ << BITS_PER_SI;
      res0 = pp_ll + pp_hl;
      if (res0 < pp_ll)
	res2++;
      res2 += (ps_hh__ >> BITS_PER_SI) + pp_hh;
   1a6f4:	00c88733          	add	a4,a7,a2
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1a6f8:	04512823          	sw	t0,80(sp)
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
   1a6fc:	05012623          	sw	a6,76(sp)
   1a700:	00550613          	addi	a2,a0,5
    {
      tmp->normal_exp++;
      if (high & 1)
	{
	  low >>= 1;
	  low |= FRACHIGH;
   1a704:	80000eb7          	lui	t4,0x80000
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
  while (high >= IMPLICIT_2)
   1a708:	10776863          	bltu	a4,t2,1a818 <__muldf3+0x218>
    {
      tmp->normal_exp++;
      if (high & 1)
   1a70c:	0017f813          	andi	a6,a5,1
	{
	  low >>= 1;
	  low |= FRACHIGH;
	}
      high >>= 1;
   1a710:	01f71513          	slli	a0,a4,0x1f
   1a714:	0017d793          	srli	a5,a5,0x1
   1a718:	00175713          	srli	a4,a4,0x1
  while (high >= IMPLICIT_2)
    {
      tmp->normal_exp++;
      if (high & 1)
	{
	  low >>= 1;
   1a71c:	01f69313          	slli	t1,a3,0x1f
   1a720:	0015d293          	srli	t0,a1,0x1
   1a724:	0016d893          	srli	a7,a3,0x1
  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
  while (high >= IMPLICIT_2)
    {
      tmp->normal_exp++;
   1a728:	00060e13          	mv	t3,a2
      if (high & 1)
   1a72c:	00080663          	beqz	a6,1a738 <__muldf3+0x138>
	{
	  low >>= 1;
	  low |= FRACHIGH;
   1a730:	005365b3          	or	a1,t1,t0
   1a734:	01d8e6b3          	or	a3,a7,t4
	}
      high >>= 1;
   1a738:	00f567b3          	or	a5,a0,a5
   1a73c:	00160613          	addi	a2,a2,1 # 10000001 <_gp+0xffe19c1>
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
  while (high >= IMPLICIT_2)
   1a740:	fc7776e3          	bleu	t2,a4,1a70c <__muldf3+0x10c>
   1a744:	05c12823          	sw	t3,80(sp)
      if (low & FRACHIGH)
	high |= 1;
      low <<= 1;
    }

  if ((high & GARDMASK) == GARDMSB)
   1a748:	0ff7f613          	andi	a2,a5,255
   1a74c:	08000513          	li	a0,128
   1a750:	08a60c63          	beq	a2,a0,1a7e8 <__muldf3+0x1e8>

	  /* Avoid further rounding in pack_d.  */
	  high &= ~(fractype) GARDMASK;
	}
    }
  tmp->fraction.ll = high;
   1a754:	04f12c23          	sw	a5,88(sp)
  tmp->class = CLASS_NUMBER;
   1a758:	00300793          	li	a5,3

	  /* Avoid further rounding in pack_d.  */
	  high &= ~(fractype) GARDMASK;
	}
    }
  tmp->fraction.ll = high;
   1a75c:	04e12e23          	sw	a4,92(sp)
  tmp->class = CLASS_NUMBER;
   1a760:	04f12423          	sw	a5,72(sp)
  return tmp;
   1a764:	04810513          	addi	a0,sp,72
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
   1a768:	a89ff0ef          	jal	1a1f0 <__pack_d>
}
   1a76c:	06c12083          	lw	ra,108(sp)
   1a770:	07010113          	addi	sp,sp,112
   1a774:	00008067          	ret
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isinf (b))
    {
      if (iszero (a))
   1a778:	00200713          	li	a4,2
   1a77c:	08e78863          	beq	a5,a4,1a80c <__muldf3+0x20c>
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isnan (b))
    {
      b->sign = a->sign != b->sign;
   1a780:	03412703          	lw	a4,52(sp)
   1a784:	01c12783          	lw	a5,28(sp)
      return b;
   1a788:	03010513          	addi	a0,sp,48
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isnan (b))
    {
      b->sign = a->sign != b->sign;
   1a78c:	40e787b3          	sub	a5,a5,a4
   1a790:	00f037b3          	snez	a5,a5
   1a794:	02f12a23          	sw	a5,52(sp)
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
   1a798:	a59ff0ef          	jal	1a1f0 <__pack_d>
}
   1a79c:	06c12083          	lw	ra,108(sp)
   1a7a0:	07010113          	addi	sp,sp,112
   1a7a4:	00008067          	ret
      b->sign = a->sign != b->sign;
      return b;
    }
  if (isinf (a))
    {
      if (iszero (b))
   1a7a8:	00200793          	li	a5,2
   1a7ac:	06f70063          	beq	a4,a5,1a80c <__muldf3+0x20c>
  fractype low = 0;
  fractype high = 0;

  if (isnan (a))
    {
      a->sign = a->sign != b->sign;
   1a7b0:	03412703          	lw	a4,52(sp)
   1a7b4:	01c12783          	lw	a5,28(sp)
      return a;
   1a7b8:	01810513          	addi	a0,sp,24
  fractype low = 0;
  fractype high = 0;

  if (isnan (a))
    {
      a->sign = a->sign != b->sign;
   1a7bc:	40e787b3          	sub	a5,a5,a4
   1a7c0:	00f037b3          	snez	a5,a5
   1a7c4:	00f12e23          	sw	a5,28(sp)
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
   1a7c8:	a29ff0ef          	jal	1a1f0 <__pack_d>
}
   1a7cc:	06c12083          	lw	ra,108(sp)
   1a7d0:	07010113          	addi	sp,sp,112
   1a7d4:	00008067          	ret
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
      UDItype res2 = 0;
      UDItype res0 = 0;
      UDItype ps_hh__ = pp_hl + pp_lh;
      if (ps_hh__ < pp_hl)
   1a7d8:	ec7376e3          	bleu	t2,t1,1a6a4 <__muldf3+0xa4>
	res2 += (UDItype)1 << BITS_PER_SI;
   1a7dc:	00000793          	li	a5,0
   1a7e0:	00100713          	li	a4,1
   1a7e4:	ec9ff06f          	j	1a6ac <__muldf3+0xac>
      low <<= 1;
    }

  if ((high & GARDMASK) == GARDMSB)
    {
      if (high & (1 << NGARDS))
   1a7e8:	1007f613          	andi	a2,a5,256
   1a7ec:	f60614e3          	bnez	a2,1a754 <__muldf3+0x154>
	     function, and rounding twice will lose precision and cause
	     the result to be too far off.  Example: 32-bit floats with
	     bit patterns 0xfff * 0x3f800400 ~= 0xfff (less than 0.5ulp
	     off), not 0x1000 (more than 0.5ulp off).  */
	}
      else if (low)
   1a7f0:	00d5e6b3          	or	a3,a1,a3
   1a7f4:	f60680e3          	beqz	a3,1a754 <__muldf3+0x154>
	{
	  /* We're a further than half way by a small amount corresponding
	     to the bits set in "low".  Knowing that, we round here and
	     not in pack_d, because there we don't have "low" available
	     anymore.  */
	  high += GARDROUND + 1;
   1a7f8:	00a786b3          	add	a3,a5,a0
   1a7fc:	00f6b7b3          	sltu	a5,a3,a5

	  /* Avoid further rounding in pack_d.  */
	  high &= ~(fractype) GARDMASK;
   1a800:	00e78733          	add	a4,a5,a4
   1a804:	f006f793          	andi	a5,a3,-256
   1a808:	f4dff06f          	j	1a754 <__muldf3+0x154>
      return b;
    }
  if (isinf (a))
    {
      if (iszero (b))
	return makenan ();
   1a80c:	0001c537          	lui	a0,0x1c
   1a810:	0f850513          	addi	a0,a0,248 # 1c0f8 <__thenan_df>
   1a814:	f55ff06f          	j	1a768 <__muldf3+0x168>
	  low >>= 1;
	  low |= FRACHIGH;
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
   1a818:	10000337          	lui	t1,0x10000
   1a81c:	00350513          	addi	a0,a0,3
   1a820:	f26774e3          	bleu	t1,a4,1a748 <__muldf3+0x148>
    {
      tmp->normal_exp--;

      high <<= 1;
   1a824:	01f7d813          	srli	a6,a5,0x1f
   1a828:	00171613          	slli	a2,a4,0x1
   1a82c:	00c86633          	or	a2,a6,a2
      if (low & FRACHIGH)
	high |= 1;
      low <<= 1;
   1a830:	01f5d893          	srli	a7,a1,0x1f
   1a834:	00169813          	slli	a6,a3,0x1
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
    {
      tmp->normal_exp--;
   1a838:	00050293          	mv	t0,a0

      high <<= 1;
   1a83c:	00179793          	slli	a5,a5,0x1
   1a840:	00060713          	mv	a4,a2
      if (low & FRACHIGH)
   1a844:	0006d463          	bgez	a3,1a84c <__muldf3+0x24c>
	high |= 1;
   1a848:	0017e793          	ori	a5,a5,1
      low <<= 1;
   1a84c:	00159593          	slli	a1,a1,0x1
   1a850:	0108e6b3          	or	a3,a7,a6
   1a854:	fff50513          	addi	a0,a0,-1
	  low >>= 1;
	  low |= FRACHIGH;
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
   1a858:	fc6666e3          	bltu	a2,t1,1a824 <__muldf3+0x224>
   1a85c:	04512823          	sw	t0,80(sp)
   1a860:	ee9ff06f          	j	1a748 <__muldf3+0x148>

0001a864 <__divdf3>:
  }
}

FLO_type
divide (FLO_type arg_a, FLO_type arg_b)
{
   1a864:	fb010113          	addi	sp,sp,-80
  fp_number_type a;
  fp_number_type b;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1a868:	00a12023          	sw	a0,0(sp)
   1a86c:	00b12223          	sw	a1,4(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1a870:	00010513          	mv	a0,sp
   1a874:	01010593          	addi	a1,sp,16
  fp_number_type b;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1a878:	00c12423          	sw	a2,8(sp)
  }
}

FLO_type
divide (FLO_type arg_a, FLO_type arg_b)
{
   1a87c:	04112623          	sw	ra,76(sp)
  fp_number_type b;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1a880:	00d12623          	sw	a3,12(sp)

  unpack_d (&au, &a);
   1a884:	bb1ff0ef          	jal	1a434 <__unpack_d>
  unpack_d (&bu, &b);
   1a888:	02810593          	addi	a1,sp,40
   1a88c:	00810513          	addi	a0,sp,8
   1a890:	ba5ff0ef          	jal	1a434 <__unpack_d>
   1a894:	01012603          	lw	a2,16(sp)
  fractype bit;
  fractype numerator;
  fractype denominator;
  fractype quotient;

  if (isnan (a))
   1a898:	00100793          	li	a5,1
   1a89c:	0ec7fa63          	bleu	a2,a5,1a990 <__divdf3+0x12c>
   1a8a0:	02812683          	lw	a3,40(sp)
    {
      return a;
    }
  if (isnan (b))
   1a8a4:	14d7fe63          	bleu	a3,a5,1aa00 <__divdf3+0x19c>
    {
      return b;
    }

  a->sign = a->sign ^ b->sign;
   1a8a8:	01412583          	lw	a1,20(sp)
   1a8ac:	02c12703          	lw	a4,44(sp)

  if (isinf (a) || iszero (a))
   1a8b0:	ffe60793          	addi	a5,a2,-2
   1a8b4:	ffd7f793          	andi	a5,a5,-3
  if (isnan (b))
    {
      return b;
    }

  a->sign = a->sign ^ b->sign;
   1a8b8:	00e5c733          	xor	a4,a1,a4
   1a8bc:	00e12a23          	sw	a4,20(sp)

  if (isinf (a) || iszero (a))
   1a8c0:	0e078263          	beqz	a5,1a9a4 <__divdf3+0x140>
      if (a->class == b->class)
	return makenan ();
      return a;
    }

  if (isinf (b))
   1a8c4:	00400793          	li	a5,4
   1a8c8:	0ef68663          	beq	a3,a5,1a9b4 <__divdf3+0x150>
    {
      a->fraction.ll = 0;
      a->normal_exp = 0;
      return a;
    }
  if (iszero (b))
   1a8cc:	00200713          	li	a4,2
   1a8d0:	12e68263          	beq	a3,a4,1a9f4 <__divdf3+0x190>
  {
    /* quotient =
       ( numerator / denominator) * 2^(numerator exponent -  denominator exponent)
     */

    a->normal_exp = a->normal_exp - b->normal_exp;
   1a8d4:	01812703          	lw	a4,24(sp)
   1a8d8:	03012603          	lw	a2,48(sp)
    numerator = a->fraction.ll;
   1a8dc:	02412783          	lw	a5,36(sp)
    denominator = b->fraction.ll;
   1a8e0:	03c12883          	lw	a7,60(sp)
  {
    /* quotient =
       ( numerator / denominator) * 2^(numerator exponent -  denominator exponent)
     */

    a->normal_exp = a->normal_exp - b->normal_exp;
   1a8e4:	40c70633          	sub	a2,a4,a2
   1a8e8:	00c12c23          	sw	a2,24(sp)
    numerator = a->fraction.ll;
   1a8ec:	02012683          	lw	a3,32(sp)
    denominator = b->fraction.ll;
   1a8f0:	03812f03          	lw	t5,56(sp)

    if (numerator < denominator)
   1a8f4:	0117e663          	bltu	a5,a7,1a900 <__divdf3+0x9c>
   1a8f8:	02f89063          	bne	a7,a5,1a918 <__divdf3+0xb4>
   1a8fc:	01e6fe63          	bleu	t5,a3,1a918 <__divdf3+0xb4>
      {
	/* Fraction will be less than 1.0 */
	numerator *= 2;
   1a900:	01f6d593          	srli	a1,a3,0x1f
   1a904:	00179713          	slli	a4,a5,0x1
	a->normal_exp--;
   1a908:	fff60613          	addi	a2,a2,-1
    denominator = b->fraction.ll;

    if (numerator < denominator)
      {
	/* Fraction will be less than 1.0 */
	numerator *= 2;
   1a90c:	00e5e7b3          	or	a5,a1,a4
   1a910:	00169693          	slli	a3,a3,0x1
	a->normal_exp--;
   1a914:	00c12c23          	sw	a2,24(sp)
  }
}

FLO_type
divide (FLO_type arg_a, FLO_type arg_b)
{
   1a918:	03d00513          	li	a0,61
	/* Fraction will be less than 1.0 */
	numerator *= 2;
	a->normal_exp--;
      }
    bit = IMPLICIT_1;
    quotient = 0;
   1a91c:	00000393          	li	t2,0
   1a920:	00000e13          	li	t3,0
      {
	/* Fraction will be less than 1.0 */
	numerator *= 2;
	a->normal_exp--;
      }
    bit = IMPLICIT_1;
   1a924:	00000813          	li	a6,0
   1a928:	100005b7          	lui	a1,0x10000
	if (numerator >= denominator)
	  {
	    quotient |= bit;
	    numerator -= denominator;
	  }
	bit >>= 1;
   1a92c:	01f59313          	slli	t1,a1,0x1f
   1a930:	00185293          	srli	t0,a6,0x1
   1a934:	fff50513          	addi	a0,a0,-1
    bit = IMPLICIT_1;
    quotient = 0;
    /* ??? Does divide one bit at a time.  Optimize.  */
    while (bit)
      {
	if (numerator >= denominator)
   1a938:	0317e463          	bltu	a5,a7,1a960 <__divdf3+0xfc>
	  {
	    quotient |= bit;
	    numerator -= denominator;
   1a93c:	41e68733          	sub	a4,a3,t5
   1a940:	00e6b633          	sltu	a2,a3,a4
   1a944:	41178eb3          	sub	t4,a5,a7
    bit = IMPLICIT_1;
    quotient = 0;
    /* ??? Does divide one bit at a time.  Optimize.  */
    while (bit)
      {
	if (numerator >= denominator)
   1a948:	00f89463          	bne	a7,a5,1a950 <__divdf3+0xec>
   1a94c:	01e6ea63          	bltu	a3,t5,1a960 <__divdf3+0xfc>
	  {
	    quotient |= bit;
	    numerator -= denominator;
   1a950:	00070693          	mv	a3,a4
   1a954:	40ce87b3          	sub	a5,t4,a2
    /* ??? Does divide one bit at a time.  Optimize.  */
    while (bit)
      {
	if (numerator >= denominator)
	  {
	    quotient |= bit;
   1a958:	0103e3b3          	or	t2,t2,a6
   1a95c:	00be6e33          	or	t3,t3,a1
	    numerator -= denominator;
	  }
	bit >>= 1;
	numerator *= 2;
   1a960:	01f6d613          	srli	a2,a3,0x1f
   1a964:	00179713          	slli	a4,a5,0x1
	if (numerator >= denominator)
	  {
	    quotient |= bit;
	    numerator -= denominator;
	  }
	bit >>= 1;
   1a968:	00536833          	or	a6,t1,t0
   1a96c:	0015d593          	srli	a1,a1,0x1
	numerator *= 2;
   1a970:	00e667b3          	or	a5,a2,a4
   1a974:	00169693          	slli	a3,a3,0x1
	a->normal_exp--;
      }
    bit = IMPLICIT_1;
    quotient = 0;
    /* ??? Does divide one bit at a time.  Optimize.  */
    while (bit)
   1a978:	fa051ae3          	bnez	a0,1a92c <__divdf3+0xc8>
	  }
	bit >>= 1;
	numerator *= 2;
      }

    if ((quotient & GARDMASK) == GARDMSB)
   1a97c:	0ff3f713          	andi	a4,t2,255
   1a980:	08000613          	li	a2,128
   1a984:	04c70663          	beq	a4,a2,1a9d0 <__divdf3+0x16c>
	    /* Avoid further rounding in pack_d.  */
	    quotient &= ~(fractype) GARDMASK;
	  }
      }

    a->fraction.ll = quotient;
   1a988:	02712023          	sw	t2,32(sp)
   1a98c:	03c12223          	sw	t3,36(sp)
    return (a);
   1a990:	01010513          	addi	a0,sp,16
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpdiv_parts (&a, &b);

  return pack_d (res);
   1a994:	85dff0ef          	jal	1a1f0 <__pack_d>
}
   1a998:	04c12083          	lw	ra,76(sp)
   1a99c:	05010113          	addi	sp,sp,80
   1a9a0:	00008067          	ret

  a->sign = a->sign ^ b->sign;

  if (isinf (a) || iszero (a))
    {
      if (a->class == b->class)
   1a9a4:	fed616e3          	bne	a2,a3,1a990 <__divdf3+0x12c>
	return makenan ();
   1a9a8:	0001c537          	lui	a0,0x1c
   1a9ac:	0f850513          	addi	a0,a0,248 # 1c0f8 <__thenan_df>
   1a9b0:	fe5ff06f          	j	1a994 <__divdf3+0x130>
      return a;
    }

  if (isinf (b))
    {
      a->fraction.ll = 0;
   1a9b4:	00000713          	li	a4,0
   1a9b8:	00000793          	li	a5,0
   1a9bc:	02e12023          	sw	a4,32(sp)
   1a9c0:	02f12223          	sw	a5,36(sp)
      a->normal_exp = 0;
   1a9c4:	00012c23          	sw	zero,24(sp)
      return a;
   1a9c8:	01010513          	addi	a0,sp,16
   1a9cc:	fc9ff06f          	j	1a994 <__divdf3+0x130>
	numerator *= 2;
      }

    if ((quotient & GARDMASK) == GARDMSB)
      {
	if (quotient & (1 << NGARDS))
   1a9d0:	1003f713          	andi	a4,t2,256
   1a9d4:	fa071ae3          	bnez	a4,1a988 <__divdf3+0x124>
	    /* Because we're half way, we would round to even by adding
	       GARDROUND + 1, except that's also done in the packing
	       function, and rounding twice will lose precision and cause
	       the result to be too far off.  */
	  }
	else if (numerator)
   1a9d8:	00f6e7b3          	or	a5,a3,a5
   1a9dc:	fa0786e3          	beqz	a5,1a988 <__divdf3+0x124>
	  {
	    /* We're a further than half way by the small amount
	       corresponding to the bits set in "numerator".  Knowing
	       that, we round here and not in pack_d, because there we
	       don't have "numerator" available anymore.  */
	    quotient += GARDROUND + 1;
   1a9e0:	00c387b3          	add	a5,t2,a2
   1a9e4:	0077b3b3          	sltu	t2,a5,t2

	    /* Avoid further rounding in pack_d.  */
	    quotient &= ~(fractype) GARDMASK;
   1a9e8:	01c38e33          	add	t3,t2,t3
   1a9ec:	f007f393          	andi	t2,a5,-256
   1a9f0:	f99ff06f          	j	1a988 <__divdf3+0x124>
      a->normal_exp = 0;
      return a;
    }
  if (iszero (b))
    {
      a->class = CLASS_INFINITY;
   1a9f4:	00f12823          	sw	a5,16(sp)
      return a;
   1a9f8:	01010513          	addi	a0,sp,16
   1a9fc:	f99ff06f          	j	1a994 <__divdf3+0x130>
    {
      return a;
    }
  if (isnan (b))
    {
      return b;
   1aa00:	02810513          	addi	a0,sp,40
   1aa04:	f91ff06f          	j	1a994 <__divdf3+0x130>

0001aa08 <__fpcmp_parts_d>:
   a>b -> +1
 */

int
__fpcmp_parts (fp_number_type * a, fp_number_type * b)
{
   1aa08:	00052703          	lw	a4,0(a0)
    {
      return 1;			/* still unordered! */
    }
#endif

  if (isnan (a) || isnan (b))
   1aa0c:	00100793          	li	a5,1
   a>b -> +1
 */

int
__fpcmp_parts (fp_number_type * a, fp_number_type * b)
{
   1aa10:	00050613          	mv	a2,a0
    {
      return 1;			/* still unordered! */
    }
#endif

  if (isnan (a) || isnan (b))
   1aa14:	08e7f263          	bleu	a4,a5,1aa98 <__fpcmp_parts_d+0x90>
   1aa18:	0005a683          	lw	a3,0(a1) # 10000000 <_gp+0xffe19c0>
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1aa1c:	00078513          	mv	a0,a5
    {
      return 1;			/* still unordered! */
    }
#endif

  if (isnan (a) || isnan (b))
   1aa20:	04d7f263          	bleu	a3,a5,1aa64 <__fpcmp_parts_d+0x5c>
    {
      return 1;			/* how to indicate unordered compare? */
    }
  if (isinf (a) && isinf (b))
   1aa24:	00400793          	li	a5,4
   1aa28:	04f70c63          	beq	a4,a5,1aa80 <__fpcmp_parts_d+0x78>
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
    }
  if (isinf (b))
   1aa2c:	04f68063          	beq	a3,a5,1aa6c <__fpcmp_parts_d+0x64>
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (a) && iszero (b))
   1aa30:	00200793          	li	a5,2
   1aa34:	02f70a63          	beq	a4,a5,1aa68 <__fpcmp_parts_d+0x60>
    }
  if (iszero (a))
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (b))
   1aa38:	04f68663          	beq	a3,a5,1aa84 <__fpcmp_parts_d+0x7c>
    {
      return a->sign ? -1 : 1;
    }
  /* now both are "normal".  */
  if (a->sign != b->sign)
   1aa3c:	00462783          	lw	a5,4(a2)
   1aa40:	0045a703          	lw	a4,4(a1)
   1aa44:	04e78e63          	beq	a5,a4,1aaa0 <__fpcmp_parts_d+0x98>
    {
      return a->sign ? -1 : 1;
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
   1aa48:	00f03533          	snez	a0,a5
   1aa4c:	40a00533          	neg	a0,a0
   1aa50:	00156513          	ori	a0,a0,1
   1aa54:	00008067          	ret
  /* same exponents; check size.  */
  if (a->fraction.ll > b->fraction.ll)
    {
      return a->sign ? -1 : 1;
    }
  if (a->fraction.ll < b->fraction.ll)
   1aa58:	00e69463          	bne	a3,a4,1aa60 <__fpcmp_parts_d+0x58>
   1aa5c:	06b66a63          	bltu	a2,a1,1aad0 <__fpcmp_parts_d+0xc8>
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (a) && iszero (b))
    {
      return 0;
   1aa60:	00000513          	li	a0,0
    {
      return a->sign ? 1 : -1;
    }
  /* after all that, they're equal.  */
  return 0;
}
   1aa64:	00008067          	ret
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (a) && iszero (b))
   1aa68:	fee68ce3          	beq	a3,a4,1aa60 <__fpcmp_parts_d+0x58>
    {
      return a->sign ? -1 : 1;
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
   1aa6c:	0045a503          	lw	a0,4(a1)
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1aa70:	00153513          	seqz	a0,a0
   1aa74:	40a00533          	neg	a0,a0
   1aa78:	00156513          	ori	a0,a0,1
   1aa7c:	00008067          	ret

  if (isnan (a) || isnan (b))
    {
      return 1;			/* how to indicate unordered compare? */
    }
  if (isinf (a) && isinf (b))
   1aa80:	06e68063          	beq	a3,a4,1aae0 <__fpcmp_parts_d+0xd8>
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1aa84:	00462503          	lw	a0,4(a2)
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
   1aa88:	00a03533          	snez	a0,a0
   1aa8c:	40a00533          	neg	a0,a0
   1aa90:	00156513          	ori	a0,a0,1
   1aa94:	00008067          	ret
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1aa98:	00078513          	mv	a0,a5
   1aa9c:	00008067          	ret
    {
      /* opposite signs */
      return a->sign ? -1 : 1;
    }
  /* same sign; exponents? */
  if (a->normal_exp > b->normal_exp)
   1aaa0:	00862683          	lw	a3,8(a2)
   1aaa4:	0085a703          	lw	a4,8(a1)
   1aaa8:	fad740e3          	blt	a4,a3,1aa48 <__fpcmp_parts_d+0x40>
    {
      return a->sign ? -1 : 1;
    }
  if (a->normal_exp < b->normal_exp)
   1aaac:	02e6c263          	blt	a3,a4,1aad0 <__fpcmp_parts_d+0xc8>
    {
      return a->sign ? 1 : -1;
    }
  /* same exponents; check size.  */
  if (a->fraction.ll > b->fraction.ll)
   1aab0:	01462703          	lw	a4,20(a2)
   1aab4:	0145a683          	lw	a3,20(a1)
   1aab8:	01062603          	lw	a2,16(a2)
   1aabc:	0105a583          	lw	a1,16(a1)
   1aac0:	f8e6e4e3          	bltu	a3,a4,1aa48 <__fpcmp_parts_d+0x40>
   1aac4:	00d71463          	bne	a4,a3,1aacc <__fpcmp_parts_d+0xc4>
   1aac8:	f8c5e0e3          	bltu	a1,a2,1aa48 <__fpcmp_parts_d+0x40>
    {
      return a->sign ? -1 : 1;
    }
  if (a->fraction.ll < b->fraction.ll)
   1aacc:	f8d776e3          	bleu	a3,a4,1aa58 <__fpcmp_parts_d+0x50>
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1aad0:	0017b513          	seqz	a0,a5
   1aad4:	40a00533          	neg	a0,a0
   1aad8:	00156513          	ori	a0,a0,1
   1aadc:	00008067          	ret
       -------+--------+--------
       -inf(1)| a>b(1) | a==b(0)
       -------+--------+--------
       So since unordered must be nonzero, just line up the columns...
       */
      return b->sign - a->sign;
   1aae0:	0045a783          	lw	a5,4(a1)
   1aae4:	00462503          	lw	a0,4(a2)
   1aae8:	40a78533          	sub	a0,a5,a0
   1aaec:	00008067          	ret

0001aaf0 <__cmpdf2>:
#endif

#if defined(L_compare_sf) || defined(L_compare_df) || defined(L_compoare_tf)
CMPtype
compare (FLO_type arg_a, FLO_type arg_b)
{
   1aaf0:	fb010113          	addi	sp,sp,-80
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1aaf4:	00a12023          	sw	a0,0(sp)
   1aaf8:	00b12223          	sw	a1,4(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1aafc:	00010513          	mv	a0,sp
   1ab00:	01010593          	addi	a1,sp,16
#endif

#if defined(L_compare_sf) || defined(L_compare_df) || defined(L_compoare_tf)
CMPtype
compare (FLO_type arg_a, FLO_type arg_b)
{
   1ab04:	04112623          	sw	ra,76(sp)
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1ab08:	00c12423          	sw	a2,8(sp)
   1ab0c:	00d12623          	sw	a3,12(sp)

  unpack_d (&au, &a);
   1ab10:	925ff0ef          	jal	1a434 <__unpack_d>
  unpack_d (&bu, &b);
   1ab14:	02810593          	addi	a1,sp,40
   1ab18:	00810513          	addi	a0,sp,8
   1ab1c:	919ff0ef          	jal	1a434 <__unpack_d>

  return __fpcmp_parts (&a, &b);
   1ab20:	02810593          	addi	a1,sp,40
   1ab24:	01010513          	addi	a0,sp,16
   1ab28:	ee1ff0ef          	jal	1aa08 <__fpcmp_parts_d>
}
   1ab2c:	04c12083          	lw	ra,76(sp)
   1ab30:	05010113          	addi	sp,sp,80
   1ab34:	00008067          	ret

0001ab38 <__gedf2>:
#endif /* L_gt_sf || L_gt_df */

#if defined(L_ge_sf) || defined(L_ge_df) || defined(L_ge_tf)
CMPtype
_ge_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1ab38:	fb010113          	addi	sp,sp,-80
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1ab3c:	00a12023          	sw	a0,0(sp)
   1ab40:	00b12223          	sw	a1,4(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1ab44:	00010513          	mv	a0,sp
   1ab48:	01010593          	addi	a1,sp,16
#endif /* L_gt_sf || L_gt_df */

#if defined(L_ge_sf) || defined(L_ge_df) || defined(L_ge_tf)
CMPtype
_ge_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1ab4c:	04112623          	sw	ra,76(sp)
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1ab50:	00c12423          	sw	a2,8(sp)
   1ab54:	00d12623          	sw	a3,12(sp)

  unpack_d (&au, &a);
   1ab58:	8ddff0ef          	jal	1a434 <__unpack_d>
  unpack_d (&bu, &b);
   1ab5c:	00810513          	addi	a0,sp,8
   1ab60:	02810593          	addi	a1,sp,40
   1ab64:	8d1ff0ef          	jal	1a434 <__unpack_d>

  if (isnan (&a) || isnan (&b))
   1ab68:	01012703          	lw	a4,16(sp)
   1ab6c:	00100793          	li	a5,1
    return -1;			/* false, truth >= 0 */
   1ab70:	fff00513          	li	a0,-1
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  if (isnan (&a) || isnan (&b))
   1ab74:	00e7fc63          	bleu	a4,a5,1ab8c <__gedf2+0x54>
   1ab78:	02812703          	lw	a4,40(sp)
   1ab7c:	00e7f863          	bleu	a4,a5,1ab8c <__gedf2+0x54>
    return -1;			/* false, truth >= 0 */
  return __fpcmp_parts (&a, &b) ;
   1ab80:	02810593          	addi	a1,sp,40
   1ab84:	01010513          	addi	a0,sp,16
   1ab88:	e81ff0ef          	jal	1aa08 <__fpcmp_parts_d>
}
   1ab8c:	04c12083          	lw	ra,76(sp)
   1ab90:	05010113          	addi	sp,sp,80
   1ab94:	00008067          	ret

0001ab98 <__gtdf2>:
   1ab98:	fa1ff06f          	j	1ab38 <__gedf2>

0001ab9c <__ledf2>:
#endif /* L_lt_sf || L_lt_df */

#if defined(L_le_sf) || defined(L_le_df) || defined(L_le_tf)
CMPtype
_le_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1ab9c:	fb010113          	addi	sp,sp,-80
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1aba0:	00a12023          	sw	a0,0(sp)
   1aba4:	00b12223          	sw	a1,4(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1aba8:	00010513          	mv	a0,sp
   1abac:	01010593          	addi	a1,sp,16
#endif /* L_lt_sf || L_lt_df */

#if defined(L_le_sf) || defined(L_le_df) || defined(L_le_tf)
CMPtype
_le_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1abb0:	04112623          	sw	ra,76(sp)
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1abb4:	00c12423          	sw	a2,8(sp)
   1abb8:	00d12623          	sw	a3,12(sp)

  unpack_d (&au, &a);
   1abbc:	879ff0ef          	jal	1a434 <__unpack_d>
  unpack_d (&bu, &b);
   1abc0:	00810513          	addi	a0,sp,8
   1abc4:	02810593          	addi	a1,sp,40
   1abc8:	86dff0ef          	jal	1a434 <__unpack_d>

  if (isnan (&a) || isnan (&b))
   1abcc:	01012783          	lw	a5,16(sp)
   1abd0:	00100513          	li	a0,1
   1abd4:	00f57c63          	bleu	a5,a0,1abec <__ledf2+0x50>
   1abd8:	02812783          	lw	a5,40(sp)
   1abdc:	00f57863          	bleu	a5,a0,1abec <__ledf2+0x50>
    return 1;			/* false, truth <= 0 */

  return __fpcmp_parts (&a, &b) ;
   1abe0:	02810593          	addi	a1,sp,40
   1abe4:	01010513          	addi	a0,sp,16
   1abe8:	e21ff0ef          	jal	1aa08 <__fpcmp_parts_d>
}
   1abec:	04c12083          	lw	ra,76(sp)
   1abf0:	05010113          	addi	sp,sp,80
   1abf4:	00008067          	ret

0001abf8 <__ltdf2>:
   1abf8:	fa5ff06f          	j	1ab9c <__ledf2>

0001abfc <__nedf2>:
   1abfc:	fa1ff06f          	j	1ab9c <__ledf2>

0001ac00 <__eqdf2>:
   1ac00:	f9dff06f          	j	1ab9c <__ledf2>

0001ac04 <__unorddf2>:
#endif /* L_le_sf || L_le_df */

#if defined(L_unord_sf) || defined(L_unord_df) || defined(L_unord_tf)
CMPtype
_unord_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1ac04:	fb010113          	addi	sp,sp,-80
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1ac08:	00a12023          	sw	a0,0(sp)
   1ac0c:	00b12223          	sw	a1,4(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1ac10:	00010513          	mv	a0,sp
   1ac14:	01010593          	addi	a1,sp,16
#endif /* L_le_sf || L_le_df */

#if defined(L_unord_sf) || defined(L_unord_df) || defined(L_unord_tf)
CMPtype
_unord_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1ac18:	04112623          	sw	ra,76(sp)
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1ac1c:	00c12423          	sw	a2,8(sp)
   1ac20:	00d12623          	sw	a3,12(sp)

  unpack_d (&au, &a);
   1ac24:	811ff0ef          	jal	1a434 <__unpack_d>
  unpack_d (&bu, &b);
   1ac28:	00810513          	addi	a0,sp,8
   1ac2c:	02810593          	addi	a1,sp,40
   1ac30:	805ff0ef          	jal	1a434 <__unpack_d>

  return (isnan (&a) || isnan (&b));
   1ac34:	01012783          	lw	a5,16(sp)
   1ac38:	00100513          	li	a0,1
   1ac3c:	00f57663          	bleu	a5,a0,1ac48 <__unorddf2+0x44>
   1ac40:	02812503          	lw	a0,40(sp)
   1ac44:	00253513          	sltiu	a0,a0,2
}
   1ac48:	04c12083          	lw	ra,76(sp)
   1ac4c:	05010113          	addi	sp,sp,80
   1ac50:	00008067          	ret

0001ac54 <__floatsidf>:
#endif /* L_unord_sf || L_unord_df */

#if defined(L_si_to_sf) || defined(L_si_to_df) || defined(L_si_to_tf)
FLO_type
si_to_float (SItype arg_a)
{
   1ac54:	fd010113          	addi	sp,sp,-48
  fp_number_type in;

  in.class = CLASS_NUMBER;
  in.sign = arg_a < 0;
   1ac58:	01f55793          	srli	a5,a0,0x1f
FLO_type
si_to_float (SItype arg_a)
{
  fp_number_type in;

  in.class = CLASS_NUMBER;
   1ac5c:	00300713          	li	a4,3
#endif /* L_unord_sf || L_unord_df */

#if defined(L_si_to_sf) || defined(L_si_to_df) || defined(L_si_to_tf)
FLO_type
si_to_float (SItype arg_a)
{
   1ac60:	02112623          	sw	ra,44(sp)
   1ac64:	02812423          	sw	s0,40(sp)
  fp_number_type in;

  in.class = CLASS_NUMBER;
   1ac68:	00e12423          	sw	a4,8(sp)
  in.sign = arg_a < 0;
   1ac6c:	00f12623          	sw	a5,12(sp)
  if (!arg_a)
   1ac70:	02051263          	bnez	a0,1ac94 <__floatsidf+0x40>
    {
      in.class = CLASS_ZERO;
   1ac74:	00200793          	li	a5,2
   1ac78:	00f12423          	sw	a5,8(sp)
	{
	  in.fraction.ll <<= shift;
	  in.normal_exp -= shift;
	}
    }
  return pack_d (&in);
   1ac7c:	00810513          	addi	a0,sp,8
   1ac80:	d70ff0ef          	jal	1a1f0 <__pack_d>
}
   1ac84:	02c12083          	lw	ra,44(sp)
   1ac88:	02812403          	lw	s0,40(sp)
   1ac8c:	03010113          	addi	sp,sp,48
   1ac90:	00008067          	ret
  else
    {
      USItype uarg;
      int shift;
      in.normal_exp = FRACBITS + NGARDS;
      if (in.sign) 
   1ac94:	02054c63          	bltz	a0,1accc <__floatsidf+0x78>
	      return (FLO_type)(- MAX_SI_INT - 1);
	    }
	  uarg = (-arg_a);
	}
      else
	uarg = arg_a;
   1ac98:	00050413          	mv	s0,a0
static int
clzusi (USItype n)
{
  extern int __clzsi2 (USItype);
  if (sizeof (USItype) == sizeof (unsigned int))
    return __builtin_clz (n);
   1ac9c:	00040513          	mv	a0,s0
   1aca0:	27c000ef          	jal	1af1c <__clzsi2>
	}
      else
	uarg = arg_a;

      in.fraction.ll = uarg;
      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
   1aca4:	01d50513          	addi	a0,a0,29
      if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1aca8:	02057793          	andi	a5,a0,32
   1acac:	04078063          	beqz	a5,1acec <__floatsidf+0x98>
   1acb0:	00a41433          	sll	s0,s0,a0
   1acb4:	00812e23          	sw	s0,28(sp)
   1acb8:	00012c23          	sw	zero,24(sp)
	  in.normal_exp -= shift;
   1acbc:	03c00793          	li	a5,60
   1acc0:	40a78533          	sub	a0,a5,a0
   1acc4:	00a12823          	sw	a0,16(sp)
   1acc8:	fb5ff06f          	j	1ac7c <__floatsidf+0x28>
      in.normal_exp = FRACBITS + NGARDS;
      if (in.sign) 
	{
	  /* Special case for minint, since there is no +ve integer
	     representation for it */
	  if (arg_a == (- MAX_SI_INT - 1))
   1accc:	800007b7          	lui	a5,0x80000
   1acd0:	02f50c63          	beq	a0,a5,1ad08 <__floatsidf+0xb4>
	    {
	      return (FLO_type)(- MAX_SI_INT - 1);
	    }
	  uarg = (-arg_a);
   1acd4:	40a00433          	neg	s0,a0
static int
clzusi (USItype n)
{
  extern int __clzsi2 (USItype);
  if (sizeof (USItype) == sizeof (unsigned int))
    return __builtin_clz (n);
   1acd8:	00040513          	mv	a0,s0
   1acdc:	240000ef          	jal	1af1c <__clzsi2>
	}
      else
	uarg = arg_a;

      in.fraction.ll = uarg;
      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
   1ace0:	01d50513          	addi	a0,a0,29
      if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1ace4:	02057793          	andi	a5,a0,32
   1ace8:	fc0794e3          	bnez	a5,1acb0 <__floatsidf+0x5c>
   1acec:	00145793          	srli	a5,s0,0x1
   1acf0:	fff54713          	not	a4,a0
   1acf4:	00e7d7b3          	srl	a5,a5,a4
   1acf8:	00a41433          	sll	s0,s0,a0
   1acfc:	00f12e23          	sw	a5,28(sp)
   1ad00:	00812c23          	sw	s0,24(sp)
   1ad04:	fb9ff06f          	j	1acbc <__floatsidf+0x68>
	{
	  /* Special case for minint, since there is no +ve integer
	     representation for it */
	  if (arg_a == (- MAX_SI_INT - 1))
	    {
	      return (FLO_type)(- MAX_SI_INT - 1);
   1ad08:	8701a503          	lw	a0,-1936(gp) # 1deb0 <__wctomb+0x50>
   1ad0c:	8741a583          	lw	a1,-1932(gp) # 1deb4 <__wctomb+0x54>
   1ad10:	f75ff06f          	j	1ac84 <__floatsidf+0x30>

0001ad14 <__floatunsidf>:
#endif /* L_si_to_sf || L_si_to_df */

#if defined(L_usi_to_sf) || defined(L_usi_to_df) || defined(L_usi_to_tf)
FLO_type
usi_to_float (USItype arg_a)
{
   1ad14:	fd010113          	addi	sp,sp,-48
   1ad18:	02112623          	sw	ra,44(sp)
   1ad1c:	02812423          	sw	s0,40(sp)
  fp_number_type in;

  in.sign = 0;
   1ad20:	00012623          	sw	zero,12(sp)
  if (!arg_a)
   1ad24:	06050663          	beqz	a0,1ad90 <__floatunsidf+0x7c>
      in.class = CLASS_ZERO;
    }
  else
    {
      int shift;
      in.class = CLASS_NUMBER;
   1ad28:	00300793          	li	a5,3
   1ad2c:	00f12423          	sw	a5,8(sp)
   1ad30:	00050413          	mv	s0,a0
static int
clzusi (USItype n)
{
  extern int __clzsi2 (USItype);
  if (sizeof (USItype) == sizeof (unsigned int))
    return __builtin_clz (n);
   1ad34:	1e8000ef          	jal	1af1c <__clzsi2>
      int shift;
      in.class = CLASS_NUMBER;
      in.normal_exp = FRACBITS + NGARDS;
      in.fraction.ll = arg_a;

      shift = clzusi (arg_a) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
   1ad38:	01d50513          	addi	a0,a0,29
	  in.fraction.ll |= (guard != 0);
	  in.normal_exp -= shift;
	}
      else if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1ad3c:	02057793          	andi	a5,a0,32
   1ad40:	02078a63          	beqz	a5,1ad74 <__floatunsidf+0x60>
   1ad44:	00a41433          	sll	s0,s0,a0
   1ad48:	00812e23          	sw	s0,28(sp)
   1ad4c:	00012c23          	sw	zero,24(sp)
	  in.normal_exp -= shift;
   1ad50:	03c00793          	li	a5,60
   1ad54:	40a78533          	sub	a0,a5,a0
   1ad58:	00a12823          	sw	a0,16(sp)
	}
    }
  return pack_d (&in);
   1ad5c:	00810513          	addi	a0,sp,8
   1ad60:	c90ff0ef          	jal	1a1f0 <__pack_d>
}
   1ad64:	02c12083          	lw	ra,44(sp)
   1ad68:	02812403          	lw	s0,40(sp)
   1ad6c:	03010113          	addi	sp,sp,48
   1ad70:	00008067          	ret
	  in.fraction.ll |= (guard != 0);
	  in.normal_exp -= shift;
	}
      else if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1ad74:	00145793          	srli	a5,s0,0x1
   1ad78:	fff54713          	not	a4,a0
   1ad7c:	00e7d7b3          	srl	a5,a5,a4
   1ad80:	00a41433          	sll	s0,s0,a0
   1ad84:	00f12e23          	sw	a5,28(sp)
   1ad88:	00812c23          	sw	s0,24(sp)
   1ad8c:	fc5ff06f          	j	1ad50 <__floatunsidf+0x3c>
  fp_number_type in;

  in.sign = 0;
  if (!arg_a)
    {
      in.class = CLASS_ZERO;
   1ad90:	00200793          	li	a5,2
   1ad94:	00f12423          	sw	a5,8(sp)
   1ad98:	fc5ff06f          	j	1ad5c <__floatunsidf+0x48>

0001ad9c <__fixdfsi>:
#endif

#if defined(L_sf_to_si) || defined(L_df_to_si) || defined(L_tf_to_si)
SItype
float_to_si (FLO_type arg_a)
{
   1ad9c:	fd010113          	addi	sp,sp,-48
  fp_number_type a;
  SItype tmp;
  FLO_union_type au;

  au.value = arg_a;
   1ada0:	00a12023          	sw	a0,0(sp)
   1ada4:	00b12223          	sw	a1,4(sp)
  unpack_d (&au, &a);
   1ada8:	00010513          	mv	a0,sp
   1adac:	00810593          	addi	a1,sp,8
#endif

#if defined(L_sf_to_si) || defined(L_df_to_si) || defined(L_tf_to_si)
SItype
float_to_si (FLO_type arg_a)
{
   1adb0:	02112623          	sw	ra,44(sp)
  fp_number_type a;
  SItype tmp;
  FLO_union_type au;

  au.value = arg_a;
  unpack_d (&au, &a);
   1adb4:	e80ff0ef          	jal	1a434 <__unpack_d>
   1adb8:	00812783          	lw	a5,8(sp)

  if (iszero (&a))
    return 0;
  if (isnan (&a))
   1adbc:	00200713          	li	a4,2
   1adc0:	06f77463          	bleu	a5,a4,1ae28 <__fixdfsi+0x8c>
    return 0;
  /* get reasonable MAX_SI_INT...  */
  if (isinf (&a))
   1adc4:	00400713          	li	a4,4
   1adc8:	00e78a63          	beq	a5,a4,1addc <__fixdfsi+0x40>
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  /* it is a number, but a small one */
  if (a.normal_exp < 0)
   1adcc:	01012503          	lw	a0,16(sp)
   1add0:	04054c63          	bltz	a0,1ae28 <__fixdfsi+0x8c>
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
   1add4:	01e00793          	li	a5,30
   1add8:	02a7d063          	ble	a0,a5,1adf8 <__fixdfsi+0x5c>
    return 0;
  if (isnan (&a))
    return 0;
  /* get reasonable MAX_SI_INT...  */
  if (isinf (&a))
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
   1addc:	00c12783          	lw	a5,12(sp)
   1ade0:	80000537          	lui	a0,0x80000
   1ade4:	00079463          	bnez	a5,1adec <__fixdfsi+0x50>
   1ade8:	fff54513          	not	a0,a0
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
  return a.sign ? (-tmp) : (tmp);
}
   1adec:	02c12083          	lw	ra,44(sp)
   1adf0:	03010113          	addi	sp,sp,48
   1adf4:	00008067          	ret
  /* it is a number, but a small one */
  if (a.normal_exp < 0)
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
   1adf8:	03c00793          	li	a5,60
   1adfc:	40a78533          	sub	a0,a5,a0
   1ae00:	02057793          	andi	a5,a0,32
   1ae04:	02078a63          	beqz	a5,1ae38 <__fixdfsi+0x9c>
   1ae08:	01c12783          	lw	a5,28(sp)
   1ae0c:	00a7d533          	srl	a0,a5,a0
  return a.sign ? (-tmp) : (tmp);
   1ae10:	00c12783          	lw	a5,12(sp)
   1ae14:	fc078ce3          	beqz	a5,1adec <__fixdfsi+0x50>
}
   1ae18:	02c12083          	lw	ra,44(sp)
  if (a.normal_exp < 0)
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
  return a.sign ? (-tmp) : (tmp);
   1ae1c:	40a00533          	neg	a0,a0
}
   1ae20:	03010113          	addi	sp,sp,48
   1ae24:	00008067          	ret
   1ae28:	02c12083          	lw	ra,44(sp)
  unpack_d (&au, &a);

  if (iszero (&a))
    return 0;
  if (isnan (&a))
    return 0;
   1ae2c:	00000513          	li	a0,0
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
  return a.sign ? (-tmp) : (tmp);
}
   1ae30:	03010113          	addi	sp,sp,48
   1ae34:	00008067          	ret
  /* it is a number, but a small one */
  if (a.normal_exp < 0)
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
   1ae38:	01c12783          	lw	a5,28(sp)
   1ae3c:	fff54713          	not	a4,a0
   1ae40:	00179793          	slli	a5,a5,0x1
   1ae44:	00e797b3          	sll	a5,a5,a4
   1ae48:	01812703          	lw	a4,24(sp)
   1ae4c:	00a75533          	srl	a0,a4,a0
   1ae50:	00a7e533          	or	a0,a5,a0
   1ae54:	fbdff06f          	j	1ae10 <__fixdfsi+0x74>

0001ae58 <__negdf2>:
#endif /* L_tf_to_usi */

#if defined(L_negate_sf) || defined(L_negate_df) || defined(L_negate_tf)
FLO_type
negate (FLO_type arg_a)
{
   1ae58:	fd010113          	addi	sp,sp,-48
  fp_number_type a;
  FLO_union_type au;

  au.value = arg_a;
   1ae5c:	00a12023          	sw	a0,0(sp)
   1ae60:	00b12223          	sw	a1,4(sp)
  unpack_d (&au, &a);
   1ae64:	00010513          	mv	a0,sp
   1ae68:	00810593          	addi	a1,sp,8
#endif /* L_tf_to_usi */

#if defined(L_negate_sf) || defined(L_negate_df) || defined(L_negate_tf)
FLO_type
negate (FLO_type arg_a)
{
   1ae6c:	02112623          	sw	ra,44(sp)
  fp_number_type a;
  FLO_union_type au;

  au.value = arg_a;
  unpack_d (&au, &a);
   1ae70:	dc4ff0ef          	jal	1a434 <__unpack_d>

INLINE 
static void
flip_sign ( fp_number_type *  x)
{
  x->sign = !x->sign;
   1ae74:	00c12783          	lw	a5,12(sp)

  au.value = arg_a;
  unpack_d (&au, &a);

  flip_sign (&a);
  return pack_d (&a);
   1ae78:	00810513          	addi	a0,sp,8

INLINE 
static void
flip_sign ( fp_number_type *  x)
{
  x->sign = !x->sign;
   1ae7c:	0017b793          	seqz	a5,a5
   1ae80:	00f12623          	sw	a5,12(sp)

  au.value = arg_a;
  unpack_d (&au, &a);

  flip_sign (&a);
  return pack_d (&a);
   1ae84:	b6cff0ef          	jal	1a1f0 <__pack_d>
}
   1ae88:	02c12083          	lw	ra,44(sp)
   1ae8c:	03010113          	addi	sp,sp,48
   1ae90:	00008067          	ret

0001ae94 <__make_dp>:
extern SFtype __make_fp (fp_class_type, unsigned int, int, USItype);

#if defined(L_make_df)
DFtype
__make_dp (fp_class_type class, unsigned int sign, int exp, UDItype frac)
{
   1ae94:	fd010113          	addi	sp,sp,-48
  fp_number_type in;

  in.class = class;
   1ae98:	00a12423          	sw	a0,8(sp)
  in.sign = sign;
  in.normal_exp = exp;
  in.fraction.ll = frac;
  return pack_d (&in);
   1ae9c:	00810513          	addi	a0,sp,8
extern SFtype __make_fp (fp_class_type, unsigned int, int, USItype);

#if defined(L_make_df)
DFtype
__make_dp (fp_class_type class, unsigned int sign, int exp, UDItype frac)
{
   1aea0:	02112623          	sw	ra,44(sp)
  fp_number_type in;

  in.class = class;
  in.sign = sign;
   1aea4:	00b12623          	sw	a1,12(sp)
  in.normal_exp = exp;
   1aea8:	00c12823          	sw	a2,16(sp)
  in.fraction.ll = frac;
   1aeac:	00e12c23          	sw	a4,24(sp)
   1aeb0:	00f12e23          	sw	a5,28(sp)
  return pack_d (&in);
   1aeb4:	b3cff0ef          	jal	1a1f0 <__pack_d>
}
   1aeb8:	02c12083          	lw	ra,44(sp)
   1aebc:	03010113          	addi	sp,sp,48
   1aec0:	00008067          	ret

0001aec4 <__truncdfsf2>:
#endif /* L_make_df */

#if defined(L_df_to_sf)
SFtype
df_to_sf (DFtype arg_a)
{
   1aec4:	fd010113          	addi	sp,sp,-48
  fp_number_type in;
  USItype sffrac;
  FLO_union_type au;

  au.value = arg_a;
   1aec8:	00a12023          	sw	a0,0(sp)
   1aecc:	00b12223          	sw	a1,4(sp)
  unpack_d (&au, &in);
   1aed0:	00010513          	mv	a0,sp
   1aed4:	00810593          	addi	a1,sp,8
#endif /* L_make_df */

#if defined(L_df_to_sf)
SFtype
df_to_sf (DFtype arg_a)
{
   1aed8:	02112623          	sw	ra,44(sp)
  fp_number_type in;
  USItype sffrac;
  FLO_union_type au;

  au.value = arg_a;
  unpack_d (&au, &in);
   1aedc:	d58ff0ef          	jal	1a434 <__unpack_d>

  sffrac = in.fraction.ll >> F_D_BITOFF;
   1aee0:	01812703          	lw	a4,24(sp)
   1aee4:	01c12683          	lw	a3,28(sp)
   1aee8:	01e75793          	srli	a5,a4,0x1e
   1aeec:	00269693          	slli	a3,a3,0x2
   1aef0:	00f6e6b3          	or	a3,a3,a5

  /* We set the lowest guard bit in SFFRAC if we discarded any non
     zero bits.  */
  if ((in.fraction.ll & (((USItype) 1 << F_D_BITOFF) - 1)) != 0)
   1aef4:	00271793          	slli	a5,a4,0x2
   1aef8:	00078463          	beqz	a5,1af00 <__truncdfsf2+0x3c>
    sffrac |= 1;
   1aefc:	0016e693          	ori	a3,a3,1

  return __make_fp (in.class, in.sign, in.normal_exp, sffrac);
   1af00:	01012603          	lw	a2,16(sp)
   1af04:	00c12583          	lw	a1,12(sp)
   1af08:	00812503          	lw	a0,8(sp)
   1af0c:	401000ef          	jal	1bb0c <__make_fp>
}
   1af10:	02c12083          	lw	ra,44(sp)
   1af14:	03010113          	addi	sp,sp,48
   1af18:	00008067          	ret

0001af1c <__clzsi2>:
int
__clzSI2 (UWtype x)
{
  Wtype ret;

  count_leading_zeros (ret, x);
   1af1c:	000107b7          	lui	a5,0x10
   1af20:	02f57c63          	bleu	a5,a0,1af58 <__clzsi2+0x3c>
   1af24:	0ff00693          	li	a3,255
   1af28:	01800713          	li	a4,24
   1af2c:	00800793          	li	a5,8
   1af30:	00a6e663          	bltu	a3,a0,1af3c <__clzsi2+0x20>
   1af34:	02000713          	li	a4,32
   1af38:	00000793          	li	a5,0
   1af3c:	00f55533          	srl	a0,a0,a5
   1af40:	0001c7b7          	lui	a5,0x1c
   1af44:	bc478793          	addi	a5,a5,-1084 # 1bbc4 <__clz_tab>
   1af48:	00f507b3          	add	a5,a0,a5

  return ret;
   1af4c:	0007c503          	lbu	a0,0(a5)
}
   1af50:	40a70533          	sub	a0,a4,a0
   1af54:	00008067          	ret
int
__clzSI2 (UWtype x)
{
  Wtype ret;

  count_leading_zeros (ret, x);
   1af58:	010006b7          	lui	a3,0x1000
   1af5c:	00800713          	li	a4,8
   1af60:	01800793          	li	a5,24
   1af64:	fcd57ce3          	bleu	a3,a0,1af3c <__clzsi2+0x20>
   1af68:	01000713          	li	a4,16
   1af6c:	00070793          	mv	a5,a4
   1af70:	00f55533          	srl	a0,a0,a5
   1af74:	0001c7b7          	lui	a5,0x1c
   1af78:	bc478793          	addi	a5,a5,-1084 # 1bbc4 <__clz_tab>
   1af7c:	00f507b3          	add	a5,a0,a5

  return ret;
   1af80:	0007c503          	lbu	a0,0(a5)
}
   1af84:	40a70533          	sub	a0,a4,a0
   1af88:	00008067          	ret

0001af8c <_fpadd_parts>:
#if defined(L_addsub_sf) || defined(L_addsub_df) || defined(L_addsub_tf)
static const fp_number_type *
_fpadd_parts (fp_number_type * a,
	      fp_number_type * b,
	      fp_number_type * tmp)
{
   1af8c:	00052783          	lw	a5,0(a0) # 80000000 <_gp+0x7ffe19c0>
  int a_normal_exp;
  int b_normal_exp;
  fractype a_fraction;
  fractype b_fraction;

  if (isnan (a))
   1af90:	00100713          	li	a4,1
   1af94:	0ef77463          	bleu	a5,a4,1b07c <_fpadd_parts+0xf0>
   1af98:	0005a683          	lw	a3,0(a1)
    {
      return a;
    }
  if (isnan (b))
   1af9c:	0cd77e63          	bleu	a3,a4,1b078 <_fpadd_parts+0xec>
    {
      return b;
    }
  if (isinf (a))
   1afa0:	00400813          	li	a6,4
   1afa4:	15078c63          	beq	a5,a6,1b0fc <_fpadd_parts+0x170>
      /* Adding infinities with opposite signs yields a NaN.  */
      if (isinf (b) && a->sign != b->sign)
	return makenan ();
      return a;
    }
  if (isinf (b))
   1afa8:	0d068863          	beq	a3,a6,1b078 <_fpadd_parts+0xec>
    {
      return b;
    }
  if (iszero (b))
   1afac:	00200813          	li	a6,2
   1afb0:	11068663          	beq	a3,a6,1b0bc <_fpadd_parts+0x130>
	  tmp->sign = a->sign & b->sign;
	  return tmp;
	}
      return a;
    }
  if (iszero (a))
   1afb4:	0d078263          	beq	a5,a6,1b078 <_fpadd_parts+0xec>
     they're the same */
  {
    int diff;
    int sdiff;

    a_normal_exp = a->normal_exp;
   1afb8:	00852303          	lw	t1,8(a0)
    b_normal_exp = b->normal_exp;
   1afbc:	0085a783          	lw	a5,8(a1)
    diff = a_normal_exp - b_normal_exp;
    sdiff = diff;

    if (diff < 0)
      diff = -diff;
    if (diff < FRAC_NBITS)
   1afc0:	01f00693          	li	a3,31
    int diff;
    int sdiff;

    a_normal_exp = a->normal_exp;
    b_normal_exp = b->normal_exp;
    a_fraction = a->fraction.ll;
   1afc4:	00c52383          	lw	t2,12(a0)
    b_fraction = b->fraction.ll;

    diff = a_normal_exp - b_normal_exp;
   1afc8:	40f30833          	sub	a6,t1,a5
   1afcc:	41f85293          	srai	t0,a6,0x1f
   1afd0:	0102c8b3          	xor	a7,t0,a6
   1afd4:	405888b3          	sub	a7,a7,t0
    int sdiff;

    a_normal_exp = a->normal_exp;
    b_normal_exp = b->normal_exp;
    a_fraction = a->fraction.ll;
    b_fraction = b->fraction.ll;
   1afd8:	00c5a283          	lw	t0,12(a1)
    diff = a_normal_exp - b_normal_exp;
    sdiff = diff;

    if (diff < 0)
      diff = -diff;
    if (diff < FRAC_NBITS)
   1afdc:	0b16d263          	ble	a7,a3,1b080 <_fpadd_parts+0xf4>
	  }
      }
    else
      {
	/* Somethings's up.. choose the biggest */
	if (a_normal_exp > b_normal_exp)
   1afe0:	1067ca63          	blt	a5,t1,1b0f4 <_fpadd_parts+0x168>
   1afe4:	00078313          	mv	t1,a5
	    b_fraction = 0;
	  }
	else
	  {
	    a_normal_exp = b_normal_exp;
	    a_fraction = 0;
   1afe8:	00000393          	li	t2,0
	  }
      }
  }

  if (a->sign != b->sign)
   1afec:	00452703          	lw	a4,4(a0)
   1aff0:	0045a783          	lw	a5,4(a1)
   1aff4:	0af70a63          	beq	a4,a5,1b0a8 <_fpadd_parts+0x11c>
	{
	  tfraction = -a_fraction + b_fraction;
	}
      else
	{
	  tfraction = a_fraction - b_fraction;
   1aff8:	405387b3          	sub	a5,t2,t0
      }
  }

  if (a->sign != b->sign)
    {
      if (a->sign)
   1affc:	00070463          	beqz	a4,1b004 <_fpadd_parts+0x78>
	{
	  tfraction = -a_fraction + b_fraction;
   1b000:	407287b3          	sub	a5,t0,t2
	}
      else
	{
	  tfraction = a_fraction - b_fraction;
	}
      if (tfraction >= 0)
   1b004:	1007ca63          	bltz	a5,1b118 <_fpadd_parts+0x18c>
	{
	  tmp->sign = 0;
   1b008:	00062223          	sw	zero,4(a2)
	  tmp->normal_exp = a_normal_exp;
   1b00c:	00662423          	sw	t1,8(a2)
	  tmp->fraction.ll = tfraction;
   1b010:	00f62623          	sw	a5,12(a2)
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1b014:	400005b7          	lui	a1,0x40000
   1b018:	fff78713          	addi	a4,a5,-1
   1b01c:	ffe58593          	addi	a1,a1,-2 # 3ffffffe <_gp+0x3ffe19be>
   1b020:	02e5e463          	bltu	a1,a4,1b048 <_fpadd_parts+0xbc>
   1b024:	00862703          	lw	a4,8(a2)
   1b028:	fff70713          	addi	a4,a4,-1
	{
	  tmp->fraction.ll <<= 1;
   1b02c:	00179793          	slli	a5,a5,0x1
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1b030:	fff78693          	addi	a3,a5,-1
	{
	  tmp->fraction.ll <<= 1;
	  tmp->normal_exp--;
   1b034:	00070513          	mv	a0,a4
   1b038:	fff70713          	addi	a4,a4,-1
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1b03c:	fed5f8e3          	bleu	a3,a1,1b02c <_fpadd_parts+0xa0>
   1b040:	00f62623          	sw	a5,12(a2)
   1b044:	00a62423          	sw	a0,8(a2)
    {
      tmp->sign = a->sign;
      tmp->normal_exp = a_normal_exp;
      tmp->fraction.ll = a_fraction + b_fraction;
    }
  tmp->class = CLASS_NUMBER;
   1b048:	00300713          	li	a4,3
   1b04c:	00e62023          	sw	a4,0(a2)
   1b050:	00060513          	mv	a0,a2
  /* Now the fraction is added, we have to shift down to renormalize the
     number */

  if (tmp->fraction.ll >= IMPLICIT_2)
   1b054:	0207d463          	bgez	a5,1b07c <_fpadd_parts+0xf0>
    {
      LSHIFT (tmp->fraction.ll, 1);
      tmp->normal_exp++;
   1b058:	00862703          	lw	a4,8(a2)
  /* Now the fraction is added, we have to shift down to renormalize the
     number */

  if (tmp->fraction.ll >= IMPLICIT_2)
    {
      LSHIFT (tmp->fraction.ll, 1);
   1b05c:	0017d693          	srli	a3,a5,0x1
   1b060:	0017f793          	andi	a5,a5,1
   1b064:	00f6e7b3          	or	a5,a3,a5
      tmp->normal_exp++;
   1b068:	00170713          	addi	a4,a4,1
  /* Now the fraction is added, we have to shift down to renormalize the
     number */

  if (tmp->fraction.ll >= IMPLICIT_2)
    {
      LSHIFT (tmp->fraction.ll, 1);
   1b06c:	00f62623          	sw	a5,12(a2)
      tmp->normal_exp++;
   1b070:	00e62423          	sw	a4,8(a2)
   1b074:	00008067          	ret
   1b078:	00058513          	mv	a0,a1
    }
  return tmp;
}
   1b07c:	00008067          	ret

    if (diff < 0)
      diff = -diff;
    if (diff < FRAC_NBITS)
      {
	if (sdiff > 0)
   1b080:	0b005863          	blez	a6,1b130 <_fpadd_parts+0x1a4>
	  {
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
   1b084:	011716b3          	sll	a3,a4,a7
   1b088:	fff68693          	addi	a3,a3,-1 # ffffff <_gp+0xfe19bf>
   1b08c:	0056f6b3          	and	a3,a3,t0
   1b090:	00d03733          	snez	a4,a3
   1b094:	0112d2b3          	srl	t0,t0,a7
   1b098:	00e2e2b3          	or	t0,t0,a4
	    a_fraction = 0;
	  }
      }
  }

  if (a->sign != b->sign)
   1b09c:	0045a783          	lw	a5,4(a1)
   1b0a0:	00452703          	lw	a4,4(a0)
   1b0a4:	f4f71ae3          	bne	a4,a5,1aff8 <_fpadd_parts+0x6c>
    }
  else
    {
      tmp->sign = a->sign;
      tmp->normal_exp = a_normal_exp;
      tmp->fraction.ll = a_fraction + b_fraction;
   1b0a8:	005387b3          	add	a5,t2,t0
	  tmp->normal_exp--;
	}
    }
  else
    {
      tmp->sign = a->sign;
   1b0ac:	00e62223          	sw	a4,4(a2)
      tmp->normal_exp = a_normal_exp;
   1b0b0:	00662423          	sw	t1,8(a2)
      tmp->fraction.ll = a_fraction + b_fraction;
   1b0b4:	00f62623          	sw	a5,12(a2)
   1b0b8:	f91ff06f          	j	1b048 <_fpadd_parts+0xbc>
    {
      return b;
    }
  if (iszero (b))
    {
      if (iszero (a))
   1b0bc:	fcd790e3          	bne	a5,a3,1b07c <_fpadd_parts+0xf0>
	{
	  *tmp = *a;
   1b0c0:	00f62023          	sw	a5,0(a2)
   1b0c4:	00452783          	lw	a5,4(a0)
   1b0c8:	00f62223          	sw	a5,4(a2)
   1b0cc:	00852703          	lw	a4,8(a0)
	  tmp->sign = a->sign & b->sign;
   1b0d0:	00452683          	lw	a3,4(a0)
   1b0d4:	0045a783          	lw	a5,4(a1)
    }
  if (iszero (b))
    {
      if (iszero (a))
	{
	  *tmp = *a;
   1b0d8:	00e62423          	sw	a4,8(a2)
   1b0dc:	00c52703          	lw	a4,12(a0)
	  tmp->sign = a->sign & b->sign;
   1b0e0:	00f6f7b3          	and	a5,a3,a5
   1b0e4:	00f62223          	sw	a5,4(a2)
    }
  if (iszero (b))
    {
      if (iszero (a))
	{
	  *tmp = *a;
   1b0e8:	00e62623          	sw	a4,12(a2)
	  tmp->sign = a->sign & b->sign;
	  return tmp;
   1b0ec:	00060513          	mv	a0,a2
   1b0f0:	00008067          	ret
      {
	/* Somethings's up.. choose the biggest */
	if (a_normal_exp > b_normal_exp)
	  {
	    b_normal_exp = a_normal_exp;
	    b_fraction = 0;
   1b0f4:	00000293          	li	t0,0
   1b0f8:	ef5ff06f          	j	1afec <_fpadd_parts+0x60>
      return b;
    }
  if (isinf (a))
    {
      /* Adding infinities with opposite signs yields a NaN.  */
      if (isinf (b) && a->sign != b->sign)
   1b0fc:	f8f690e3          	bne	a3,a5,1b07c <_fpadd_parts+0xf0>
   1b100:	00452703          	lw	a4,4(a0)
   1b104:	0045a783          	lw	a5,4(a1)
   1b108:	f6f70ae3          	beq	a4,a5,1b07c <_fpadd_parts+0xf0>
	return makenan ();
   1b10c:	0001c537          	lui	a0,0x1c
   1b110:	11050513          	addi	a0,a0,272 # 1c110 <__thenan_sf>
   1b114:	00008067          	ret
	}
      else
	{
	  tmp->sign = 1;
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
   1b118:	40f007b3          	neg	a5,a5
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = tfraction;
	}
      else
	{
	  tmp->sign = 1;
   1b11c:	00100713          	li	a4,1
   1b120:	00e62223          	sw	a4,4(a2)
	  tmp->normal_exp = a_normal_exp;
   1b124:	00662423          	sw	t1,8(a2)
	  tmp->fraction.ll = -tfraction;
   1b128:	00f62623          	sw	a5,12(a2)
   1b12c:	ee9ff06f          	j	1b014 <_fpadd_parts+0x88>
	if (sdiff > 0)
	  {
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
	  }
	else if (sdiff < 0)
   1b130:	ea080ee3          	beqz	a6,1afec <_fpadd_parts+0x60>
	  {
	    a_normal_exp += diff;
	    LSHIFT (a_fraction, diff);
   1b134:	01171833          	sll	a6,a4,a7
   1b138:	fff80813          	addi	a6,a6,-1
   1b13c:	00787833          	and	a6,a6,t2
   1b140:	0113d7b3          	srl	a5,t2,a7
   1b144:	010036b3          	snez	a3,a6
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
	  }
	else if (sdiff < 0)
	  {
	    a_normal_exp += diff;
   1b148:	01130333          	add	t1,t1,a7
	    LSHIFT (a_fraction, diff);
   1b14c:	00d7e3b3          	or	t2,a5,a3
   1b150:	e9dff06f          	j	1afec <_fpadd_parts+0x60>

0001b154 <__pack_f>:
extern FLO_type pack_d (const fp_number_type * );

#if defined(L_pack_df) || defined(L_pack_sf) || defined(L_pack_tf)
FLO_type
pack_d (const fp_number_type *src)
{
   1b154:	00052783          	lw	a5,0(a0)
  FLO_union_type dst;
  fractype fraction = src->fraction.ll;	/* wasn't unsigned before? */
  int sign = src->sign;
  int exp = 0;

  if (isnan (src))
   1b158:	00100613          	li	a2,1
#if defined(L_pack_df) || defined(L_pack_sf) || defined(L_pack_tf)
FLO_type
pack_d (const fp_number_type *src)
{
  FLO_union_type dst;
  fractype fraction = src->fraction.ll;	/* wasn't unsigned before? */
   1b15c:	00c52683          	lw	a3,12(a0)
  int sign = src->sign;
   1b160:	00452583          	lw	a1,4(a0)
  int exp = 0;

  if (isnan (src))
   1b164:	08f67a63          	bleu	a5,a2,1b1f8 <__pack_f+0xa4>
	  /* Set the quiet/signaling bit.  */
	  fraction |= QUIET_NAN;
#endif
	}
    }
  else if (isinf (src))
   1b168:	00400713          	li	a4,4
   1b16c:	08e78063          	beq	a5,a4,1b1ec <__pack_f+0x98>
    {
      exp = EXPMAX;
      fraction = 0;
    }
  else if (iszero (src))
   1b170:	00200713          	li	a4,2
   1b174:	04e78263          	beq	a5,a4,1b1b8 <__pack_f+0x64>
    {
      exp = 0;
      fraction = 0;
    }
  else if (fraction == 0)
   1b178:	04068063          	beqz	a3,1b1b8 <__pack_f+0x64>
    {
      exp = 0;
    }
  else
    {
      if (__builtin_expect (src->normal_exp < NORMAL_EXPMIN, 0))
   1b17c:	00852703          	lw	a4,8(a0)
   1b180:	f8200793          	li	a5,-126
   1b184:	0af74c63          	blt	a4,a5,1b23c <__pack_f+0xe8>
	      exp += 1;
	    }
	  fraction >>= NGARDS;
#endif /* NO_DENORMALS */
	}
      else if (__builtin_expect (src->normal_exp > EXPBIAS, 0))
   1b188:	07f00793          	li	a5,127
   1b18c:	06e7c063          	blt	a5,a4,1b1ec <__pack_f+0x98>
	{
	  exp = src->normal_exp + EXPBIAS;
	  /* IF the gard bits are the all zero, but the first, then we're
	     half way between two numbers, choose the one which makes the
	     lsb of the answer 0.  */
	  if ((fraction & GARDMASK) == GARDMSB)
   1b190:	00f6f7b3          	and	a5,a3,a5
   1b194:	04000613          	li	a2,64
   1b198:	08c78463          	beq	a5,a2,1b220 <__pack_f+0xcc>
		fraction += GARDROUND + 1;
	    }
	  else
	    {
	      /* Add a one to the guards to round up */
	      fraction += GARDROUND;
   1b19c:	03f68693          	addi	a3,a3,63
	    }
	  if (fraction >= IMPLICIT_2)
   1b1a0:	0806c863          	bltz	a3,1b230 <__pack_f+0xdc>
	  exp = EXPMAX;
	  fraction = 0;
	}
      else
	{
	  exp = src->normal_exp + EXPBIAS;
   1b1a4:	07f70713          	addi	a4,a4,127
   1b1a8:	00269693          	slli	a3,a3,0x2
   1b1ac:	0096d693          	srli	a3,a3,0x9
   1b1b0:	0ff77713          	andi	a4,a4,255
   1b1b4:	00c0006f          	j	1b1c0 <__pack_f+0x6c>
   1b1b8:	00000713          	li	a4,0
   1b1bc:	00000693          	li	a3,0

  /* We previously used bitfields to store the number, but this doesn't
     handle little/big endian systems conveniently, so use shifts and
     masks */
#ifdef FLOAT_BIT_ORDER_MISMATCH
  dst.bits.fraction = fraction;
   1b1c0:	008007b7          	lui	a5,0x800
   1b1c4:	fff78793          	addi	a5,a5,-1 # 7fffff <_gp+0x7e19bf>
  dst.bits.exp = exp;
   1b1c8:	80800637          	lui	a2,0x80800

  /* We previously used bitfields to store the number, but this doesn't
     handle little/big endian systems conveniently, so use shifts and
     masks */
#ifdef FLOAT_BIT_ORDER_MISMATCH
  dst.bits.fraction = fraction;
   1b1cc:	00f6f7b3          	and	a5,a3,a5
  dst.bits.exp = exp;
   1b1d0:	fff60613          	addi	a2,a2,-1 # 807fffff <_gp+0x807e19bf>
   1b1d4:	01771713          	slli	a4,a4,0x17
   1b1d8:	00c7f7b3          	and	a5,a5,a2
  dst.bits.sign = sign;
   1b1dc:	01f59513          	slli	a0,a1,0x1f
   1b1e0:	00e7e7b3          	or	a5,a5,a4
    dst.words[1] = tmp;
  }
#endif
#endif

  return dst.value;
   1b1e4:	00a7e533          	or	a0,a5,a0
}
   1b1e8:	00008067          	ret
   1b1ec:	0ff00713          	li	a4,255
   1b1f0:	00000693          	li	a3,0
   1b1f4:	fcdff06f          	j	1b1c0 <__pack_f+0x6c>
  if (isnan (src))
    {
      exp = EXPMAX;
      /* Restore the NaN's payload.  */
      fraction >>= NGARDS;
      fraction &= QUIET_NAN - 1;
   1b1f8:	004007b7          	lui	a5,0x400

  if (isnan (src))
    {
      exp = EXPMAX;
      /* Restore the NaN's payload.  */
      fraction >>= NGARDS;
   1b1fc:	0076d713          	srli	a4,a3,0x7
      fraction &= QUIET_NAN - 1;
   1b200:	fff78693          	addi	a3,a5,-1 # 3fffff <_gp+0x3e19bf>
   1b204:	00d776b3          	and	a3,a4,a3
   1b208:	00f6e6b3          	or	a3,a3,a5
   1b20c:	008007b7          	lui	a5,0x800
   1b210:	fff78793          	addi	a5,a5,-1 # 7fffff <_gp+0x7e19bf>
   1b214:	00f6f6b3          	and	a3,a3,a5
	  /* Make sure the fraction has a non-zero value.  */
	  if (fraction == 0)
	    fraction |= QUIET_NAN - 1;
#else
	  /* Set the quiet/signaling bit.  */
	  fraction |= QUIET_NAN;
   1b218:	0ff00713          	li	a4,255
   1b21c:	fa5ff06f          	j	1b1c0 <__pack_f+0x6c>
	  /* IF the gard bits are the all zero, but the first, then we're
	     half way between two numbers, choose the one which makes the
	     lsb of the answer 0.  */
	  if ((fraction & GARDMASK) == GARDMSB)
	    {
	      if (fraction & (1 << NGARDS))
   1b220:	0806f793          	andi	a5,a3,128
   1b224:	f6078ee3          	beqz	a5,1b1a0 <__pack_f+0x4c>
		fraction += GARDROUND + 1;
   1b228:	00c686b3          	add	a3,a3,a2
   1b22c:	f75ff06f          	j	1b1a0 <__pack_f+0x4c>
	      /* Add a one to the guards to round up */
	      fraction += GARDROUND;
	    }
	  if (fraction >= IMPLICIT_2)
	    {
	      fraction >>= 1;
   1b230:	0016d693          	srli	a3,a3,0x1
	      exp += 1;
   1b234:	08070713          	addi	a4,a4,128
   1b238:	f71ff06f          	j	1b1a8 <__pack_f+0x54>
#else /* NO_DENORMALS */
	  /* This number's exponent is too low to fit into the bits
	     available in the number, so we'll store 0 in the exponent and
	     shift the fraction to the right to make up for it.  */

	  int shift = NORMAL_EXPMIN - src->normal_exp;
   1b23c:	40e78733          	sub	a4,a5,a4

	  exp = 0;

	  if (shift > FRAC_NBITS - NGARDS)
   1b240:	01900793          	li	a5,25
   1b244:	f6e7cae3          	blt	a5,a4,1b1b8 <__pack_f+0x64>
	      fraction = 0;
	    }
	  else
	    {
	      int lowbit = (fraction & (((fractype)1 << shift) - 1)) ? 1 : 0;
	      fraction = (fraction >> shift) | lowbit;
   1b248:	00e617b3          	sll	a5,a2,a4
   1b24c:	fff78793          	addi	a5,a5,-1
   1b250:	00d7f7b3          	and	a5,a5,a3
   1b254:	00e6d6b3          	srl	a3,a3,a4
   1b258:	00f03733          	snez	a4,a5
   1b25c:	00e6e6b3          	or	a3,a3,a4
	    }
	  if ((fraction & GARDMASK) == GARDMSB)
   1b260:	07f6f713          	andi	a4,a3,127
   1b264:	04000793          	li	a5,64
   1b268:	02f71263          	bne	a4,a5,1b28c <__pack_f+0x138>
	    {
	      if ((fraction & (1 << NGARDS)))
   1b26c:	0806f793          	andi	a5,a3,128
   1b270:	02079c63          	bnez	a5,1b2a8 <__pack_f+0x154>
   1b274:	40000737          	lui	a4,0x40000
   1b278:	00e6b733          	sltu	a4,a3,a4
   1b27c:	00269613          	slli	a2,a3,0x2
   1b280:	00965693          	srli	a3,a2,0x9
   1b284:	00174713          	xori	a4,a4,1
   1b288:	f39ff06f          	j	1b1c0 <__pack_f+0x6c>
   1b28c:	03f68713          	addi	a4,a3,63
   1b290:	400007b7          	lui	a5,0x40000
   1b294:	00271693          	slli	a3,a4,0x2
   1b298:	00f73733          	sltu	a4,a4,a5
   1b29c:	0096d693          	srli	a3,a3,0x9
   1b2a0:	00174713          	xori	a4,a4,1
   1b2a4:	f1dff06f          	j	1b1c0 <__pack_f+0x6c>
		fraction += GARDROUND + 1;
   1b2a8:	04068713          	addi	a4,a3,64
   1b2ac:	fe5ff06f          	j	1b290 <__pack_f+0x13c>

0001b2b0 <__unpack_f>:
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
  exp = src->bits.exp;
   1b2b0:	00255703          	lhu	a4,2(a0)
  sign = src->bits.sign;
   1b2b4:	00354683          	lbu	a3,3(a0)
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1b2b8:	00052603          	lw	a2,0(a0)
  exp = src->bits.exp;
   1b2bc:	00775713          	srli	a4,a4,0x7
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1b2c0:	008007b7          	lui	a5,0x800
  exp = ((int)(src->value_raw >> FRACBITS)) & ((1 << EXPBITS) - 1);
  sign = ((int)(src->value_raw >> (FRACBITS + EXPBITS))) & 1;
# endif
#endif

  dst->sign = sign;
   1b2c4:	0076d693          	srli	a3,a3,0x7
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1b2c8:	fff78793          	addi	a5,a5,-1 # 7fffff <_gp+0x7e19bf>
  exp = src->bits.exp;
   1b2cc:	0ff77713          	andi	a4,a4,255
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1b2d0:	00f677b3          	and	a5,a2,a5
  exp = ((int)(src->value_raw >> FRACBITS)) & ((1 << EXPBITS) - 1);
  sign = ((int)(src->value_raw >> (FRACBITS + EXPBITS))) & 1;
# endif
#endif

  dst->sign = sign;
   1b2d4:	00d5a223          	sw	a3,4(a1)
  if (exp == 0)
   1b2d8:	02071c63          	bnez	a4,1b310 <__unpack_f+0x60>
    {
      /* Hmm.  Looks like 0 */
      if (fraction == 0
   1b2dc:	06078063          	beqz	a5,1b33c <__unpack_f+0x8c>
	     so there isn't a leading implicit one - we'll shift it so
	     it gets one.  */
	  dst->normal_exp = exp - EXPBIAS + 1;
	  fraction <<= NGARDS;

	  dst->class = CLASS_NUMBER;
   1b2e0:	00300713          	li	a4,3
   1b2e4:	00e5a023          	sw	a4,0(a1)
	{
	  /* Zero exponent with nonzero fraction - it's denormalized,
	     so there isn't a leading implicit one - we'll shift it so
	     it gets one.  */
	  dst->normal_exp = exp - EXPBIAS + 1;
	  fraction <<= NGARDS;
   1b2e8:	00779793          	slli	a5,a5,0x7

	  dst->class = CLASS_NUMBER;
   1b2ec:	f8100713          	li	a4,-127
#if 1
	  while (fraction < IMPLICIT_1)
   1b2f0:	40000637          	lui	a2,0x40000
	    {
	      fraction <<= 1;
   1b2f4:	00179793          	slli	a5,a5,0x1
	      dst->normal_exp--;
   1b2f8:	00070693          	mv	a3,a4
   1b2fc:	fff70713          	addi	a4,a4,-1 # 3fffffff <_gp+0x3ffe19bf>
	  dst->normal_exp = exp - EXPBIAS + 1;
	  fraction <<= NGARDS;

	  dst->class = CLASS_NUMBER;
#if 1
	  while (fraction < IMPLICIT_1)
   1b300:	fec7eae3          	bltu	a5,a2,1b2f4 <__unpack_f+0x44>
   1b304:	00d5a423          	sw	a3,8(a1)
	    {
	      fraction <<= 1;
	      dst->normal_exp--;
	    }
#endif
	  dst->fraction.ll = fraction;
   1b308:	00f5a623          	sw	a5,12(a1)
   1b30c:	00008067          	ret
	}
    }
  else if (__builtin_expect (exp == EXPMAX, 0))
   1b310:	0ff00693          	li	a3,255
   1b314:	02d70a63          	beq	a4,a3,1b348 <__unpack_f+0x98>
	}
    }
  else
    {
      /* Nothing strange about this number */
      dst->normal_exp = exp - EXPBIAS;
   1b318:	f8170713          	addi	a4,a4,-127
      dst->class = CLASS_NUMBER;
      dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;
   1b31c:	00779793          	slli	a5,a5,0x7
   1b320:	400006b7          	lui	a3,0x40000
   1b324:	00d7e7b3          	or	a5,a5,a3
	}
    }
  else
    {
      /* Nothing strange about this number */
      dst->normal_exp = exp - EXPBIAS;
   1b328:	00e5a423          	sw	a4,8(a1)
      dst->class = CLASS_NUMBER;
   1b32c:	00300713          	li	a4,3
   1b330:	00e5a023          	sw	a4,0(a1)
      dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;
   1b334:	00f5a623          	sw	a5,12(a1)
   1b338:	00008067          	ret
	  || 1
#endif
	  )
	{
	  /* tastes like zero */
	  dst->class = CLASS_ZERO;
   1b33c:	00200793          	li	a5,2
   1b340:	00f5a023          	sw	a5,0(a1)
   1b344:	00008067          	ret
	}
    }
  else if (__builtin_expect (exp == EXPMAX, 0))
    {
      /* Huge exponent*/
      if (fraction == 0)
   1b348:	02078663          	beqz	a5,1b374 <__unpack_f+0xc4>
	{
	  /* Nonzero fraction, means nan */
#ifdef QUIET_NAN_NEGATED
	  if ((fraction & QUIET_NAN) == 0)
#else
	  if (fraction & QUIET_NAN)
   1b34c:	00979713          	slli	a4,a5,0x9
   1b350:	02075863          	bgez	a4,1b380 <__unpack_f+0xd0>
#endif
	    {
	      dst->class = CLASS_QNAN;
   1b354:	00100713          	li	a4,1
   1b358:	00e5a023          	sw	a4,0(a1)
	      dst->class = CLASS_SNAN;
	    }
	  /* Now that we know which kind of NaN we got, discard the
	     quiet/signaling bit, but do preserve the NaN payload.  */
	  fraction &= ~QUIET_NAN;
	  dst->fraction.ll = fraction << NGARDS;
   1b35c:	ffc00737          	lui	a4,0xffc00
   1b360:	fff70713          	addi	a4,a4,-1 # ffbfffff <_gp+0xffbe19bf>
   1b364:	00e7f7b3          	and	a5,a5,a4
   1b368:	00779793          	slli	a5,a5,0x7
   1b36c:	00f5a623          	sw	a5,12(a1)
   1b370:	00008067          	ret
    {
      /* Huge exponent*/
      if (fraction == 0)
	{
	  /* Attached to a zero fraction - means infinity */
	  dst->class = CLASS_INFINITY;
   1b374:	00400793          	li	a5,4
   1b378:	00f5a023          	sw	a5,0(a1)
   1b37c:	00008067          	ret
	    {
	      dst->class = CLASS_QNAN;
	    }
	  else
	    {
	      dst->class = CLASS_SNAN;
   1b380:	0005a023          	sw	zero,0(a1)
   1b384:	fd9ff06f          	j	1b35c <__unpack_f+0xac>

0001b388 <__addsf3>:
  return tmp;
}

FLO_type
add (FLO_type arg_a, FLO_type arg_b)
{
   1b388:	fb010113          	addi	sp,sp,-80
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1b38c:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1b390:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1b394:	00810513          	addi	a0,sp,8
   1b398:	01010593          	addi	a1,sp,16
  return tmp;
}

FLO_type
add (FLO_type arg_a, FLO_type arg_b)
{
   1b39c:	04112623          	sw	ra,76(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1b3a0:	f11ff0ef          	jal	1b2b0 <__unpack_f>
  unpack_d (&bu, &b);
   1b3a4:	02010593          	addi	a1,sp,32
   1b3a8:	00c10513          	addi	a0,sp,12
   1b3ac:	f05ff0ef          	jal	1b2b0 <__unpack_f>

  res = _fpadd_parts (&a, &b, &tmp);
   1b3b0:	03010613          	addi	a2,sp,48
   1b3b4:	02010593          	addi	a1,sp,32
   1b3b8:	01010513          	addi	a0,sp,16
   1b3bc:	bd1ff0ef          	jal	1af8c <_fpadd_parts>

  return pack_d (res);
   1b3c0:	d95ff0ef          	jal	1b154 <__pack_f>
}
   1b3c4:	04c12083          	lw	ra,76(sp)
   1b3c8:	05010113          	addi	sp,sp,80
   1b3cc:	00008067          	ret

0001b3d0 <__subsf3>:

FLO_type
sub (FLO_type arg_a, FLO_type arg_b)
{
   1b3d0:	fb010113          	addi	sp,sp,-80
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1b3d4:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1b3d8:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1b3dc:	00810513          	addi	a0,sp,8
   1b3e0:	01010593          	addi	a1,sp,16
  return pack_d (res);
}

FLO_type
sub (FLO_type arg_a, FLO_type arg_b)
{
   1b3e4:	04112623          	sw	ra,76(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1b3e8:	ec9ff0ef          	jal	1b2b0 <__unpack_f>
  unpack_d (&bu, &b);
   1b3ec:	02010593          	addi	a1,sp,32
   1b3f0:	00c10513          	addi	a0,sp,12
   1b3f4:	ebdff0ef          	jal	1b2b0 <__unpack_f>

  b.sign ^= 1;
   1b3f8:	02412783          	lw	a5,36(sp)

  res = _fpadd_parts (&a, &b, &tmp);
   1b3fc:	03010613          	addi	a2,sp,48
   1b400:	02010593          	addi	a1,sp,32
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  b.sign ^= 1;
   1b404:	0017c793          	xori	a5,a5,1

  res = _fpadd_parts (&a, &b, &tmp);
   1b408:	01010513          	addi	a0,sp,16
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  b.sign ^= 1;
   1b40c:	02f12223          	sw	a5,36(sp)

  res = _fpadd_parts (&a, &b, &tmp);
   1b410:	b7dff0ef          	jal	1af8c <_fpadd_parts>

  return pack_d (res);
   1b414:	d41ff0ef          	jal	1b154 <__pack_f>
}
   1b418:	04c12083          	lw	ra,76(sp)
   1b41c:	05010113          	addi	sp,sp,80
   1b420:	00008067          	ret

0001b424 <__mulsf3>:
  return tmp;
}

FLO_type
multiply (FLO_type arg_a, FLO_type arg_b)
{
   1b424:	fb010113          	addi	sp,sp,-80
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1b428:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1b42c:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1b430:	00810513          	addi	a0,sp,8
   1b434:	01010593          	addi	a1,sp,16
  return tmp;
}

FLO_type
multiply (FLO_type arg_a, FLO_type arg_b)
{
   1b438:	04112623          	sw	ra,76(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1b43c:	e75ff0ef          	jal	1b2b0 <__unpack_f>
  unpack_d (&bu, &b);
   1b440:	02010593          	addi	a1,sp,32
   1b444:	00c10513          	addi	a0,sp,12
   1b448:	e69ff0ef          	jal	1b2b0 <__unpack_f>
   1b44c:	01012783          	lw	a5,16(sp)
	       fp_number_type * tmp)
{
  fractype low = 0;
  fractype high = 0;

  if (isnan (a))
   1b450:	00100693          	li	a3,1
   1b454:	0ef6f463          	bleu	a5,a3,1b53c <__mulsf3+0x118>
   1b458:	02012703          	lw	a4,32(sp)
    {
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isnan (b))
   1b45c:	0ae6f863          	bleu	a4,a3,1b50c <__mulsf3+0xe8>
    {
      b->sign = a->sign != b->sign;
      return b;
    }
  if (isinf (a))
   1b460:	00400693          	li	a3,4
   1b464:	0cd78863          	beq	a5,a3,1b534 <__mulsf3+0x110>
      if (iszero (b))
	return makenan ();
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isinf (b))
   1b468:	08d70e63          	beq	a4,a3,1b504 <__mulsf3+0xe0>
	  return makenan ();
	}
      b->sign = a->sign != b->sign;
      return b;
    }
  if (iszero (a))
   1b46c:	00200693          	li	a3,2
   1b470:	0cd78663          	beq	a5,a3,1b53c <__mulsf3+0x118>
    {
      a->sign = a->sign != b->sign;
      return a;
    }
  if (iszero (b))
   1b474:	08d70c63          	beq	a4,a3,1b50c <__mulsf3+0xe8>
	}
    }
#elif defined(FLOAT) 
    /* Multiplying two USIs to get a UDI, we're safe.  */
    {
      UDItype answer = (UDItype)a->fraction.ll * (UDItype)b->fraction.ll;
   1b478:	01c12703          	lw	a4,28(sp)
   1b47c:	02c12583          	lw	a1,44(sp)
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1b480:	02812683          	lw	a3,40(sp)
   1b484:	01812783          	lw	a5,24(sp)
	}
    }
#elif defined(FLOAT) 
    /* Multiplying two USIs to get a UDI, we're safe.  */
    {
      UDItype answer = (UDItype)a->fraction.ll * (UDItype)b->fraction.ll;
   1b488:	02b73633          	mulhu	a2,a4,a1
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
   1b48c:	02412803          	lw	a6,36(sp)
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1b490:	00d787b3          	add	a5,a5,a3
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
   1b494:	01412683          	lw	a3,20(sp)
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1b498:	00278513          	addi	a0,a5,2
   1b49c:	02a12c23          	sw	a0,56(sp)
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
   1b4a0:	410686b3          	sub	a3,a3,a6
   1b4a4:	00d036b3          	snez	a3,a3
   1b4a8:	02d12a23          	sw	a3,52(sp)
    /* Multiplying two USIs to get a UDI, we're safe.  */
    {
      UDItype answer = (UDItype)a->fraction.ll * (UDItype)b->fraction.ll;
      
      high = answer >> BITS_PER_SI;
      low = answer;
   1b4ac:	02b70733          	mul	a4,a4,a1
#elif defined(FLOAT) 
    /* Multiplying two USIs to get a UDI, we're safe.  */
    {
      UDItype answer = (UDItype)a->fraction.ll * (UDItype)b->fraction.ll;
      
      high = answer >> BITS_PER_SI;
   1b4b0:	00060693          	mv	a3,a2
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
  while (high >= IMPLICIT_2)
   1b4b4:	0c065a63          	bgez	a2,1b588 <__mulsf3+0x164>
    {
      tmp->normal_exp++;
      if (high & 1)
   1b4b8:	00167693          	andi	a3,a2,1
   1b4bc:	00378793          	addi	a5,a5,3
   1b4c0:	00068863          	beqz	a3,1b4d0 <__mulsf3+0xac>
	{
	  low >>= 1;
   1b4c4:	00175713          	srli	a4,a4,0x1
	  low |= FRACHIGH;
   1b4c8:	800006b7          	lui	a3,0x80000
   1b4cc:	00d76733          	or	a4,a4,a3
	}
      high >>= 1;
   1b4d0:	00165693          	srli	a3,a2,0x1
   1b4d4:	02f12c23          	sw	a5,56(sp)
      if (low & FRACHIGH)
	high |= 1;
      low <<= 1;
    }

  if ((high & GARDMASK) == GARDMSB)
   1b4d8:	07f6f793          	andi	a5,a3,127
   1b4dc:	04000613          	li	a2,64
   1b4e0:	08c78263          	beq	a5,a2,1b564 <__mulsf3+0x140>
	  /* Avoid further rounding in pack_d.  */
	  high &= ~(fractype) GARDMASK;
	}
    }
  tmp->fraction.ll = high;
  tmp->class = CLASS_NUMBER;
   1b4e4:	00300793          	li	a5,3

	  /* Avoid further rounding in pack_d.  */
	  high &= ~(fractype) GARDMASK;
	}
    }
  tmp->fraction.ll = high;
   1b4e8:	02d12e23          	sw	a3,60(sp)
  tmp->class = CLASS_NUMBER;
   1b4ec:	02f12823          	sw	a5,48(sp)
  return tmp;
   1b4f0:	03010513          	addi	a0,sp,48
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
   1b4f4:	c61ff0ef          	jal	1b154 <__pack_f>
}
   1b4f8:	04c12083          	lw	ra,76(sp)
   1b4fc:	05010113          	addi	sp,sp,80
   1b500:	00008067          	ret
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isinf (b))
    {
      if (iszero (a))
   1b504:	00200713          	li	a4,2
   1b508:	06e78a63          	beq	a5,a4,1b57c <__mulsf3+0x158>
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isnan (b))
    {
      b->sign = a->sign != b->sign;
   1b50c:	02412703          	lw	a4,36(sp)
   1b510:	01412783          	lw	a5,20(sp)
      return b;
   1b514:	02010513          	addi	a0,sp,32
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isnan (b))
    {
      b->sign = a->sign != b->sign;
   1b518:	40e787b3          	sub	a5,a5,a4
   1b51c:	00f037b3          	snez	a5,a5
   1b520:	02f12223          	sw	a5,36(sp)
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
   1b524:	c31ff0ef          	jal	1b154 <__pack_f>
}
   1b528:	04c12083          	lw	ra,76(sp)
   1b52c:	05010113          	addi	sp,sp,80
   1b530:	00008067          	ret
      b->sign = a->sign != b->sign;
      return b;
    }
  if (isinf (a))
    {
      if (iszero (b))
   1b534:	00200793          	li	a5,2
   1b538:	04f70263          	beq	a4,a5,1b57c <__mulsf3+0x158>
  fractype low = 0;
  fractype high = 0;

  if (isnan (a))
    {
      a->sign = a->sign != b->sign;
   1b53c:	02412703          	lw	a4,36(sp)
   1b540:	01412783          	lw	a5,20(sp)
      return a;
   1b544:	01010513          	addi	a0,sp,16
  fractype low = 0;
  fractype high = 0;

  if (isnan (a))
    {
      a->sign = a->sign != b->sign;
   1b548:	40e787b3          	sub	a5,a5,a4
   1b54c:	00f037b3          	snez	a5,a5
   1b550:	00f12a23          	sw	a5,20(sp)
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
   1b554:	c01ff0ef          	jal	1b154 <__pack_f>
}
   1b558:	04c12083          	lw	ra,76(sp)
   1b55c:	05010113          	addi	sp,sp,80
   1b560:	00008067          	ret
      low <<= 1;
    }

  if ((high & GARDMASK) == GARDMSB)
    {
      if (high & (1 << NGARDS))
   1b564:	0806f793          	andi	a5,a3,128
   1b568:	f6079ee3          	bnez	a5,1b4e4 <__mulsf3+0xc0>
	     function, and rounding twice will lose precision and cause
	     the result to be too far off.  Example: 32-bit floats with
	     bit patterns 0xfff * 0x3f800400 ~= 0xfff (less than 0.5ulp
	     off), not 0x1000 (more than 0.5ulp off).  */
	}
      else if (low)
   1b56c:	f6070ce3          	beqz	a4,1b4e4 <__mulsf3+0xc0>
	{
	  /* We're a further than half way by a small amount corresponding
	     to the bits set in "low".  Knowing that, we round here and
	     not in pack_d, because there we don't have "low" available
	     anymore.  */
	  high += GARDROUND + 1;
   1b570:	00c686b3          	add	a3,a3,a2

	  /* Avoid further rounding in pack_d.  */
	  high &= ~(fractype) GARDMASK;
   1b574:	f806f693          	andi	a3,a3,-128
   1b578:	f6dff06f          	j	1b4e4 <__mulsf3+0xc0>
      return b;
    }
  if (isinf (a))
    {
      if (iszero (b))
	return makenan ();
   1b57c:	0001c537          	lui	a0,0x1c
   1b580:	11050513          	addi	a0,a0,272 # 1c110 <__thenan_sf>
   1b584:	f71ff06f          	j	1b4f4 <__mulsf3+0xd0>
	  low >>= 1;
	  low |= FRACHIGH;
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
   1b588:	40000637          	lui	a2,0x40000
   1b58c:	f4c6f6e3          	bleu	a2,a3,1b4d8 <__mulsf3+0xb4>
   1b590:	00178793          	addi	a5,a5,1
   1b594:	0100006f          	j	1b5a4 <__mulsf3+0x180>
      tmp->normal_exp--;

      high <<= 1;
      if (low & FRACHIGH)
	high |= 1;
      low <<= 1;
   1b598:	00171713          	slli	a4,a4,0x1
   1b59c:	fff78793          	addi	a5,a5,-1
	  low >>= 1;
	  low |= FRACHIGH;
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
   1b5a0:	02c6f063          	bleu	a2,a3,1b5c0 <__mulsf3+0x19c>
    {
      tmp->normal_exp--;

      high <<= 1;
   1b5a4:	00169693          	slli	a3,a3,0x1
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
    {
      tmp->normal_exp--;
   1b5a8:	00078593          	mv	a1,a5

      high <<= 1;
      if (low & FRACHIGH)
   1b5ac:	fe0756e3          	bgez	a4,1b598 <__mulsf3+0x174>
	high |= 1;
   1b5b0:	0016e693          	ori	a3,a3,1
      low <<= 1;
   1b5b4:	00171713          	slli	a4,a4,0x1
   1b5b8:	fff78793          	addi	a5,a5,-1
	  low >>= 1;
	  low |= FRACHIGH;
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
   1b5bc:	fec6e4e3          	bltu	a3,a2,1b5a4 <__mulsf3+0x180>
   1b5c0:	02b12c23          	sw	a1,56(sp)
   1b5c4:	f15ff06f          	j	1b4d8 <__mulsf3+0xb4>

0001b5c8 <__divsf3>:
  }
}

FLO_type
divide (FLO_type arg_a, FLO_type arg_b)
{
   1b5c8:	fc010113          	addi	sp,sp,-64
  fp_number_type a;
  fp_number_type b;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1b5cc:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1b5d0:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1b5d4:	00810513          	addi	a0,sp,8
   1b5d8:	01010593          	addi	a1,sp,16
  }
}

FLO_type
divide (FLO_type arg_a, FLO_type arg_b)
{
   1b5dc:	02112e23          	sw	ra,60(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1b5e0:	cd1ff0ef          	jal	1b2b0 <__unpack_f>
  unpack_d (&bu, &b);
   1b5e4:	02010593          	addi	a1,sp,32
   1b5e8:	00c10513          	addi	a0,sp,12
   1b5ec:	cc5ff0ef          	jal	1b2b0 <__unpack_f>
   1b5f0:	01012683          	lw	a3,16(sp)
  fractype bit;
  fractype numerator;
  fractype denominator;
  fractype quotient;

  if (isnan (a))
   1b5f4:	00100793          	li	a5,1
   1b5f8:	08d7f663          	bleu	a3,a5,1b684 <__divsf3+0xbc>
   1b5fc:	02012603          	lw	a2,32(sp)
    {
      return a;
    }
  if (isnan (b))
   1b600:	0ec7f663          	bleu	a2,a5,1b6ec <__divsf3+0x124>
    {
      return b;
    }

  a->sign = a->sign ^ b->sign;
   1b604:	01412583          	lw	a1,20(sp)
   1b608:	02412703          	lw	a4,36(sp)

  if (isinf (a) || iszero (a))
   1b60c:	ffe68793          	addi	a5,a3,-2 # 7ffffffe <_gp+0x7ffe19be>
   1b610:	ffd7f793          	andi	a5,a5,-3
  if (isnan (b))
    {
      return b;
    }

  a->sign = a->sign ^ b->sign;
   1b614:	00e5c733          	xor	a4,a1,a4
   1b618:	00e12a23          	sw	a4,20(sp)

  if (isinf (a) || iszero (a))
   1b61c:	06078e63          	beqz	a5,1b698 <__divsf3+0xd0>
      if (a->class == b->class)
	return makenan ();
      return a;
    }

  if (isinf (b))
   1b620:	00400793          	li	a5,4
   1b624:	08f60a63          	beq	a2,a5,1b6b8 <__divsf3+0xf0>
    {
      a->fraction.ll = 0;
      a->normal_exp = 0;
      return a;
    }
  if (iszero (b))
   1b628:	00200713          	li	a4,2
   1b62c:	0ae60a63          	beq	a2,a4,1b6e0 <__divsf3+0x118>
  {
    /* quotient =
       ( numerator / denominator) * 2^(numerator exponent -  denominator exponent)
     */

    a->normal_exp = a->normal_exp - b->normal_exp;
   1b630:	01812703          	lw	a4,24(sp)
   1b634:	02812683          	lw	a3,40(sp)
    numerator = a->fraction.ll;
   1b638:	01c12783          	lw	a5,28(sp)
    denominator = b->fraction.ll;
   1b63c:	02c12603          	lw	a2,44(sp)
  {
    /* quotient =
       ( numerator / denominator) * 2^(numerator exponent -  denominator exponent)
     */

    a->normal_exp = a->normal_exp - b->normal_exp;
   1b640:	40d70733          	sub	a4,a4,a3
   1b644:	00e12c23          	sw	a4,24(sp)
    numerator = a->fraction.ll;
    denominator = b->fraction.ll;

    if (numerator < denominator)
   1b648:	06c7e063          	bltu	a5,a2,1b6a8 <__divsf3+0xe0>
  }
}

FLO_type
divide (FLO_type arg_a, FLO_type arg_b)
{
   1b64c:	01f00713          	li	a4,31
	/* Fraction will be less than 1.0 */
	numerator *= 2;
	a->normal_exp--;
      }
    bit = IMPLICIT_1;
    quotient = 0;
   1b650:	00000593          	li	a1,0
      {
	/* Fraction will be less than 1.0 */
	numerator *= 2;
	a->normal_exp--;
      }
    bit = IMPLICIT_1;
   1b654:	400006b7          	lui	a3,0x40000
   1b658:	fff70713          	addi	a4,a4,-1
    quotient = 0;
    /* ??? Does divide one bit at a time.  Optimize.  */
    while (bit)
      {
	if (numerator >= denominator)
   1b65c:	00c7e663          	bltu	a5,a2,1b668 <__divsf3+0xa0>
	  {
	    quotient |= bit;
   1b660:	00d5e5b3          	or	a1,a1,a3
	    numerator -= denominator;
   1b664:	40c787b3          	sub	a5,a5,a2
	  }
	bit >>= 1;
   1b668:	0016d693          	srli	a3,a3,0x1
	numerator *= 2;
   1b66c:	00179793          	slli	a5,a5,0x1
	a->normal_exp--;
      }
    bit = IMPLICIT_1;
    quotient = 0;
    /* ??? Does divide one bit at a time.  Optimize.  */
    while (bit)
   1b670:	fe0714e3          	bnez	a4,1b658 <__divsf3+0x90>
	  }
	bit >>= 1;
	numerator *= 2;
      }

    if ((quotient & GARDMASK) == GARDMSB)
   1b674:	07f5f713          	andi	a4,a1,127
   1b678:	04000693          	li	a3,64
   1b67c:	04d70663          	beq	a4,a3,1b6c8 <__divsf3+0x100>
	    /* Avoid further rounding in pack_d.  */
	    quotient &= ~(fractype) GARDMASK;
	  }
      }

    a->fraction.ll = quotient;
   1b680:	00b12e23          	sw	a1,28(sp)
    return (a);
   1b684:	01010513          	addi	a0,sp,16
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpdiv_parts (&a, &b);

  return pack_d (res);
   1b688:	acdff0ef          	jal	1b154 <__pack_f>
}
   1b68c:	03c12083          	lw	ra,60(sp)
   1b690:	04010113          	addi	sp,sp,64
   1b694:	00008067          	ret

  a->sign = a->sign ^ b->sign;

  if (isinf (a) || iszero (a))
    {
      if (a->class == b->class)
   1b698:	fec696e3          	bne	a3,a2,1b684 <__divsf3+0xbc>
	return makenan ();
   1b69c:	0001c537          	lui	a0,0x1c
   1b6a0:	11050513          	addi	a0,a0,272 # 1c110 <__thenan_sf>
   1b6a4:	fe5ff06f          	j	1b688 <__divsf3+0xc0>

    if (numerator < denominator)
      {
	/* Fraction will be less than 1.0 */
	numerator *= 2;
	a->normal_exp--;
   1b6a8:	fff70713          	addi	a4,a4,-1
    denominator = b->fraction.ll;

    if (numerator < denominator)
      {
	/* Fraction will be less than 1.0 */
	numerator *= 2;
   1b6ac:	00179793          	slli	a5,a5,0x1
	a->normal_exp--;
   1b6b0:	00e12c23          	sw	a4,24(sp)
   1b6b4:	f99ff06f          	j	1b64c <__divsf3+0x84>
      return a;
    }

  if (isinf (b))
    {
      a->fraction.ll = 0;
   1b6b8:	00012e23          	sw	zero,28(sp)
      a->normal_exp = 0;
   1b6bc:	00012c23          	sw	zero,24(sp)
      return a;
   1b6c0:	01010513          	addi	a0,sp,16
   1b6c4:	fc5ff06f          	j	1b688 <__divsf3+0xc0>
	numerator *= 2;
      }

    if ((quotient & GARDMASK) == GARDMSB)
      {
	if (quotient & (1 << NGARDS))
   1b6c8:	0805f713          	andi	a4,a1,128
   1b6cc:	fa071ae3          	bnez	a4,1b680 <__divsf3+0xb8>
	    /* Because we're half way, we would round to even by adding
	       GARDROUND + 1, except that's also done in the packing
	       function, and rounding twice will lose precision and cause
	       the result to be too far off.  */
	  }
	else if (numerator)
   1b6d0:	fa0788e3          	beqz	a5,1b680 <__divsf3+0xb8>
	  {
	    /* We're a further than half way by the small amount
	       corresponding to the bits set in "numerator".  Knowing
	       that, we round here and not in pack_d, because there we
	       don't have "numerator" available anymore.  */
	    quotient += GARDROUND + 1;
   1b6d4:	00d585b3          	add	a1,a1,a3

	    /* Avoid further rounding in pack_d.  */
	    quotient &= ~(fractype) GARDMASK;
   1b6d8:	f805f593          	andi	a1,a1,-128
   1b6dc:	fa5ff06f          	j	1b680 <__divsf3+0xb8>
      a->normal_exp = 0;
      return a;
    }
  if (iszero (b))
    {
      a->class = CLASS_INFINITY;
   1b6e0:	00f12823          	sw	a5,16(sp)
      return a;
   1b6e4:	01010513          	addi	a0,sp,16
   1b6e8:	fa1ff06f          	j	1b688 <__divsf3+0xc0>
    {
      return a;
    }
  if (isnan (b))
    {
      return b;
   1b6ec:	02010513          	addi	a0,sp,32
   1b6f0:	f99ff06f          	j	1b688 <__divsf3+0xc0>

0001b6f4 <__fpcmp_parts_f>:
   a>b -> +1
 */

int
__fpcmp_parts (fp_number_type * a, fp_number_type * b)
{
   1b6f4:	00052703          	lw	a4,0(a0)
    {
      return 1;			/* still unordered! */
    }
#endif

  if (isnan (a) || isnan (b))
   1b6f8:	00100793          	li	a5,1
   a>b -> +1
 */

int
__fpcmp_parts (fp_number_type * a, fp_number_type * b)
{
   1b6fc:	00050613          	mv	a2,a0
    {
      return 1;			/* still unordered! */
    }
#endif

  if (isnan (a) || isnan (b))
   1b700:	06e7fe63          	bleu	a4,a5,1b77c <__fpcmp_parts_f+0x88>
   1b704:	0005a683          	lw	a3,0(a1)
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1b708:	00078513          	mv	a0,a5
    {
      return 1;			/* still unordered! */
    }
#endif

  if (isnan (a) || isnan (b))
   1b70c:	04d7f063          	bleu	a3,a5,1b74c <__fpcmp_parts_f+0x58>
    {
      return 1;			/* how to indicate unordered compare? */
    }
  if (isinf (a) && isinf (b))
   1b710:	00400793          	li	a5,4
   1b714:	04f70863          	beq	a4,a5,1b764 <__fpcmp_parts_f+0x70>
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
    }
  if (isinf (b))
   1b718:	02f68c63          	beq	a3,a5,1b750 <__fpcmp_parts_f+0x5c>
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (a) && iszero (b))
   1b71c:	00200793          	li	a5,2
   1b720:	02f70263          	beq	a4,a5,1b744 <__fpcmp_parts_f+0x50>
    }
  if (iszero (a))
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (b))
   1b724:	04f68263          	beq	a3,a5,1b768 <__fpcmp_parts_f+0x74>
    {
      return a->sign ? -1 : 1;
    }
  /* now both are "normal".  */
  if (a->sign != b->sign)
   1b728:	00462783          	lw	a5,4(a2) # 40000004 <_gp+0x3ffe19c4>
   1b72c:	0045a703          	lw	a4,4(a1)
   1b730:	04e78a63          	beq	a5,a4,1b784 <__fpcmp_parts_f+0x90>
    {
      return a->sign ? -1 : 1;
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
   1b734:	00f03533          	snez	a0,a5
   1b738:	40a00533          	neg	a0,a0
   1b73c:	00156513          	ori	a0,a0,1
   1b740:	00008067          	ret
    }
  if (iszero (a) && iszero (b))
   1b744:	00e69663          	bne	a3,a4,1b750 <__fpcmp_parts_f+0x5c>
    {
      return 0;
   1b748:	00000513          	li	a0,0
    {
      return a->sign ? 1 : -1;
    }
  /* after all that, they're equal.  */
  return 0;
}
   1b74c:	00008067          	ret
    {
      return a->sign ? -1 : 1;
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
   1b750:	0045a503          	lw	a0,4(a1)
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1b754:	00153513          	seqz	a0,a0
   1b758:	40a00533          	neg	a0,a0
   1b75c:	00156513          	ori	a0,a0,1
   1b760:	00008067          	ret

  if (isnan (a) || isnan (b))
    {
      return 1;			/* how to indicate unordered compare? */
    }
  if (isinf (a) && isinf (b))
   1b764:	04e68a63          	beq	a3,a4,1b7b8 <__fpcmp_parts_f+0xc4>
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1b768:	00462503          	lw	a0,4(a2)
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
   1b76c:	00a03533          	snez	a0,a0
   1b770:	40a00533          	neg	a0,a0
   1b774:	00156513          	ori	a0,a0,1
   1b778:	00008067          	ret
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1b77c:	00078513          	mv	a0,a5
   1b780:	00008067          	ret
    {
      /* opposite signs */
      return a->sign ? -1 : 1;
    }
  /* same sign; exponents? */
  if (a->normal_exp > b->normal_exp)
   1b784:	00862683          	lw	a3,8(a2)
   1b788:	0085a703          	lw	a4,8(a1)
   1b78c:	fad744e3          	blt	a4,a3,1b734 <__fpcmp_parts_f+0x40>
    {
      return a->sign ? -1 : 1;
    }
  if (a->normal_exp < b->normal_exp)
   1b790:	00e6cc63          	blt	a3,a4,1b7a8 <__fpcmp_parts_f+0xb4>
    {
      return a->sign ? 1 : -1;
    }
  /* same exponents; check size.  */
  if (a->fraction.ll > b->fraction.ll)
   1b794:	00c62683          	lw	a3,12(a2)
   1b798:	00c5a703          	lw	a4,12(a1)
   1b79c:	f8d76ce3          	bltu	a4,a3,1b734 <__fpcmp_parts_f+0x40>
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (a) && iszero (b))
    {
      return 0;
   1b7a0:	00000513          	li	a0,0
  /* same exponents; check size.  */
  if (a->fraction.ll > b->fraction.ll)
    {
      return a->sign ? -1 : 1;
    }
  if (a->fraction.ll < b->fraction.ll)
   1b7a4:	fae6f4e3          	bleu	a4,a3,1b74c <__fpcmp_parts_f+0x58>
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1b7a8:	0017b513          	seqz	a0,a5
   1b7ac:	40a00533          	neg	a0,a0
   1b7b0:	00156513          	ori	a0,a0,1
   1b7b4:	00008067          	ret
       -------+--------+--------
       -inf(1)| a>b(1) | a==b(0)
       -------+--------+--------
       So since unordered must be nonzero, just line up the columns...
       */
      return b->sign - a->sign;
   1b7b8:	0045a783          	lw	a5,4(a1)
   1b7bc:	00462503          	lw	a0,4(a2)
   1b7c0:	40a78533          	sub	a0,a5,a0
   1b7c4:	00008067          	ret

0001b7c8 <__cmpsf2>:
#endif

#if defined(L_compare_sf) || defined(L_compare_df) || defined(L_compoare_tf)
CMPtype
compare (FLO_type arg_a, FLO_type arg_b)
{
   1b7c8:	fc010113          	addi	sp,sp,-64
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1b7cc:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1b7d0:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1b7d4:	00810513          	addi	a0,sp,8
   1b7d8:	01010593          	addi	a1,sp,16
#endif

#if defined(L_compare_sf) || defined(L_compare_df) || defined(L_compoare_tf)
CMPtype
compare (FLO_type arg_a, FLO_type arg_b)
{
   1b7dc:	02112e23          	sw	ra,60(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1b7e0:	ad1ff0ef          	jal	1b2b0 <__unpack_f>
  unpack_d (&bu, &b);
   1b7e4:	02010593          	addi	a1,sp,32
   1b7e8:	00c10513          	addi	a0,sp,12
   1b7ec:	ac5ff0ef          	jal	1b2b0 <__unpack_f>

  return __fpcmp_parts (&a, &b);
   1b7f0:	02010593          	addi	a1,sp,32
   1b7f4:	01010513          	addi	a0,sp,16
   1b7f8:	efdff0ef          	jal	1b6f4 <__fpcmp_parts_f>
}
   1b7fc:	03c12083          	lw	ra,60(sp)
   1b800:	04010113          	addi	sp,sp,64
   1b804:	00008067          	ret

0001b808 <__gesf2>:
#endif /* L_gt_sf || L_gt_df */

#if defined(L_ge_sf) || defined(L_ge_df) || defined(L_ge_tf)
CMPtype
_ge_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1b808:	fc010113          	addi	sp,sp,-64
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1b80c:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1b810:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1b814:	00810513          	addi	a0,sp,8
   1b818:	01010593          	addi	a1,sp,16
#endif /* L_gt_sf || L_gt_df */

#if defined(L_ge_sf) || defined(L_ge_df) || defined(L_ge_tf)
CMPtype
_ge_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1b81c:	02112e23          	sw	ra,60(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1b820:	a91ff0ef          	jal	1b2b0 <__unpack_f>
  unpack_d (&bu, &b);
   1b824:	00c10513          	addi	a0,sp,12
   1b828:	02010593          	addi	a1,sp,32
   1b82c:	a85ff0ef          	jal	1b2b0 <__unpack_f>

  if (isnan (&a) || isnan (&b))
   1b830:	01012703          	lw	a4,16(sp)
   1b834:	00100793          	li	a5,1
    return -1;			/* false, truth >= 0 */
   1b838:	fff00513          	li	a0,-1
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  if (isnan (&a) || isnan (&b))
   1b83c:	00e7fc63          	bleu	a4,a5,1b854 <__gesf2+0x4c>
   1b840:	02012703          	lw	a4,32(sp)
   1b844:	00e7f863          	bleu	a4,a5,1b854 <__gesf2+0x4c>
    return -1;			/* false, truth >= 0 */
  return __fpcmp_parts (&a, &b) ;
   1b848:	02010593          	addi	a1,sp,32
   1b84c:	01010513          	addi	a0,sp,16
   1b850:	ea5ff0ef          	jal	1b6f4 <__fpcmp_parts_f>
}
   1b854:	03c12083          	lw	ra,60(sp)
   1b858:	04010113          	addi	sp,sp,64
   1b85c:	00008067          	ret

0001b860 <__gtsf2>:
   1b860:	fa9ff06f          	j	1b808 <__gesf2>

0001b864 <__lesf2>:
#endif /* L_lt_sf || L_lt_df */

#if defined(L_le_sf) || defined(L_le_df) || defined(L_le_tf)
CMPtype
_le_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1b864:	fc010113          	addi	sp,sp,-64
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1b868:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1b86c:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1b870:	00810513          	addi	a0,sp,8
   1b874:	01010593          	addi	a1,sp,16
#endif /* L_lt_sf || L_lt_df */

#if defined(L_le_sf) || defined(L_le_df) || defined(L_le_tf)
CMPtype
_le_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1b878:	02112e23          	sw	ra,60(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1b87c:	a35ff0ef          	jal	1b2b0 <__unpack_f>
  unpack_d (&bu, &b);
   1b880:	00c10513          	addi	a0,sp,12
   1b884:	02010593          	addi	a1,sp,32
   1b888:	a29ff0ef          	jal	1b2b0 <__unpack_f>

  if (isnan (&a) || isnan (&b))
   1b88c:	01012783          	lw	a5,16(sp)
   1b890:	00100513          	li	a0,1
   1b894:	00f57c63          	bleu	a5,a0,1b8ac <__lesf2+0x48>
   1b898:	02012783          	lw	a5,32(sp)
   1b89c:	00f57863          	bleu	a5,a0,1b8ac <__lesf2+0x48>
    return 1;			/* false, truth <= 0 */

  return __fpcmp_parts (&a, &b) ;
   1b8a0:	02010593          	addi	a1,sp,32
   1b8a4:	01010513          	addi	a0,sp,16
   1b8a8:	e4dff0ef          	jal	1b6f4 <__fpcmp_parts_f>
}
   1b8ac:	03c12083          	lw	ra,60(sp)
   1b8b0:	04010113          	addi	sp,sp,64
   1b8b4:	00008067          	ret

0001b8b8 <__ltsf2>:
   1b8b8:	fadff06f          	j	1b864 <__lesf2>

0001b8bc <__nesf2>:
   1b8bc:	fa9ff06f          	j	1b864 <__lesf2>

0001b8c0 <__eqsf2>:
   1b8c0:	fa5ff06f          	j	1b864 <__lesf2>

0001b8c4 <__unordsf2>:
#endif /* L_le_sf || L_le_df */

#if defined(L_unord_sf) || defined(L_unord_df) || defined(L_unord_tf)
CMPtype
_unord_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1b8c4:	fc010113          	addi	sp,sp,-64
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1b8c8:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1b8cc:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1b8d0:	00810513          	addi	a0,sp,8
   1b8d4:	01010593          	addi	a1,sp,16
#endif /* L_le_sf || L_le_df */

#if defined(L_unord_sf) || defined(L_unord_df) || defined(L_unord_tf)
CMPtype
_unord_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1b8d8:	02112e23          	sw	ra,60(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1b8dc:	9d5ff0ef          	jal	1b2b0 <__unpack_f>
  unpack_d (&bu, &b);
   1b8e0:	00c10513          	addi	a0,sp,12
   1b8e4:	02010593          	addi	a1,sp,32
   1b8e8:	9c9ff0ef          	jal	1b2b0 <__unpack_f>

  return (isnan (&a) || isnan (&b));
   1b8ec:	01012783          	lw	a5,16(sp)
   1b8f0:	00100513          	li	a0,1
   1b8f4:	00f57663          	bleu	a5,a0,1b900 <__unordsf2+0x3c>
   1b8f8:	02012503          	lw	a0,32(sp)
   1b8fc:	00253513          	sltiu	a0,a0,2
}
   1b900:	03c12083          	lw	ra,60(sp)
   1b904:	04010113          	addi	sp,sp,64
   1b908:	00008067          	ret

0001b90c <__floatsisf>:
#endif /* L_unord_sf || L_unord_df */

#if defined(L_si_to_sf) || defined(L_si_to_df) || defined(L_si_to_tf)
FLO_type
si_to_float (SItype arg_a)
{
   1b90c:	fe010113          	addi	sp,sp,-32
  fp_number_type in;

  in.class = CLASS_NUMBER;
  in.sign = arg_a < 0;
   1b910:	01f55793          	srli	a5,a0,0x1f
FLO_type
si_to_float (SItype arg_a)
{
  fp_number_type in;

  in.class = CLASS_NUMBER;
   1b914:	00300713          	li	a4,3
#endif /* L_unord_sf || L_unord_df */

#if defined(L_si_to_sf) || defined(L_si_to_df) || defined(L_si_to_tf)
FLO_type
si_to_float (SItype arg_a)
{
   1b918:	00112e23          	sw	ra,28(sp)
   1b91c:	00812c23          	sw	s0,24(sp)
  fp_number_type in;

  in.class = CLASS_NUMBER;
   1b920:	00e12023          	sw	a4,0(sp)
  in.sign = arg_a < 0;
   1b924:	00f12223          	sw	a5,4(sp)
  if (!arg_a)
   1b928:	02051263          	bnez	a0,1b94c <__floatsisf+0x40>
    {
      in.class = CLASS_ZERO;
   1b92c:	00200793          	li	a5,2
   1b930:	00f12023          	sw	a5,0(sp)
	{
	  in.fraction.ll <<= shift;
	  in.normal_exp -= shift;
	}
    }
  return pack_d (&in);
   1b934:	00010513          	mv	a0,sp
   1b938:	81dff0ef          	jal	1b154 <__pack_f>
}
   1b93c:	01c12083          	lw	ra,28(sp)
   1b940:	01812403          	lw	s0,24(sp)
   1b944:	02010113          	addi	sp,sp,32
   1b948:	00008067          	ret
    }
  else
    {
      USItype uarg;
      int shift;
      in.normal_exp = FRACBITS + NGARDS;
   1b94c:	01e00793          	li	a5,30
   1b950:	00f12423          	sw	a5,8(sp)
      if (in.sign) 
   1b954:	02054863          	bltz	a0,1b984 <__floatsisf+0x78>
	      return (FLO_type)(- MAX_SI_INT - 1);
	    }
	  uarg = (-arg_a);
	}
      else
	uarg = arg_a;
   1b958:	00050413          	mv	s0,a0
static int
clzusi (USItype n)
{
  extern int __clzsi2 (USItype);
  if (sizeof (USItype) == sizeof (unsigned int))
    return __builtin_clz (n);
   1b95c:	00040513          	mv	a0,s0
   1b960:	dbcff0ef          	jal	1af1c <__clzsi2>
	}
      else
	uarg = arg_a;

      in.fraction.ll = uarg;
      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
   1b964:	fff50793          	addi	a5,a0,-1
      if (shift > 0)
   1b968:	02078c63          	beqz	a5,1b9a0 <__floatsisf+0x94>
	{
	  in.fraction.ll <<= shift;
	  in.normal_exp -= shift;
   1b96c:	01e00713          	li	a4,30

      in.fraction.ll = uarg;
      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
      if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1b970:	00f41533          	sll	a0,s0,a5
	  in.normal_exp -= shift;
   1b974:	40f707b3          	sub	a5,a4,a5

      in.fraction.ll = uarg;
      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
      if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1b978:	00a12623          	sw	a0,12(sp)
	  in.normal_exp -= shift;
   1b97c:	00f12423          	sw	a5,8(sp)
   1b980:	fb5ff06f          	j	1b934 <__floatsisf+0x28>
      in.normal_exp = FRACBITS + NGARDS;
      if (in.sign) 
	{
	  /* Special case for minint, since there is no +ve integer
	     representation for it */
	  if (arg_a == (- MAX_SI_INT - 1))
   1b984:	800007b7          	lui	a5,0x80000
   1b988:	02f50063          	beq	a0,a5,1b9a8 <__floatsisf+0x9c>
	    {
	      return (FLO_type)(- MAX_SI_INT - 1);
	    }
	  uarg = (-arg_a);
   1b98c:	40a00433          	neg	s0,a0
static int
clzusi (USItype n)
{
  extern int __clzsi2 (USItype);
  if (sizeof (USItype) == sizeof (unsigned int))
    return __builtin_clz (n);
   1b990:	00040513          	mv	a0,s0
   1b994:	d88ff0ef          	jal	1af1c <__clzsi2>
	}
      else
	uarg = arg_a;

      in.fraction.ll = uarg;
      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
   1b998:	fff50793          	addi	a5,a0,-1
      if (shift > 0)
   1b99c:	fc0798e3          	bnez	a5,1b96c <__floatsisf+0x60>
	  uarg = (-arg_a);
	}
      else
	uarg = arg_a;

      in.fraction.ll = uarg;
   1b9a0:	00812623          	sw	s0,12(sp)
   1b9a4:	f91ff06f          	j	1b934 <__floatsisf+0x28>
	{
	  /* Special case for minint, since there is no +ve integer
	     representation for it */
	  if (arg_a == (- MAX_SI_INT - 1))
	    {
	      return (FLO_type)(- MAX_SI_INT - 1);
   1b9a8:	8781a503          	lw	a0,-1928(gp) # 1deb8 <__wctomb+0x58>
   1b9ac:	f91ff06f          	j	1b93c <__floatsisf+0x30>

0001b9b0 <__floatunsisf>:
#endif /* L_si_to_sf || L_si_to_df */

#if defined(L_usi_to_sf) || defined(L_usi_to_df) || defined(L_usi_to_tf)
FLO_type
usi_to_float (USItype arg_a)
{
   1b9b0:	fe010113          	addi	sp,sp,-32
   1b9b4:	00112e23          	sw	ra,28(sp)
   1b9b8:	00812c23          	sw	s0,24(sp)
   1b9bc:	00912a23          	sw	s1,20(sp)
  fp_number_type in;

  in.sign = 0;
   1b9c0:	00012223          	sw	zero,4(sp)
  if (!arg_a)
   1b9c4:	04050a63          	beqz	a0,1ba18 <__floatunsisf+0x68>
      in.class = CLASS_ZERO;
    }
  else
    {
      int shift;
      in.class = CLASS_NUMBER;
   1b9c8:	00300793          	li	a5,3
      in.normal_exp = FRACBITS + NGARDS;
   1b9cc:	01e00493          	li	s1,30
      in.class = CLASS_ZERO;
    }
  else
    {
      int shift;
      in.class = CLASS_NUMBER;
   1b9d0:	00f12023          	sw	a5,0(sp)
   1b9d4:	00050413          	mv	s0,a0
      in.normal_exp = FRACBITS + NGARDS;
   1b9d8:	00912423          	sw	s1,8(sp)
static int
clzusi (USItype n)
{
  extern int __clzsi2 (USItype);
  if (sizeof (USItype) == sizeof (unsigned int))
    return __builtin_clz (n);
   1b9dc:	d40ff0ef          	jal	1af1c <__clzsi2>
      in.class = CLASS_NUMBER;
      in.normal_exp = FRACBITS + NGARDS;
      in.fraction.ll = arg_a;

      shift = clzusi (arg_a) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
      if (shift < 0)
   1b9e0:	fff50793          	addi	a5,a0,-1
   1b9e4:	04050063          	beqz	a0,1ba24 <__floatunsisf+0x74>
	  fractype guard = in.fraction.ll & (((fractype)1 << -shift) - 1);
	  in.fraction.ll >>= -shift;
	  in.fraction.ll |= (guard != 0);
	  in.normal_exp -= shift;
	}
      else if (shift > 0)
   1b9e8:	04078c63          	beqz	a5,1ba40 <__floatunsisf+0x90>
	{
	  in.fraction.ll <<= shift;
   1b9ec:	00f41433          	sll	s0,s0,a5
	  in.normal_exp -= shift;
   1b9f0:	40f484b3          	sub	s1,s1,a5
	  in.fraction.ll |= (guard != 0);
	  in.normal_exp -= shift;
	}
      else if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1b9f4:	00812623          	sw	s0,12(sp)
	  in.normal_exp -= shift;
   1b9f8:	00912423          	sw	s1,8(sp)
	}
    }
  return pack_d (&in);
   1b9fc:	00010513          	mv	a0,sp
   1ba00:	f54ff0ef          	jal	1b154 <__pack_f>
}
   1ba04:	01c12083          	lw	ra,28(sp)
   1ba08:	01812403          	lw	s0,24(sp)
   1ba0c:	01412483          	lw	s1,20(sp)
   1ba10:	02010113          	addi	sp,sp,32
   1ba14:	00008067          	ret
  fp_number_type in;

  in.sign = 0;
  if (!arg_a)
    {
      in.class = CLASS_ZERO;
   1ba18:	00200793          	li	a5,2
   1ba1c:	00f12023          	sw	a5,0(sp)
   1ba20:	fddff06f          	j	1b9fc <__floatunsisf+0x4c>
      shift = clzusi (arg_a) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
      if (shift < 0)
	{
	  fractype guard = in.fraction.ll & (((fractype)1 << -shift) - 1);
	  in.fraction.ll >>= -shift;
	  in.fraction.ll |= (guard != 0);
   1ba24:	00147793          	andi	a5,s0,1
   1ba28:	00145413          	srli	s0,s0,0x1
   1ba2c:	0087e433          	or	s0,a5,s0
	  in.normal_exp -= shift;
   1ba30:	01f00793          	li	a5,31
      shift = clzusi (arg_a) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
      if (shift < 0)
	{
	  fractype guard = in.fraction.ll & (((fractype)1 << -shift) - 1);
	  in.fraction.ll >>= -shift;
	  in.fraction.ll |= (guard != 0);
   1ba34:	00812623          	sw	s0,12(sp)
	  in.normal_exp -= shift;
   1ba38:	00f12423          	sw	a5,8(sp)
   1ba3c:	fc1ff06f          	j	1b9fc <__floatunsisf+0x4c>
  else
    {
      int shift;
      in.class = CLASS_NUMBER;
      in.normal_exp = FRACBITS + NGARDS;
      in.fraction.ll = arg_a;
   1ba40:	00812623          	sw	s0,12(sp)
   1ba44:	fb9ff06f          	j	1b9fc <__floatunsisf+0x4c>

0001ba48 <__fixsfsi>:
#endif

#if defined(L_sf_to_si) || defined(L_df_to_si) || defined(L_tf_to_si)
SItype
float_to_si (FLO_type arg_a)
{
   1ba48:	fd010113          	addi	sp,sp,-48
  fp_number_type a;
  SItype tmp;
  FLO_union_type au;

  au.value = arg_a;
   1ba4c:	00a12623          	sw	a0,12(sp)
  unpack_d (&au, &a);
   1ba50:	01010593          	addi	a1,sp,16
   1ba54:	00c10513          	addi	a0,sp,12
#endif

#if defined(L_sf_to_si) || defined(L_df_to_si) || defined(L_tf_to_si)
SItype
float_to_si (FLO_type arg_a)
{
   1ba58:	02112623          	sw	ra,44(sp)
  fp_number_type a;
  SItype tmp;
  FLO_union_type au;

  au.value = arg_a;
  unpack_d (&au, &a);
   1ba5c:	855ff0ef          	jal	1b2b0 <__unpack_f>
   1ba60:	01012783          	lw	a5,16(sp)

  if (iszero (&a))
    return 0;
  if (isnan (&a))
   1ba64:	00200713          	li	a4,2
   1ba68:	04f77e63          	bleu	a5,a4,1bac4 <__fixsfsi+0x7c>
    return 0;
  /* get reasonable MAX_SI_INT...  */
  if (isinf (&a))
   1ba6c:	00400713          	li	a4,4
   1ba70:	00e78a63          	beq	a5,a4,1ba84 <__fixsfsi+0x3c>
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  /* it is a number, but a small one */
  if (a.normal_exp < 0)
   1ba74:	01812783          	lw	a5,24(sp)
   1ba78:	0407c663          	bltz	a5,1bac4 <__fixsfsi+0x7c>
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
   1ba7c:	01e00513          	li	a0,30
   1ba80:	02f55063          	ble	a5,a0,1baa0 <__fixsfsi+0x58>
    return 0;
  if (isnan (&a))
    return 0;
  /* get reasonable MAX_SI_INT...  */
  if (isinf (&a))
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
   1ba84:	01412783          	lw	a5,20(sp)
   1ba88:	80000537          	lui	a0,0x80000
   1ba8c:	00079463          	bnez	a5,1ba94 <__fixsfsi+0x4c>
   1ba90:	fff54513          	not	a0,a0
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
  return a.sign ? (-tmp) : (tmp);
}
   1ba94:	02c12083          	lw	ra,44(sp)
   1ba98:	03010113          	addi	sp,sp,48
   1ba9c:	00008067          	ret
  /* it is a number, but a small one */
  if (a.normal_exp < 0)
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
   1baa0:	40f50533          	sub	a0,a0,a5
  return a.sign ? (-tmp) : (tmp);
   1baa4:	01c12783          	lw	a5,28(sp)
   1baa8:	00a7d533          	srl	a0,a5,a0
   1baac:	01412783          	lw	a5,20(sp)
   1bab0:	fe0782e3          	beqz	a5,1ba94 <__fixsfsi+0x4c>
}
   1bab4:	02c12083          	lw	ra,44(sp)
  if (a.normal_exp < 0)
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
  return a.sign ? (-tmp) : (tmp);
   1bab8:	40a00533          	neg	a0,a0
}
   1babc:	03010113          	addi	sp,sp,48
   1bac0:	00008067          	ret
   1bac4:	02c12083          	lw	ra,44(sp)
  unpack_d (&au, &a);

  if (iszero (&a))
    return 0;
  if (isnan (&a))
    return 0;
   1bac8:	00000513          	li	a0,0
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
  return a.sign ? (-tmp) : (tmp);
}
   1bacc:	03010113          	addi	sp,sp,48
   1bad0:	00008067          	ret

0001bad4 <__negsf2>:
#endif /* L_tf_to_usi */

#if defined(L_negate_sf) || defined(L_negate_df) || defined(L_negate_tf)
FLO_type
negate (FLO_type arg_a)
{
   1bad4:	fd010113          	addi	sp,sp,-48
  fp_number_type a;
  FLO_union_type au;

  au.value = arg_a;
   1bad8:	00a12623          	sw	a0,12(sp)
  unpack_d (&au, &a);
   1badc:	01010593          	addi	a1,sp,16
   1bae0:	00c10513          	addi	a0,sp,12
#endif /* L_tf_to_usi */

#if defined(L_negate_sf) || defined(L_negate_df) || defined(L_negate_tf)
FLO_type
negate (FLO_type arg_a)
{
   1bae4:	02112623          	sw	ra,44(sp)
  fp_number_type a;
  FLO_union_type au;

  au.value = arg_a;
  unpack_d (&au, &a);
   1bae8:	fc8ff0ef          	jal	1b2b0 <__unpack_f>

INLINE 
static void
flip_sign ( fp_number_type *  x)
{
  x->sign = !x->sign;
   1baec:	01412783          	lw	a5,20(sp)

  au.value = arg_a;
  unpack_d (&au, &a);

  flip_sign (&a);
  return pack_d (&a);
   1baf0:	01010513          	addi	a0,sp,16

INLINE 
static void
flip_sign ( fp_number_type *  x)
{
  x->sign = !x->sign;
   1baf4:	0017b793          	seqz	a5,a5
   1baf8:	00f12a23          	sw	a5,20(sp)

  au.value = arg_a;
  unpack_d (&au, &a);

  flip_sign (&a);
  return pack_d (&a);
   1bafc:	e58ff0ef          	jal	1b154 <__pack_f>
}
   1bb00:	02c12083          	lw	ra,44(sp)
   1bb04:	03010113          	addi	sp,sp,48
   1bb08:	00008067          	ret

0001bb0c <__make_fp>:
SFtype
__make_fp(fp_class_type class,
	     unsigned int sign,
	     int exp, 
	     USItype frac)
{
   1bb0c:	fe010113          	addi	sp,sp,-32
  fp_number_type in;

  in.class = class;
   1bb10:	00a12023          	sw	a0,0(sp)
  in.sign = sign;
  in.normal_exp = exp;
  in.fraction.ll = frac;
  return pack_d (&in);
   1bb14:	00010513          	mv	a0,sp
SFtype
__make_fp(fp_class_type class,
	     unsigned int sign,
	     int exp, 
	     USItype frac)
{
   1bb18:	00112e23          	sw	ra,28(sp)
  fp_number_type in;

  in.class = class;
  in.sign = sign;
   1bb1c:	00b12223          	sw	a1,4(sp)
  in.normal_exp = exp;
   1bb20:	00c12423          	sw	a2,8(sp)
  in.fraction.ll = frac;
   1bb24:	00d12623          	sw	a3,12(sp)
  return pack_d (&in);
   1bb28:	e2cff0ef          	jal	1b154 <__pack_f>
}
   1bb2c:	01c12083          	lw	ra,28(sp)
   1bb30:	02010113          	addi	sp,sp,32
   1bb34:	00008067          	ret

0001bb38 <__extendsfdf2>:
   are 8-bytes in size, so we just don't support double for them at all.  */

#if defined(L_sf_to_df)
DFtype
sf_to_df (SFtype arg_a)
{
   1bb38:	fd010113          	addi	sp,sp,-48
  fp_number_type in;
  FLO_union_type au;

  au.value = arg_a;
   1bb3c:	00a12623          	sw	a0,12(sp)
  unpack_d (&au, &in);
   1bb40:	01010593          	addi	a1,sp,16
   1bb44:	00c10513          	addi	a0,sp,12
   are 8-bytes in size, so we just don't support double for them at all.  */

#if defined(L_sf_to_df)
DFtype
sf_to_df (SFtype arg_a)
{
   1bb48:	02112623          	sw	ra,44(sp)
  fp_number_type in;
  FLO_union_type au;

  au.value = arg_a;
  unpack_d (&au, &in);
   1bb4c:	f64ff0ef          	jal	1b2b0 <__unpack_f>

  return __make_dp (in.class, in.sign, in.normal_exp,
   1bb50:	01c12783          	lw	a5,28(sp)
   1bb54:	01812603          	lw	a2,24(sp)
   1bb58:	01412583          	lw	a1,20(sp)
   1bb5c:	01012503          	lw	a0,16(sp)
   1bb60:	01e79713          	slli	a4,a5,0x1e
   1bb64:	0027d793          	srli	a5,a5,0x2
   1bb68:	b2cff0ef          	jal	1ae94 <__make_dp>
		    ((UDItype) in.fraction.ll) << F_D_BITOFF);
}
   1bb6c:	02c12083          	lw	ra,44(sp)
   1bb70:	03010113          	addi	sp,sp,48
   1bb74:	00008067          	ret

Disassembly of section .startup:

00000000 <_reset-0x200>:
	...

00000200 <_reset>:
 200:	00100137          	lui	sp,0x100
 204:	00016113          	ori	sp,sp,0
 208:	00012023          	sw	zero,0(sp) # 100000 <_gp+0xe19c0>
 20c:	fe012e23          	sw	zero,-4(sp)
 210:	00003437          	lui	s0,0x3
 214:	00640413          	addi	s0,s0,6 # 3006 <_reset+0x2e06>
 218:	30041073          	csrw	mstatus,s0
 21c:	10000413          	li	s0,256
 220:	0c042023          	sw	zero,192(s0)
 224:	30141073          	csrw	mtvec,s0
 228:	5d90f06f          	j	10000 <_ftext>
