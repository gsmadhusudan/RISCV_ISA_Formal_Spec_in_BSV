
multiply_main:     file format elf32-littleriscv
multiply_main
architecture: riscv, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000200

Program Header:
    LOAD off    0x00001000 vaddr 0x00000000 paddr 0x00000000 align 2**12
         filesz 0x0000022c memsz 0x0000022c flags r-x
    LOAD off    0x00002000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x000057dc memsz 0x0000583c flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003fc8  00010000  00010000  00002000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000124  00013fc8  00013fc8  00005fc8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init_array   00000008  000140ec  000140ec  000060ec  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .fini_array   00000004  000140f4  000140f4  000060f4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .eh_frame     000009bc  000140f8  000140f8  000060f8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .jcr          00000004  00014ab4  00014ab4  00006ab4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000cf8  00014ac0  00014ac0  00006ac0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  7 .sdata        0000001c  000157c0  000157c0  000077c0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .sbss         00000010  000157e0  000157e0  000077dc  2**2
                  ALLOC
  9 .bss          0000004c  000157f0  000157f0  000077dc  2**2
                  ALLOC
 10 .startup      0000022c  00000000  00000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .comment      00000011  00000000  00000000  000077dc  2**0
                  CONTENTS, READONLY
 12 .debug_info   0000c861  00000000  00000000  000077ed  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00002e4a  00000000  00000000  0001404e  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 000003b0  00000000  00000000  00016e98  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   000074f5  00000000  00000000  00017248  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00001c83  00000000  00000000  0001e73d  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    000055a3  00000000  00000000  000203c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00000520  00000000  00000000  00025963  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
00013fc8 l    d  .rodata	00000000 .rodata
000140ec l    d  .init_array	00000000 .init_array
000140f4 l    d  .fini_array	00000000 .fini_array
000140f8 l    d  .eh_frame	00000000 .eh_frame
00014ab4 l    d  .jcr	00000000 .jcr
00014ac0 l    d  .data	00000000 .data
000157c0 l    d  .sdata	00000000 .sdata
000157e0 l    d  .sbss	00000000 .sbss
000157f0 l    d  .bss	00000000 .bss
00000000 l    d  .startup	00000000 .startup
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 crtstuff.c
000140f8 l     O .eh_frame	00000000 __EH_FRAME_BEGIN__
00014ab4 l     O .jcr	00000000 __JCR_LIST__
0001004c l     F .text	00000000 deregister_tm_clones
00010080 l     F .text	00000000 register_tm_clones
000100c0 l     F .text	00000000 __do_global_dtors_aux
000157f0 l     O .bss	00000001 completed.3082
000140f4 l     O .fini_array	00000000 __do_global_dtors_aux_fini_array_entry
00010104 l     F .text	00000000 frame_dummy
000157f4 l     O .bss	00000018 object.3087
000140ec l     O .init_array	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 syscalls.c
0001580c l     O .bss	00000004 heap_end.1982
00000000 l    df *ABS*	00000000 htif.c
000106f4 l     F .text	00000068 htif_tohost
0001075c l     F .text	00000044 htif_fromhost
00000000 l    df *ABS*	00000000 riscv_counters.c
00000000 l    df *ABS*	00000000 ns16550.c
000157c8 l     O .sdata	00000004 pio
000108e4 l     F .text	000000b0 ns16550_init
00000000 l    df *ABS*	00000000 multiply_main.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 impure.c
00014f70 l     O .data	00000440 impure_data
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
00013230 l     F .text	00000008 __fp_unlock
00013244 l     F .text	0000018c __sinit.part.1
000133d4 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 crtstuff.c
00014ab0 l     O .eh_frame	00000000 __FRAME_END__
00014ab4 l     O .jcr	00000000 __JCR_END__
00000000 l    df *ABS*	00000000 
000140f8 l       .fini_array	00000000 __fini_array_end
000140f4 l       .fini_array	00000000 __fini_array_start
000140f4 l       .init_array	00000000 __init_array_end
000140ec l       .init_array	00000000 __preinit_array_end
000140ec l       .init_array	00000000 __init_array_start
000140ec l       .init_array	00000000 __preinit_array_start
000116dc g     F .text	000000b0 _puts_r
00010c68 g     F .text	000004d0 .hidden __divdi3
00014ac0 g       .data	00000000 _fdata
00013e58 g     F .text	00000068 __sseek
00013564 g     F .text	00000010 __sinit
000133dc g     F .text	00000070 __sfmoreglue
00012844 g     F .text	00000004 __malloc_unlock
00012720 g     F .text	00000120 memmove
00013554 g     F .text	00000010 _cleanup
00010848 g     F .text	00000034 read_cycle
00010474 g     F .text	00000024 times
00015838 g     O .bss	00000004 errno
00013dd8 g     F .text	00000008 __seofread
000140ec g       .rodata	00000000 _etext
00015fc0 g       *ABS*	00000000 _gp
00010188 g     F .text	00000034 execve
00010218 g     F .text	00000020 getpid
00012600 g     F .text	00000120 memcpy
000157b8 g     O .data	00000000 .hidden __TMC_END__
00013238 g     F .text	0000000c _cleanup_r
0001178c g     F .text	0000000c puts
00010a88 g     F .text	00000080 multiply
00010994 g     F .text	00000034 ns16550_rxready
00000000  w      *UND*	00000000 malloc
00010238 g     F .text	00000024 isatty
00010654 g     F .text	000000a0 sleep
000157f0 g       .bss	00000000 _bss_start
000157ec g     O .sbss	00000004 __malloc_top_pad
00010a08 g     F .text	0000004c ns16550_txchar
000157c0 g     O .sdata	00000000 .hidden __dso_handle
000107a0 g     F .text	00000040 htif_putc
0001191c g     F .text	00000498 __sfvwrite_r
00013ecc g     F .text	000000f0 _fclose_r
00013210 g     F .text	00000020 fflush
000157e8 g     O .sbss	00000004 __malloc_max_sbrked_mem
000102bc g     F .text	0000002c lseek
000157cc g     O .sdata	00000004 _global_impure_ptr
00012848 g     F .text	00000588 _realloc_r
0001163c g     F .text	000000a0 __libc_init_array
00013584 g     F .text	00000010 __fp_lock_all
0001087c g     F .text	00000034 read_time
00010048 g       .text	00000000 _init
000115dc g     F .text	00000060 __libc_fini_array
000104f0 g     F .text	0000006c write
000157c4 g     O .sdata	00000004 environ
000101e4 g     F .text	00000034 fstat
0001025c g     F .text	00000030 kill
00000000  w      *UND*	00000000 __deregister_frame_info
00000000  w      *UND*	00000000 _ITM_registerTMCloneTable
00010b08 g     F .text	00000080 verify
00013574 g     F .text	00000000 __sfp_lock_acquire
0001252c g     F .text	000000d4 memchr
000136a4 g     F .text	000002dc _free_r
000104c4 g     F .text	0000002c wait
00010000 g       .text	00000000 _ftext
000157d4 g     O .sdata	00000004 __malloc_sbrk_base
00010000 g       .text	00000000 _start
00010314 g     F .text	000000bc read
00011828 g     F .text	000000f4 __register_exitproc
000108b0 g     F .text	00000034 read_instret
00015810 g     O .bss	00000028 __malloc_current_mallinfo
00010498 g     F .text	0000002c unlink
000101bc g     F .text	00000028 fork
00012dd0 g     F .text	00000154 __swsetup_r
0001344c g     F .text	00000108 __sfp
00014ac0 g     O .data	00000190 input_data1
000153b0 g     O .data	00000408 __malloc_av_
00013580 g     F .text	00000004 __sinit_lock_release
00013d5c g     F .text	0000007c __sread
000157e0 g     O .sbss	00000004 __env
00012840 g     F .text	00000004 __malloc_lock
00000000  w      *UND*	00000000 _ITM_deregisterTMCloneTable
000103d0 g     F .text	00000070 sbrk
000131b4 g     F .text	0000005c _fflush_r
0001055c g     F .text	000000f8 gettimeofday
00013c80 g       .text	00000000 memset
00010b88 g     F .text	000000e0 main
000157e4 g     O .sbss	00000004 __malloc_max_total_mem
00013ec4 g     F .text	00000008 __sclose
00013fbc g     F .text	0000000c fclose
00011db4 g     F .text	00000778 _malloc_r
00013980 g     F .text	000000b0 _fwalk
000135a4 g     F .text	00000100 _malloc_trim_r
00010048 g       .text	00000000 _fini
00013fe4 g     O .rodata	00000100 .hidden __clz_tab
000115c8 g     F .text	00000014 atexit
000157d0 g     O .sdata	00000004 _impure_ptr
00012f24 g     F .text	00000290 __sflush_r
00013594 g     F .text	00000010 __fp_unlock_all
00014c50 g     O .data	00000190 input_data2
00010440 g     F .text	00000034 stat
00000200 g       .startup	00000000 _reset
000157b8 g       .data	00000000 _edata
00015840 g       .bss	00000000 _end
00013de0 g     F .text	00000078 __swrite
000157d8 g     O .sdata	00000004 __malloc_trim_threshold
0001028c g     F .text	00000030 link
00010150 g     F .text	00000014 exit
000107e0 g     F .text	00000068 htif_getc
00013a30 g     F .text	000000c0 _fwalk_reent
00013578 g     F .text	00000004 __sfp_lock_release
00014de0 g     O .data	00000190 verify_data
00011138 g     F .text	00000490 .hidden __moddi3
00013af0 g     F .text	00000190 __smakebuf_r
00011798 g     F .text	00000090 strlen
000102e8 g     F .text	0000002c open
00010a54 g     F .text	00000034 ns16550_flush
000109c8 g     F .text	00000040 ns16550_rxchar
00000000  w      *UND*	00000000 _Jv_RegisterClasses
000157e0 g       .sbss	00000000 _fbss
00000000  w      *UND*	00000000 __register_frame_info
00010164 g     F .text	00000024 close
0001357c g     F .text	00000004 __sinit_lock_acquire



Disassembly of section .text:

00010000 <_ftext>:
   10000:	00006197          	auipc	gp,0x6
   10004:	fc018193          	addi	gp,gp,-64 # 15fc0 <_gp>
   10008:	00005297          	auipc	t0,0x5
   1000c:	7d828293          	addi	t0,t0,2008 # 157e0 <__env>
   10010:	00006317          	auipc	t1,0x6
   10014:	83030313          	addi	t1,t1,-2000 # 15840 <_end>
   10018:	0002a023          	sw	zero,0(t0)
   1001c:	00428293          	addi	t0,t0,4
   10020:	fe62ece3          	bltu	t0,t1,10018 <_ftext+0x18>
   10024:	00001517          	auipc	a0,0x1
   10028:	5b850513          	addi	a0,a0,1464 # 115dc <__libc_fini_array>
   1002c:	59c010ef          	jal	115c8 <atexit>
   10030:	60c010ef          	jal	1163c <__libc_init_array>
   10034:	00012503          	lw	a0,0(sp)
   10038:	00410593          	addi	a1,sp,4
   1003c:	00000613          	li	a2,0
   10040:	349000ef          	jal	10b88 <main>
   10044:	10c0006f          	j	10150 <exit>

00010048 <_fini>:
   10048:	00008067          	ret

0001004c <deregister_tm_clones>:
   1004c:	00015537          	lui	a0,0x15
   10050:	000157b7          	lui	a5,0x15
   10054:	7b850713          	addi	a4,a0,1976 # 157b8 <__TMC_END__>
   10058:	7bb78793          	addi	a5,a5,1979 # 157bb <__TMC_END__+0x3>
   1005c:	40e787b3          	sub	a5,a5,a4
   10060:	00600713          	li	a4,6
   10064:	00f77c63          	bleu	a5,a4,1007c <deregister_tm_clones+0x30>
   10068:	00000293          	li	t0,0
   1006c:	00028863          	beqz	t0,1007c <deregister_tm_clones+0x30>
   10070:	7b850513          	addi	a0,a0,1976
   10074:	00028313          	mv	t1,t0
   10078:	00030067          	jr	t1
   1007c:	00008067          	ret

00010080 <register_tm_clones>:
   10080:	00015537          	lui	a0,0x15
   10084:	000157b7          	lui	a5,0x15
   10088:	7b850593          	addi	a1,a0,1976 # 157b8 <__TMC_END__>
   1008c:	7b878793          	addi	a5,a5,1976 # 157b8 <__TMC_END__>
   10090:	40b787b3          	sub	a5,a5,a1
   10094:	4027d793          	srai	a5,a5,0x2
   10098:	01f7d593          	srli	a1,a5,0x1f
   1009c:	00f585b3          	add	a1,a1,a5
   100a0:	4015d593          	srai	a1,a1,0x1
   100a4:	00058c63          	beqz	a1,100bc <register_tm_clones+0x3c>
   100a8:	00000293          	li	t0,0
   100ac:	00028863          	beqz	t0,100bc <register_tm_clones+0x3c>
   100b0:	7b850513          	addi	a0,a0,1976
   100b4:	00028313          	mv	t1,t0
   100b8:	00030067          	jr	t1
   100bc:	00008067          	ret

000100c0 <__do_global_dtors_aux>:
   100c0:	ff010113          	addi	sp,sp,-16
   100c4:	00812423          	sw	s0,8(sp)
   100c8:	8301c783          	lbu	a5,-2000(gp) # 157f0 <_bss_start>
   100cc:	00112623          	sw	ra,12(sp)
   100d0:	02079263          	bnez	a5,100f4 <__do_global_dtors_aux+0x34>
   100d4:	f79ff0ef          	jal	1004c <deregister_tm_clones>
   100d8:	00000793          	li	a5,0
   100dc:	00078863          	beqz	a5,100ec <__do_global_dtors_aux+0x2c>
   100e0:	00014537          	lui	a0,0x14
   100e4:	0f850513          	addi	a0,a0,248 # 140f8 <__fini_array_end>
   100e8:	f19ef0ef          	jal	0 <_reset-0x200>
   100ec:	00100793          	li	a5,1
   100f0:	82f18823          	sb	a5,-2000(gp) # 157f0 <_bss_start>
   100f4:	00c12083          	lw	ra,12(sp)
   100f8:	00812403          	lw	s0,8(sp)
   100fc:	01010113          	addi	sp,sp,16
   10100:	00008067          	ret

00010104 <frame_dummy>:
   10104:	ff010113          	addi	sp,sp,-16
   10108:	00000793          	li	a5,0
   1010c:	00112623          	sw	ra,12(sp)
   10110:	00078a63          	beqz	a5,10124 <frame_dummy+0x20>
   10114:	00014537          	lui	a0,0x14
   10118:	83418593          	addi	a1,gp,-1996 # 157f4 <object.3087>
   1011c:	0f850513          	addi	a0,a0,248 # 140f8 <__fini_array_end>
   10120:	ee1ef0ef          	jal	0 <_reset-0x200>
   10124:	00015537          	lui	a0,0x15
   10128:	ab450513          	addi	a0,a0,-1356 # 14ab4 <__JCR_END__>
   1012c:	00052783          	lw	a5,0(a0)
   10130:	00079863          	bnez	a5,10140 <frame_dummy+0x3c>
   10134:	00c12083          	lw	ra,12(sp)
   10138:	01010113          	addi	sp,sp,16
   1013c:	f45ff06f          	j	10080 <register_tm_clones>
   10140:	00000793          	li	a5,0
   10144:	fe0788e3          	beqz	a5,10134 <frame_dummy+0x30>
   10148:	000780e7          	jalr	a5
   1014c:	fe9ff06f          	j	10134 <frame_dummy+0x30>

00010150 <exit>:
register char * stack_ptr asm ("sp");

#undef errno
int errno;

void exit (int status) {
   10150:	fe010113          	addi	sp,sp,-32
   10154:	00812e23          	sw	s0,28(sp)
   10158:	02010413          	addi	s0,sp,32
   1015c:	fea42623          	sw	a0,-20(s0)
  while (1)
    ;
   10160:	0000006f          	j	10160 <exit+0x10>

00010164 <close>:
}

int close(int file) {
   10164:	fe010113          	addi	sp,sp,-32
   10168:	00812e23          	sw	s0,28(sp)
   1016c:	02010413          	addi	s0,sp,32
   10170:	fea42623          	sw	a0,-20(s0)
  return -1;
   10174:	fff00793          	li	a5,-1
}
   10178:	00078513          	mv	a0,a5
   1017c:	01c12403          	lw	s0,28(sp)
   10180:	02010113          	addi	sp,sp,32
   10184:	00008067          	ret

00010188 <execve>:

char *__env[1] = { 0 };
char **environ = __env;

int execve(char *name, char **argv, char **env) {
   10188:	fe010113          	addi	sp,sp,-32
   1018c:	00812e23          	sw	s0,28(sp)
   10190:	02010413          	addi	s0,sp,32
   10194:	fea42623          	sw	a0,-20(s0)
   10198:	feb42423          	sw	a1,-24(s0)
   1019c:	fec42223          	sw	a2,-28(s0)
  errno = ENOMEM;
   101a0:	00c00713          	li	a4,12
   101a4:	86e1ac23          	sw	a4,-1928(gp) # 15838 <errno>
  return -1;
   101a8:	fff00793          	li	a5,-1
}
   101ac:	00078513          	mv	a0,a5
   101b0:	01c12403          	lw	s0,28(sp)
   101b4:	02010113          	addi	sp,sp,32
   101b8:	00008067          	ret

000101bc <fork>:

int fork(void) {
   101bc:	ff010113          	addi	sp,sp,-16
   101c0:	00812623          	sw	s0,12(sp)
   101c4:	01010413          	addi	s0,sp,16
  errno = EAGAIN;
   101c8:	00b00713          	li	a4,11
   101cc:	86e1ac23          	sw	a4,-1928(gp) # 15838 <errno>
  return -1;
   101d0:	fff00793          	li	a5,-1
}
   101d4:	00078513          	mv	a0,a5
   101d8:	00c12403          	lw	s0,12(sp)
   101dc:	01010113          	addi	sp,sp,16
   101e0:	00008067          	ret

000101e4 <fstat>:

int fstat(int file, struct stat *st) {
   101e4:	fe010113          	addi	sp,sp,-32
   101e8:	00812e23          	sw	s0,28(sp)
   101ec:	02010413          	addi	s0,sp,32
   101f0:	fea42623          	sw	a0,-20(s0)
   101f4:	feb42423          	sw	a1,-24(s0)
  st->st_mode = S_IFCHR;
   101f8:	fe842783          	lw	a5,-24(s0)
   101fc:	00002737          	lui	a4,0x2
   10200:	00e7a823          	sw	a4,16(a5)
  return 0;
   10204:	00000793          	li	a5,0
}
   10208:	00078513          	mv	a0,a5
   1020c:	01c12403          	lw	s0,28(sp)
   10210:	02010113          	addi	sp,sp,32
   10214:	00008067          	ret

00010218 <getpid>:

int getpid(void) {
   10218:	ff010113          	addi	sp,sp,-16
   1021c:	00812623          	sw	s0,12(sp)
   10220:	01010413          	addi	s0,sp,16
  return 1;
   10224:	00100793          	li	a5,1
}
   10228:	00078513          	mv	a0,a5
   1022c:	00c12403          	lw	s0,12(sp)
   10230:	01010113          	addi	sp,sp,16
   10234:	00008067          	ret

00010238 <isatty>:

int isatty(int file) {
   10238:	fe010113          	addi	sp,sp,-32
   1023c:	00812e23          	sw	s0,28(sp)
   10240:	02010413          	addi	s0,sp,32
   10244:	fea42623          	sw	a0,-20(s0)
  return 1;
   10248:	00100793          	li	a5,1
}
   1024c:	00078513          	mv	a0,a5
   10250:	01c12403          	lw	s0,28(sp)
   10254:	02010113          	addi	sp,sp,32
   10258:	00008067          	ret

0001025c <kill>:

int kill(int pid, int sig) {
   1025c:	fe010113          	addi	sp,sp,-32
   10260:	00812e23          	sw	s0,28(sp)
   10264:	02010413          	addi	s0,sp,32
   10268:	fea42623          	sw	a0,-20(s0)
   1026c:	feb42423          	sw	a1,-24(s0)
  errno = EINVAL;
   10270:	01600713          	li	a4,22
   10274:	86e1ac23          	sw	a4,-1928(gp) # 15838 <errno>
  return -1;
   10278:	fff00793          	li	a5,-1
}
   1027c:	00078513          	mv	a0,a5
   10280:	01c12403          	lw	s0,28(sp)
   10284:	02010113          	addi	sp,sp,32
   10288:	00008067          	ret

0001028c <link>:

int link(char *old, char *new) {
   1028c:	fe010113          	addi	sp,sp,-32
   10290:	00812e23          	sw	s0,28(sp)
   10294:	02010413          	addi	s0,sp,32
   10298:	fea42623          	sw	a0,-20(s0)
   1029c:	feb42423          	sw	a1,-24(s0)
  errno = EMLINK;
   102a0:	01f00713          	li	a4,31
   102a4:	86e1ac23          	sw	a4,-1928(gp) # 15838 <errno>
  return -1;
   102a8:	fff00793          	li	a5,-1
}
   102ac:	00078513          	mv	a0,a5
   102b0:	01c12403          	lw	s0,28(sp)
   102b4:	02010113          	addi	sp,sp,32
   102b8:	00008067          	ret

000102bc <lseek>:

int lseek(int file, int ptr, int dir) {
   102bc:	fe010113          	addi	sp,sp,-32
   102c0:	00812e23          	sw	s0,28(sp)
   102c4:	02010413          	addi	s0,sp,32
   102c8:	fea42623          	sw	a0,-20(s0)
   102cc:	feb42423          	sw	a1,-24(s0)
   102d0:	fec42223          	sw	a2,-28(s0)
  return 0;
   102d4:	00000793          	li	a5,0
}
   102d8:	00078513          	mv	a0,a5
   102dc:	01c12403          	lw	s0,28(sp)
   102e0:	02010113          	addi	sp,sp,32
   102e4:	00008067          	ret

000102e8 <open>:

int open(const char *name, int flags, int mode) {
   102e8:	fe010113          	addi	sp,sp,-32
   102ec:	00812e23          	sw	s0,28(sp)
   102f0:	02010413          	addi	s0,sp,32
   102f4:	fea42623          	sw	a0,-20(s0)
   102f8:	feb42423          	sw	a1,-24(s0)
   102fc:	fec42223          	sw	a2,-28(s0)
  return -1;
   10300:	fff00793          	li	a5,-1
}
   10304:	00078513          	mv	a0,a5
   10308:	01c12403          	lw	s0,28(sp)
   1030c:	02010113          	addi	sp,sp,32
   10310:	00008067          	ret

00010314 <read>:

int read(int file, char *ptr, int len) {
   10314:	fd010113          	addi	sp,sp,-48
   10318:	02112623          	sw	ra,44(sp)
   1031c:	02812423          	sw	s0,40(sp)
   10320:	02912223          	sw	s1,36(sp)
   10324:	03010413          	addi	s0,sp,48
   10328:	fca42e23          	sw	a0,-36(s0)
   1032c:	fcb42c23          	sw	a1,-40(s0)
   10330:	fcc42a23          	sw	a2,-44(s0)
  int todo;
  if(len == 0)
   10334:	fd442783          	lw	a5,-44(s0)
   10338:	00079663          	bnez	a5,10344 <read+0x30>
    return 0;
   1033c:	00000793          	li	a5,0
   10340:	0780006f          	j	103b8 <read+0xa4>
    // note: this is always blocking
    *ptr++ = htif_getc();
  }
#endif
#ifdef CONSOLE_UART
  *ptr++ = ns16550_rxchar();
   10344:	fd842483          	lw	s1,-40(s0)
   10348:	00148793          	addi	a5,s1,1
   1034c:	fcf42c23          	sw	a5,-40(s0)
   10350:	678000ef          	jal	109c8 <ns16550_rxchar>
   10354:	00050793          	mv	a5,a0
   10358:	0ff7f793          	andi	a5,a5,255
   1035c:	00f48023          	sb	a5,0(s1)
  for(todo = 1; todo < len; todo++) {
   10360:	00100793          	li	a5,1
   10364:	fef42623          	sw	a5,-20(s0)
   10368:	0380006f          	j	103a0 <read+0x8c>
    if (!ns16550_rxready())
   1036c:	628000ef          	jal	10994 <ns16550_rxready>
   10370:	00050793          	mv	a5,a0
   10374:	02078e63          	beqz	a5,103b0 <read+0x9c>
      break;
    *ptr++ = ns16550_rxchar();
   10378:	fd842483          	lw	s1,-40(s0)
   1037c:	00148793          	addi	a5,s1,1
   10380:	fcf42c23          	sw	a5,-40(s0)
   10384:	644000ef          	jal	109c8 <ns16550_rxchar>
   10388:	00050793          	mv	a5,a0
   1038c:	0ff7f793          	andi	a5,a5,255
   10390:	00f48023          	sb	a5,0(s1)
    *ptr++ = htif_getc();
  }
#endif
#ifdef CONSOLE_UART
  *ptr++ = ns16550_rxchar();
  for(todo = 1; todo < len; todo++) {
   10394:	fec42783          	lw	a5,-20(s0)
   10398:	00178793          	addi	a5,a5,1
   1039c:	fef42623          	sw	a5,-20(s0)
   103a0:	fec42703          	lw	a4,-20(s0)
   103a4:	fd442783          	lw	a5,-44(s0)
   103a8:	fcf742e3          	blt	a4,a5,1036c <read+0x58>
   103ac:	0080006f          	j	103b4 <read+0xa0>
    if (!ns16550_rxready())
      break;
   103b0:	00000013          	nop
    *ptr++ = ns16550_rxchar();
  }
#endif
  return todo;
   103b4:	fec42783          	lw	a5,-20(s0)
}
   103b8:	00078513          	mv	a0,a5
   103bc:	02c12083          	lw	ra,44(sp)
   103c0:	02812403          	lw	s0,40(sp)
   103c4:	02412483          	lw	s1,36(sp)
   103c8:	03010113          	addi	sp,sp,48
   103cc:	00008067          	ret

000103d0 <sbrk>:

caddr_t sbrk(int incr) {
   103d0:	fd010113          	addi	sp,sp,-48
   103d4:	02812623          	sw	s0,44(sp)
   103d8:	03010413          	addi	s0,sp,48
   103dc:	fca42e23          	sw	a0,-36(s0)
  extern char _end;		/* Defined by the linker */
  static char *heap_end;
  char *prev_heap_end;

  if (heap_end == 0) {
   103e0:	84c1a783          	lw	a5,-1972(gp) # 1580c <heap_end.1982>
   103e4:	00079663          	bnez	a5,103f0 <sbrk+0x20>
    heap_end = &_end;
   103e8:	88018713          	addi	a4,gp,-1920 # 15840 <_end>
   103ec:	84e1a623          	sw	a4,-1972(gp) # 1580c <heap_end.1982>
  }
  prev_heap_end = heap_end;
   103f0:	84c1a783          	lw	a5,-1972(gp) # 1580c <heap_end.1982>
   103f4:	fef42623          	sw	a5,-20(s0)
  if (heap_end + incr > stack_ptr) {
   103f8:	84c1a703          	lw	a4,-1972(gp) # 1580c <heap_end.1982>
   103fc:	fdc42783          	lw	a5,-36(s0)
   10400:	00f707b3          	add	a5,a4,a5
   10404:	00010713          	mv	a4,sp
   10408:	00f77a63          	bleu	a5,a4,1041c <sbrk+0x4c>
    errno = ENOMEM;
   1040c:	00c00713          	li	a4,12
   10410:	86e1ac23          	sw	a4,-1928(gp) # 15838 <errno>
    return (caddr_t) -1;
   10414:	fff00793          	li	a5,-1
   10418:	0180006f          	j	10430 <sbrk+0x60>
  }

  heap_end += incr;
   1041c:	84c1a703          	lw	a4,-1972(gp) # 1580c <heap_end.1982>
   10420:	fdc42783          	lw	a5,-36(s0)
   10424:	00f70733          	add	a4,a4,a5
   10428:	84e1a623          	sw	a4,-1972(gp) # 1580c <heap_end.1982>
  return (caddr_t) prev_heap_end;
   1042c:	fec42783          	lw	a5,-20(s0)
}
   10430:	00078513          	mv	a0,a5
   10434:	02c12403          	lw	s0,44(sp)
   10438:	03010113          	addi	sp,sp,48
   1043c:	00008067          	ret

00010440 <stat>:

int stat(const char *file, struct stat *st) {
   10440:	fe010113          	addi	sp,sp,-32
   10444:	00812e23          	sw	s0,28(sp)
   10448:	02010413          	addi	s0,sp,32
   1044c:	fea42623          	sw	a0,-20(s0)
   10450:	feb42423          	sw	a1,-24(s0)
  st->st_mode = S_IFCHR;
   10454:	fe842783          	lw	a5,-24(s0)
   10458:	00002737          	lui	a4,0x2
   1045c:	00e7a823          	sw	a4,16(a5)
  return 0;
   10460:	00000793          	li	a5,0
}
   10464:	00078513          	mv	a0,a5
   10468:	01c12403          	lw	s0,28(sp)
   1046c:	02010113          	addi	sp,sp,32
   10470:	00008067          	ret

00010474 <times>:

clock_t times(struct tms *buf) {
   10474:	fe010113          	addi	sp,sp,-32
   10478:	00812e23          	sw	s0,28(sp)
   1047c:	02010413          	addi	s0,sp,32
   10480:	fea42623          	sw	a0,-20(s0)
  return -1;
   10484:	fff00793          	li	a5,-1
}
   10488:	00078513          	mv	a0,a5
   1048c:	01c12403          	lw	s0,28(sp)
   10490:	02010113          	addi	sp,sp,32
   10494:	00008067          	ret

00010498 <unlink>:

int unlink(char *name) {
   10498:	fe010113          	addi	sp,sp,-32
   1049c:	00812e23          	sw	s0,28(sp)
   104a0:	02010413          	addi	s0,sp,32
   104a4:	fea42623          	sw	a0,-20(s0)
  errno = ENOENT;
   104a8:	00200713          	li	a4,2
   104ac:	86e1ac23          	sw	a4,-1928(gp) # 15838 <errno>
  return -1;
   104b0:	fff00793          	li	a5,-1
}
   104b4:	00078513          	mv	a0,a5
   104b8:	01c12403          	lw	s0,28(sp)
   104bc:	02010113          	addi	sp,sp,32
   104c0:	00008067          	ret

000104c4 <wait>:

int wait(int *status) {
   104c4:	fe010113          	addi	sp,sp,-32
   104c8:	00812e23          	sw	s0,28(sp)
   104cc:	02010413          	addi	s0,sp,32
   104d0:	fea42623          	sw	a0,-20(s0)
  errno = ECHILD;
   104d4:	00a00713          	li	a4,10
   104d8:	86e1ac23          	sw	a4,-1928(gp) # 15838 <errno>
  return -1;
   104dc:	fff00793          	li	a5,-1
}
   104e0:	00078513          	mv	a0,a5
   104e4:	01c12403          	lw	s0,28(sp)
   104e8:	02010113          	addi	sp,sp,32
   104ec:	00008067          	ret

000104f0 <write>:

int write(int file, char *ptr, int len) {
   104f0:	fd010113          	addi	sp,sp,-48
   104f4:	02112623          	sw	ra,44(sp)
   104f8:	02812423          	sw	s0,40(sp)
   104fc:	03010413          	addi	s0,sp,48
   10500:	fca42e23          	sw	a0,-36(s0)
   10504:	fcb42c23          	sw	a1,-40(s0)
   10508:	fcc42a23          	sw	a2,-44(s0)
  for (todo = 0; todo < len; todo++) {
    htif_putc (*ptr++);
  }
#endif
#ifdef CONSOLE_UART
  for (todo = 0; todo < len; todo++) {
   1050c:	fe042623          	sw	zero,-20(s0)
   10510:	0280006f          	j	10538 <write+0x48>
    ns16550_txchar (*ptr++);
   10514:	fd842783          	lw	a5,-40(s0)
   10518:	00178713          	addi	a4,a5,1
   1051c:	fce42c23          	sw	a4,-40(s0)
   10520:	0007c783          	lbu	a5,0(a5)
   10524:	00078513          	mv	a0,a5
   10528:	4e0000ef          	jal	10a08 <ns16550_txchar>
  for (todo = 0; todo < len; todo++) {
    htif_putc (*ptr++);
  }
#endif
#ifdef CONSOLE_UART
  for (todo = 0; todo < len; todo++) {
   1052c:	fec42783          	lw	a5,-20(s0)
   10530:	00178793          	addi	a5,a5,1
   10534:	fef42623          	sw	a5,-20(s0)
   10538:	fec42703          	lw	a4,-20(s0)
   1053c:	fd442783          	lw	a5,-44(s0)
   10540:	fcf74ae3          	blt	a4,a5,10514 <write+0x24>
    ns16550_txchar (*ptr++);
  }
#endif
  return len;
   10544:	fd442783          	lw	a5,-44(s0)
}
   10548:	00078513          	mv	a0,a5
   1054c:	02c12083          	lw	ra,44(sp)
   10550:	02812403          	lw	s0,40(sp)
   10554:	03010113          	addi	sp,sp,48
   10558:	00008067          	ret

0001055c <gettimeofday>:

#define CLOCK_PERIOD  (10000000)

int gettimeofday(struct timeval *ptimeval, void *ptimezone)
{
   1055c:	fd010113          	addi	sp,sp,-48
   10560:	02112623          	sw	ra,44(sp)
   10564:	02812423          	sw	s0,40(sp)
   10568:	03010413          	addi	s0,sp,48
   1056c:	fca42e23          	sw	a0,-36(s0)
   10570:	fcb42c23          	sw	a1,-40(s0)
    if (ptimeval)
   10574:	fdc42583          	lw	a1,-36(s0)
   10578:	0c058263          	beqz	a1,1063c <gettimeofday+0xe0>
#ifdef __riscv64
	asm ("rdtime %0" : "=r" (tv));
#else
	unsigned int tvh;
	unsigned int tvl;
	asm ("rdtime %0;"
   1057c:	c0102573          	rdtime	a0
   10580:	c81025f3          	rdtimeh	a1
   10584:	fea42623          	sw	a0,-20(s0)
   10588:	feb42423          	sw	a1,-24(s0)
	    "rdtimeh %1 " : "=r" (tvl), "=r" (tvh));
	tv = ((long long)tvh) << 32 | tvl;
   1058c:	fe842583          	lw	a1,-24(s0)
   10590:	00058813          	mv	a6,a1
   10594:	00000893          	li	a7,0
   10598:	00081793          	slli	a5,a6,0x0
   1059c:	00000713          	li	a4,0
   105a0:	fec42583          	lw	a1,-20(s0)
   105a4:	00058613          	mv	a2,a1
   105a8:	00000693          	li	a3,0
   105ac:	00c765b3          	or	a1,a4,a2
   105b0:	feb42023          	sw	a1,-32(s0)
   105b4:	00d7e7b3          	or	a5,a5,a3
   105b8:	fef42223          	sw	a5,-28(s0)
#endif
	ptimeval->tv_sec = tv / CLOCK_PERIOD;
   105bc:	fe042703          	lw	a4,-32(s0)
   105c0:	fe442783          	lw	a5,-28(s0)
   105c4:	00989637          	lui	a2,0x989
   105c8:	68060613          	addi	a2,a2,1664 # 989680 <_gp+0x9736c0>
   105cc:	00000693          	li	a3,0
   105d0:	00070513          	mv	a0,a4
   105d4:	00078593          	mv	a1,a5
   105d8:	690000ef          	jal	10c68 <__divdi3>
   105dc:	00050713          	mv	a4,a0
   105e0:	00058793          	mv	a5,a1
   105e4:	fdc42683          	lw	a3,-36(s0)
   105e8:	00e6a023          	sw	a4,0(a3)
   105ec:	00f6a223          	sw	a5,4(a3)
	ptimeval->tv_usec = tv % CLOCK_PERIOD / (CLOCK_PERIOD / 1000000);
   105f0:	fe042703          	lw	a4,-32(s0)
   105f4:	fe442783          	lw	a5,-28(s0)
   105f8:	00989637          	lui	a2,0x989
   105fc:	68060613          	addi	a2,a2,1664 # 989680 <_gp+0x9736c0>
   10600:	00000693          	li	a3,0
   10604:	00070513          	mv	a0,a4
   10608:	00078593          	mv	a1,a5
   1060c:	32d000ef          	jal	11138 <__moddi3>
   10610:	00050713          	mv	a4,a0
   10614:	00058793          	mv	a5,a1
   10618:	00a00613          	li	a2,10
   1061c:	00000693          	li	a3,0
   10620:	00070513          	mv	a0,a4
   10624:	00078593          	mv	a1,a5
   10628:	640000ef          	jal	10c68 <__divdi3>
   1062c:	00050713          	mv	a4,a0
   10630:	00058793          	mv	a5,a1
   10634:	fdc42783          	lw	a5,-36(s0)
   10638:	00e7a423          	sw	a4,8(a5)
    }

    return 0;
   1063c:	00000793          	li	a5,0
}
   10640:	00078513          	mv	a0,a5
   10644:	02c12083          	lw	ra,44(sp)
   10648:	02812403          	lw	s0,40(sp)
   1064c:	03010113          	addi	sp,sp,48
   10650:	00008067          	ret

00010654 <sleep>:

unsigned int sleep(unsigned int seconds)
{
   10654:	fd010113          	addi	sp,sp,-48
   10658:	02112623          	sw	ra,44(sp)
   1065c:	02812423          	sw	s0,40(sp)
   10660:	03212223          	sw	s2,36(sp)
   10664:	03312023          	sw	s3,32(sp)
   10668:	03010413          	addi	s0,sp,48
   1066c:	fca42e23          	sw	a0,-36(s0)
    struct timeval tv;
    gettimeofday(&tv, NULL);
   10670:	fe040793          	addi	a5,s0,-32
   10674:	00000593          	li	a1,0
   10678:	00078513          	mv	a0,a5
   1067c:	ee1ff0ef          	jal	1055c <gettimeofday>
    seconds += tv.tv_sec;
   10680:	fe042703          	lw	a4,-32(s0)
   10684:	fe442783          	lw	a5,-28(s0)
   10688:	fdc42783          	lw	a5,-36(s0)
   1068c:	00e787b3          	add	a5,a5,a4
   10690:	fcf42e23          	sw	a5,-36(s0)

    while (tv.tv_sec < seconds)
   10694:	0140006f          	j	106a8 <sleep+0x54>
	gettimeofday(&tv, NULL);
   10698:	fe040793          	addi	a5,s0,-32
   1069c:	00000593          	li	a1,0
   106a0:	00078513          	mv	a0,a5
   106a4:	eb9ff0ef          	jal	1055c <gettimeofday>
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    seconds += tv.tv_sec;

    while (tv.tv_sec < seconds)
   106a8:	fe042703          	lw	a4,-32(s0)
   106ac:	fe442783          	lw	a5,-28(s0)
   106b0:	fdc42683          	lw	a3,-36(s0)
   106b4:	00068913          	mv	s2,a3
   106b8:	00000993          	li	s3,0
   106bc:	00078693          	mv	a3,a5
   106c0:	fd36ece3          	bltu	a3,s3,10698 <sleep+0x44>
   106c4:	00078693          	mv	a3,a5
   106c8:	00d99663          	bne	s3,a3,106d4 <sleep+0x80>
   106cc:	00070793          	mv	a5,a4
   106d0:	fd27e4e3          	bltu	a5,s2,10698 <sleep+0x44>
	gettimeofday(&tv, NULL);

    return 0;
   106d4:	00000793          	li	a5,0
}
   106d8:	00078513          	mv	a0,a5
   106dc:	02c12083          	lw	ra,44(sp)
   106e0:	02812403          	lw	s0,40(sp)
   106e4:	02412903          	lw	s2,36(sp)
   106e8:	02012983          	lw	s3,32(sp)
   106ec:	03010113          	addi	sp,sp,48
   106f0:	00008067          	ret

000106f4 <htif_tohost>:
#define HTIF_CMD_WRITE      (0x01UL)
#define HTIF_CMD_IDENTITY   (0xFFUL)

static inline void htif_tohost(unsigned long dev,
	unsigned long cmd, unsigned long data)
{
   106f4:	fd010113          	addi	sp,sp,-48
   106f8:	02812623          	sw	s0,44(sp)
   106fc:	03010413          	addi	s0,sp,48
   10700:	fca42e23          	sw	a0,-36(s0)
   10704:	fcb42c23          	sw	a1,-40(s0)
   10708:	fcc42a23          	sw	a2,-44(s0)
	unsigned long packet;
	packet = (dev << HTIF_DEV_SHIFT) | (cmd << HTIF_CMD_SHIFT) | data;
   1070c:	fdc42783          	lw	a5,-36(s0)
   10710:	01879713          	slli	a4,a5,0x18
   10714:	fd842783          	lw	a5,-40(s0)
   10718:	01079793          	slli	a5,a5,0x10
   1071c:	00f76733          	or	a4,a4,a5
   10720:	fd442783          	lw	a5,-44(s0)
   10724:	00f767b3          	or	a5,a4,a5
   10728:	fef42623          	sw	a5,-20(s0)
	while (csr_swap(mtohost, packet) != 0);
   1072c:	00000013          	nop
   10730:	fec42783          	lw	a5,-20(s0)
   10734:	fef42423          	sw	a5,-24(s0)
   10738:	fe842783          	lw	a5,-24(s0)
   1073c:	780797f3          	csrrw	a5,mtohost,a5
   10740:	fef42423          	sw	a5,-24(s0)
   10744:	fe842783          	lw	a5,-24(s0)
   10748:	fe0794e3          	bnez	a5,10730 <htif_tohost+0x3c>
}
   1074c:	00000013          	nop
   10750:	02c12403          	lw	s0,44(sp)
   10754:	03010113          	addi	sp,sp,48
   10758:	00008067          	ret

0001075c <htif_fromhost>:

static inline unsigned long htif_fromhost(void)
{
   1075c:	fe010113          	addi	sp,sp,-32
   10760:	00812e23          	sw	s0,28(sp)
   10764:	02010413          	addi	s0,sp,32
	unsigned long data;
	while ((data = csr_swap(mfromhost, 0)) == 0);
   10768:	00000013          	nop
   1076c:	fe042623          	sw	zero,-20(s0)
   10770:	fec42783          	lw	a5,-20(s0)
   10774:	781797f3          	csrrw	a5,mfromhost,a5
   10778:	fef42623          	sw	a5,-20(s0)
   1077c:	fec42783          	lw	a5,-20(s0)
   10780:	fef42423          	sw	a5,-24(s0)
   10784:	fe842783          	lw	a5,-24(s0)
   10788:	fe0782e3          	beqz	a5,1076c <htif_fromhost+0x10>
	return data;
   1078c:	fe842783          	lw	a5,-24(s0)
}
   10790:	00078513          	mv	a0,a5
   10794:	01c12403          	lw	s0,28(sp)
   10798:	02010113          	addi	sp,sp,32
   1079c:	00008067          	ret

000107a0 <htif_putc>:

#define HTIF_DEV_CONSOLE        (1U)

void htif_putc(char c)
{
   107a0:	fe010113          	addi	sp,sp,-32
   107a4:	00112e23          	sw	ra,28(sp)
   107a8:	00812c23          	sw	s0,24(sp)
   107ac:	02010413          	addi	s0,sp,32
   107b0:	00050793          	mv	a5,a0
   107b4:	fef407a3          	sb	a5,-17(s0)
    htif_tohost(HTIF_DEV_CONSOLE, HTIF_CMD_WRITE, c);
   107b8:	fef44783          	lbu	a5,-17(s0)
   107bc:	00078613          	mv	a2,a5
   107c0:	00100593          	li	a1,1
   107c4:	00100513          	li	a0,1
   107c8:	f2dff0ef          	jal	106f4 <htif_tohost>
}
   107cc:	00000013          	nop
   107d0:	01c12083          	lw	ra,28(sp)
   107d4:	01812403          	lw	s0,24(sp)
   107d8:	02010113          	addi	sp,sp,32
   107dc:	00008067          	ret

000107e0 <htif_getc>:

char htif_getc(void)
{
   107e0:	fe010113          	addi	sp,sp,-32
   107e4:	00112e23          	sw	ra,28(sp)
   107e8:	00812c23          	sw	s0,24(sp)
   107ec:	02010413          	addi	s0,sp,32
    htif_tohost(HTIF_DEV_CONSOLE, HTIF_CMD_READ, 0);
   107f0:	00000613          	li	a2,0
   107f4:	00000593          	li	a1,0
   107f8:	00100513          	li	a0,1
   107fc:	ef9ff0ef          	jal	106f4 <htif_tohost>

    // poll interrupt
    unsigned long mip = csr_read(mip);
   10800:	344027f3          	csrr	a5,mip
   10804:	00078093          	mv	ra,a5
   10808:	00008793          	mv	a5,ra
   1080c:	fef42623          	sw	a5,-20(s0)
    while (!(mip & 0x40000000))
   10810:	00000013          	nop
   10814:	fec42703          	lw	a4,-20(s0)
   10818:	400007b7          	lui	a5,0x40000
   1081c:	00f777b3          	and	a5,a4,a5
   10820:	fe078ae3          	beqz	a5,10814 <htif_getc+0x34>
	;  // nothing

    unsigned long data = htif_fromhost();
   10824:	f39ff0ef          	jal	1075c <htif_fromhost>
   10828:	fea42423          	sw	a0,-24(s0)
    return data;
   1082c:	fe842783          	lw	a5,-24(s0)
   10830:	0ff7f793          	andi	a5,a5,255
}
   10834:	00078513          	mv	a0,a5
   10838:	01c12083          	lw	ra,28(sp)
   1083c:	01812403          	lw	s0,24(sp)
   10840:	02010113          	addi	sp,sp,32
   10844:	00008067          	ret

00010848 <read_cycle>:
// The following are interfaces to inline RISC-V assembly instructions
//     RDCYCLE, RDTIME, RDINSTRET
// For all of them, the result is left in v0 (= x2) per calling convention

uint64_t  read_cycle (void)
{
   10848:	fe010113          	addi	sp,sp,-32
   1084c:	00812e23          	sw	s0,28(sp)
   10850:	02010413          	addi	s0,sp,32
    uint64_t result;

    asm volatile ("RDCYCLE %0" : "=r" (result));
   10854:	c0002773          	rdcycle	a4
   10858:	fee42423          	sw	a4,-24(s0)
   1085c:	fef42623          	sw	a5,-20(s0)
    return result;
   10860:	fe842703          	lw	a4,-24(s0)
   10864:	fec42783          	lw	a5,-20(s0)
}
   10868:	00070513          	mv	a0,a4
   1086c:	00078593          	mv	a1,a5
   10870:	01c12403          	lw	s0,28(sp)
   10874:	02010113          	addi	sp,sp,32
   10878:	00008067          	ret

0001087c <read_time>:

uint64_t  read_time (void)
{
   1087c:	fe010113          	addi	sp,sp,-32
   10880:	00812e23          	sw	s0,28(sp)
   10884:	02010413          	addi	s0,sp,32
    uint64_t result;

    asm volatile ("RDTIME %0" : "=r" (result));
   10888:	c0102773          	rdtime	a4
   1088c:	fee42423          	sw	a4,-24(s0)
   10890:	fef42623          	sw	a5,-20(s0)
    return result;
   10894:	fe842703          	lw	a4,-24(s0)
   10898:	fec42783          	lw	a5,-20(s0)
}
   1089c:	00070513          	mv	a0,a4
   108a0:	00078593          	mv	a1,a5
   108a4:	01c12403          	lw	s0,28(sp)
   108a8:	02010113          	addi	sp,sp,32
   108ac:	00008067          	ret

000108b0 <read_instret>:

uint64_t  read_instret (void)
{
   108b0:	fe010113          	addi	sp,sp,-32
   108b4:	00812e23          	sw	s0,28(sp)
   108b8:	02010413          	addi	s0,sp,32
    uint64_t result;

    asm volatile ("RDINSTRET %0" : "=r" (result));
   108bc:	c0202773          	rdinstret	a4
   108c0:	fee42423          	sw	a4,-24(s0)
   108c4:	fef42623          	sw	a5,-20(s0)
    return result;
   108c8:	fe842703          	lw	a4,-24(s0)
   108cc:	fec42783          	lw	a5,-20(s0)
}
   108d0:	00070513          	mv	a0,a4
   108d4:	00078593          	mv	a1,a5
   108d8:	01c12403          	lw	s0,28(sp)
   108dc:	02010113          	addi	sp,sp,32
   108e0:	00008067          	ret

000108e4 <ns16550_init>:
static struct ns16550_pio * pio = (void*)NS16550_BASE;

#ifdef CONSOLE_UART
__attribute__ ((constructor))
static int ns16550_init(void)
{
   108e4:	fe010113          	addi	sp,sp,-32
   108e8:	00812e23          	sw	s0,28(sp)
   108ec:	02010413          	addi	s0,sp,32
  uint32_t divisor;

  pio->ier = 0;
   108f0:	8081a783          	lw	a5,-2040(gp) # 157c8 <pio>
   108f4:	00078223          	sb	zero,4(a5) # 40000004 <_gp+0x3ffea044>

  divisor = NS16550_CLOCK_RATE / (16 * DEFAULT_BAUDRATE);
   108f8:	01a00793          	li	a5,26
   108fc:	fef42623          	sw	a5,-20(s0)
  pio->lcr |= LCR_DLAB;
   10900:	8081a783          	lw	a5,-2040(gp) # 157c8 <pio>
   10904:	8081a703          	lw	a4,-2040(gp) # 157c8 <pio>
   10908:	00c74703          	lbu	a4,12(a4) # 200c <_reset+0x1e0c>
   1090c:	0ff77713          	andi	a4,a4,255
   10910:	f8076713          	ori	a4,a4,-128
   10914:	0ff77713          	andi	a4,a4,255
   10918:	00e78623          	sb	a4,12(a5)
  pio->dll = divisor & 0xff;
   1091c:	8081a783          	lw	a5,-2040(gp) # 157c8 <pio>
   10920:	fec42703          	lw	a4,-20(s0)
   10924:	0ff77713          	andi	a4,a4,255
   10928:	00e78023          	sb	a4,0(a5)
  pio->dlm = (divisor >> 8) & 0xff;
   1092c:	8081a783          	lw	a5,-2040(gp) # 157c8 <pio>
   10930:	fec42703          	lw	a4,-20(s0)
   10934:	00875713          	srli	a4,a4,0x8
   10938:	0ff77713          	andi	a4,a4,255
   1093c:	00e78223          	sb	a4,4(a5)
  pio->lcr &= ~LCR_DLAB;
   10940:	8081a783          	lw	a5,-2040(gp) # 157c8 <pio>
   10944:	8081a703          	lw	a4,-2040(gp) # 157c8 <pio>
   10948:	00c74703          	lbu	a4,12(a4)
   1094c:	0ff77713          	andi	a4,a4,255
   10950:	07f77713          	andi	a4,a4,127
   10954:	0ff77713          	andi	a4,a4,255
   10958:	00e78623          	sb	a4,12(a5)

  pio->lcr = LCR_WLS8;
   1095c:	8081a783          	lw	a5,-2040(gp) # 157c8 <pio>
   10960:	00300713          	li	a4,3
   10964:	00e78623          	sb	a4,12(a5)
  pio->fcr = FCR_FE;
   10968:	8081a783          	lw	a5,-2040(gp) # 157c8 <pio>
   1096c:	00100713          	li	a4,1
   10970:	00e78423          	sb	a4,8(a5)
  pio->mcr = MCR_RTS;
   10974:	8081a783          	lw	a5,-2040(gp) # 157c8 <pio>
   10978:	00200713          	li	a4,2
   1097c:	00e78823          	sb	a4,16(a5)

  return 0;
   10980:	00000793          	li	a5,0
}
   10984:	00078513          	mv	a0,a5
   10988:	01c12403          	lw	s0,28(sp)
   1098c:	02010113          	addi	sp,sp,32
   10990:	00008067          	ret

00010994 <ns16550_rxready>:
#endif


int ns16550_rxready(void)
{
   10994:	ff010113          	addi	sp,sp,-16
   10998:	00812623          	sw	s0,12(sp)
   1099c:	01010413          	addi	s0,sp,16
  return (pio->lsr & LSR_DR) != 0;
   109a0:	8081a783          	lw	a5,-2040(gp) # 157c8 <pio>
   109a4:	0147c783          	lbu	a5,20(a5)
   109a8:	0ff7f793          	andi	a5,a5,255
   109ac:	0017f793          	andi	a5,a5,1
   109b0:	00f037b3          	snez	a5,a5
   109b4:	0ff7f793          	andi	a5,a5,255
}
   109b8:	00078513          	mv	a0,a5
   109bc:	00c12403          	lw	s0,12(sp)
   109c0:	01010113          	addi	sp,sp,16
   109c4:	00008067          	ret

000109c8 <ns16550_rxchar>:


int ns16550_rxchar(void)
{
   109c8:	ff010113          	addi	sp,sp,-16
   109cc:	00812623          	sw	s0,12(sp)
   109d0:	01010413          	addi	s0,sp,16
  while ((pio->lsr & LSR_DR) == 0)
   109d4:	00000013          	nop
   109d8:	8081a783          	lw	a5,-2040(gp) # 157c8 <pio>
   109dc:	0147c783          	lbu	a5,20(a5)
   109e0:	0ff7f793          	andi	a5,a5,255
   109e4:	0017f793          	andi	a5,a5,1
   109e8:	fe0788e3          	beqz	a5,109d8 <ns16550_rxchar+0x10>
    ;  // nothing

  return pio->rbr;
   109ec:	8081a783          	lw	a5,-2040(gp) # 157c8 <pio>
   109f0:	0007c783          	lbu	a5,0(a5)
   109f4:	0ff7f793          	andi	a5,a5,255
}
   109f8:	00078513          	mv	a0,a5
   109fc:	00c12403          	lw	s0,12(sp)
   10a00:	01010113          	addi	sp,sp,16
   10a04:	00008067          	ret

00010a08 <ns16550_txchar>:


int ns16550_txchar(int c)
{
   10a08:	fe010113          	addi	sp,sp,-32
   10a0c:	00812e23          	sw	s0,28(sp)
   10a10:	02010413          	addi	s0,sp,32
   10a14:	fea42623          	sw	a0,-20(s0)
  while ((pio->lsr & LSR_THRE) == 0)
   10a18:	00000013          	nop
   10a1c:	8081a783          	lw	a5,-2040(gp) # 157c8 <pio>
   10a20:	0147c783          	lbu	a5,20(a5)
   10a24:	0ff7f793          	andi	a5,a5,255
   10a28:	0207f793          	andi	a5,a5,32
   10a2c:	fe0788e3          	beqz	a5,10a1c <ns16550_txchar+0x14>
    ;  // nothing

  pio->thr = c;
   10a30:	8081a783          	lw	a5,-2040(gp) # 157c8 <pio>
   10a34:	fec42703          	lw	a4,-20(s0)
   10a38:	0ff77713          	andi	a4,a4,255
   10a3c:	00e78023          	sb	a4,0(a5)

  return c;
   10a40:	fec42783          	lw	a5,-20(s0)
}
   10a44:	00078513          	mv	a0,a5
   10a48:	01c12403          	lw	s0,28(sp)
   10a4c:	02010113          	addi	sp,sp,32
   10a50:	00008067          	ret

00010a54 <ns16550_flush>:


void ns16550_flush(void)
{
   10a54:	ff010113          	addi	sp,sp,-16
   10a58:	00812623          	sw	s0,12(sp)
   10a5c:	01010413          	addi	s0,sp,16
  while ((pio->lsr & LSR_TEMT) == 0)
   10a60:	00000013          	nop
   10a64:	8081a783          	lw	a5,-2040(gp) # 157c8 <pio>
   10a68:	0147c783          	lbu	a5,20(a5)
   10a6c:	0ff7f793          	andi	a5,a5,255
   10a70:	0407f793          	andi	a5,a5,64
   10a74:	fe0788e3          	beqz	a5,10a64 <ns16550_flush+0x10>
    ;  // nothing
}
   10a78:	00000013          	nop
   10a7c:	00c12403          	lw	s0,12(sp)
   10a80:	01010113          	addi	sp,sp,16
   10a84:	00008067          	ret

00010a88 <multiply>:
// multiply function (c version)
// -------------------------------------------------------------------------
// $Id: multiply.c,v 1.1 2006-03-05 07:03:29 cbatten Exp $

int multiply( int x, int y )
{
   10a88:	fd010113          	addi	sp,sp,-48
   10a8c:	02812623          	sw	s0,44(sp)
   10a90:	03010413          	addi	s0,sp,48
   10a94:	fca42e23          	sw	a0,-36(s0)
   10a98:	fcb42c23          	sw	a1,-40(s0)

 int i;
 int result = 0;
   10a9c:	fe042423          	sw	zero,-24(s0)

 for (i = 0; i < 32; i++) {
   10aa0:	fe042623          	sw	zero,-20(s0)
   10aa4:	0440006f          	j	10ae8 <multiply+0x60>
   if ((x & 0x1) == 1)
   10aa8:	fdc42783          	lw	a5,-36(s0)
   10aac:	0017f793          	andi	a5,a5,1
   10ab0:	00078a63          	beqz	a5,10ac4 <multiply+0x3c>
     result = result + y;
   10ab4:	fe842703          	lw	a4,-24(s0)
   10ab8:	fd842783          	lw	a5,-40(s0)
   10abc:	00f707b3          	add	a5,a4,a5
   10ac0:	fef42423          	sw	a5,-24(s0)
       
   x = x >> 1;
   10ac4:	fdc42783          	lw	a5,-36(s0)
   10ac8:	4017d793          	srai	a5,a5,0x1
   10acc:	fcf42e23          	sw	a5,-36(s0)
   y = y << 1;
   10ad0:	fd842783          	lw	a5,-40(s0)
   10ad4:	00179793          	slli	a5,a5,0x1
   10ad8:	fcf42c23          	sw	a5,-40(s0)
{

 int i;
 int result = 0;

 for (i = 0; i < 32; i++) {
   10adc:	fec42783          	lw	a5,-20(s0)
   10ae0:	00178793          	addi	a5,a5,1
   10ae4:	fef42623          	sw	a5,-20(s0)
   10ae8:	fec42703          	lw	a4,-20(s0)
   10aec:	01f00793          	li	a5,31
   10af0:	fae7dce3          	ble	a4,a5,10aa8 <multiply+0x20>
       
   x = x >> 1;
   y = y << 1;
 } 
 
 return result;
   10af4:	fe842783          	lw	a5,-24(s0)

}
   10af8:	00078513          	mv	a0,a5
   10afc:	02c12403          	lw	s0,44(sp)
   10b00:	03010113          	addi	sp,sp,48
   10b04:	00008067          	ret

00010b08 <verify>:

//--------------------------------------------------------------------------
// Helper functions

int verify( int n, int test[], int correct[] )
{
   10b08:	fd010113          	addi	sp,sp,-48
   10b0c:	02812623          	sw	s0,44(sp)
   10b10:	03010413          	addi	s0,sp,48
   10b14:	fca42e23          	sw	a0,-36(s0)
   10b18:	fcb42c23          	sw	a1,-40(s0)
   10b1c:	fcc42a23          	sw	a2,-44(s0)
  int i;
  for ( i = 0; i < n; i++ ) {
   10b20:	fe042623          	sw	zero,-20(s0)
   10b24:	0440006f          	j	10b68 <verify+0x60>
    if ( test[i] != correct[i] ) {
   10b28:	fec42783          	lw	a5,-20(s0)
   10b2c:	00279793          	slli	a5,a5,0x2
   10b30:	fd842703          	lw	a4,-40(s0)
   10b34:	00f707b3          	add	a5,a4,a5
   10b38:	0007a703          	lw	a4,0(a5)
   10b3c:	fec42783          	lw	a5,-20(s0)
   10b40:	00279793          	slli	a5,a5,0x2
   10b44:	fd442683          	lw	a3,-44(s0)
   10b48:	00f687b3          	add	a5,a3,a5
   10b4c:	0007a783          	lw	a5,0(a5)
   10b50:	00f70663          	beq	a4,a5,10b5c <verify+0x54>
      return 0;
   10b54:	00000793          	li	a5,0
   10b58:	0200006f          	j	10b78 <verify+0x70>
// Helper functions

int verify( int n, int test[], int correct[] )
{
  int i;
  for ( i = 0; i < n; i++ ) {
   10b5c:	fec42783          	lw	a5,-20(s0)
   10b60:	00178793          	addi	a5,a5,1
   10b64:	fef42623          	sw	a5,-20(s0)
   10b68:	fec42703          	lw	a4,-20(s0)
   10b6c:	fdc42783          	lw	a5,-36(s0)
   10b70:	faf74ce3          	blt	a4,a5,10b28 <verify+0x20>
    if ( test[i] != correct[i] ) {
      return 0;
    }
  }
  return 1;
   10b74:	00100793          	li	a5,1
}
   10b78:	00078513          	mv	a0,a5
   10b7c:	02c12403          	lw	s0,44(sp)
   10b80:	03010113          	addi	sp,sp,48
   10b84:	00008067          	ret

00010b88 <main>:

//--------------------------------------------------------------------------
// Main

int main( int argc, char* argv[] )
{
   10b88:	e4010113          	addi	sp,sp,-448
   10b8c:	1a112e23          	sw	ra,444(sp)
   10b90:	1a812c23          	sw	s0,440(sp)
   10b94:	1c010413          	addi	s0,sp,448
   10b98:	e4a42623          	sw	a0,-436(s0)
   10b9c:	e4b42423          	sw	a1,-440(s0)
  int i;
  int results_data[DATA_SIZE];

  // Do the multiply
  for (i = 0; i < DATA_SIZE; i++) {
   10ba0:	fe042623          	sw	zero,-20(s0)
   10ba4:	0640006f          	j	10c08 <main+0x80>
    results_data[i] = multiply( input_data1[i], input_data2[i] );
   10ba8:	000157b7          	lui	a5,0x15
   10bac:	fec42703          	lw	a4,-20(s0)
   10bb0:	00271713          	slli	a4,a4,0x2
   10bb4:	ac078793          	addi	a5,a5,-1344 # 14ac0 <_fdata>
   10bb8:	00f707b3          	add	a5,a4,a5
   10bbc:	0007a683          	lw	a3,0(a5)
   10bc0:	000157b7          	lui	a5,0x15
   10bc4:	fec42703          	lw	a4,-20(s0)
   10bc8:	00271713          	slli	a4,a4,0x2
   10bcc:	c5078793          	addi	a5,a5,-944 # 14c50 <input_data2>
   10bd0:	00f707b3          	add	a5,a4,a5
   10bd4:	0007a783          	lw	a5,0(a5)
   10bd8:	00078593          	mv	a1,a5
   10bdc:	00068513          	mv	a0,a3
   10be0:	ea9ff0ef          	jal	10a88 <multiply>
   10be4:	00050713          	mv	a4,a0
   10be8:	fec42783          	lw	a5,-20(s0)
   10bec:	00279793          	slli	a5,a5,0x2
   10bf0:	ff040693          	addi	a3,s0,-16
   10bf4:	00f687b3          	add	a5,a3,a5
   10bf8:	e6e7a623          	sw	a4,-404(a5)
{
  int i;
  int results_data[DATA_SIZE];

  // Do the multiply
  for (i = 0; i < DATA_SIZE; i++) {
   10bfc:	fec42783          	lw	a5,-20(s0)
   10c00:	00178793          	addi	a5,a5,1
   10c04:	fef42623          	sw	a5,-20(s0)
   10c08:	fec42703          	lw	a4,-20(s0)
   10c0c:	06300793          	li	a5,99
   10c10:	f8e7dce3          	ble	a4,a5,10ba8 <main+0x20>
    results_data[i] = multiply( input_data1[i], input_data2[i] );
  }

  // Check the results
  if (verify( DATA_SIZE, results_data, verify_data ))
   10c14:	e5c40713          	addi	a4,s0,-420
   10c18:	000157b7          	lui	a5,0x15
   10c1c:	de078613          	addi	a2,a5,-544 # 14de0 <verify_data>
   10c20:	00070593          	mv	a1,a4
   10c24:	06400513          	li	a0,100
   10c28:	ee1ff0ef          	jal	10b08 <verify>
   10c2c:	00050793          	mv	a5,a0
   10c30:	00078a63          	beqz	a5,10c44 <main+0xbc>
      printf ("Verify = ok\n");
   10c34:	000147b7          	lui	a5,0x14
   10c38:	fc878513          	addi	a0,a5,-56 # 13fc8 <fclose+0xc>
   10c3c:	351000ef          	jal	1178c <puts>
   10c40:	0100006f          	j	10c50 <main+0xc8>
  else
      printf ("Verify = not ok\n");
   10c44:	000147b7          	lui	a5,0x14
   10c48:	fd478513          	addi	a0,a5,-44 # 13fd4 <fclose+0x18>
   10c4c:	341000ef          	jal	1178c <puts>

  return 0;
   10c50:	00000793          	li	a5,0
}
   10c54:	00078513          	mv	a0,a5
   10c58:	1bc12083          	lw	ra,444(sp)
   10c5c:	1b812403          	lw	s0,440(sp)
   10c60:	1c010113          	addi	sp,sp,448
   10c64:	00008067          	ret

00010c68 <__divdi3>:
  Wtype c = 0;
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
   10c68:	2605ce63          	bltz	a1,10ee4 <__divdi3+0x27c>
   10c6c:	00050313          	mv	t1,a0
   10c70:	00058793          	mv	a5,a1

#ifdef L_divdi3
DWtype
__divdi3 (DWtype u, DWtype v)
{
  Wtype c = 0;
   10c74:	00000893          	li	a7,0
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
   10c78:	2406ca63          	bltz	a3,10ecc <__divdi3+0x264>
  DWunion rr;
  UWtype d0, d1, n0, n1, n2;
  UWtype q0, q1;
  UWtype b, bm;

  d0 = dd.s.low;
   10c7c:	00060293          	mv	t0,a2
  d1 = dd.s.high;
  n0 = nn.s.low;
   10c80:	00030393          	mv	t2,t1
  n1 = nn.s.high;
   10c84:	00078593          	mv	a1,a5
	}
    }

#else /* UDIV_NEEDS_NORMALIZATION */

  if (d1 == 0)
   10c88:	0e069e63          	bnez	a3,10d84 <__divdi3+0x11c>
    {
      if (d0 > n1)
   10c8c:	16c7f263          	bleu	a2,a5,10df0 <__divdi3+0x188>
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   10c90:	00010737          	lui	a4,0x10
   10c94:	26e66c63          	bltu	a2,a4,10f0c <__divdi3+0x2a4>
   10c98:	01000737          	lui	a4,0x1000
   10c9c:	00e63733          	sltu	a4,a2,a4
   10ca0:	00174713          	xori	a4,a4,1
   10ca4:	40e00733          	neg	a4,a4
   10ca8:	00877713          	andi	a4,a4,8
   10cac:	01070713          	addi	a4,a4,16 # 1000010 <_gp+0xfea050>
   10cb0:	000146b7          	lui	a3,0x14
   10cb4:	00e65533          	srl	a0,a2,a4
   10cb8:	fe468693          	addi	a3,a3,-28 # 13fe4 <__clz_tab>
   10cbc:	00d506b3          	add	a3,a0,a3
   10cc0:	0006c683          	lbu	a3,0(a3)
   10cc4:	00e68733          	add	a4,a3,a4
   10cc8:	02000693          	li	a3,32
   10ccc:	40e686b3          	sub	a3,a3,a4

	  if (bm != 0)
   10cd0:	00068c63          	beqz	a3,10ce8 <__divdi3+0x80>
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   10cd4:	00d797b3          	sll	a5,a5,a3
   10cd8:	00e35733          	srl	a4,t1,a4
	  if (bm != 0)
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
   10cdc:	00d612b3          	sll	t0,a2,a3
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   10ce0:	00f765b3          	or	a1,a4,a5
	      n0 = n0 << bm;
   10ce4:	00d313b3          	sll	t2,t1,a3
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   10ce8:	0102d613          	srli	a2,t0,0x10
   10cec:	02c5d533          	divu	a0,a1,a2
   10cf0:	01029693          	slli	a3,t0,0x10
   10cf4:	0106d693          	srli	a3,a3,0x10
   10cf8:	0103d713          	srli	a4,t2,0x10
   10cfc:	02c5f7b3          	remu	a5,a1,a2
   10d00:	02a68833          	mul	a6,a3,a0
   10d04:	01079793          	slli	a5,a5,0x10
   10d08:	00f765b3          	or	a1,a4,a5
   10d0c:	0105fc63          	bleu	a6,a1,10d24 <__divdi3+0xbc>
   10d10:	005585b3          	add	a1,a1,t0
   10d14:	fff50793          	addi	a5,a0,-1
   10d18:	0055e463          	bltu	a1,t0,10d20 <__divdi3+0xb8>
   10d1c:	4105e263          	bltu	a1,a6,11120 <__divdi3+0x4b8>
   10d20:	00078513          	mv	a0,a5
   10d24:	410585b3          	sub	a1,a1,a6
   10d28:	02c5d7b3          	divu	a5,a1,a2
   10d2c:	01039393          	slli	t2,t2,0x10
   10d30:	0103d393          	srli	t2,t2,0x10
   10d34:	02c5f5b3          	remu	a1,a1,a2
   10d38:	02f686b3          	mul	a3,a3,a5
   10d3c:	01059593          	slli	a1,a1,0x10
   10d40:	00b3e5b3          	or	a1,t2,a1
   10d44:	00d5fe63          	bleu	a3,a1,10d60 <__divdi3+0xf8>
   10d48:	00b285b3          	add	a1,t0,a1
   10d4c:	fff78713          	addi	a4,a5,-1
   10d50:	0055e663          	bltu	a1,t0,10d5c <__divdi3+0xf4>
   10d54:	ffe78793          	addi	a5,a5,-2
   10d58:	00d5e463          	bltu	a1,a3,10d60 <__divdi3+0xf8>
   10d5c:	00070793          	mv	a5,a4
   10d60:	01051513          	slli	a0,a0,0x10
   10d64:	00f56533          	or	a0,a0,a5
   10d68:	00000593          	li	a1,0
  if (vv.s.high < 0)
    c = ~c,
    vv.ll = -vv.ll;

  w = __udivmoddi4 (uu.ll, vv.ll, (UDWtype *) 0);
  if (c)
   10d6c:	00088a63          	beqz	a7,10d80 <__divdi3+0x118>
    w = -w;
   10d70:	40a00533          	neg	a0,a0
   10d74:	00a037b3          	snez	a5,a0
   10d78:	40b005b3          	neg	a1,a1
   10d7c:	40f585b3          	sub	a1,a1,a5

  return w;
}
   10d80:	00008067          	ret
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
   10d84:	00d7f863          	bleu	a3,a5,10d94 <__divdi3+0x12c>
   10d88:	00000593          	li	a1,0
   10d8c:	00000513          	li	a0,0
   10d90:	fddff06f          	j	10d6c <__divdi3+0x104>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   10d94:	00010737          	lui	a4,0x10
   10d98:	18e6e263          	bltu	a3,a4,10f1c <__divdi3+0x2b4>
   10d9c:	01000737          	lui	a4,0x1000
   10da0:	00e6b733          	sltu	a4,a3,a4
   10da4:	00174713          	xori	a4,a4,1
   10da8:	40e00733          	neg	a4,a4
   10dac:	00877713          	andi	a4,a4,8
   10db0:	01070713          	addi	a4,a4,16 # 1000010 <_gp+0xfea050>
   10db4:	000145b7          	lui	a1,0x14
   10db8:	00e6d533          	srl	a0,a3,a4
   10dbc:	fe458593          	addi	a1,a1,-28 # 13fe4 <__clz_tab>
   10dc0:	00b505b3          	add	a1,a0,a1
   10dc4:	0005c803          	lbu	a6,0(a1)
   10dc8:	02000293          	li	t0,32
   10dcc:	00e80833          	add	a6,a6,a4
   10dd0:	410282b3          	sub	t0,t0,a6
	  if (bm == 0)
   10dd4:	14029c63          	bnez	t0,10f2c <__divdi3+0x2c4>

		 This special case is necessary, not an optimization.  */

	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
   10dd8:	00000593          	li	a1,0
   10ddc:	00100513          	li	a0,1
   10de0:	f8f6e6e3          	bltu	a3,a5,10d6c <__divdi3+0x104>
   10de4:	00c33533          	sltu	a0,t1,a2
   10de8:	00154513          	xori	a0,a0,1
   10dec:	f81ff06f          	j	10d6c <__divdi3+0x104>
	}
      else
	{
	  /* qq = NN / 0d */

	  if (d0 == 0)
   10df0:	00061663          	bnez	a2,10dfc <__divdi3+0x194>
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
   10df4:	00100293          	li	t0,1
   10df8:	02d2d2b3          	divu	t0,t0,a3

	  count_leading_zeros (bm, d0);
   10dfc:	00010737          	lui	a4,0x10
   10e00:	0ee2ee63          	bltu	t0,a4,10efc <__divdi3+0x294>
   10e04:	01000737          	lui	a4,0x1000
   10e08:	00e2b733          	sltu	a4,t0,a4
   10e0c:	00174713          	xori	a4,a4,1
   10e10:	40e00733          	neg	a4,a4
   10e14:	00877713          	andi	a4,a4,8
   10e18:	01070713          	addi	a4,a4,16 # 1000010 <_gp+0xfea050>
   10e1c:	000146b7          	lui	a3,0x14
   10e20:	00e2d633          	srl	a2,t0,a4
   10e24:	fe468693          	addi	a3,a3,-28 # 13fe4 <__clz_tab>
   10e28:	00d606b3          	add	a3,a2,a3
   10e2c:	0006c503          	lbu	a0,0(a3)
   10e30:	02000e13          	li	t3,32
   10e34:	00e50533          	add	a0,a0,a4
   10e38:	40ae0e33          	sub	t3,t3,a0

	  if (bm == 0)
   10e3c:	1e0e1663          	bnez	t3,11028 <__divdi3+0x3c0>
   10e40:	01029813          	slli	a6,t0,0x10
		 leading quotient digit q1 = 1).

		 This special case is necessary, not an optimization.
		 (Shifts counts of W_TYPE_SIZE are undefined.)  */

	      n1 -= d0;
   10e44:	405786b3          	sub	a3,a5,t0
   10e48:	0102d613          	srli	a2,t0,0x10
   10e4c:	01085813          	srli	a6,a6,0x10
   10e50:	00100593          	li	a1,1
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   10e54:	0103d793          	srli	a5,t2,0x10
   10e58:	02c6d533          	divu	a0,a3,a2
   10e5c:	02c6f6b3          	remu	a3,a3,a2
   10e60:	03050733          	mul	a4,a0,a6
   10e64:	01069693          	slli	a3,a3,0x10
   10e68:	00d7e7b3          	or	a5,a5,a3
   10e6c:	00e7fc63          	bleu	a4,a5,10e84 <__divdi3+0x21c>
   10e70:	005787b3          	add	a5,a5,t0
   10e74:	fff50693          	addi	a3,a0,-1
   10e78:	0057e463          	bltu	a5,t0,10e80 <__divdi3+0x218>
   10e7c:	2ae7e863          	bltu	a5,a4,1112c <__divdi3+0x4c4>
   10e80:	00068513          	mv	a0,a3
   10e84:	40e78733          	sub	a4,a5,a4
   10e88:	02c757b3          	divu	a5,a4,a2
   10e8c:	01039393          	slli	t2,t2,0x10
   10e90:	0103d393          	srli	t2,t2,0x10
   10e94:	02c77733          	remu	a4,a4,a2
   10e98:	03078833          	mul	a6,a5,a6
   10e9c:	01071713          	slli	a4,a4,0x10
   10ea0:	00e3e733          	or	a4,t2,a4
   10ea4:	01077e63          	bleu	a6,a4,10ec0 <__divdi3+0x258>
   10ea8:	00e28733          	add	a4,t0,a4
   10eac:	fff78693          	addi	a3,a5,-1
   10eb0:	00576663          	bltu	a4,t0,10ebc <__divdi3+0x254>
   10eb4:	ffe78793          	addi	a5,a5,-2
   10eb8:	01076463          	bltu	a4,a6,10ec0 <__divdi3+0x258>
   10ebc:	00068793          	mv	a5,a3
   10ec0:	01051513          	slli	a0,a0,0x10
   10ec4:	00f56533          	or	a0,a0,a5
   10ec8:	ea5ff06f          	j	10d6c <__divdi3+0x104>
  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    c = ~c,
    vv.ll = -vv.ll;
   10ecc:	40c00633          	neg	a2,a2
   10ed0:	00c03733          	snez	a4,a2
   10ed4:	40d006b3          	neg	a3,a3

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    c = ~c,
   10ed8:	fff8c893          	not	a7,a7
    vv.ll = -vv.ll;
   10edc:	40e686b3          	sub	a3,a3,a4
   10ee0:	d9dff06f          	j	10c7c <__divdi3+0x14>
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
   10ee4:	40a00333          	neg	t1,a0
   10ee8:	00603733          	snez	a4,t1
   10eec:	40b007b3          	neg	a5,a1
   10ef0:	40e787b3          	sub	a5,a5,a4
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
   10ef4:	fff00893          	li	a7,-1
   10ef8:	d81ff06f          	j	10c78 <__divdi3+0x10>
	  /* qq = NN / 0d */

	  if (d0 == 0)
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */

	  count_leading_zeros (bm, d0);
   10efc:	0ff00713          	li	a4,255
   10f00:	00573733          	sltu	a4,a4,t0
   10f04:	00371713          	slli	a4,a4,0x3
   10f08:	f15ff06f          	j	10e1c <__divdi3+0x1b4>
    {
      if (d0 > n1)
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   10f0c:	0ff00713          	li	a4,255
   10f10:	00c73733          	sltu	a4,a4,a2
   10f14:	00371713          	slli	a4,a4,0x3
   10f18:	d99ff06f          	j	10cb0 <__divdi3+0x48>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   10f1c:	0ff00713          	li	a4,255
   10f20:	00d73733          	sltu	a4,a4,a3
   10f24:	00371713          	slli	a4,a4,0x3
   10f28:	e8dff06f          	j	10db4 <__divdi3+0x14c>
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
   10f2c:	01065733          	srl	a4,a2,a6
   10f30:	005696b3          	sll	a3,a3,t0
   10f34:	00e6e6b3          	or	a3,a3,a4
	      d0 = d0 << bm;
	      n2 = n1 >> b;
   10f38:	0107d5b3          	srl	a1,a5,a6
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   10f3c:	0106de93          	srli	t4,a3,0x10
   10f40:	03d5de33          	divu	t3,a1,t4
   10f44:	01069393          	slli	t2,a3,0x10
   10f48:	0103d393          	srli	t2,t2,0x10
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   10f4c:	005797b3          	sll	a5,a5,t0
   10f50:	01035833          	srl	a6,t1,a6
   10f54:	00f867b3          	or	a5,a6,a5
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   10f58:	0107d713          	srli	a4,a5,0x10
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
   10f5c:	00561633          	sll	a2,a2,t0
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   10f60:	03d5f5b3          	remu	a1,a1,t4
   10f64:	03c38533          	mul	a0,t2,t3
   10f68:	01059593          	slli	a1,a1,0x10
   10f6c:	00b76733          	or	a4,a4,a1
   10f70:	00a77e63          	bleu	a0,a4,10f8c <__divdi3+0x324>
   10f74:	00d70733          	add	a4,a4,a3
   10f78:	fffe0593          	addi	a1,t3,-1
   10f7c:	18d76e63          	bltu	a4,a3,11118 <__divdi3+0x4b0>
   10f80:	18a77c63          	bleu	a0,a4,11118 <__divdi3+0x4b0>
   10f84:	ffee0e13          	addi	t3,t3,-2
   10f88:	00d70733          	add	a4,a4,a3
   10f8c:	40a70733          	sub	a4,a4,a0
   10f90:	03d75833          	divu	a6,a4,t4
   10f94:	01079793          	slli	a5,a5,0x10
   10f98:	0107d793          	srli	a5,a5,0x10
   10f9c:	03d77733          	remu	a4,a4,t4
   10fa0:	030385b3          	mul	a1,t2,a6
   10fa4:	01071713          	slli	a4,a4,0x10
   10fa8:	00e7e7b3          	or	a5,a5,a4
   10fac:	00b7fe63          	bleu	a1,a5,10fc8 <__divdi3+0x360>
   10fb0:	00d787b3          	add	a5,a5,a3
   10fb4:	fff80713          	addi	a4,a6,-1
   10fb8:	14d7e863          	bltu	a5,a3,11108 <__divdi3+0x4a0>
   10fbc:	14b7f663          	bleu	a1,a5,11108 <__divdi3+0x4a0>
   10fc0:	ffe80813          	addi	a6,a6,-2
   10fc4:	00d787b3          	add	a5,a5,a3
   10fc8:	010e1e13          	slli	t3,t3,0x10
	      umul_ppmm (m1, m0, q0, d0);
   10fcc:	000103b7          	lui	t2,0x10
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   10fd0:	010e6533          	or	a0,t3,a6
	      umul_ppmm (m1, m0, q0, d0);
   10fd4:	fff38713          	addi	a4,t2,-1 # ffff <_reset+0xfdff>
   10fd8:	00e576b3          	and	a3,a0,a4
   10fdc:	01055813          	srli	a6,a0,0x10
   10fe0:	00e67733          	and	a4,a2,a4
   10fe4:	01065613          	srli	a2,a2,0x10
   10fe8:	02e68e33          	mul	t3,a3,a4
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   10fec:	40b787b3          	sub	a5,a5,a1
   10ff0:	02c686b3          	mul	a3,a3,a2
	      umul_ppmm (m1, m0, q0, d0);
   10ff4:	010e5593          	srli	a1,t3,0x10
   10ff8:	02e80733          	mul	a4,a6,a4
   10ffc:	00e686b3          	add	a3,a3,a4
   11000:	00d586b3          	add	a3,a1,a3
   11004:	02c80633          	mul	a2,a6,a2
   11008:	00e6f463          	bleu	a4,a3,11010 <__divdi3+0x3a8>
   1100c:	00760633          	add	a2,a2,t2
   11010:	0106d813          	srli	a6,a3,0x10
   11014:	00c80633          	add	a2,a6,a2

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   11018:	0cc7ee63          	bltu	a5,a2,110f4 <__divdi3+0x48c>
   1101c:	0ac78c63          	beq	a5,a2,110d4 <__divdi3+0x46c>
		{
		  q0--;
   11020:	00000593          	li	a1,0
   11024:	d49ff06f          	j	10d6c <__divdi3+0x104>
	    {
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
   11028:	01c292b3          	sll	t0,t0,t3
	      n2 = n1 >> b;
   1102c:	00a7d833          	srl	a6,a5,a0
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11030:	0102d713          	srli	a4,t0,0x10
   11034:	02e85eb3          	divu	t4,a6,a4
   11038:	01029f13          	slli	t5,t0,0x10

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   1103c:	01c796b3          	sll	a3,a5,t3
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11040:	010f5f13          	srli	t5,t5,0x10

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   11044:	00a35533          	srl	a0,t1,a0
   11048:	00d56533          	or	a0,a0,a3
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   1104c:	01055613          	srli	a2,a0,0x10
	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;
   11050:	01c313b3          	sll	t2,t1,t3

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11054:	02e87833          	remu	a6,a6,a4
   11058:	03df06b3          	mul	a3,t5,t4
   1105c:	01081813          	slli	a6,a6,0x10
   11060:	01066633          	or	a2,a2,a6
   11064:	00d67e63          	bleu	a3,a2,11080 <__divdi3+0x418>
   11068:	00560633          	add	a2,a2,t0
   1106c:	fffe8793          	addi	a5,t4,-1
   11070:	0a566063          	bltu	a2,t0,11110 <__divdi3+0x4a8>
   11074:	08d67e63          	bleu	a3,a2,11110 <__divdi3+0x4a8>
   11078:	ffee8e93          	addi	t4,t4,-2
   1107c:	00560633          	add	a2,a2,t0
   11080:	40d60633          	sub	a2,a2,a3
   11084:	02e655b3          	divu	a1,a2,a4
   11088:	01051513          	slli	a0,a0,0x10
   1108c:	01055513          	srli	a0,a0,0x10
   11090:	02e67633          	remu	a2,a2,a4
   11094:	02bf07b3          	mul	a5,t5,a1
   11098:	01061613          	slli	a2,a2,0x10
   1109c:	00c566b3          	or	a3,a0,a2
   110a0:	00f6fe63          	bleu	a5,a3,110bc <__divdi3+0x454>
   110a4:	005686b3          	add	a3,a3,t0
   110a8:	fff58613          	addi	a2,a1,-1
   110ac:	0456ea63          	bltu	a3,t0,11100 <__divdi3+0x498>
   110b0:	04f6f863          	bleu	a5,a3,11100 <__divdi3+0x498>
   110b4:	ffe58593          	addi	a1,a1,-2
   110b8:	005686b3          	add	a3,a3,t0
   110bc:	010e9e93          	slli	t4,t4,0x10
   110c0:	40f686b3          	sub	a3,a3,a5
   110c4:	00bee5b3          	or	a1,t4,a1
   110c8:	000f0813          	mv	a6,t5
   110cc:	00070613          	mv	a2,a4
   110d0:	d85ff06f          	j	10e54 <__divdi3+0x1ec>
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   110d4:	000107b7          	lui	a5,0x10
   110d8:	fff78793          	addi	a5,a5,-1 # ffff <_reset+0xfdff>
   110dc:	00f6f6b3          	and	a3,a3,a5
   110e0:	01069693          	slli	a3,a3,0x10
   110e4:	00fe77b3          	and	a5,t3,a5
   110e8:	00531333          	sll	t1,t1,t0
   110ec:	00f687b3          	add	a5,a3,a5
   110f0:	f2f378e3          	bleu	a5,t1,11020 <__divdi3+0x3b8>
   110f4:	fff50513          	addi	a0,a0,-1
		{
		  q0--;
   110f8:	00000593          	li	a1,0
   110fc:	c71ff06f          	j	10d6c <__divdi3+0x104>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11100:	00060593          	mv	a1,a2
   11104:	fb9ff06f          	j	110bc <__divdi3+0x454>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11108:	00070813          	mv	a6,a4
   1110c:	ebdff06f          	j	10fc8 <__divdi3+0x360>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11110:	00078e93          	mv	t4,a5
   11114:	f6dff06f          	j	11080 <__divdi3+0x418>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11118:	00058e13          	mv	t3,a1
   1111c:	e71ff06f          	j	10f8c <__divdi3+0x324>
	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
	      n0 = n0 << bm;
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11120:	ffe50513          	addi	a0,a0,-2
   11124:	005585b3          	add	a1,a1,t0
   11128:	bfdff06f          	j	10d24 <__divdi3+0xbc>
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   1112c:	ffe50513          	addi	a0,a0,-2
   11130:	005787b3          	add	a5,a5,t0
   11134:	d51ff06f          	j	10e84 <__divdi3+0x21c>

00011138 <__moddi3>:

#ifdef L_moddi3
DWtype
__moddi3 (DWtype u, DWtype v)
{
  Wtype c = 0;
   11138:	00000813          	li	a6,0
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
   1113c:	1605c863          	bltz	a1,112ac <__moddi3+0x174>
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
   11140:	1806c263          	bltz	a3,112c4 <__moddi3+0x18c>
  DWunion rr;
  UWtype d0, d1, n0, n1, n2;
  UWtype q0, q1;
  UWtype b, bm;

  d0 = dd.s.low;
   11144:	00060893          	mv	a7,a2
  d1 = dd.s.high;
  n0 = nn.s.low;
   11148:	00050313          	mv	t1,a0
  n1 = nn.s.high;
   1114c:	00058393          	mv	t2,a1
	}
    }

#else /* UDIV_NEEDS_NORMALIZATION */

  if (d1 == 0)
   11150:	0e069663          	bnez	a3,1123c <__moddi3+0x104>
    {
      if (d0 > n1)
   11154:	18c5f263          	bleu	a2,a1,112d8 <__moddi3+0x1a0>
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   11158:	000107b7          	lui	a5,0x10
   1115c:	24f66063          	bltu	a2,a5,1139c <__moddi3+0x264>
   11160:	010002b7          	lui	t0,0x1000
   11164:	005632b3          	sltu	t0,a2,t0
   11168:	0012c293          	xori	t0,t0,1
   1116c:	405002b3          	neg	t0,t0
   11170:	0082f293          	andi	t0,t0,8
   11174:	01028293          	addi	t0,t0,16 # 1000010 <_gp+0xfea050>
   11178:	000147b7          	lui	a5,0x14
   1117c:	00565733          	srl	a4,a2,t0
   11180:	fe478793          	addi	a5,a5,-28 # 13fe4 <__clz_tab>
   11184:	00f707b3          	add	a5,a4,a5
   11188:	0007c783          	lbu	a5,0(a5)
   1118c:	005787b3          	add	a5,a5,t0
   11190:	02000293          	li	t0,32
   11194:	40f282b3          	sub	t0,t0,a5

	  if (bm != 0)
   11198:	00028c63          	beqz	t0,111b0 <__moddi3+0x78>
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   1119c:	005595b3          	sll	a1,a1,t0
   111a0:	00f557b3          	srl	a5,a0,a5
	  if (bm != 0)
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
   111a4:	005618b3          	sll	a7,a2,t0
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   111a8:	00b7e3b3          	or	t2,a5,a1
	      n0 = n0 << bm;
   111ac:	00551333          	sll	t1,a0,t0
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   111b0:	0108de13          	srli	t3,a7,0x10
   111b4:	03c3d633          	divu	a2,t2,t3
   111b8:	01089693          	slli	a3,a7,0x10
   111bc:	0106d693          	srli	a3,a3,0x10
   111c0:	01035713          	srli	a4,t1,0x10
   111c4:	03c3f5b3          	remu	a1,t2,t3
   111c8:	02c68633          	mul	a2,a3,a2
   111cc:	01059593          	slli	a1,a1,0x10
   111d0:	00b76733          	or	a4,a4,a1
   111d4:	00c77863          	bleu	a2,a4,111e4 <__moddi3+0xac>
   111d8:	01170733          	add	a4,a4,a7
   111dc:	01176463          	bltu	a4,a7,111e4 <__moddi3+0xac>
   111e0:	3cc76863          	bltu	a4,a2,115b0 <__moddi3+0x478>
   111e4:	40c70733          	sub	a4,a4,a2
   111e8:	03c757b3          	divu	a5,a4,t3
   111ec:	01031313          	slli	t1,t1,0x10
   111f0:	01035313          	srli	t1,t1,0x10
   111f4:	03c77733          	remu	a4,a4,t3
   111f8:	02f68533          	mul	a0,a3,a5
   111fc:	01071713          	slli	a4,a4,0x10
   11200:	00e367b3          	or	a5,t1,a4
   11204:	00a7fa63          	bleu	a0,a5,11218 <__moddi3+0xe0>
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11208:	011787b3          	add	a5,a5,a7
   1120c:	0117e663          	bltu	a5,a7,11218 <__moddi3+0xe0>
   11210:	00a7f463          	bleu	a0,a5,11218 <__moddi3+0xe0>
   11214:	011787b3          	add	a5,a5,a7
   11218:	40a787b3          	sub	a5,a5,a0
	  /* Remainder in n0 >> bm.  */
	}

      if (rp != 0)
	{
	  rr.s.low = n0 >> bm;
   1121c:	0057d533          	srl	a0,a5,t0
	  rr.s.high = 0;
	  *rp = rr.ll;
   11220:	00000593          	li	a1,0
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    vv.ll = -vv.ll;

  (void) __udivmoddi4 (uu.ll, vv.ll, (UDWtype*)&w);
  if (c)
   11224:	00080a63          	beqz	a6,11238 <__moddi3+0x100>
    w = -w;
   11228:	40a00533          	neg	a0,a0
   1122c:	00a037b3          	snez	a5,a0
   11230:	40b005b3          	neg	a1,a1
   11234:	40f585b3          	sub	a1,a1,a5

  return w;
}
   11238:	00008067          	ret
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
   1123c:	fed5e4e3          	bltu	a1,a3,11224 <__moddi3+0xec>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   11240:	000107b7          	lui	a5,0x10
   11244:	16f6e463          	bltu	a3,a5,113ac <__moddi3+0x274>
   11248:	010008b7          	lui	a7,0x1000
   1124c:	0116b8b3          	sltu	a7,a3,a7
   11250:	0018c893          	xori	a7,a7,1
   11254:	411008b3          	neg	a7,a7
   11258:	0088f893          	andi	a7,a7,8
   1125c:	01088893          	addi	a7,a7,16 # 1000010 <_gp+0xfea050>
   11260:	000147b7          	lui	a5,0x14
   11264:	0116d733          	srl	a4,a3,a7
   11268:	fe478793          	addi	a5,a5,-28 # 13fe4 <__clz_tab>
   1126c:	00f707b3          	add	a5,a4,a5
   11270:	0007ce83          	lbu	t4,0(a5)
   11274:	02000e13          	li	t3,32
   11278:	011e8eb3          	add	t4,t4,a7
   1127c:	41de0e33          	sub	t3,t3,t4
	  if (bm == 0)
   11280:	1c0e1863          	bnez	t3,11450 <__moddi3+0x318>

		 This special case is necessary, not an optimization.  */

	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
   11284:	00b6e663          	bltu	a3,a1,11290 <__moddi3+0x158>
   11288:	00050793          	mv	a5,a0
   1128c:	00c56a63          	bltu	a0,a2,112a0 <__moddi3+0x168>
		{
		  q0 = 1;
		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
   11290:	40c507b3          	sub	a5,a0,a2
   11294:	40d585b3          	sub	a1,a1,a3
   11298:	00f53533          	sltu	a0,a0,a5
   1129c:	40a583b3          	sub	t2,a1,a0

	      if (rp != 0)
		{
		  rr.s.low = n0;
		  rr.s.high = n1;
		  *rp = rr.ll;
   112a0:	00078513          	mv	a0,a5
   112a4:	00038593          	mv	a1,t2
   112a8:	f7dff06f          	j	11224 <__moddi3+0xec>
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
   112ac:	40a00533          	neg	a0,a0
   112b0:	00a037b3          	snez	a5,a0
   112b4:	40b00733          	neg	a4,a1
   112b8:	40f705b3          	sub	a1,a4,a5
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
   112bc:	fff00813          	li	a6,-1
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
   112c0:	e806d2e3          	bgez	a3,11144 <__moddi3+0xc>
    vv.ll = -vv.ll;
   112c4:	40c00633          	neg	a2,a2
   112c8:	00c037b3          	snez	a5,a2
   112cc:	40d006b3          	neg	a3,a3
   112d0:	40f686b3          	sub	a3,a3,a5
   112d4:	e71ff06f          	j	11144 <__moddi3+0xc>
	}
      else
	{
	  /* qq = NN / 0d */

	  if (d0 == 0)
   112d8:	00061663          	bnez	a2,112e4 <__moddi3+0x1ac>
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
   112dc:	00100893          	li	a7,1
   112e0:	02d8d8b3          	divu	a7,a7,a3

	  count_leading_zeros (bm, d0);
   112e4:	000107b7          	lui	a5,0x10
   112e8:	0af8e263          	bltu	a7,a5,1138c <__moddi3+0x254>
   112ec:	010007b7          	lui	a5,0x1000
   112f0:	00f8b7b3          	sltu	a5,a7,a5
   112f4:	0017c793          	xori	a5,a5,1
   112f8:	40f007b3          	neg	a5,a5
   112fc:	0087f793          	andi	a5,a5,8
   11300:	01078793          	addi	a5,a5,16 # 1000010 <_gp+0xfea050>
   11304:	00014737          	lui	a4,0x14
   11308:	00f8d6b3          	srl	a3,a7,a5
   1130c:	fe470713          	addi	a4,a4,-28 # 13fe4 <__clz_tab>
   11310:	00e68733          	add	a4,a3,a4
   11314:	00074703          	lbu	a4,0(a4)
   11318:	02000293          	li	t0,32
   1131c:	00f707b3          	add	a5,a4,a5
   11320:	40f282b3          	sub	t0,t0,a5

	  if (bm == 0)
   11324:	08029c63          	bnez	t0,113bc <__moddi3+0x284>
   11328:	01089793          	slli	a5,a7,0x10
		 leading quotient digit q1 = 1).

		 This special case is necessary, not an optimization.
		 (Shifts counts of W_TYPE_SIZE are undefined.)  */

	      n1 -= d0;
   1132c:	411585b3          	sub	a1,a1,a7
   11330:	0108d693          	srli	a3,a7,0x10
   11334:	0107d793          	srli	a5,a5,0x10
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11338:	01035713          	srli	a4,t1,0x10
   1133c:	02d5d633          	divu	a2,a1,a3
   11340:	02d5f5b3          	remu	a1,a1,a3
   11344:	02f60633          	mul	a2,a2,a5
   11348:	01059593          	slli	a1,a1,0x10
   1134c:	00b76733          	or	a4,a4,a1
   11350:	00c77a63          	bleu	a2,a4,11364 <__moddi3+0x22c>
   11354:	01170733          	add	a4,a4,a7
   11358:	01176663          	bltu	a4,a7,11364 <__moddi3+0x22c>
   1135c:	00c77463          	bleu	a2,a4,11364 <__moddi3+0x22c>
   11360:	01170733          	add	a4,a4,a7
   11364:	40c70733          	sub	a4,a4,a2
   11368:	02d75633          	divu	a2,a4,a3
   1136c:	01031313          	slli	t1,t1,0x10
   11370:	01035313          	srli	t1,t1,0x10
   11374:	02d77733          	remu	a4,a4,a3
   11378:	02f60533          	mul	a0,a2,a5
   1137c:	01071713          	slli	a4,a4,0x10
   11380:	00e367b3          	or	a5,t1,a4
   11384:	e8a7fae3          	bleu	a0,a5,11218 <__moddi3+0xe0>
   11388:	e81ff06f          	j	11208 <__moddi3+0xd0>
	  /* qq = NN / 0d */

	  if (d0 == 0)
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */

	  count_leading_zeros (bm, d0);
   1138c:	0ff00793          	li	a5,255
   11390:	0117b7b3          	sltu	a5,a5,a7
   11394:	00379793          	slli	a5,a5,0x3
   11398:	f6dff06f          	j	11304 <__moddi3+0x1cc>
    {
      if (d0 > n1)
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   1139c:	0ff00293          	li	t0,255
   113a0:	00c2b2b3          	sltu	t0,t0,a2
   113a4:	00329293          	slli	t0,t0,0x3
   113a8:	dd1ff06f          	j	11178 <__moddi3+0x40>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   113ac:	0ff00893          	li	a7,255
   113b0:	00d8b8b3          	sltu	a7,a7,a3
   113b4:	00389893          	slli	a7,a7,0x3
   113b8:	ea9ff06f          	j	11260 <__moddi3+0x128>
	    {
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
   113bc:	005898b3          	sll	a7,a7,t0
	      n2 = n1 >> b;
   113c0:	00f5de33          	srl	t3,a1,a5
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   113c4:	0108d713          	srli	a4,a7,0x10
   113c8:	02ee5633          	divu	a2,t3,a4
   113cc:	01089393          	slli	t2,a7,0x10

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   113d0:	005595b3          	sll	a1,a1,t0
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   113d4:	0103d393          	srli	t2,t2,0x10

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   113d8:	00f557b3          	srl	a5,a0,a5
   113dc:	00b7e7b3          	or	a5,a5,a1
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   113e0:	0107d693          	srli	a3,a5,0x10
	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;
   113e4:	00551333          	sll	t1,a0,t0

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   113e8:	02ee7e33          	remu	t3,t3,a4
   113ec:	02c385b3          	mul	a1,t2,a2
   113f0:	010e1e13          	slli	t3,t3,0x10
   113f4:	01c6e633          	or	a2,a3,t3
   113f8:	00b67a63          	bleu	a1,a2,1140c <__moddi3+0x2d4>
   113fc:	01160633          	add	a2,a2,a7
   11400:	01166663          	bltu	a2,a7,1140c <__moddi3+0x2d4>
   11404:	00b67463          	bleu	a1,a2,1140c <__moddi3+0x2d4>
   11408:	01160633          	add	a2,a2,a7
   1140c:	40b60633          	sub	a2,a2,a1
   11410:	02e655b3          	divu	a1,a2,a4
   11414:	01079793          	slli	a5,a5,0x10
   11418:	0107d793          	srli	a5,a5,0x10
   1141c:	02e67633          	remu	a2,a2,a4
   11420:	02b385b3          	mul	a1,t2,a1
   11424:	01061613          	slli	a2,a2,0x10
   11428:	00c7e6b3          	or	a3,a5,a2
   1142c:	00b6fa63          	bleu	a1,a3,11440 <__moddi3+0x308>
   11430:	011686b3          	add	a3,a3,a7
   11434:	0116e663          	bltu	a3,a7,11440 <__moddi3+0x308>
   11438:	00b6f463          	bleu	a1,a3,11440 <__moddi3+0x308>
   1143c:	011686b3          	add	a3,a3,a7
   11440:	40b685b3          	sub	a1,a3,a1
   11444:	00038793          	mv	a5,t2
   11448:	00070693          	mv	a3,a4
   1144c:	eedff06f          	j	11338 <__moddi3+0x200>
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
   11450:	01c696b3          	sll	a3,a3,t3
   11454:	01d653b3          	srl	t2,a2,t4
   11458:	0076e3b3          	or	t2,a3,t2
	      d0 = d0 << bm;
	      n2 = n1 >> b;
   1145c:	01d5d333          	srl	t1,a1,t4
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11460:	0103d893          	srli	a7,t2,0x10
   11464:	031357b3          	divu	a5,t1,a7
   11468:	01039713          	slli	a4,t2,0x10
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   1146c:	01c596b3          	sll	a3,a1,t3
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11470:	01075713          	srli	a4,a4,0x10
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   11474:	01d555b3          	srl	a1,a0,t4
   11478:	00d5e6b3          	or	a3,a1,a3
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   1147c:	0106d293          	srli	t0,a3,0x10
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
   11480:	01c61633          	sll	a2,a2,t3
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;
   11484:	01c51533          	sll	a0,a0,t3

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11488:	03137333          	remu	t1,t1,a7
   1148c:	02f705b3          	mul	a1,a4,a5
   11490:	01031313          	slli	t1,t1,0x10
   11494:	0062e2b3          	or	t0,t0,t1
   11498:	00b2fe63          	bleu	a1,t0,114b4 <__moddi3+0x37c>
   1149c:	007282b3          	add	t0,t0,t2
   114a0:	fff78313          	addi	t1,a5,-1
   114a4:	1072e263          	bltu	t0,t2,115a8 <__moddi3+0x470>
   114a8:	10b2f063          	bleu	a1,t0,115a8 <__moddi3+0x470>
   114ac:	ffe78793          	addi	a5,a5,-2
   114b0:	007282b3          	add	t0,t0,t2
   114b4:	40b282b3          	sub	t0,t0,a1
   114b8:	0312d333          	divu	t1,t0,a7
   114bc:	01069693          	slli	a3,a3,0x10
   114c0:	0106d693          	srli	a3,a3,0x10
   114c4:	0312f2b3          	remu	t0,t0,a7
   114c8:	02670733          	mul	a4,a4,t1
   114cc:	01029893          	slli	a7,t0,0x10
   114d0:	0116e8b3          	or	a7,a3,a7
   114d4:	00e8fe63          	bleu	a4,a7,114f0 <__moddi3+0x3b8>
   114d8:	007888b3          	add	a7,a7,t2
   114dc:	fff30693          	addi	a3,t1,-1
   114e0:	0c78e063          	bltu	a7,t2,115a0 <__moddi3+0x468>
   114e4:	0ae8fe63          	bleu	a4,a7,115a0 <__moddi3+0x468>
   114e8:	ffe30313          	addi	t1,t1,-2
   114ec:	007888b3          	add	a7,a7,t2
   114f0:	01079793          	slli	a5,a5,0x10
	      umul_ppmm (m1, m0, q0, d0);
   114f4:	00010fb7          	lui	t6,0x10
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   114f8:	0067e333          	or	t1,a5,t1
	      umul_ppmm (m1, m0, q0, d0);
   114fc:	ffff8793          	addi	a5,t6,-1 # ffff <_reset+0xfdff>
   11500:	00f376b3          	and	a3,t1,a5
   11504:	01065593          	srli	a1,a2,0x10
   11508:	01035313          	srli	t1,t1,0x10
   1150c:	00f677b3          	and	a5,a2,a5
   11510:	02f68f33          	mul	t5,a3,a5
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11514:	40e88733          	sub	a4,a7,a4
	      umul_ppmm (m1, m0, q0, d0);
   11518:	02f307b3          	mul	a5,t1,a5
   1151c:	010f5293          	srli	t0,t5,0x10
   11520:	02b686b3          	mul	a3,a3,a1
   11524:	00f686b3          	add	a3,a3,a5
   11528:	00d288b3          	add	a7,t0,a3
   1152c:	02b30333          	mul	t1,t1,a1
   11530:	00f8f463          	bleu	a5,a7,11538 <__moddi3+0x400>
   11534:	01f30333          	add	t1,t1,t6
   11538:	000106b7          	lui	a3,0x10
   1153c:	fff68793          	addi	a5,a3,-1 # ffff <_reset+0xfdff>
   11540:	0108d693          	srli	a3,a7,0x10
   11544:	00f8f8b3          	and	a7,a7,a5
   11548:	01089293          	slli	t0,a7,0x10
   1154c:	00668333          	add	t1,a3,t1
   11550:	00ff78b3          	and	a7,t5,a5
   11554:	011288b3          	add	a7,t0,a7

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   11558:	00676a63          	bltu	a4,t1,1156c <__moddi3+0x434>
   1155c:	04670e63          	beq	a4,t1,115b8 <__moddi3+0x480>
   11560:	40670733          	sub	a4,a4,t1
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);
   11564:	00088793          	mv	a5,a7
   11568:	0180006f          	j	11580 <__moddi3+0x448>

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
		{
		  q0--;
		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
   1156c:	40c887b3          	sub	a5,a7,a2
   11570:	40730333          	sub	t1,t1,t2
   11574:	00f8b8b3          	sltu	a7,a7,a5
   11578:	411308b3          	sub	a7,t1,a7
   1157c:	41170733          	sub	a4,a4,a7
	      q1 = 0;

	      /* Remainder in (n1n0 - m1m0) >> bm.  */
	      if (rp != 0)
		{
		  sub_ddmmss (n1, n0, n1, n0, m1, m0);
   11580:	40f507b3          	sub	a5,a0,a5
   11584:	00f53533          	sltu	a0,a0,a5
   11588:	40a70733          	sub	a4,a4,a0
		  rr.s.low = (n1 << b) | (n0 >> bm);
   1158c:	01d71533          	sll	a0,a4,t4
   11590:	01c7d7b3          	srl	a5,a5,t3
		  rr.s.high = n1 >> bm;
		  *rp = rr.ll;
   11594:	00f56533          	or	a0,a0,a5
   11598:	01c755b3          	srl	a1,a4,t3
   1159c:	c89ff06f          	j	11224 <__moddi3+0xec>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   115a0:	00068313          	mv	t1,a3
   115a4:	f4dff06f          	j	114f0 <__moddi3+0x3b8>
   115a8:	00030793          	mv	a5,t1
   115ac:	f09ff06f          	j	114b4 <__moddi3+0x37c>
	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
	      n0 = n0 << bm;
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   115b0:	01170733          	add	a4,a4,a7
   115b4:	c31ff06f          	j	111e4 <__moddi3+0xac>
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   115b8:	fb156ae3          	bltu	a0,a7,1156c <__moddi3+0x434>
   115bc:	00088793          	mv	a5,a7
   115c0:	00000713          	li	a4,0
   115c4:	fbdff06f          	j	11580 <__moddi3+0x448>

000115c8 <atexit>:
int
_DEFUN (atexit,
	(fn),
	_VOID _EXFNPTR(fn, (_VOID)))
{
  return __register_exitproc (__et_atexit, fn, NULL, NULL);
   115c8:	00050593          	mv	a1,a0
   115cc:	00000693          	li	a3,0
   115d0:	00000613          	li	a2,0
   115d4:	00000513          	li	a0,0
   115d8:	2500006f          	j	11828 <__register_exitproc>

000115dc <__libc_fini_array>:
extern void _fini (void);

/* Run all the cleanup routines.  */
void
__libc_fini_array (void)
{
   115dc:	ff010113          	addi	sp,sp,-16
   115e0:	00812423          	sw	s0,8(sp)
   115e4:	00912223          	sw	s1,4(sp)
  size_t count;
  size_t i;
  
  count = __fini_array_end - __fini_array_start;
   115e8:	00014437          	lui	s0,0x14
   115ec:	000144b7          	lui	s1,0x14
   115f0:	0f448493          	addi	s1,s1,244 # 140f4 <__init_array_end>
   115f4:	0f840413          	addi	s0,s0,248 # 140f8 <__fini_array_end>
   115f8:	40940433          	sub	s0,s0,s1
   115fc:	40245413          	srai	s0,s0,0x2
   11600:	00241793          	slli	a5,s0,0x2
   11604:	ffc78793          	addi	a5,a5,-4
extern void _fini (void);

/* Run all the cleanup routines.  */
void
__libc_fini_array (void)
{
   11608:	00112623          	sw	ra,12(sp)
   1160c:	009784b3          	add	s1,a5,s1
  size_t count;
  size_t i;
  
  count = __fini_array_end - __fini_array_start;
  for (i = count; i > 0; i--)
   11610:	00040c63          	beqz	s0,11628 <__libc_fini_array+0x4c>
    __fini_array_start[i-1] ();
   11614:	0004a783          	lw	a5,0(s1)
   11618:	fff40413          	addi	s0,s0,-1
   1161c:	ffc48493          	addi	s1,s1,-4
   11620:	000780e7          	jalr	a5
{
  size_t count;
  size_t i;
  
  count = __fini_array_end - __fini_array_start;
  for (i = count; i > 0; i--)
   11624:	fe0418e3          	bnez	s0,11614 <__libc_fini_array+0x38>
    __fini_array_start[i-1] ();

  _fini ();
}
   11628:	00c12083          	lw	ra,12(sp)
   1162c:	00812403          	lw	s0,8(sp)
   11630:	00412483          	lw	s1,4(sp)
   11634:	01010113          	addi	sp,sp,16
  
  count = __fini_array_end - __fini_array_start;
  for (i = count; i > 0; i--)
    __fini_array_start[i-1] ();

  _fini ();
   11638:	a11fe06f          	j	10048 <_fini>

0001163c <__libc_init_array>:
extern void _init (void);

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
   1163c:	ff010113          	addi	sp,sp,-16
   11640:	00812423          	sw	s0,8(sp)
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
   11644:	000147b7          	lui	a5,0x14
   11648:	00014437          	lui	s0,0x14
extern void _init (void);

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
   1164c:	01212023          	sw	s2,0(sp)
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
   11650:	0ec78793          	addi	a5,a5,236 # 140ec <_etext>
   11654:	0ec40913          	addi	s2,s0,236 # 140ec <_etext>
   11658:	41278933          	sub	s2,a5,s2
   1165c:	40295913          	srai	s2,s2,0x2
extern void _init (void);

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
   11660:	00912223          	sw	s1,4(sp)
   11664:	00112623          	sw	ra,12(sp)
   11668:	0ec40413          	addi	s0,s0,236
   1166c:	00000493          	li	s1,0
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
   11670:	00090c63          	beqz	s2,11688 <__libc_init_array+0x4c>
    __preinit_array_start[i] ();
   11674:	00042783          	lw	a5,0(s0)
{
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
   11678:	00148493          	addi	s1,s1,1
   1167c:	00440413          	addi	s0,s0,4
    __preinit_array_start[i] ();
   11680:	000780e7          	jalr	a5
{
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
   11684:	fe9918e3          	bne	s2,s1,11674 <__libc_init_array+0x38>
    __preinit_array_start[i] ();

  _init ();

  count = __init_array_end - __init_array_start;
   11688:	00014437          	lui	s0,0x14

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
    __preinit_array_start[i] ();

  _init ();
   1168c:	9bdfe0ef          	jal	10048 <_fini>

  count = __init_array_end - __init_array_start;
   11690:	000147b7          	lui	a5,0x14
   11694:	0ec40913          	addi	s2,s0,236 # 140ec <_etext>
   11698:	0f478793          	addi	a5,a5,244 # 140f4 <__init_array_end>
   1169c:	41278933          	sub	s2,a5,s2
   116a0:	40295913          	srai	s2,s2,0x2
   116a4:	0ec40413          	addi	s0,s0,236
  for (i = 0; i < count; i++)
   116a8:	00000493          	li	s1,0
   116ac:	00090c63          	beqz	s2,116c4 <__libc_init_array+0x88>
    __init_array_start[i] ();
   116b0:	00042783          	lw	a5,0(s0)
    __preinit_array_start[i] ();

  _init ();

  count = __init_array_end - __init_array_start;
  for (i = 0; i < count; i++)
   116b4:	00148493          	addi	s1,s1,1
   116b8:	00440413          	addi	s0,s0,4
    __init_array_start[i] ();
   116bc:	000780e7          	jalr	a5
    __preinit_array_start[i] ();

  _init ();

  count = __init_array_end - __init_array_start;
  for (i = 0; i < count; i++)
   116c0:	fe9918e3          	bne	s2,s1,116b0 <__libc_init_array+0x74>
    __init_array_start[i] ();
}
   116c4:	00c12083          	lw	ra,12(sp)
   116c8:	00812403          	lw	s0,8(sp)
   116cc:	00412483          	lw	s1,4(sp)
   116d0:	00012903          	lw	s2,0(sp)
   116d4:	01010113          	addi	sp,sp,16
   116d8:	00008067          	ret

000116dc <_puts_r>:

int
_DEFUN(_puts_r, (ptr, s),
       struct _reent *ptr _AND
       _CONST char * s)
{
   116dc:	fd010113          	addi	sp,sp,-48
   116e0:	02812423          	sw	s0,40(sp)
   116e4:	00050413          	mv	s0,a0
#ifdef _FVWRITE_IN_STREAMIO
  int result;
  size_t c = strlen (s);
   116e8:	00058513          	mv	a0,a1

int
_DEFUN(_puts_r, (ptr, s),
       struct _reent *ptr _AND
       _CONST char * s)
{
   116ec:	02912223          	sw	s1,36(sp)
   116f0:	02112623          	sw	ra,44(sp)
   116f4:	00058493          	mv	s1,a1
#ifdef _FVWRITE_IN_STREAMIO
  int result;
  size_t c = strlen (s);
   116f8:	0a0000ef          	jal	11798 <strlen>
  uio.uio_resid = c + 1;
  uio.uio_iov = &iov[0];
  uio.uio_iovcnt = 2;

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
   116fc:	00842583          	lw	a1,8(s0)
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
  iov[0].iov_len = c;
  iov[1].iov_base = "\n";
   11700:	00014737          	lui	a4,0x14
   11704:	0e470713          	addi	a4,a4,228 # 140e4 <__clz_tab+0x100>
  uio.uio_iovcnt = 2;

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
   11708:	00c59683          	lh	a3,12(a1)
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
  iov[0].iov_len = c;
  iov[1].iov_base = "\n";
   1170c:	00e12c23          	sw	a4,24(sp)
  iov[1].iov_len = 1;
   11710:	00100713          	li	a4,1
   11714:	00e12e23          	sw	a4,28(sp)
  uio.uio_resid = c + 1;
  uio.uio_iov = &iov[0];
   11718:	01010713          	addi	a4,sp,16

  iov[0].iov_base = s;
  iov[0].iov_len = c;
  iov[1].iov_base = "\n";
  iov[1].iov_len = 1;
  uio.uio_resid = c + 1;
   1171c:	00150613          	addi	a2,a0,1
  uio.uio_iov = &iov[0];
   11720:	00e12223          	sw	a4,4(sp)
  uio.uio_iovcnt = 2;

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
   11724:	01269793          	slli	a5,a3,0x12
  iov[0].iov_len = c;
  iov[1].iov_base = "\n";
  iov[1].iov_len = 1;
  uio.uio_resid = c + 1;
  uio.uio_iov = &iov[0];
  uio.uio_iovcnt = 2;
   11728:	00200713          	li	a4,2
  size_t c = strlen (s);
  struct __suio uio;
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
   1172c:	00912823          	sw	s1,16(sp)
  iov[0].iov_len = c;
   11730:	00a12a23          	sw	a0,20(sp)
  iov[1].iov_base = "\n";
  iov[1].iov_len = 1;
  uio.uio_resid = c + 1;
   11734:	00c12623          	sw	a2,12(sp)
  uio.uio_iov = &iov[0];
  uio.uio_iovcnt = 2;
   11738:	00e12423          	sw	a4,8(sp)

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
   1173c:	0207c263          	bltz	a5,11760 <_puts_r+0x84>
  uio.uio_iov = &iov[0];
  uio.uio_iovcnt = 2;

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  _newlib_flockfile_start (fp);
   11740:	0685a783          	lw	a5,104(a1)
  ORIENT (fp, -1);
   11744:	ffffe737          	lui	a4,0xffffe
   11748:	00002637          	lui	a2,0x2
   1174c:	fff70713          	addi	a4,a4,-1 # ffffdfff <_gp+0xfffe803f>
   11750:	00c6e6b3          	or	a3,a3,a2
   11754:	00e7f733          	and	a4,a5,a4
   11758:	00d59623          	sh	a3,12(a1)
   1175c:	06e5a423          	sw	a4,104(a1)
  result = (__sfvwrite_r (ptr, fp, &uio) ? EOF : '\n');
   11760:	00410613          	addi	a2,sp,4
   11764:	00040513          	mv	a0,s0
   11768:	1b4000ef          	jal	1191c <__sfvwrite_r>

err:
  _newlib_flockfile_end (fp);
  return result;
#endif
}
   1176c:	02c12083          	lw	ra,44(sp)

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
  result = (__sfvwrite_r (ptr, fp, &uio) ? EOF : '\n');
   11770:	00a03533          	snez	a0,a0
   11774:	40a00533          	neg	a0,a0

err:
  _newlib_flockfile_end (fp);
  return result;
#endif
}
   11778:	00a56513          	ori	a0,a0,10
   1177c:	02812403          	lw	s0,40(sp)
   11780:	02412483          	lw	s1,36(sp)
   11784:	03010113          	addi	sp,sp,48
   11788:	00008067          	ret

0001178c <puts>:

int
_DEFUN(puts, (s),
       char _CONST * s)
{
  return _puts_r (_REENT, s);
   1178c:	00050593          	mv	a1,a0
   11790:	8101a503          	lw	a0,-2032(gp) # 157d0 <_impure_ptr>
   11794:	f49ff06f          	j	116dc <_puts_r>

00011798 <strlen>:
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  while (*str++)
    ;
  return str - start - 1;
#else
  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
   11798:	00357793          	andi	a5,a0,3
   1179c:	00050593          	mv	a1,a0
   117a0:	04079a63          	bnez	a5,117f4 <strlen+0x5c>
    if (!ch)
      return str - start - 1;
  } while ((uintptr_t)str & (sizeof(long)-1));

  unsigned long* ls = (unsigned long*)str;
  while (!__libc_detect_null(*ls++))
   117a4:	7f7f86b7          	lui	a3,0x7f7f8
   117a8:	f7f68693          	addi	a3,a3,-129 # 7f7f7f7f <_gp+0x7f7e1fbf>
   117ac:	fff00613          	li	a2,-1
   117b0:	00450513          	addi	a0,a0,4
   117b4:	ffc52783          	lw	a5,-4(a0)
   117b8:	00d7f733          	and	a4,a5,a3
   117bc:	00d70733          	add	a4,a4,a3
   117c0:	00d7e7b3          	or	a5,a5,a3
   117c4:	00f767b3          	or	a5,a4,a5
   117c8:	fec784e3          	beq	a5,a2,117b0 <strlen+0x18>

  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
   117cc:	ffc54703          	lbu	a4,-4(a0)
  while (!__libc_detect_null(*ls++))
    ;
  asm volatile ("" : "+r"(ls)); /* prevent "optimization" */

  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);
   117d0:	40b507b3          	sub	a5,a0,a1

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
   117d4:	ffd54683          	lbu	a3,-3(a0)
   117d8:	ffe54603          	lbu	a2,-2(a0)
  if (c0 == 0)            return ret + 0 - sl;
   117dc:	02070e63          	beqz	a4,11818 <strlen+0x80>
  if (c1 == 0)            return ret + 1 - sl;
   117e0:	02068863          	beqz	a3,11810 <strlen+0x78>
  if (c2 == 0)            return ret + 2 - sl;
  if (sl == 4 || c3 == 0) return ret + 3 - sl;
   117e4:	fff78513          	addi	a0,a5,-1
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
  if (c1 == 0)            return ret + 1 - sl;
  if (c2 == 0)            return ret + 2 - sl;
   117e8:	02060c63          	beqz	a2,11820 <strlen+0x88>
  if (c0 == 0)            return ret + 4 - sl;
  if (c1 == 0)            return ret + 5 - sl;
  if (c2 == 0)            return ret + 6 - sl;
                          return ret + 7 - sl;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   117ec:	00008067          	ret
  {
    char ch = *str;
    str++;
    if (!ch)
      return str - start - 1;
  } while ((uintptr_t)str & (sizeof(long)-1));
   117f0:	fa070ae3          	beqz	a4,117a4 <strlen+0xc>
    ;
  return str - start - 1;
#else
  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
  {
    char ch = *str;
   117f4:	00054783          	lbu	a5,0(a0)
    str++;
   117f8:	00150513          	addi	a0,a0,1
    if (!ch)
      return str - start - 1;
  } while ((uintptr_t)str & (sizeof(long)-1));
   117fc:	00357713          	andi	a4,a0,3
#else
  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
  {
    char ch = *str;
    str++;
    if (!ch)
   11800:	fe0798e3          	bnez	a5,117f0 <strlen+0x58>
      return str - start - 1;
   11804:	40b50533          	sub	a0,a0,a1
   11808:	fff50513          	addi	a0,a0,-1
   1180c:	00008067          	ret
  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
  if (c1 == 0)            return ret + 1 - sl;
   11810:	ffd78513          	addi	a0,a5,-3
   11814:	00008067          	ret

  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
   11818:	ffc78513          	addi	a0,a5,-4
   1181c:	00008067          	ret
  if (c1 == 0)            return ret + 1 - sl;
  if (c2 == 0)            return ret + 2 - sl;
   11820:	ffe78513          	addi	a0,a5,-2
  if (c0 == 0)            return ret + 4 - sl;
  if (c1 == 0)            return ret + 5 - sl;
  if (c2 == 0)            return ret + 6 - sl;
                          return ret + 7 - sl;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   11824:	00008067          	ret

00011828 <__register_exitproc>:
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
   11828:	fe010113          	addi	sp,sp,-32
   1182c:	00812c23          	sw	s0,24(sp)

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
   11830:	80c1a403          	lw	s0,-2036(gp) # 157cc <_global_impure_ptr>
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
   11834:	00912a23          	sw	s1,20(sp)
   11838:	00050493          	mv	s1,a0

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
   1183c:	14842503          	lw	a0,328(s0)
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
   11840:	00112e23          	sw	ra,28(sp)
#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
  if (p == NULL)
   11844:	0c050263          	beqz	a0,11908 <__register_exitproc+0xe0>
    _GLOBAL_ATEXIT = p = _GLOBAL_ATEXIT0;
  if (p->_ind >= _ATEXIT_SIZE)
   11848:	00452783          	lw	a5,4(a0)
   1184c:	01f00713          	li	a4,31
   11850:	00178813          	addi	a6,a5,1
   11854:	04f75863          	ble	a5,a4,118a4 <__register_exitproc+0x7c>
#ifndef _ATEXIT_DYNAMIC_ALLOC
      return -1;
#else
      /* Don't dynamically allocate the atexit array if malloc is not
	 available.  */
      if (!malloc)
   11858:	00000793          	li	a5,0
   1185c:	0a078c63          	beqz	a5,11914 <__register_exitproc+0xec>
	return -1;

      p = (struct _atexit *) malloc (sizeof *p);
   11860:	19000513          	li	a0,400
   11864:	00b12623          	sw	a1,12(sp)
   11868:	00c12423          	sw	a2,8(sp)
   1186c:	00d12223          	sw	a3,4(sp)
   11870:	f90ee0ef          	jal	0 <_reset-0x200>
      if (p == NULL)
   11874:	00c12583          	lw	a1,12(sp)
   11878:	00812603          	lw	a2,8(sp)
   1187c:	00412683          	lw	a3,4(sp)
   11880:	08050a63          	beqz	a0,11914 <__register_exitproc+0xec>
	  __lock_release_recursive(__atexit_lock);
#endif
	  return -1;
	}
      p->_ind = 0;
      p->_next = _GLOBAL_ATEXIT;
   11884:	14842783          	lw	a5,328(s0)
      _GLOBAL_ATEXIT = p;
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
      p->_on_exit_args._is_cxa = 0;
   11888:	00100813          	li	a6,1
#ifndef __SINGLE_THREAD__
	  __lock_release_recursive(__atexit_lock);
#endif
	  return -1;
	}
      p->_ind = 0;
   1188c:	00052223          	sw	zero,4(a0)
      p->_next = _GLOBAL_ATEXIT;
   11890:	00f52023          	sw	a5,0(a0)
      _GLOBAL_ATEXIT = p;
   11894:	14a42423          	sw	a0,328(s0)
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
      p->_on_exit_args._is_cxa = 0;
   11898:	00000793          	li	a5,0
	}
      p->_ind = 0;
      p->_next = _GLOBAL_ATEXIT;
      _GLOBAL_ATEXIT = p;
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
   1189c:	18052423          	sw	zero,392(a0)
      p->_on_exit_args._is_cxa = 0;
   118a0:	18052623          	sw	zero,396(a0)
   118a4:	00279713          	slli	a4,a5,0x2
      p->_on_exit_args_ptr = NULL;
#endif
#endif
    }

  if (type != __et_atexit)
   118a8:	02049463          	bnez	s1,118d0 <__register_exitproc+0xa8>
      args->_fntypes |= (1 << p->_ind);
      args->_dso_handle[p->_ind] = d;
      if (type == __et_cxa)
	args->_is_cxa |= (1 << p->_ind);
    }
  p->_fns[p->_ind++] = fn;
   118ac:	00e50733          	add	a4,a0,a4
   118b0:	01052223          	sw	a6,4(a0)
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif
  return 0;
   118b4:	00000513          	li	a0,0
      args->_fntypes |= (1 << p->_ind);
      args->_dso_handle[p->_ind] = d;
      if (type == __et_cxa)
	args->_is_cxa |= (1 << p->_ind);
    }
  p->_fns[p->_ind++] = fn;
   118b8:	00b72423          	sw	a1,8(a4)
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif
  return 0;
}
   118bc:	01c12083          	lw	ra,28(sp)
   118c0:	01812403          	lw	s0,24(sp)
   118c4:	01412483          	lw	s1,20(sp)
   118c8:	02010113          	addi	sp,sp,32
   118cc:	00008067          	ret
   118d0:	00e502b3          	add	t0,a0,a4
	  p->_on_exit_args_ptr = args;
	}
#else
      args = &p->_on_exit_args;
#endif
      args->_fnargs[p->_ind] = arg;
   118d4:	08c2a423          	sw	a2,136(t0)
      args->_fntypes |= (1 << p->_ind);
   118d8:	18852883          	lw	a7,392(a0)
   118dc:	00100613          	li	a2,1
   118e0:	00f617b3          	sll	a5,a2,a5
   118e4:	00f8e633          	or	a2,a7,a5
   118e8:	18c52423          	sw	a2,392(a0)
      args->_dso_handle[p->_ind] = d;
   118ec:	10d2a423          	sw	a3,264(t0)
      if (type == __et_cxa)
   118f0:	00200693          	li	a3,2
   118f4:	fad49ce3          	bne	s1,a3,118ac <__register_exitproc+0x84>
	args->_is_cxa |= (1 << p->_ind);
   118f8:	18c52683          	lw	a3,396(a0)
   118fc:	00f6e7b3          	or	a5,a3,a5
   11900:	18f52623          	sw	a5,396(a0)
   11904:	fa9ff06f          	j	118ac <__register_exitproc+0x84>
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
  if (p == NULL)
    _GLOBAL_ATEXIT = p = _GLOBAL_ATEXIT0;
   11908:	14c40513          	addi	a0,s0,332
   1190c:	14a42423          	sw	a0,328(s0)
   11910:	f39ff06f          	j	11848 <__register_exitproc+0x20>
      return -1;
#else
      /* Don't dynamically allocate the atexit array if malloc is not
	 available.  */
      if (!malloc)
	return -1;
   11914:	fff00513          	li	a0,-1
   11918:	fa5ff06f          	j	118bc <__register_exitproc+0x94>

0001191c <__sfvwrite_r>:
  register struct __siov *iov;
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
   1191c:	00862783          	lw	a5,8(a2) # 2008 <_reset+0x1e08>
   11920:	1a078e63          	beqz	a5,11adc <__sfvwrite_r+0x1c0>
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   11924:	00c5d703          	lhu	a4,12(a1)
int
_DEFUN(__sfvwrite_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       register FILE *fp _AND
       register struct __suio *uio)
{
   11928:	fd010113          	addi	sp,sp,-48
   1192c:	02812423          	sw	s0,40(sp)

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   11930:	00877793          	andi	a5,a4,8
int
_DEFUN(__sfvwrite_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       register FILE *fp _AND
       register struct __suio *uio)
{
   11934:	01412c23          	sw	s4,24(sp)
   11938:	01512a23          	sw	s5,20(sp)
   1193c:	02112623          	sw	ra,44(sp)
   11940:	02912223          	sw	s1,36(sp)
   11944:	03212023          	sw	s2,32(sp)
   11948:	01312e23          	sw	s3,28(sp)
   1194c:	01612823          	sw	s6,16(sp)
   11950:	01712623          	sw	s7,12(sp)
   11954:	01812423          	sw	s8,8(sp)
   11958:	01912223          	sw	s9,4(sp)
   1195c:	01a12023          	sw	s10,0(sp)
   11960:	00058413          	mv	s0,a1
   11964:	00050a93          	mv	s5,a0
   11968:	00060a13          	mv	s4,a2

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   1196c:	0a078463          	beqz	a5,11a14 <__sfvwrite_r+0xf8>
   11970:	0105a783          	lw	a5,16(a1)
   11974:	0a078063          	beqz	a5,11a14 <__sfvwrite_r+0xf8>
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   11978:	00277793          	andi	a5,a4,2

  /* make sure we can write */
  if (cantwrite (ptr, fp))
    return EOF;

  iov = uio->uio_iov;
   1197c:	000a2483          	lw	s1,0(s4)
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   11980:	0a078c63          	beqz	a5,11a38 <__sfvwrite_r+0x11c>
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
   11984:	80000b37          	lui	s6,0x80000
   11988:	00000993          	li	s3,0
   1198c:	00000913          	li	s2,0
   11990:	c00b4b13          	xori	s6,s6,-1024
   11994:	00098613          	mv	a2,s3
   11998:	000a8513          	mv	a0,s5
       * Unbuffered: Split buffer in the largest multiple of BUFSIZ < INT_MAX
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
   1199c:	12090863          	beqz	s2,11acc <__sfvwrite_r+0x1b0>
	  w = fp->_write (ptr, fp->_cookie, p,
   119a0:	00090693          	mv	a3,s2
   119a4:	012b7463          	bleu	s2,s6,119ac <__sfvwrite_r+0x90>
   119a8:	000b0693          	mv	a3,s6
   119ac:	02442783          	lw	a5,36(s0)
   119b0:	01c42583          	lw	a1,28(s0)
   119b4:	000780e7          	jalr	a5
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
	  if (w <= 0)
   119b8:	16a05863          	blez	a0,11b28 <__sfvwrite_r+0x20c>
	    goto err;
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
   119bc:	008a2783          	lw	a5,8(s4)
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
	  if (w <= 0)
	    goto err;
	  p += w;
   119c0:	00a989b3          	add	s3,s3,a0
	  len -= w;
   119c4:	40a90933          	sub	s2,s2,a0
	}
      while ((uio->uio_resid -= w) != 0);
   119c8:	40a78533          	sub	a0,a5,a0
   119cc:	00aa2423          	sw	a0,8(s4)
   119d0:	fc0512e3          	bnez	a0,11994 <__sfvwrite_r+0x78>
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
    return 0;
   119d4:	00000793          	li	a5,0
  return 0;

err:
  fp->_flags |= __SERR;
  return EOF;
}
   119d8:	02c12083          	lw	ra,44(sp)
   119dc:	00078513          	mv	a0,a5
   119e0:	02812403          	lw	s0,40(sp)
   119e4:	02412483          	lw	s1,36(sp)
   119e8:	02012903          	lw	s2,32(sp)
   119ec:	01c12983          	lw	s3,28(sp)
   119f0:	01812a03          	lw	s4,24(sp)
   119f4:	01412a83          	lw	s5,20(sp)
   119f8:	01012b03          	lw	s6,16(sp)
   119fc:	00c12b83          	lw	s7,12(sp)
   11a00:	00812c03          	lw	s8,8(sp)
   11a04:	00412c83          	lw	s9,4(sp)
   11a08:	00012d03          	lw	s10,0(sp)
   11a0c:	03010113          	addi	sp,sp,48
   11a10:	00008067          	ret

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   11a14:	00040593          	mv	a1,s0
   11a18:	000a8513          	mv	a0,s5
   11a1c:	3b4010ef          	jal	12dd0 <__swsetup_r>
    return EOF;
   11a20:	fff00793          	li	a5,-1

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   11a24:	fa051ae3          	bnez	a0,119d8 <__sfvwrite_r+0xbc>
   11a28:	00c45703          	lhu	a4,12(s0)
    return EOF;

  iov = uio->uio_iov;
   11a2c:	000a2483          	lw	s1,0(s4)
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   11a30:	00277793          	andi	a5,a4,2
   11a34:	f40798e3          	bnez	a5,11984 <__sfvwrite_r+0x68>
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
    }
  else if ((fp->_flags & __SLBF) == 0)
   11a38:	00177793          	andi	a5,a4,1
   11a3c:	10079063          	bnez	a5,11b3c <__sfvwrite_r+0x220>
		goto err;
	    }
	  else
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
   11a40:	80000b37          	lui	s6,0x80000
   11a44:	00000b93          	li	s7,0
   11a48:	00000913          	li	s2,0
   11a4c:	fffb4b13          	not	s6,s6
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
   11a50:	06090663          	beqz	s2,11abc <__sfvwrite_r+0x1a0>
	  w = fp->_w;
	  if (fp->_flags & __SSTR)
   11a54:	20077793          	andi	a5,a4,512
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
	  w = fp->_w;
   11a58:	00842983          	lw	s3,8(s0)
	  if (fp->_flags & __SSTR)
   11a5c:	08078663          	beqz	a5,11ae8 <__sfvwrite_r+0x1cc>
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
   11a60:	23396e63          	bltu	s2,s3,11c9c <__sfvwrite_r+0x380>
   11a64:	48077793          	andi	a5,a4,1152
   11a68:	26079463          	bnez	a5,11cd0 <__sfvwrite_r+0x3b4>
   11a6c:	00042503          	lw	a0,0(s0)
   11a70:	00098c13          	mv	s8,s3
		  w = len;
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
	      COPY (w);		/* copy MIN(fp->_w,len), */
   11a74:	000c0613          	mv	a2,s8
   11a78:	000b8593          	mv	a1,s7
   11a7c:	4a5000ef          	jal	12720 <memmove>
	      fp->_w -= w;
   11a80:	00842783          	lw	a5,8(s0)
	      fp->_p += w;
   11a84:	00042603          	lw	a2,0(s0)
   11a88:	00090513          	mv	a0,s2
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
	      COPY (w);		/* copy MIN(fp->_w,len), */
	      fp->_w -= w;
   11a8c:	413789b3          	sub	s3,a5,s3
	      fp->_p += w;
   11a90:	01860633          	add	a2,a2,s8
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
	      COPY (w);		/* copy MIN(fp->_w,len), */
	      fp->_w -= w;
   11a94:	01342423          	sw	s3,8(s0)
	      fp->_p += w;
   11a98:	00c42023          	sw	a2,0(s0)
		goto err;
	    }
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
   11a9c:	008a2783          	lw	a5,8(s4)
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
	      w = fp->_write (ptr, fp->_cookie, p, w);
	      if (w <= 0)
		goto err;
	    }
	  p += w;
   11aa0:	00ab8bb3          	add	s7,s7,a0
	  len -= w;
   11aa4:	40a90933          	sub	s2,s2,a0
	}
      while ((uio->uio_resid -= w) != 0);
   11aa8:	40a789b3          	sub	s3,a5,a0
   11aac:	013a2423          	sw	s3,8(s4)
   11ab0:	f20982e3          	beqz	s3,119d4 <__sfvwrite_r+0xb8>
   11ab4:	00c45703          	lhu	a4,12(s0)
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
   11ab8:	f8091ee3          	bnez	s2,11a54 <__sfvwrite_r+0x138>
   11abc:	0004ab83          	lw	s7,0(s1)
   11ac0:	0044a903          	lw	s2,4(s1)
   11ac4:	00848493          	addi	s1,s1,8
   11ac8:	f89ff06f          	j	11a50 <__sfvwrite_r+0x134>
       * Unbuffered: Split buffer in the largest multiple of BUFSIZ < INT_MAX
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
   11acc:	0004a983          	lw	s3,0(s1)
   11ad0:	0044a903          	lw	s2,4(s1)
   11ad4:	00848493          	addi	s1,s1,8
   11ad8:	ebdff06f          	j	11994 <__sfvwrite_r+0x78>
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
    return 0;
   11adc:	00000793          	li	a5,0
  return 0;

err:
  fp->_flags |= __SERR;
  return EOF;
}
   11ae0:	00078513          	mv	a0,a5
   11ae4:	00008067          	ret
	      COPY (w);		/* copy MIN(fp->_w,len), */
	      fp->_w -= w;
	      fp->_p += w;
	      w = len;		/* but pretend copied all */
	    }
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
   11ae8:	00042503          	lw	a0,0(s0)
   11aec:	01042783          	lw	a5,16(s0)
   11af0:	12a7ea63          	bltu	a5,a0,11c24 <__sfvwrite_r+0x308>
   11af4:	01442783          	lw	a5,20(s0)
   11af8:	12f96663          	bltu	s2,a5,11c24 <__sfvwrite_r+0x308>
		goto err;
	    }
	  else
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
   11afc:	00090693          	mv	a3,s2
   11b00:	012b7463          	bleu	s2,s6,11b08 <__sfvwrite_r+0x1ec>
   11b04:	000b0693          	mv	a3,s6
   11b08:	02f6c6b3          	div	a3,a3,a5
	      w = fp->_write (ptr, fp->_cookie, p, w);
   11b0c:	02442703          	lw	a4,36(s0)
   11b10:	01c42583          	lw	a1,28(s0)
   11b14:	000b8613          	mv	a2,s7
   11b18:	000a8513          	mv	a0,s5
   11b1c:	02f686b3          	mul	a3,a3,a5
   11b20:	000700e7          	jalr	a4
	      if (w <= 0)
   11b24:	f6a04ce3          	bgtz	a0,11a9c <__sfvwrite_r+0x180>
   11b28:	00c41783          	lh	a5,12(s0)
      while ((uio->uio_resid -= w) != 0);
    }
  return 0;

err:
  fp->_flags |= __SERR;
   11b2c:	0407e793          	ori	a5,a5,64
   11b30:	00f41623          	sh	a5,12(s0)
  return EOF;
   11b34:	fff00793          	li	a5,-1
   11b38:	ea1ff06f          	j	119d8 <__sfvwrite_r+0xbc>
   11b3c:	00000993          	li	s3,0
   11b40:	00000c13          	li	s8,0
   11b44:	00000d13          	li	s10,0
   11b48:	00000913          	li	s2,0
       */
      nlknown = 0;
      nldist = 0;
      do
	{
	  GETIOV (nlknown = 0);
   11b4c:	06090c63          	beqz	s2,11bc4 <__sfvwrite_r+0x2a8>
	  if (!nlknown)
   11b50:	140c0e63          	beqz	s8,11cac <__sfvwrite_r+0x390>
	    {
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
	      nlknown = 1;
	    }
	  s = MIN (len, nldist);
   11b54:	00098b93          	mv	s7,s3
   11b58:	01397463          	bleu	s3,s2,11b60 <__sfvwrite_r+0x244>
   11b5c:	00090b93          	mv	s7,s2
	  w = fp->_w + fp->_bf._size;
	  if (fp->_p > fp->_bf._base && s > w)
   11b60:	00042503          	lw	a0,0(s0)
   11b64:	01042783          	lw	a5,16(s0)
	    {
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
	      nlknown = 1;
	    }
	  s = MIN (len, nldist);
   11b68:	000b8b13          	mv	s6,s7
	  w = fp->_w + fp->_bf._size;
   11b6c:	01442683          	lw	a3,20(s0)
	  if (fp->_p > fp->_bf._base && s > w)
   11b70:	00a7f863          	bleu	a0,a5,11b80 <__sfvwrite_r+0x264>
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
	      nlknown = 1;
	    }
	  s = MIN (len, nldist);
	  w = fp->_w + fp->_bf._size;
   11b74:	00842c83          	lw	s9,8(s0)
   11b78:	01968cb3          	add	s9,a3,s9
	  if (fp->_p > fp->_bf._base && s > w)
   11b7c:	057cce63          	blt	s9,s7,11bd8 <__sfvwrite_r+0x2bc>
	      /* fp->_w -= w; */
	      fp->_p += w;
	      if (_fflush_r (ptr, fp))
		goto err;
	    }
	  else if (s >= (w = fp->_bf._size))
   11b80:	0edbca63          	blt	s7,a3,11c74 <__sfvwrite_r+0x358>
	    {
	      w = fp->_write (ptr, fp->_cookie, p, w);
   11b84:	02442783          	lw	a5,36(s0)
   11b88:	01c42583          	lw	a1,28(s0)
   11b8c:	000d0613          	mv	a2,s10
   11b90:	000a8513          	mv	a0,s5
   11b94:	000780e7          	jalr	a5
   11b98:	00050b13          	mv	s6,a0
	      if (w <= 0)
   11b9c:	f8a056e3          	blez	a0,11b28 <__sfvwrite_r+0x20c>
	      w = s;
	      COPY (w);
	      fp->_w -= w;
	      fp->_p += w;
	    }
	  if ((nldist -= w) == 0)
   11ba0:	416989b3          	sub	s3,s3,s6
   11ba4:	06098463          	beqz	s3,11c0c <__sfvwrite_r+0x2f0>
	      nlknown = 0;
	    }
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
   11ba8:	008a2783          	lw	a5,8(s4)
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
		goto err;
	      nlknown = 0;
	    }
	  p += w;
   11bac:	016d0d33          	add	s10,s10,s6
	  len -= w;
   11bb0:	41690933          	sub	s2,s2,s6
	}
      while ((uio->uio_resid -= w) != 0);
   11bb4:	41678b33          	sub	s6,a5,s6
   11bb8:	016a2423          	sw	s6,8(s4)
   11bbc:	e00b0ce3          	beqz	s6,119d4 <__sfvwrite_r+0xb8>
       */
      nlknown = 0;
      nldist = 0;
      do
	{
	  GETIOV (nlknown = 0);
   11bc0:	f80918e3          	bnez	s2,11b50 <__sfvwrite_r+0x234>
   11bc4:	0004ad03          	lw	s10,0(s1)
   11bc8:	0044a903          	lw	s2,4(s1)
   11bcc:	00000c13          	li	s8,0
   11bd0:	00848493          	addi	s1,s1,8
   11bd4:	f79ff06f          	j	11b4c <__sfvwrite_r+0x230>
	    }
	  s = MIN (len, nldist);
	  w = fp->_w + fp->_bf._size;
	  if (fp->_p > fp->_bf._base && s > w)
	    {
	      COPY (w);
   11bd8:	000d0593          	mv	a1,s10
   11bdc:	000c8613          	mv	a2,s9
   11be0:	341000ef          	jal	12720 <memmove>
	      /* fp->_w -= w; */
	      fp->_p += w;
   11be4:	00042783          	lw	a5,0(s0)
	      if (_fflush_r (ptr, fp))
   11be8:	00040593          	mv	a1,s0
   11bec:	000a8513          	mv	a0,s5
	  w = fp->_w + fp->_bf._size;
	  if (fp->_p > fp->_bf._base && s > w)
	    {
	      COPY (w);
	      /* fp->_w -= w; */
	      fp->_p += w;
   11bf0:	019787b3          	add	a5,a5,s9
   11bf4:	00f42023          	sw	a5,0(s0)
	      if (_fflush_r (ptr, fp))
   11bf8:	5bc010ef          	jal	131b4 <_fflush_r>
   11bfc:	f20516e3          	bnez	a0,11b28 <__sfvwrite_r+0x20c>
   11c00:	000c8b13          	mv	s6,s9
	      w = s;
	      COPY (w);
	      fp->_w -= w;
	      fp->_p += w;
	    }
	  if ((nldist -= w) == 0)
   11c04:	416989b3          	sub	s3,s3,s6
   11c08:	fa0990e3          	bnez	s3,11ba8 <__sfvwrite_r+0x28c>
	    {
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
   11c0c:	00040593          	mv	a1,s0
   11c10:	000a8513          	mv	a0,s5
   11c14:	5a0010ef          	jal	131b4 <_fflush_r>
   11c18:	f00518e3          	bnez	a0,11b28 <__sfvwrite_r+0x20c>
		goto err;
	      nlknown = 0;
   11c1c:	00000c13          	li	s8,0
   11c20:	f89ff06f          	j	11ba8 <__sfvwrite_r+0x28c>
	      w = len;		/* but pretend copied all */
	    }
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
   11c24:	01397463          	bleu	s3,s2,11c2c <__sfvwrite_r+0x310>
   11c28:	00090993          	mv	s3,s2
	      COPY (w);
   11c2c:	00098613          	mv	a2,s3
   11c30:	000b8593          	mv	a1,s7
   11c34:	2ed000ef          	jal	12720 <memmove>
	      fp->_w -= w;
   11c38:	00842783          	lw	a5,8(s0)
	      fp->_p += w;
   11c3c:	00042703          	lw	a4,0(s0)
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
	      COPY (w);
	      fp->_w -= w;
   11c40:	413787b3          	sub	a5,a5,s3
	      fp->_p += w;
   11c44:	01370733          	add	a4,a4,s3
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
	      COPY (w);
	      fp->_w -= w;
   11c48:	00f42423          	sw	a5,8(s0)
	      fp->_p += w;
   11c4c:	00e42023          	sw	a4,0(s0)
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
   11c50:	00078663          	beqz	a5,11c5c <__sfvwrite_r+0x340>
   11c54:	00098513          	mv	a0,s3
   11c58:	e45ff06f          	j	11a9c <__sfvwrite_r+0x180>
   11c5c:	00040593          	mv	a1,s0
   11c60:	000a8513          	mv	a0,s5
   11c64:	550010ef          	jal	131b4 <_fflush_r>
   11c68:	ec0510e3          	bnez	a0,11b28 <__sfvwrite_r+0x20c>
   11c6c:	00098513          	mv	a0,s3
   11c70:	e2dff06f          	j	11a9c <__sfvwrite_r+0x180>
		goto err;
	    }
	  else
	    {
	      w = s;
	      COPY (w);
   11c74:	000b8613          	mv	a2,s7
   11c78:	000d0593          	mv	a1,s10
   11c7c:	2a5000ef          	jal	12720 <memmove>
	      fp->_w -= w;
   11c80:	00842703          	lw	a4,8(s0)
	      fp->_p += w;
   11c84:	00042783          	lw	a5,0(s0)
	    }
	  else
	    {
	      w = s;
	      COPY (w);
	      fp->_w -= w;
   11c88:	41770733          	sub	a4,a4,s7
	      fp->_p += w;
   11c8c:	01778bb3          	add	s7,a5,s7
	    }
	  else
	    {
	      w = s;
	      COPY (w);
	      fp->_w -= w;
   11c90:	00e42423          	sw	a4,8(s0)
	      fp->_p += w;
   11c94:	01742023          	sw	s7,0(s0)
   11c98:	f09ff06f          	j	11ba0 <__sfvwrite_r+0x284>
   11c9c:	00042503          	lw	a0,0(s0)
		  fp->_bf._size = newsize;
		  w = len;
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
   11ca0:	00090993          	mv	s3,s2
   11ca4:	00090c13          	mv	s8,s2
   11ca8:	dcdff06f          	j	11a74 <__sfvwrite_r+0x158>
      do
	{
	  GETIOV (nlknown = 0);
	  if (!nlknown)
	    {
	      nl = memchr ((_PTR) p, '\n', len);
   11cac:	00090613          	mv	a2,s2
   11cb0:	00a00593          	li	a1,10
   11cb4:	000d0513          	mv	a0,s10
   11cb8:	075000ef          	jal	1252c <memchr>
	      nldist = nl ? nl + 1 - p : len + 1;
   11cbc:	0c050e63          	beqz	a0,11d98 <__sfvwrite_r+0x47c>
   11cc0:	00150513          	addi	a0,a0,1
   11cc4:	41a509b3          	sub	s3,a0,s10
	      nlknown = 1;
   11cc8:	00100c13          	li	s8,1
   11ccc:	e89ff06f          	j	11b54 <__sfvwrite_r+0x238>
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   11cd0:	01442983          	lw	s3,20(s0)
	  if (fp->_flags & __SSTR)
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
   11cd4:	01042583          	lw	a1,16(s0)
   11cd8:	00042c03          	lw	s8,0(s0)
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   11cdc:	00199793          	slli	a5,s3,0x1
   11ce0:	013789b3          	add	s3,a5,s3
   11ce4:	01f9d793          	srli	a5,s3,0x1f
	  if (fp->_flags & __SSTR)
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
   11ce8:	40bc0c33          	sub	s8,s8,a1
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   11cec:	013789b3          	add	s3,a5,s3
		  if (newsize < curpos + len + 1)
   11cf0:	001c0793          	addi	a5,s8,1
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   11cf4:	4019d993          	srai	s3,s3,0x1
		  if (newsize < curpos + len + 1)
   11cf8:	012787b3          	add	a5,a5,s2
   11cfc:	00098613          	mv	a2,s3
   11d00:	00f9f663          	bleu	a5,s3,11d0c <__sfvwrite_r+0x3f0>
		    newsize = curpos + len + 1;
   11d04:	00078993          	mv	s3,a5
   11d08:	00078613          	mv	a2,a5
		  if (fp->_flags & __SOPT)
   11d0c:	40077713          	andi	a4,a4,1024
   11d10:	04070c63          	beqz	a4,11d68 <__sfvwrite_r+0x44c>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
   11d14:	00060593          	mv	a1,a2
   11d18:	000a8513          	mv	a0,s5
   11d1c:	098000ef          	jal	11db4 <_malloc_r>
   11d20:	00050c93          	mv	s9,a0
		      if (!str)
   11d24:	08050063          	beqz	a0,11da4 <__sfvwrite_r+0x488>
			{
			  ptr->_errno = ENOMEM;
			  goto err;
			}
		      memcpy (str, fp->_bf._base, curpos);
   11d28:	01042583          	lw	a1,16(s0)
   11d2c:	000c0613          	mv	a2,s8
   11d30:	0d1000ef          	jal	12600 <memcpy>
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
   11d34:	00c45783          	lhu	a5,12(s0)
   11d38:	b7f7f793          	andi	a5,a5,-1153
   11d3c:	0807e793          	ori	a5,a5,128
   11d40:	00f41623          	sh	a5,12(s0)
			  ptr->_errno = ENOMEM;
			  goto err;
			}
		    }
		  fp->_bf._base = str;
		  fp->_p = str + curpos;
   11d44:	018c8533          	add	a0,s9,s8
		  fp->_bf._size = newsize;
		  w = len;
		  fp->_w = newsize - curpos;
   11d48:	41898c33          	sub	s8,s3,s8
			  goto err;
			}
		    }
		  fp->_bf._base = str;
		  fp->_p = str + curpos;
		  fp->_bf._size = newsize;
   11d4c:	01342a23          	sw	s3,20(s0)
		  w = len;
		  fp->_w = newsize - curpos;
   11d50:	01842423          	sw	s8,8(s0)
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
			  goto err;
			}
		    }
		  fp->_bf._base = str;
   11d54:	01942823          	sw	s9,16(s0)
		  fp->_p = str + curpos;
   11d58:	00a42023          	sw	a0,0(s0)
		  fp->_bf._size = newsize;
		  w = len;
   11d5c:	00090993          	mv	s3,s2
   11d60:	00090c13          	mv	s8,s2
   11d64:	d11ff06f          	j	11a74 <__sfvwrite_r+0x158>
		      memcpy (str, fp->_bf._base, curpos);
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
		    }
		  else
		    {
		      str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
   11d68:	000a8513          	mv	a0,s5
   11d6c:	2dd000ef          	jal	12848 <_realloc_r>
   11d70:	00050c93          	mv	s9,a0
							 newsize);
		      if (!str)
   11d74:	fc0518e3          	bnez	a0,11d44 <__sfvwrite_r+0x428>
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
   11d78:	01042583          	lw	a1,16(s0)
   11d7c:	000a8513          	mv	a0,s5
   11d80:	125010ef          	jal	136a4 <_free_r>
			  fp->_flags &=  ~__SMBF;
   11d84:	00c41783          	lh	a5,12(s0)
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
   11d88:	00c00713          	li	a4,12
   11d8c:	00eaa023          	sw	a4,0(s5)
		      if (!str)
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
			  fp->_flags &=  ~__SMBF;
   11d90:	f7f7f793          	andi	a5,a5,-129
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
			  goto err;
   11d94:	d99ff06f          	j	11b2c <__sfvwrite_r+0x210>
	{
	  GETIOV (nlknown = 0);
	  if (!nlknown)
	    {
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
   11d98:	00190993          	addi	s3,s2,1
	      nlknown = 1;
   11d9c:	00100c13          	li	s8,1
   11da0:	db5ff06f          	j	11b54 <__sfvwrite_r+0x238>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
		      if (!str)
			{
			  ptr->_errno = ENOMEM;
   11da4:	00c00793          	li	a5,12
   11da8:	00faa023          	sw	a5,0(s5)
   11dac:	00c41783          	lh	a5,12(s0)
			  goto err;
   11db0:	d7dff06f          	j	11b2c <__sfvwrite_r+0x210>

00011db4 <_malloc_r>:
#if __STD_C
Void_t* mALLOc(RARG size_t bytes)
#else
Void_t* mALLOc(RARG bytes) RDECL size_t bytes;
#endif
{
   11db4:	fd010113          	addi	sp,sp,-48
   11db8:	02912223          	sw	s1,36(sp)
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
   11dbc:	01600793          	li	a5,22
   11dc0:	00b58493          	addi	s1,a1,11
#if __STD_C
Void_t* mALLOc(RARG size_t bytes)
#else
Void_t* mALLOc(RARG bytes) RDECL size_t bytes;
#endif
{
   11dc4:	01312e23          	sw	s3,28(sp)
   11dc8:	02112623          	sw	ra,44(sp)
   11dcc:	02812423          	sw	s0,40(sp)
   11dd0:	03212023          	sw	s2,32(sp)
   11dd4:	01412c23          	sw	s4,24(sp)
   11dd8:	01512a23          	sw	s5,20(sp)
   11ddc:	01612823          	sw	s6,16(sp)
   11de0:	01712623          	sw	s7,12(sp)
   11de4:	01812423          	sw	s8,8(sp)
   11de8:	01912223          	sw	s9,4(sp)
   11dec:	00050993          	mv	s3,a0
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
   11df0:	1a97fc63          	bleu	s1,a5,11fa8 <_malloc_r+0x1f4>
   11df4:	ff84f493          	andi	s1,s1,-8

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   11df8:	2404c463          	bltz	s1,12040 <_malloc_r+0x28c>
   11dfc:	24b4e263          	bltu	s1,a1,12040 <_malloc_r+0x28c>
  {
    RERRNO = ENOMEM;
    return 0;
  }

  MALLOC_LOCK;
   11e00:	241000ef          	jal	12840 <__malloc_lock>

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
   11e04:	1f700793          	li	a5,503
   11e08:	7097fa63          	bleu	s1,a5,1251c <_malloc_r+0x768>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   11e0c:	0094d793          	srli	a5,s1,0x9
   11e10:	08000693          	li	a3,128
   11e14:	04000513          	li	a0,64
   11e18:	03f00593          	li	a1,63
   11e1c:	22079a63          	bnez	a5,12050 <_malloc_r+0x29c>
    bin = bin_at(idx);
   11e20:	00015937          	lui	s2,0x15
   11e24:	3b090913          	addi	s2,s2,944 # 153b0 <__malloc_av_>
   11e28:	00269693          	slli	a3,a3,0x2
   11e2c:	00d906b3          	add	a3,s2,a3

    for (victim = last(bin); victim != bin; victim = victim->bk)
   11e30:	0046a403          	lw	s0,4(a3)

  }
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);
   11e34:	ff868693          	addi	a3,a3,-8

    for (victim = last(bin); victim != bin; victim = victim->bk)
   11e38:	22868a63          	beq	a3,s0,1206c <_malloc_r+0x2b8>
    {
      victim_size = chunksize(victim);
   11e3c:	00442783          	lw	a5,4(s0)
      remainder_size = long_sub_size_t(victim_size, nb);
      
      if (remainder_size >= (long)MINSIZE) /* too big */
   11e40:	00f00613          	li	a2,15
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
    {
      victim_size = chunksize(victim);
   11e44:	ffc7f793          	andi	a5,a5,-4
      remainder_size = long_sub_size_t(victim_size, nb);
   11e48:	40978733          	sub	a4,a5,s1
      
      if (remainder_size >= (long)MINSIZE) /* too big */
   11e4c:	02e64063          	blt	a2,a4,11e6c <_malloc_r+0xb8>
      {
        --idx; /* adjust to rescan below after checking last remainder */
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
   11e50:	22075263          	bgez	a4,12074 <_malloc_r+0x2c0>
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
   11e54:	00c42403          	lw	s0,12(s0)
   11e58:	20868a63          	beq	a3,s0,1206c <_malloc_r+0x2b8>
    {
      victim_size = chunksize(victim);
   11e5c:	00442783          	lw	a5,4(s0)
   11e60:	ffc7f793          	andi	a5,a5,-4
      remainder_size = long_sub_size_t(victim_size, nb);
   11e64:	40978733          	sub	a4,a5,s1
      
      if (remainder_size >= (long)MINSIZE) /* too big */
   11e68:	fee654e3          	ble	a4,a2,11e50 <_malloc_r+0x9c>
      {
        --idx; /* adjust to rescan below after checking last remainder */
        break;   
   11e6c:	00058693          	mv	a3,a1

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
   11e70:	01092403          	lw	s0,16(s2)
   11e74:	00890813          	addi	a6,s2,8
   11e78:	4b040263          	beq	s0,a6,1231c <_malloc_r+0x568>
  {
    victim_size = chunksize(victim);
   11e7c:	00442783          	lw	a5,4(s0)
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
   11e80:	00f00613          	li	a2,15

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
  {
    victim_size = chunksize(victim);
   11e84:	ffc7f793          	andi	a5,a5,-4
    remainder_size = long_sub_size_t(victim_size, nb);
   11e88:	40978733          	sub	a4,a5,s1

    if (remainder_size >= (long)MINSIZE) /* re-split */
   11e8c:	44e64a63          	blt	a2,a4,122e0 <_malloc_r+0x52c>
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
      return chunk2mem(victim);
    }

    clear_last_remainder;
   11e90:	01092a23          	sw	a6,20(s2)
   11e94:	01092823          	sw	a6,16(s2)

    if (remainder_size >= 0)  /* exhaust */
   11e98:	20075663          	bgez	a4,120a4 <_malloc_r+0x2f0>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   11e9c:	1ff00713          	li	a4,511
   11ea0:	3cf76e63          	bltu	a4,a5,1227c <_malloc_r+0x4c8>
   11ea4:	0037d793          	srli	a5,a5,0x3
   11ea8:	00178613          	addi	a2,a5,1
   11eac:	00361613          	slli	a2,a2,0x3
   11eb0:	00492703          	lw	a4,4(s2)
   11eb4:	00c90633          	add	a2,s2,a2
   11eb8:	00062503          	lw	a0,0(a2)
   11ebc:	4027d793          	srai	a5,a5,0x2
   11ec0:	00100593          	li	a1,1
   11ec4:	00f597b3          	sll	a5,a1,a5
   11ec8:	00e7e7b3          	or	a5,a5,a4
   11ecc:	ff860713          	addi	a4,a2,-8
   11ed0:	00e42623          	sw	a4,12(s0)
   11ed4:	00a42423          	sw	a0,8(s0)
   11ed8:	00f92223          	sw	a5,4(s2)
   11edc:	00862023          	sw	s0,0(a2)
   11ee0:	00852623          	sw	s0,12(a0)
  /* 
     If there are any possibly nonempty big-enough blocks, 
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks)  
   11ee4:	4026d713          	srai	a4,a3,0x2
   11ee8:	00100613          	li	a2,1
   11eec:	00e61633          	sll	a2,a2,a4
   11ef0:	1cc7ea63          	bltu	a5,a2,120c4 <_malloc_r+0x310>
  {

    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
   11ef4:	00f67733          	and	a4,a2,a5
   11ef8:	02071463          	bnez	a4,11f20 <_malloc_r+0x16c>
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
   11efc:	00161613          	slli	a2,a2,0x1
    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
   11f00:	ffc6f693          	andi	a3,a3,-4
      block <<= 1;
      while ((block & binblocks) == 0)
   11f04:	00f67733          	and	a4,a2,a5
    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
   11f08:	00468693          	addi	a3,a3,4
      block <<= 1;
      while ((block & binblocks) == 0)
   11f0c:	00071a63          	bnez	a4,11f20 <_malloc_r+0x16c>
      {
        idx += BINBLOCKWIDTH;
        block <<= 1;
   11f10:	00161613          	slli	a2,a2,0x1
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
   11f14:	00f67733          	and	a4,a2,a5
      {
        idx += BINBLOCKWIDTH;
   11f18:	00468693          	addi	a3,a3,4
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
   11f1c:	fe070ae3          	beqz	a4,11f10 <_malloc_r+0x15c>
        for (victim = last(bin); victim != bin; victim = victim->bk)
        {
          victim_size = chunksize(victim);
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
   11f20:	00f00513          	li	a0,15
      
    /* For each possibly nonempty block ... */
    for (;;)  
    {
      startidx = idx;          /* (track incomplete blocks) */
      q = bin = bin_at(idx);
   11f24:	00369893          	slli	a7,a3,0x3
   11f28:	012888b3          	add	a7,a7,s2
   11f2c:	00088593          	mv	a1,a7
   11f30:	00068293          	mv	t0,a3
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
   11f34:	00c5a403          	lw	s0,12(a1)
   11f38:	00859a63          	bne	a1,s0,11f4c <_malloc_r+0x198>
   11f3c:	3e80006f          	j	12324 <_malloc_r+0x570>
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
   11f40:	40075463          	bgez	a4,12348 <_malloc_r+0x594>
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
   11f44:	00c42403          	lw	s0,12(s0)
   11f48:	3c858e63          	beq	a1,s0,12324 <_malloc_r+0x570>
        {
          victim_size = chunksize(victim);
   11f4c:	00442783          	lw	a5,4(s0)
   11f50:	ffc7f793          	andi	a5,a5,-4
          remainder_size = long_sub_size_t(victim_size, nb);
   11f54:	40978733          	sub	a4,a5,s1

          if (remainder_size >= (long)MINSIZE) /* split */
   11f58:	fee554e3          	ble	a4,a0,11f40 <_malloc_r+0x18c>
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
   11f5c:	00c42683          	lw	a3,12(s0)
   11f60:	00842603          	lw	a2,8(s0)
          victim_size = chunksize(victim);
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
   11f64:	009407b3          	add	a5,s0,s1
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
            link_last_remainder(remainder);
            set_head(remainder, remainder_size | PREV_INUSE);
   11f68:	00176893          	ori	a7,a4,1
            set_foot(remainder, remainder_size);
   11f6c:	00e785b3          	add	a1,a5,a4
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
   11f70:	0014e493          	ori	s1,s1,1
   11f74:	00942223          	sw	s1,4(s0)
            unlink(victim, bck, fwd);
            link_last_remainder(remainder);
            set_head(remainder, remainder_size | PREV_INUSE);
            set_foot(remainder, remainder_size);
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   11f78:	00098513          	mv	a0,s3

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
   11f7c:	00d62623          	sw	a3,12(a2)
   11f80:	00c6a423          	sw	a2,8(a3)
            link_last_remainder(remainder);
   11f84:	00f92a23          	sw	a5,20(s2)
   11f88:	00f92823          	sw	a5,16(s2)
   11f8c:	0107a623          	sw	a6,12(a5)
   11f90:	0107a423          	sw	a6,8(a5)
            set_head(remainder, remainder_size | PREV_INUSE);
   11f94:	0117a223          	sw	a7,4(a5)
            set_foot(remainder, remainder_size);
   11f98:	00e5a023          	sw	a4,0(a1)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   11f9c:	0a9000ef          	jal	12844 <__malloc_unlock>
            return chunk2mem(victim);
   11fa0:	00840513          	addi	a0,s0,8
   11fa4:	0680006f          	j	1200c <_malloc_r+0x258>
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   11fa8:	01000493          	li	s1,16
   11fac:	08b4ea63          	bltu	s1,a1,12040 <_malloc_r+0x28c>
  {
    RERRNO = ENOMEM;
    return 0;
  }

  MALLOC_LOCK;
   11fb0:	091000ef          	jal	12840 <__malloc_lock>
   11fb4:	00600793          	li	a5,6
   11fb8:	00200693          	li	a3,2
  {
    idx = smallbin_index(nb); 

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
   11fbc:	00015937          	lui	s2,0x15
   11fc0:	3b090913          	addi	s2,s2,944 # 153b0 <__malloc_av_>
   11fc4:	00279793          	slli	a5,a5,0x2
   11fc8:	00f907b3          	add	a5,s2,a5
    victim = last(q);
   11fcc:	0047a403          	lw	s0,4(a5)

#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
   11fd0:	ff878713          	addi	a4,a5,-8
   11fd4:	36e40263          	beq	s0,a4,12338 <_malloc_r+0x584>
      victim = last(q);
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
   11fd8:	00442783          	lw	a5,4(s0)
      unlink(victim, bck, fwd);
   11fdc:	00c42683          	lw	a3,12(s0)
   11fe0:	00842603          	lw	a2,8(s0)
      victim = last(q);
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
   11fe4:	ffc7f793          	andi	a5,a5,-4
      unlink(victim, bck, fwd);
      set_inuse_bit_at_offset(victim, victim_size);
   11fe8:	00f407b3          	add	a5,s0,a5
   11fec:	0047a703          	lw	a4,4(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   11ff0:	00098513          	mv	a0,s3
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
      unlink(victim, bck, fwd);
   11ff4:	00d62623          	sw	a3,12(a2)
      set_inuse_bit_at_offset(victim, victim_size);
   11ff8:	00176713          	ori	a4,a4,1
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
      unlink(victim, bck, fwd);
   11ffc:	00c6a423          	sw	a2,8(a3)
      set_inuse_bit_at_offset(victim, victim_size);
   12000:	00e7a223          	sw	a4,4(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   12004:	041000ef          	jal	12844 <__malloc_unlock>
      return chunk2mem(victim);
   12008:	00840513          	addi	a0,s0,8
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
  return chunk2mem(victim);

#endif /* MALLOC_PROVIDED */
}
   1200c:	02c12083          	lw	ra,44(sp)
   12010:	02812403          	lw	s0,40(sp)
   12014:	02412483          	lw	s1,36(sp)
   12018:	02012903          	lw	s2,32(sp)
   1201c:	01c12983          	lw	s3,28(sp)
   12020:	01812a03          	lw	s4,24(sp)
   12024:	01412a83          	lw	s5,20(sp)
   12028:	01012b03          	lw	s6,16(sp)
   1202c:	00c12b83          	lw	s7,12(sp)
   12030:	00812c03          	lw	s8,8(sp)
   12034:	00412c83          	lw	s9,4(sp)
   12038:	03010113          	addi	sp,sp,48
   1203c:	00008067          	ret
  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
  {
    RERRNO = ENOMEM;
   12040:	00c00793          	li	a5,12
   12044:	00f9a023          	sw	a5,0(s3)
    return 0;
   12048:	00000513          	li	a0,0
   1204c:	fc1ff06f          	j	1200c <_malloc_r+0x258>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   12050:	00400713          	li	a4,4
   12054:	20f76263          	bltu	a4,a5,12258 <_malloc_r+0x4a4>
   12058:	0064d593          	srli	a1,s1,0x6
   1205c:	03958513          	addi	a0,a1,57
   12060:	00151693          	slli	a3,a0,0x1
   12064:	03858593          	addi	a1,a1,56
   12068:	db9ff06f          	j	11e20 <_malloc_r+0x6c>
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
   1206c:	00050693          	mv	a3,a0
   12070:	e01ff06f          	j	11e70 <_malloc_r+0xbc>
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
        set_inuse_bit_at_offset(victim, victim_size);
   12074:	00f407b3          	add	a5,s0,a5
   12078:	0047a703          	lw	a4,4(a5)
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
   1207c:	00c42683          	lw	a3,12(s0)
   12080:	00842603          	lw	a2,8(s0)
        set_inuse_bit_at_offset(victim, victim_size);
   12084:	00176713          	ori	a4,a4,1
        check_malloced_chunk(victim, nb);
	MALLOC_UNLOCK;
   12088:	00098513          	mv	a0,s3
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
   1208c:	00d62623          	sw	a3,12(a2)
   12090:	00c6a423          	sw	a2,8(a3)
        set_inuse_bit_at_offset(victim, victim_size);
   12094:	00e7a223          	sw	a4,4(a5)
        check_malloced_chunk(victim, nb);
	MALLOC_UNLOCK;
   12098:	7ac000ef          	jal	12844 <__malloc_unlock>
        return chunk2mem(victim);
   1209c:	00840513          	addi	a0,s0,8
   120a0:	f6dff06f          	j	1200c <_malloc_r+0x258>

    clear_last_remainder;

    if (remainder_size >= 0)  /* exhaust */
    {
      set_inuse_bit_at_offset(victim, victim_size);
   120a4:	00f407b3          	add	a5,s0,a5
   120a8:	0047a703          	lw	a4,4(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   120ac:	00098513          	mv	a0,s3

    clear_last_remainder;

    if (remainder_size >= 0)  /* exhaust */
    {
      set_inuse_bit_at_offset(victim, victim_size);
   120b0:	00176713          	ori	a4,a4,1
   120b4:	00e7a223          	sw	a4,4(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   120b8:	78c000ef          	jal	12844 <__malloc_unlock>
      return chunk2mem(victim);
   120bc:	00840513          	addi	a0,s0,8
   120c0:	f4dff06f          	j	1200c <_malloc_r+0x258>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  remainder_size = long_sub_size_t(chunksize(top), nb);
   120c4:	00892403          	lw	s0,8(s2)
   120c8:	00442a03          	lw	s4,4(s0)
   120cc:	ffca7a93          	andi	s5,s4,-4
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   120d0:	009ae863          	bltu	s5,s1,120e0 <_malloc_r+0x32c>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  remainder_size = long_sub_size_t(chunksize(top), nb);
   120d4:	409a87b3          	sub	a5,s5,s1
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   120d8:	00f00713          	li	a4,15
   120dc:	14f74a63          	blt	a4,a5,12230 <_malloc_r+0x47c>
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
   120e0:	82c1a703          	lw	a4,-2004(gp) # 157ec <__malloc_top_pad>

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
   120e4:	8141a683          	lw	a3,-2028(gp) # 157d4 <__malloc_sbrk_base>
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
   120e8:	00e48733          	add	a4,s1,a4

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
   120ec:	fff00793          	li	a5,-1
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
   120f0:	01540b33          	add	s6,s0,s5

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
   120f4:	01070a13          	addi	s4,a4,16

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
   120f8:	00f68c63          	beq	a3,a5,12110 <_malloc_r+0x35c>
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
   120fc:	000016b7          	lui	a3,0x1
   12100:	00f68a13          	addi	s4,a3,15 # 100f <_reset+0xe0f>
   12104:	014706b3          	add	a3,a4,s4
   12108:	fffff737          	lui	a4,0xfffff
   1210c:	00e6fa33          	and	s4,a3,a4

  brk = (char*)(MORECORE (sbrk_size));
   12110:	000a0513          	mv	a0,s4
   12114:	abcfe0ef          	jal	103d0 <sbrk>

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
   12118:	fff00793          	li	a5,-1
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));
   1211c:	00050b93          	mv	s7,a0

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
   12120:	28f50063          	beq	a0,a5,123a0 <_malloc_r+0x5ec>
   12124:	27656c63          	bltu	a0,s6,1239c <_malloc_r+0x5e8>
      (brk < old_end && old_top != initial_top))
    return;

  sbrked_mem += sbrk_size;
   12128:	85018c13          	addi	s8,gp,-1968 # 15810 <__malloc_current_mallinfo>
   1212c:	000c2703          	lw	a4,0(s8)
   12130:	00ea0733          	add	a4,s4,a4
   12134:	00ec2023          	sw	a4,0(s8)

  if (brk == old_end /* can just add bytes to current top, unless
   12138:	357b0c63          	beq	s6,s7,12490 <_malloc_r+0x6dc>
    top_size = sbrk_size + old_top_size;
    set_head(top, top_size | PREV_INUSE);
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
   1213c:	8141a683          	lw	a3,-2028(gp) # 157d4 <__malloc_sbrk_base>
   12140:	fff00793          	li	a5,-1
   12144:	36f68a63          	beq	a3,a5,124b8 <_malloc_r+0x704>
      sbrk_base = brk;
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
   12148:	416b8b33          	sub	s6,s7,s6
   1214c:	00eb0733          	add	a4,s6,a4
   12150:	00ec2023          	sw	a4,0(s8)

    /* Guarantee alignment of first new chunk made from this space */
    front_misalign = (POINTER_UINT)chunk2mem(brk) & MALLOC_ALIGN_MASK;
   12154:	007bf713          	andi	a4,s7,7
    if (front_misalign > 0) 
   12158:	000017b7          	lui	a5,0x1
   1215c:	00070a63          	beqz	a4,12170 <_malloc_r+0x3bc>
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
      brk += correction;
   12160:	40eb8bb3          	sub	s7,s7,a4
   12164:	00878793          	addi	a5,a5,8 # 1008 <_reset+0xe08>
   12168:	008b8b93          	addi	s7,s7,8
   1216c:	40e787b3          	sub	a5,a5,a4
    }
    else
      correction = 0;

    /* Guarantee the next brk will be at a page boundary */
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));
   12170:	00001737          	lui	a4,0x1
   12174:	fff70713          	addi	a4,a4,-1 # fff <_reset+0xdff>
   12178:	014b8a33          	add	s4,s7,s4
   1217c:	00ea7a33          	and	s4,s4,a4
   12180:	41478a33          	sub	s4,a5,s4

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
   12184:	000a0513          	mv	a0,s4
   12188:	a48fe0ef          	jal	103d0 <sbrk>
    if (new_brk == (char*)(MORECORE_FAILURE))
   1218c:	fff00793          	li	a5,-1
   12190:	30f50e63          	beq	a0,a5,124ac <_malloc_r+0x6f8>
   12194:	417507b3          	sub	a5,a0,s7
   12198:	014787b3          	add	a5,a5,s4
   1219c:	0017e793          	ori	a5,a5,1
	correction = 0;
	correction_failed = 1;
	new_brk = brk;
      }

    sbrked_mem += correction;
   121a0:	000c2703          	lw	a4,0(s8)

    top = (mchunkptr)brk;
   121a4:	01792423          	sw	s7,8(s2)
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);
   121a8:	00fba223          	sw	a5,4(s7)
	correction = 0;
	correction_failed = 1;
	new_brk = brk;
      }

    sbrked_mem += correction;
   121ac:	00ea0733          	add	a4,s4,a4
   121b0:	00ec2023          	sw	a4,0(s8)

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);

    if (old_top != initial_top)
   121b4:	03240c63          	beq	s0,s2,121ec <_malloc_r+0x438>

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE) 
   121b8:	00f00613          	li	a2,15
   121bc:	29567263          	bleu	s5,a2,12440 <_malloc_r+0x68c>
        return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
   121c0:	00442683          	lw	a3,4(s0)
        set_head(top, PREV_INUSE); /* will force null return from malloc */
        return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
   121c4:	ff4a8793          	addi	a5,s5,-12
   121c8:	ff87f793          	andi	a5,a5,-8
      set_head_size(old_top, old_top_size);
   121cc:	0016f693          	andi	a3,a3,1
      chunk_at_offset(old_top, old_top_size          )->size =
   121d0:	00f405b3          	add	a1,s0,a5
   121d4:	00500513          	li	a0,5
        return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
   121d8:	00f6e6b3          	or	a3,a3,a5
   121dc:	00d42223          	sw	a3,4(s0)
      chunk_at_offset(old_top, old_top_size          )->size =
   121e0:	00a5a223          	sw	a0,4(a1)
        SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
   121e4:	00a5a423          	sw	a0,8(a1)
        SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE) 
   121e8:	2cf66c63          	bltu	a2,a5,124c0 <_malloc_r+0x70c>
        fREe(RCALL chunk2mem(old_top));
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem) 
   121ec:	8281a683          	lw	a3,-2008(gp) # 157e8 <__malloc_max_sbrked_mem>
   121f0:	00e6f463          	bleu	a4,a3,121f8 <_malloc_r+0x444>
    max_sbrked_mem = sbrked_mem;
   121f4:	82e1a423          	sw	a4,-2008(gp) # 157e8 <__malloc_max_sbrked_mem>
#if HAVE_MMAP
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem) 
    max_total_mem = mmapped_mem + sbrked_mem;
#else
  if ((unsigned long)(sbrked_mem) > (unsigned long)max_total_mem) 
   121f8:	8241a683          	lw	a3,-2012(gp) # 157e4 <__malloc_max_total_mem>
   121fc:	00892403          	lw	s0,8(s2)
   12200:	00e6f463          	bleu	a4,a3,12208 <_malloc_r+0x454>
    max_total_mem = sbrked_mem;
   12204:	82e1a223          	sw	a4,-2012(gp) # 157e4 <__malloc_max_total_mem>
   12208:	00442703          	lw	a4,4(s0)
   1220c:	ffc77713          	andi	a4,a4,-4
    }
#endif

    /* Try to extend */
    malloc_extend_top(RCALL nb);
    remainder_size = long_sub_size_t(chunksize(top), nb);
   12210:	409707b3          	sub	a5,a4,s1
    if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   12214:	00976663          	bltu	a4,s1,12220 <_malloc_r+0x46c>
   12218:	00f00713          	li	a4,15
   1221c:	00f74a63          	blt	a4,a5,12230 <_malloc_r+0x47c>
    {
      MALLOC_UNLOCK;
   12220:	00098513          	mv	a0,s3
   12224:	620000ef          	jal	12844 <__malloc_unlock>
      return 0; /* propagate failure */
   12228:	00000513          	li	a0,0
   1222c:	de1ff06f          	j	1200c <_malloc_r+0x258>
    }
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
   12230:	00940733          	add	a4,s0,s1
  set_head(top, remainder_size | PREV_INUSE);
   12234:	0017e793          	ori	a5,a5,1
      return 0; /* propagate failure */
    }
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
   12238:	0014e493          	ori	s1,s1,1
   1223c:	00942223          	sw	s1,4(s0)
  top = chunk_at_offset(victim, nb);
  set_head(top, remainder_size | PREV_INUSE);
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
   12240:	00098513          	mv	a0,s3
    }
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
   12244:	00e92423          	sw	a4,8(s2)
  set_head(top, remainder_size | PREV_INUSE);
   12248:	00f72223          	sw	a5,4(a4)
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
   1224c:	5f8000ef          	jal	12844 <__malloc_unlock>
  return chunk2mem(victim);
   12250:	00840513          	addi	a0,s0,8
   12254:	db9ff06f          	j	1200c <_malloc_r+0x258>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   12258:	01400713          	li	a4,20
   1225c:	10f77e63          	bleu	a5,a4,12378 <_malloc_r+0x5c4>
   12260:	05400713          	li	a4,84
   12264:	1af76063          	bltu	a4,a5,12404 <_malloc_r+0x650>
   12268:	00c4d593          	srli	a1,s1,0xc
   1226c:	06f58513          	addi	a0,a1,111
   12270:	00151693          	slli	a3,a0,0x1
   12274:	06e58593          	addi	a1,a1,110
   12278:	ba9ff06f          	j	11e20 <_malloc_r+0x6c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   1227c:	0097d713          	srli	a4,a5,0x9
   12280:	00400613          	li	a2,4
   12284:	10e67263          	bleu	a4,a2,12388 <_malloc_r+0x5d4>
   12288:	01400613          	li	a2,20
   1228c:	1ee66463          	bltu	a2,a4,12474 <_malloc_r+0x6c0>
   12290:	05c70593          	addi	a1,a4,92
   12294:	05b70613          	addi	a2,a4,91
   12298:	00159593          	slli	a1,a1,0x1
   1229c:	00259593          	slli	a1,a1,0x2
   122a0:	00b905b3          	add	a1,s2,a1
   122a4:	0005a703          	lw	a4,0(a1)
   122a8:	ff858593          	addi	a1,a1,-8
   122ac:	16e58a63          	beq	a1,a4,12420 <_malloc_r+0x66c>
   122b0:	00472603          	lw	a2,4(a4)
   122b4:	ffc67613          	andi	a2,a2,-4
   122b8:	00c7f663          	bleu	a2,a5,122c4 <_malloc_r+0x510>
   122bc:	00872703          	lw	a4,8(a4)
   122c0:	fee598e3          	bne	a1,a4,122b0 <_malloc_r+0x4fc>
   122c4:	00c72583          	lw	a1,12(a4)
   122c8:	00492783          	lw	a5,4(s2)
   122cc:	00b42623          	sw	a1,12(s0)
   122d0:	00e42423          	sw	a4,8(s0)
   122d4:	0085a423          	sw	s0,8(a1)
   122d8:	00872623          	sw	s0,12(a4)
   122dc:	c09ff06f          	j	11ee4 <_malloc_r+0x130>
    victim_size = chunksize(victim);
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
   122e0:	009407b3          	add	a5,s0,s1
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
   122e4:	00176613          	ori	a2,a4,1
      set_foot(remainder, remainder_size);
   122e8:	00e786b3          	add	a3,a5,a4
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
   122ec:	0014e493          	ori	s1,s1,1
   122f0:	00942223          	sw	s1,4(s0)
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
      set_foot(remainder, remainder_size);
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   122f4:	00098513          	mv	a0,s3

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
   122f8:	00f92a23          	sw	a5,20(s2)
   122fc:	00f92823          	sw	a5,16(s2)
   12300:	0107a623          	sw	a6,12(a5)
   12304:	0107a423          	sw	a6,8(a5)
      set_head(remainder, remainder_size | PREV_INUSE);
   12308:	00c7a223          	sw	a2,4(a5)
      set_foot(remainder, remainder_size);
   1230c:	00e6a023          	sw	a4,0(a3)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   12310:	534000ef          	jal	12844 <__malloc_unlock>
      return chunk2mem(victim);
   12314:	00840513          	addi	a0,s0,8
   12318:	cf5ff06f          	j	1200c <_malloc_r+0x258>
   1231c:	00492783          	lw	a5,4(s2)
   12320:	bc5ff06f          	j	11ee4 <_malloc_r+0x130>
         {
           bin = next_bin(bin);
           ++idx;
         }
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
   12324:	00128293          	addi	t0,t0,1
   12328:	0032f793          	andi	a5,t0,3
            return chunk2mem(victim);
          }

        }

       bin = next_bin(bin);
   1232c:	00858593          	addi	a1,a1,8
         {
           bin = next_bin(bin);
           ++idx;
         }
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
   12330:	c00792e3          	bnez	a5,11f34 <_malloc_r+0x180>
   12334:	0880006f          	j	123bc <_malloc_r+0x608>
#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
    {
      q = next_bin(q);
      victim = last(q);
   12338:	00c7a403          	lw	s0,12(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
      return chunk2mem(victim);
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
   1233c:	00268693          	addi	a3,a3,2
    {
      q = next_bin(q);
      victim = last(q);
    }
#endif
    if (victim != q)
   12340:	b28788e3          	beq	a5,s0,11e70 <_malloc_r+0xbc>
   12344:	c95ff06f          	j	11fd8 <_malloc_r+0x224>
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
   12348:	00f407b3          	add	a5,s0,a5
   1234c:	0047a703          	lw	a4,4(a5)
            unlink(victim, bck, fwd);
   12350:	00c42683          	lw	a3,12(s0)
   12354:	00842603          	lw	a2,8(s0)
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
   12358:	00176713          	ori	a4,a4,1
   1235c:	00e7a223          	sw	a4,4(a5)
            unlink(victim, bck, fwd);
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   12360:	00098513          	mv	a0,s3
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
            unlink(victim, bck, fwd);
   12364:	00d62623          	sw	a3,12(a2)
   12368:	00c6a423          	sw	a2,8(a3)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   1236c:	4d8000ef          	jal	12844 <__malloc_unlock>
            return chunk2mem(victim);
   12370:	00840513          	addi	a0,s0,8
   12374:	c99ff06f          	j	1200c <_malloc_r+0x258>
   12378:	05c78513          	addi	a0,a5,92
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   1237c:	05b78593          	addi	a1,a5,91
   12380:	00151693          	slli	a3,a0,0x1
   12384:	a9dff06f          	j	11e20 <_malloc_r+0x6c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   12388:	0067d613          	srli	a2,a5,0x6
   1238c:	03960593          	addi	a1,a2,57
   12390:	00159593          	slli	a1,a1,0x1
   12394:	03860613          	addi	a2,a2,56
   12398:	f05ff06f          	j	1229c <_malloc_r+0x4e8>

  brk = (char*)(MORECORE (sbrk_size));

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
      (brk < old_end && old_top != initial_top))
   1239c:	d92406e3          	beq	s0,s2,12128 <_malloc_r+0x374>
   123a0:	00892403          	lw	s0,8(s2)
   123a4:	00442703          	lw	a4,4(s0)
   123a8:	ffc77713          	andi	a4,a4,-4
   123ac:	e65ff06f          	j	12210 <_malloc_r+0x45c>
          binblocks &= ~block;
          break;
        }
        --startidx;
       q = prev_bin(q);
      } while (first(q) == q);
   123b0:	0088a783          	lw	a5,8(a7)
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
        {
          binblocks &= ~block;
          break;
        }
        --startidx;
   123b4:	fff68693          	addi	a3,a3,-1
       q = prev_bin(q);
      } while (first(q) == q);
   123b8:	14f89e63          	bne	a7,a5,12514 <_malloc_r+0x760>

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
   123bc:	0036f793          	andi	a5,a3,3
        {
          binblocks &= ~block;
          break;
        }
        --startidx;
       q = prev_bin(q);
   123c0:	ff888893          	addi	a7,a7,-8

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
   123c4:	fe0796e3          	bnez	a5,123b0 <_malloc_r+0x5fc>
        {
          binblocks &= ~block;
   123c8:	00492783          	lw	a5,4(s2)
   123cc:	fff64713          	not	a4,a2
   123d0:	00f777b3          	and	a5,a4,a5
   123d4:	00f92223          	sw	a5,4(s2)
       q = prev_bin(q);
      } while (first(q) == q);

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
   123d8:	00161613          	slli	a2,a2,0x1
   123dc:	cec7e4e3          	bltu	a5,a2,120c4 <_malloc_r+0x310>
   123e0:	ce0602e3          	beqz	a2,120c4 <_malloc_r+0x310>
      {
        while ((block & binblocks) == 0)
   123e4:	00f67733          	and	a4,a2,a5
   123e8:	00028693          	mv	a3,t0
   123ec:	b2071ce3          	bnez	a4,11f24 <_malloc_r+0x170>
        {
          idx += BINBLOCKWIDTH;
          block <<= 1;
   123f0:	00161613          	slli	a2,a2,0x1

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
   123f4:	00f67733          	and	a4,a2,a5
        {
          idx += BINBLOCKWIDTH;
   123f8:	00468693          	addi	a3,a3,4

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
   123fc:	fe070ae3          	beqz	a4,123f0 <_malloc_r+0x63c>
   12400:	b25ff06f          	j	11f24 <_malloc_r+0x170>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   12404:	15400713          	li	a4,340
   12408:	04f76263          	bltu	a4,a5,1244c <_malloc_r+0x698>
   1240c:	00f4d593          	srli	a1,s1,0xf
   12410:	07858513          	addi	a0,a1,120
   12414:	00151693          	slli	a3,a0,0x1
   12418:	07758593          	addi	a1,a1,119
   1241c:	a05ff06f          	j	11e20 <_malloc_r+0x6c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   12420:	00492703          	lw	a4,4(s2)
   12424:	40265613          	srai	a2,a2,0x2
   12428:	00100793          	li	a5,1
   1242c:	00c797b3          	sll	a5,a5,a2
   12430:	00e7e7b3          	or	a5,a5,a4
   12434:	00f92223          	sw	a5,4(s2)
   12438:	00058713          	mv	a4,a1
   1243c:	e91ff06f          	j	122cc <_malloc_r+0x518>
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE) 
      {
        set_head(top, PREV_INUSE); /* will force null return from malloc */
   12440:	00100793          	li	a5,1
   12444:	00fba223          	sw	a5,4(s7)
   12448:	dd9ff06f          	j	12220 <_malloc_r+0x46c>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   1244c:	55400713          	li	a4,1364
   12450:	0fe00693          	li	a3,254
   12454:	07f00513          	li	a0,127
   12458:	07e00593          	li	a1,126
   1245c:	9cf762e3          	bltu	a4,a5,11e20 <_malloc_r+0x6c>
   12460:	0124d593          	srli	a1,s1,0x12
   12464:	07d58513          	addi	a0,a1,125
   12468:	00151693          	slli	a3,a0,0x1
   1246c:	07c58593          	addi	a1,a1,124
   12470:	9b1ff06f          	j	11e20 <_malloc_r+0x6c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   12474:	05400613          	li	a2,84
   12478:	04e66e63          	bltu	a2,a4,124d4 <_malloc_r+0x720>
   1247c:	00c7d613          	srli	a2,a5,0xc
   12480:	06f60593          	addi	a1,a2,111
   12484:	00159593          	slli	a1,a1,0x1
   12488:	06e60613          	addi	a2,a2,110
   1248c:	e11ff06f          	j	1229c <_malloc_r+0x4e8>

  sbrked_mem += sbrk_size;

  if (brk == old_end /* can just add bytes to current top, unless
			previous correction failed */
      && ((POINTER_UINT)old_end & (pagesz - 1)) == 0)
   12490:	014b1793          	slli	a5,s6,0x14
   12494:	ca0794e3          	bnez	a5,1213c <_malloc_r+0x388>
  {
    top_size = sbrk_size + old_top_size;
    set_head(top, top_size | PREV_INUSE);
   12498:	00892783          	lw	a5,8(s2)
   1249c:	014a8a33          	add	s4,s5,s4
   124a0:	001a6a13          	ori	s4,s4,1
   124a4:	0147a223          	sw	s4,4(a5)
   124a8:	d45ff06f          	j	121ec <_malloc_r+0x438>
    /* Guarantee the next brk will be at a page boundary */
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE))
   124ac:	00100793          	li	a5,1
      {
	correction = 0;
   124b0:	00000a13          	li	s4,0
   124b4:	cedff06f          	j	121a0 <_malloc_r+0x3ec>
    set_head(top, top_size | PREV_INUSE);
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
      sbrk_base = brk;
   124b8:	8171aa23          	sw	s7,-2028(gp) # 157d4 <__malloc_sbrk_base>
   124bc:	c99ff06f          	j	12154 <_malloc_r+0x3a0>
        SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
        SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE) 
        fREe(RCALL chunk2mem(old_top));
   124c0:	00840593          	addi	a1,s0,8
   124c4:	00098513          	mv	a0,s3
   124c8:	1dc010ef          	jal	136a4 <_free_r>
   124cc:	000c2703          	lw	a4,0(s8)
   124d0:	d1dff06f          	j	121ec <_malloc_r+0x438>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   124d4:	15400613          	li	a2,340
   124d8:	00e66c63          	bltu	a2,a4,124f0 <_malloc_r+0x73c>
   124dc:	00f7d613          	srli	a2,a5,0xf
   124e0:	07860593          	addi	a1,a2,120
   124e4:	00159593          	slli	a1,a1,0x1
   124e8:	07760613          	addi	a2,a2,119
   124ec:	db1ff06f          	j	1229c <_malloc_r+0x4e8>
   124f0:	55400513          	li	a0,1364
   124f4:	0fe00593          	li	a1,254
   124f8:	07e00613          	li	a2,126
   124fc:	dae560e3          	bltu	a0,a4,1229c <_malloc_r+0x4e8>
   12500:	0127d613          	srli	a2,a5,0x12
   12504:	07d60593          	addi	a1,a2,125
   12508:	00159593          	slli	a1,a1,0x1
   1250c:	07c60613          	addi	a2,a2,124
   12510:	d8dff06f          	j	1229c <_malloc_r+0x4e8>
   12514:	00492783          	lw	a5,4(s2)
   12518:	ec1ff06f          	j	123d8 <_malloc_r+0x624>
   1251c:	0034d693          	srli	a3,s1,0x3
   12520:	00168793          	addi	a5,a3,1
   12524:	00179793          	slli	a5,a5,0x1
   12528:	a95ff06f          	j	11fbc <_malloc_r+0x208>

0001252c <memchr>:
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   1252c:	00357793          	andi	a5,a0,3
	_CONST _PTR src_void _AND
	int c _AND
	size_t length)
{
  _CONST unsigned char *src = (_CONST unsigned char *) src_void;
  unsigned char d = c;
   12530:	0ff5f693          	andi	a3,a1,255
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   12534:	0c078063          	beqz	a5,125f4 <memchr+0xc8>
    {
      if (!length--)
   12538:	fff60793          	addi	a5,a2,-1
   1253c:	06060063          	beqz	a2,1259c <memchr+0x70>
        return NULL;
      if (*src == d)
   12540:	00054703          	lbu	a4,0(a0)
   12544:	00d71c63          	bne	a4,a3,1255c <memchr+0x30>
   12548:	0b40006f          	j	125fc <memchr+0xd0>
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
    {
      if (!length--)
   1254c:	04078863          	beqz	a5,1259c <memchr+0x70>
        return NULL;
      if (*src == d)
   12550:	00054703          	lbu	a4,0(a0)
   12554:	fff78793          	addi	a5,a5,-1
   12558:	04d70463          	beq	a4,a3,125a0 <memchr+0x74>
        return (void *) src;
      src++;
   1255c:	00150513          	addi	a0,a0,1
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   12560:	00357713          	andi	a4,a0,3
   12564:	fe0714e3          	bnez	a4,1254c <memchr+0x20>
      if (*src == d)
        return (void *) src;
      src++;
    }

  if (!TOO_SMALL (length))
   12568:	00300813          	li	a6,3
   1256c:	02f86c63          	bltu	a6,a5,125a4 <memchr+0x78>
      src = (unsigned char *) asrc;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
   12570:	02078663          	beqz	a5,1259c <memchr+0x70>
    {
      if (*src == d)
   12574:	00054703          	lbu	a4,0(a0)
   12578:	02d70463          	beq	a4,a3,125a0 <memchr+0x74>
   1257c:	00150713          	addi	a4,a0,1
   12580:	00f507b3          	add	a5,a0,a5
   12584:	0100006f          	j	12594 <memchr+0x68>
   12588:	00170713          	addi	a4,a4,1
   1258c:	fff74603          	lbu	a2,-1(a4)
   12590:	00d60863          	beq	a2,a3,125a0 <memchr+0x74>
        return (void *) src;
      src++;
   12594:	00070513          	mv	a0,a4
      src = (unsigned char *) asrc;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
   12598:	fee798e3          	bne	a5,a4,12588 <memchr+0x5c>
  unsigned int i;

  while (UNALIGNED (src))
    {
      if (!length--)
        return NULL;
   1259c:	00000513          	li	a0,0
        return (void *) src;
      src++;
    }

  return NULL;
}
   125a0:	00008067          	ret
   125a4:	0ff5f593          	andi	a1,a1,255
         contain the search character, which is detected by XORing
         the word-sized segment with a word-sized block of the search
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
      mask = d << 8 | d;
   125a8:	00859713          	slli	a4,a1,0x8
   125ac:	00b765b3          	or	a1,a4,a1
      mask = mask << 16 | mask;
   125b0:	01059713          	slli	a4,a1,0x10
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
        {
          if (DETECTCHAR (*asrc, mask))
   125b4:	feff02b7          	lui	t0,0xfeff0
   125b8:	808088b7          	lui	a7,0x80808
         the word-sized segment with a word-sized block of the search
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
      mask = d << 8 | d;
      mask = mask << 16 | mask;
   125bc:	00e5e5b3          	or	a1,a1,a4
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
        {
          if (DETECTCHAR (*asrc, mask))
   125c0:	eff28293          	addi	t0,t0,-257 # fefefeff <_gp+0xfefd9f3f>
   125c4:	08088893          	addi	a7,a7,128 # 80808080 <_gp+0x807f20c0>
   125c8:	00052703          	lw	a4,0(a0)
   125cc:	00e5c733          	xor	a4,a1,a4
   125d0:	00570633          	add	a2,a4,t0
   125d4:	fff74713          	not	a4,a4
   125d8:	00e67733          	and	a4,a2,a4
   125dc:	01177733          	and	a4,a4,a7
   125e0:	f8071ae3          	bnez	a4,12574 <memchr+0x48>
            break;
          length -= LBLOCKSIZE;
   125e4:	ffc78793          	addi	a5,a5,-4
          asrc++;
   125e8:	00450513          	addi	a0,a0,4
      mask = d << 8 | d;
      mask = mask << 16 | mask;
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
   125ec:	fcf86ee3          	bltu	a6,a5,125c8 <memchr+0x9c>
   125f0:	f81ff06f          	j	12570 <memchr+0x44>
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   125f4:	00060793          	mv	a5,a2
   125f8:	f71ff06f          	j	12568 <memchr+0x3c>
   125fc:	00008067          	ret

00012600 <memcpy>:

  char* a = (char*)aa;
  const char* b = (const char*)bb;
  char* end = a+n;
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
   12600:	00a5c7b3          	xor	a5,a1,a0
   12604:	0037f793          	andi	a5,a5,3
    *(a-1) = tt; \
  }

  char* a = (char*)aa;
  const char* b = (const char*)bb;
  char* end = a+n;
   12608:	00c508b3          	add	a7,a0,a2
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
   1260c:	0e079263          	bnez	a5,126f0 <memcpy+0xf0>
   12610:	00300793          	li	a5,3
   12614:	0ec7fe63          	bleu	a2,a5,12710 <memcpy+0x110>
      while (a < end)
        BODY(a, b, char);
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
   12618:	00357793          	andi	a5,a0,3
   1261c:	04079a63          	bnez	a5,12670 <memcpy+0x70>
    while ((uintptr_t)a & msk)
      BODY(a, b, char);

  long* la = (long*)a;
  const long* lb = (const long*)b;
  long* lend = (long*)((uintptr_t)end & ~msk);
   12620:	ffc8f813          	andi	a6,a7,-4

  if (__builtin_expect(la < lend-8, 0))
   12624:	fe080793          	addi	a5,a6,-32
   12628:	00050713          	mv	a4,a0
   1262c:	06f56663          	bltu	a0,a5,12698 <memcpy+0x98>
      *la++ = b7;
      *la++ = b8;
    }
  }

  while (la < lend)
   12630:	00058693          	mv	a3,a1
   12634:	00070793          	mv	a5,a4
   12638:	03077863          	bleu	a6,a4,12668 <memcpy+0x68>
    BODY(la, lb, long);
   1263c:	0006a603          	lw	a2,0(a3)
   12640:	00478793          	addi	a5,a5,4
   12644:	00468693          	addi	a3,a3,4
   12648:	fec7ae23          	sw	a2,-4(a5)
      *la++ = b7;
      *la++ = b8;
    }
  }

  while (la < lend)
   1264c:	ff07e8e3          	bltu	a5,a6,1263c <memcpy+0x3c>
   12650:	fff74793          	not	a5,a4
   12654:	01078833          	add	a6,a5,a6
   12658:	ffc87813          	andi	a6,a6,-4
   1265c:	00480813          	addi	a6,a6,4
   12660:	01070733          	add	a4,a4,a6
   12664:	010585b3          	add	a1,a1,a6
    BODY(la, lb, long);

  a = (char*)la;
  b = (const char*)lb;
  if (__builtin_expect(a < end, 0))
   12668:	09176863          	bltu	a4,a7,126f8 <memcpy+0xf8>
    goto small;
  return aa;
}
   1266c:	00008067          	ret
   12670:	00050713          	mv	a4,a0
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
    while ((uintptr_t)a & msk)
      BODY(a, b, char);
   12674:	0005c683          	lbu	a3,0(a1)
   12678:	00170713          	addi	a4,a4,1
        BODY(a, b, char);
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
    while ((uintptr_t)a & msk)
   1267c:	00377793          	andi	a5,a4,3
      BODY(a, b, char);
   12680:	00158593          	addi	a1,a1,1
   12684:	fed70fa3          	sb	a3,-1(a4)
        BODY(a, b, char);
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
    while ((uintptr_t)a & msk)
   12688:	fe0796e3          	bnez	a5,12674 <memcpy+0x74>
      BODY(a, b, char);

  long* la = (long*)a;
  const long* lb = (const long*)b;
  long* lend = (long*)((uintptr_t)end & ~msk);
   1268c:	ffc8f813          	andi	a6,a7,-4

  if (__builtin_expect(la < lend-8, 0))
   12690:	fe080793          	addi	a5,a6,-32
   12694:	f8f77ee3          	bleu	a5,a4,12630 <memcpy+0x30>
  {
    while (la < lend-8)
    {
      long b0 = *lb++;
   12698:	0005af83          	lw	t6,0(a1)
      long b1 = *lb++;
   1269c:	0045af03          	lw	t5,4(a1)
      long b2 = *lb++;
   126a0:	0085ae83          	lw	t4,8(a1)
      long b3 = *lb++;
   126a4:	00c5ae03          	lw	t3,12(a1)
      long b4 = *lb++;
   126a8:	0105a383          	lw	t2,16(a1)
      long b5 = *lb++;
   126ac:	0145a303          	lw	t1,20(a1)
      long b6 = *lb++;
   126b0:	0185a283          	lw	t0,24(a1)
      long b7 = *lb++;
   126b4:	01c5a603          	lw	a2,28(a1)
   126b8:	02458593          	addi	a1,a1,36
   126bc:	02470713          	addi	a4,a4,36
      long b8 = *lb++;
   126c0:	ffc5a683          	lw	a3,-4(a1)
      *la++ = b0;
   126c4:	fdf72e23          	sw	t6,-36(a4)
      *la++ = b1;
   126c8:	ffe72023          	sw	t5,-32(a4)
      *la++ = b2;
   126cc:	ffd72223          	sw	t4,-28(a4)
      *la++ = b3;
   126d0:	ffc72423          	sw	t3,-24(a4)
      *la++ = b4;
   126d4:	fe772623          	sw	t2,-20(a4)
      *la++ = b5;
   126d8:	fe672823          	sw	t1,-16(a4)
      *la++ = b6;
   126dc:	fe572a23          	sw	t0,-12(a4)
      *la++ = b7;
   126e0:	fec72c23          	sw	a2,-8(a4)
      *la++ = b8;
   126e4:	fed72e23          	sw	a3,-4(a4)
  const long* lb = (const long*)b;
  long* lend = (long*)((uintptr_t)end & ~msk);

  if (__builtin_expect(la < lend-8, 0))
  {
    while (la < lend-8)
   126e8:	faf768e3          	bltu	a4,a5,12698 <memcpy+0x98>
   126ec:	f45ff06f          	j	12630 <memcpy+0x30>
  char* end = a+n;
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
  {
small:
    if (__builtin_expect(a < end, 1))
   126f0:	00050713          	mv	a4,a0
   126f4:	03157463          	bleu	a7,a0,1271c <memcpy+0x11c>
      while (a < end)
        BODY(a, b, char);
   126f8:	0005c783          	lbu	a5,0(a1)
   126fc:	00170713          	addi	a4,a4,1
   12700:	00158593          	addi	a1,a1,1
   12704:	fef70fa3          	sb	a5,-1(a4)
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
  {
small:
    if (__builtin_expect(a < end, 1))
      while (a < end)
   12708:	ff1768e3          	bltu	a4,a7,126f8 <memcpy+0xf8>
   1270c:	00008067          	ret
   12710:	00050713          	mv	a4,a0
  char* end = a+n;
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
  {
small:
    if (__builtin_expect(a < end, 1))
   12714:	ff1562e3          	bltu	a0,a7,126f8 <memcpy+0xf8>
   12718:	f55ff06f          	j	1266c <memcpy+0x6c>
   1271c:	00008067          	ret

00012720 <memmove>:
  char *dst = dst_void;
  _CONST char *src = src_void;
  long *aligned_dst;
  _CONST long *aligned_src;

  if (src < dst && dst < src + length)
   12720:	02a5f863          	bleu	a0,a1,12750 <memmove+0x30>
   12724:	00c58733          	add	a4,a1,a2
   12728:	02e57463          	bleu	a4,a0,12750 <memmove+0x30>
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
      dst += length;
   1272c:	00c507b3          	add	a5,a0,a2
   12730:	40c785b3          	sub	a1,a5,a2
      while (length--)
   12734:	0e060263          	beqz	a2,12818 <memmove+0xf8>
	{
	  *--dst = *--src;
   12738:	fff70713          	addi	a4,a4,-1
   1273c:	00074683          	lbu	a3,0(a4)
   12740:	fff78793          	addi	a5,a5,-1
   12744:	00d78023          	sb	a3,0(a5)
  if (src < dst && dst < src + length)
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
      dst += length;
      while (length--)
   12748:	fef598e3          	bne	a1,a5,12738 <memmove+0x18>
   1274c:	00008067          	ret
  else
    {
      /* Use optimizing algorithm for a non-destructive copy to closely 
         match memcpy. If the size is small or either SRC or DST is unaligned,
         then punt into the byte copy loop.  This should be rare.  */
      if (!TOO_SMALL(length) && !UNALIGNED (src, dst))
   12750:	00f00893          	li	a7,15
   12754:	0cc8f463          	bleu	a2,a7,1281c <memmove+0xfc>
   12758:	00a5e7b3          	or	a5,a1,a0
   1275c:	0037f793          	andi	a5,a5,3
   12760:	0c079463          	bnez	a5,12828 <memmove+0x108>
   12764:	00058713          	mv	a4,a1
   12768:	00050793          	mv	a5,a0
   1276c:	00060693          	mv	a3,a2
          aligned_src = (long*)src;

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
            {
              *aligned_dst++ = *aligned_src++;
   12770:	00072803          	lw	a6,0(a4)
   12774:	01078793          	addi	a5,a5,16
   12778:	01070713          	addi	a4,a4,16
   1277c:	ff07a823          	sw	a6,-16(a5)
              *aligned_dst++ = *aligned_src++;
   12780:	ff472803          	lw	a6,-12(a4)
              *aligned_dst++ = *aligned_src++;
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
   12784:	ff068693          	addi	a3,a3,-16

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
            {
              *aligned_dst++ = *aligned_src++;
              *aligned_dst++ = *aligned_src++;
   12788:	ff07aa23          	sw	a6,-12(a5)
              *aligned_dst++ = *aligned_src++;
   1278c:	ff872803          	lw	a6,-8(a4)
   12790:	ff07ac23          	sw	a6,-8(a5)
              *aligned_dst++ = *aligned_src++;
   12794:	ffc72803          	lw	a6,-4(a4)
   12798:	ff07ae23          	sw	a6,-4(a5)
        {
          aligned_dst = (long*)dst;
          aligned_src = (long*)src;

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
   1279c:	fcd8eae3          	bltu	a7,a3,12770 <memmove+0x50>
   127a0:	ff060713          	addi	a4,a2,-16
   127a4:	ff077713          	andi	a4,a4,-16
   127a8:	01070713          	addi	a4,a4,16
   127ac:	00f67313          	andi	t1,a2,15
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   127b0:	00300293          	li	t0,3
   127b4:	00e507b3          	add	a5,a0,a4
   127b8:	00e585b3          	add	a1,a1,a4
   127bc:	0662fc63          	bleu	t1,t0,12834 <memmove+0x114>
   127c0:	00058813          	mv	a6,a1
   127c4:	00078693          	mv	a3,a5
   127c8:	00030713          	mv	a4,t1
            {
              *aligned_dst++ = *aligned_src++;
   127cc:	00480813          	addi	a6,a6,4
   127d0:	ffc82883          	lw	a7,-4(a6)
   127d4:	00468693          	addi	a3,a3,4
              length -= LITTLEBLOCKSIZE;
   127d8:	ffc70713          	addi	a4,a4,-4
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
            {
              *aligned_dst++ = *aligned_src++;
   127dc:	ff16ae23          	sw	a7,-4(a3)
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   127e0:	fee2e6e3          	bltu	t0,a4,127cc <memmove+0xac>
   127e4:	ffc30713          	addi	a4,t1,-4
   127e8:	ffc77713          	andi	a4,a4,-4
   127ec:	00470713          	addi	a4,a4,4
   127f0:	00367613          	andi	a2,a2,3
   127f4:	00e787b3          	add	a5,a5,a4
   127f8:	00e585b3          	add	a1,a1,a4
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   127fc:	02060a63          	beqz	a2,12830 <memmove+0x110>
   12800:	00c78633          	add	a2,a5,a2
        {
          *dst++ = *src++;
   12804:	00158593          	addi	a1,a1,1
   12808:	fff5c703          	lbu	a4,-1(a1)
   1280c:	00178793          	addi	a5,a5,1
   12810:	fee78fa3          	sb	a4,-1(a5)
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   12814:	fec798e3          	bne	a5,a2,12804 <memmove+0xe4>
        }
    }

  return dst_void;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   12818:	00008067          	ret
   1281c:	00050793          	mv	a5,a0
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   12820:	fe0610e3          	bnez	a2,12800 <memmove+0xe0>
   12824:	00c0006f          	j	12830 <memmove+0x110>
   12828:	00050793          	mv	a5,a0
   1282c:	fd5ff06f          	j	12800 <memmove+0xe0>
   12830:	00008067          	ret
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   12834:	00030613          	mv	a2,t1
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   12838:	fc0614e3          	bnez	a2,12800 <memmove+0xe0>
   1283c:	ff5ff06f          	j	12830 <memmove+0x110>

00012840 <__malloc_lock>:
   12840:	00008067          	ret

00012844 <__malloc_unlock>:
}

void
__malloc_unlock (ptr)
     struct _reent *ptr;
{
   12844:	00008067          	ret

00012848 <_realloc_r>:
#if __STD_C
Void_t* rEALLOc(RARG Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(RARG oldmem, bytes) RDECL Void_t* oldmem; size_t bytes;
#endif
{
   12848:	fd010113          	addi	sp,sp,-48
   1284c:	01312e23          	sw	s3,28(sp)
   12850:	02112623          	sw	ra,44(sp)
   12854:	02812423          	sw	s0,40(sp)
   12858:	02912223          	sw	s1,36(sp)
   1285c:	03212023          	sw	s2,32(sp)
   12860:	01412c23          	sw	s4,24(sp)
   12864:	01512a23          	sw	s5,20(sp)
   12868:	01612823          	sw	s6,16(sp)
   1286c:	01712623          	sw	s7,12(sp)
   12870:	01812423          	sw	s8,8(sp)
   12874:	01912223          	sw	s9,4(sp)
   12878:	00060993          	mv	s3,a2
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
   1287c:	1c058863          	beqz	a1,12a4c <_realloc_r+0x204>
   12880:	00058a13          	mv	s4,a1
   12884:	00050493          	mv	s1,a0

  MALLOC_LOCK;
   12888:	fb9ff0ef          	jal	12840 <__malloc_lock>

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
   1288c:	ffca2783          	lw	a5,-4(s4)


  nb = request2size(bytes);
   12890:	00b98713          	addi	a4,s3,11
   12894:	01600693          	li	a3,22
  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);

  MALLOC_LOCK;

  newp    = oldp    = mem2chunk(oldmem);
   12898:	ff8a0b13          	addi	s6,s4,-8
  newsize = oldsize = chunksize(oldp);
   1289c:	ffc7fa93          	andi	s5,a5,-4


  nb = request2size(bytes);
   128a0:	0ce6f263          	bleu	a4,a3,12964 <_realloc_r+0x11c>
   128a4:	ff877913          	andi	s2,a4,-8

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   128a8:	00090713          	mv	a4,s2
   128ac:	14094c63          	bltz	s2,12a04 <_realloc_r+0x1bc>
   128b0:	15396a63          	bltu	s2,s3,12a04 <_realloc_r+0x1bc>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
   128b4:	0aeade63          	ble	a4,s5,12970 <_realloc_r+0x128>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next)) 
   128b8:	00015c37          	lui	s8,0x15
   128bc:	3b0c0c13          	addi	s8,s8,944 # 153b0 <__malloc_av_>
   128c0:	008c2683          	lw	a3,8(s8)
  if ((long)(oldsize) < (long)(nb))  
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
   128c4:	015b0533          	add	a0,s6,s5
    if (next == top || !inuse(next)) 
   128c8:	30d50263          	beq	a0,a3,12bcc <_realloc_r+0x384>
   128cc:	00452683          	lw	a3,4(a0)
   128d0:	ffe6f613          	andi	a2,a3,-2
   128d4:	00c50633          	add	a2,a0,a2
   128d8:	00462603          	lw	a2,4(a2)
   128dc:	00167613          	andi	a2,a2,1
   128e0:	0e060e63          	beqz	a2,129dc <_realloc_r+0x194>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   128e4:	0017f793          	andi	a5,a5,1
   128e8:	26078463          	beqz	a5,12b50 <_realloc_r+0x308>
      }
    }

    /* Must allocate */

    newmem = mALLOc (RCALL bytes);
   128ec:	00098593          	mv	a1,s3
   128f0:	00048513          	mv	a0,s1
   128f4:	cc0ff0ef          	jal	11db4 <_malloc_r>
   128f8:	00050413          	mv	s0,a0

    if (newmem == 0)  /* propagate failure */
   128fc:	4a050463          	beqz	a0,12da4 <_realloc_r+0x55c>
    }

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
   12900:	ffca2783          	lw	a5,-4(s4)
   12904:	ff850693          	addi	a3,a0,-8
   12908:	ffe7f713          	andi	a4,a5,-2
   1290c:	00eb0733          	add	a4,s6,a4
   12910:	42e68463          	beq	a3,a4,12d38 <_realloc_r+0x4f0>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12914:	ffca8613          	addi	a2,s5,-4
   12918:	02400793          	li	a5,36
   1291c:	3cc7ea63          	bltu	a5,a2,12cf0 <_realloc_r+0x4a8>
   12920:	01300713          	li	a4,19
   12924:	36c76a63          	bltu	a4,a2,12c98 <_realloc_r+0x450>
   12928:	00050793          	mv	a5,a0
   1292c:	000a0713          	mv	a4,s4
   12930:	00072683          	lw	a3,0(a4)
   12934:	00d7a023          	sw	a3,0(a5)
   12938:	00472683          	lw	a3,4(a4)
   1293c:	00d7a223          	sw	a3,4(a5)
   12940:	00872703          	lw	a4,8(a4)
   12944:	00e7a423          	sw	a4,8(a5)
    fREe(RCALL oldmem);
   12948:	000a0593          	mv	a1,s4
   1294c:	00048513          	mv	a0,s1
   12950:	555000ef          	jal	136a4 <_free_r>
    MALLOC_UNLOCK;
   12954:	00048513          	mv	a0,s1
   12958:	eedff0ef          	jal	12844 <__malloc_unlock>
    return newmem;
   1295c:	00040513          	mv	a0,s0
   12960:	0480006f          	j	129a8 <_realloc_r+0x160>


  nb = request2size(bytes);

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   12964:	01000713          	li	a4,16

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);


  nb = request2size(bytes);
   12968:	00070913          	mv	s2,a4
   1296c:	f45ff06f          	j	128b0 <_realloc_r+0x68>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
   12970:	000a0993          	mv	s3,s4
  }


 split:  /* split off extra room in old or expanded chunk */

  remainder_size = long_sub_size_t(newsize, nb);
   12974:	412a86b3          	sub	a3,s5,s2

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
   12978:	00f00713          	li	a4,15
   1297c:	08d76c63          	bltu	a4,a3,12a14 <_realloc_r+0x1cc>
    set_inuse_bit_at_offset(remainder, remainder_size);
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
  }
  else
  {
    set_head_size(newp, newsize);
   12980:	0017f793          	andi	a5,a5,1
   12984:	0157e7b3          	or	a5,a5,s5
   12988:	00fb2223          	sw	a5,4(s6) # 80000004 <_gp+0x7ffea044>
    set_inuse_bit_at_offset(newp, newsize);
   1298c:	015b0633          	add	a2,s6,s5
   12990:	00462783          	lw	a5,4(a2)
   12994:	0017e793          	ori	a5,a5,1
   12998:	00f62223          	sw	a5,4(a2)
  }

  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
   1299c:	00048513          	mv	a0,s1
   129a0:	ea5ff0ef          	jal	12844 <__malloc_unlock>
  return chunk2mem(newp);
   129a4:	00098513          	mv	a0,s3

#endif /* MALLOC_PROVIDED */
}
   129a8:	02c12083          	lw	ra,44(sp)
   129ac:	02812403          	lw	s0,40(sp)
   129b0:	02412483          	lw	s1,36(sp)
   129b4:	02012903          	lw	s2,32(sp)
   129b8:	01c12983          	lw	s3,28(sp)
   129bc:	01812a03          	lw	s4,24(sp)
   129c0:	01412a83          	lw	s5,20(sp)
   129c4:	01012b03          	lw	s6,16(sp)
   129c8:	00c12b83          	lw	s7,12(sp)
   129cc:	00812c03          	lw	s8,8(sp)
   129d0:	00412c83          	lw	s9,4(sp)
   129d4:	03010113          	addi	sp,sp,48
   129d8:	00008067          	ret
          return chunk2mem(oldp);
        }
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
   129dc:	ffc6f693          	andi	a3,a3,-4
   129e0:	015686b3          	add	a3,a3,s5
   129e4:	0ae6c063          	blt	a3,a4,12a84 <_realloc_r+0x23c>
      { 
        unlink(next, bck, fwd);
   129e8:	00c52703          	lw	a4,12(a0)
   129ec:	00852603          	lw	a2,8(a0)
        newsize  += nextsize;
        goto split;
   129f0:	000a0993          	mv	s3,s4

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
      { 
        unlink(next, bck, fwd);
        newsize  += nextsize;
   129f4:	00068a93          	mv	s5,a3
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
      { 
        unlink(next, bck, fwd);
   129f8:	00e62623          	sw	a4,12(a2)
   129fc:	00c72423          	sw	a2,8(a4)
        newsize  += nextsize;
        goto split;
   12a00:	f75ff06f          	j	12974 <_realloc_r+0x12c>
  nb = request2size(bytes);

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
  {
    RERRNO = ENOMEM;
   12a04:	00c00793          	li	a5,12
   12a08:	00f4a023          	sw	a5,0(s1)
    return 0;
   12a0c:	00000513          	li	a0,0
   12a10:	f99ff06f          	j	129a8 <_realloc_r+0x160>
  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
   12a14:	0017f713          	andi	a4,a5,1

  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
   12a18:	012b05b3          	add	a1,s6,s2
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
   12a1c:	0016e793          	ori	a5,a3,1
  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
   12a20:	01276733          	or	a4,a4,s2
   12a24:	00eb2223          	sw	a4,4(s6)
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
   12a28:	00d586b3          	add	a3,a1,a3

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
   12a2c:	00f5a223          	sw	a5,4(a1)
    set_inuse_bit_at_offset(remainder, remainder_size);
   12a30:	0046a783          	lw	a5,4(a3)
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
   12a34:	00858593          	addi	a1,a1,8
   12a38:	00048513          	mv	a0,s1
  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
   12a3c:	0017e793          	ori	a5,a5,1
   12a40:	00f6a223          	sw	a5,4(a3)
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
   12a44:	461000ef          	jal	136a4 <_free_r>
   12a48:	f55ff06f          	j	1299c <_realloc_r+0x154>
  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
  return chunk2mem(newp);

#endif /* MALLOC_PROVIDED */
}
   12a4c:	02c12083          	lw	ra,44(sp)
   12a50:	02812403          	lw	s0,40(sp)
   12a54:	02412483          	lw	s1,36(sp)
   12a58:	02012903          	lw	s2,32(sp)
   12a5c:	01c12983          	lw	s3,28(sp)
   12a60:	01812a03          	lw	s4,24(sp)
   12a64:	01412a83          	lw	s5,20(sp)
   12a68:	01012b03          	lw	s6,16(sp)
   12a6c:	00c12b83          	lw	s7,12(sp)
   12a70:	00812c03          	lw	s8,8(sp)
   12a74:	00412c83          	lw	s9,4(sp)
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
   12a78:	00060593          	mv	a1,a2
  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
  return chunk2mem(newp);

#endif /* MALLOC_PROVIDED */
}
   12a7c:	03010113          	addi	sp,sp,48
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
   12a80:	b34ff06f          	j	11db4 <_malloc_r>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   12a84:	0017f793          	andi	a5,a5,1
   12a88:	e60792e3          	bnez	a5,128ec <_realloc_r+0xa4>
    {
      prev = prev_chunk(oldp);
   12a8c:	ff8a2b83          	lw	s7,-8(s4)
   12a90:	417b0bb3          	sub	s7,s6,s7
      prevsize = chunksize(prev);
   12a94:	004ba783          	lw	a5,4(s7)
   12a98:	ffc7f793          	andi	a5,a5,-4
            return newmem;
          }
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
   12a9c:	00f68433          	add	s0,a3,a5
   12aa0:	0ce44063          	blt	s0,a4,12b60 <_realloc_r+0x318>
        {
          unlink(next, bck, fwd);
   12aa4:	00c52783          	lw	a5,12(a0)
   12aa8:	00852703          	lw	a4,8(a0)
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12aac:	ffca8613          	addi	a2,s5,-4
        {
          unlink(next, bck, fwd);
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
   12ab0:	008b8993          	addi	s3,s7,8
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
        {
          unlink(next, bck, fwd);
   12ab4:	00f72623          	sw	a5,12(a4)
   12ab8:	00e7a423          	sw	a4,8(a5)
          unlink(prev, bck, fwd);
   12abc:	008ba703          	lw	a4,8(s7)
   12ac0:	00cba783          	lw	a5,12(s7)
   12ac4:	00f72623          	sw	a5,12(a4)
   12ac8:	00e7a423          	sw	a4,8(a5)
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12acc:	02400793          	li	a5,36
   12ad0:	22c7e663          	bltu	a5,a2,12cfc <_realloc_r+0x4b4>
   12ad4:	01300713          	li	a4,19
   12ad8:	00098793          	mv	a5,s3
   12adc:	04c77663          	bleu	a2,a4,12b28 <_realloc_r+0x2e0>
   12ae0:	000a2783          	lw	a5,0(s4)
   12ae4:	00fba423          	sw	a5,8(s7)
   12ae8:	004a2783          	lw	a5,4(s4)
   12aec:	00fba623          	sw	a5,12(s7)
   12af0:	01b00793          	li	a5,27
   12af4:	24c7fc63          	bleu	a2,a5,12d4c <_realloc_r+0x504>
   12af8:	008a2783          	lw	a5,8(s4)
   12afc:	00fba823          	sw	a5,16(s7)
   12b00:	00ca2783          	lw	a5,12(s4)
   12b04:	00fbaa23          	sw	a5,20(s7)
   12b08:	02400793          	li	a5,36
   12b0c:	0af61a63          	bne	a2,a5,12bc0 <_realloc_r+0x378>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12b10:	010a2703          	lw	a4,16(s4)
   12b14:	020b8793          	addi	a5,s7,32
   12b18:	018a0a13          	addi	s4,s4,24
   12b1c:	00ebac23          	sw	a4,24(s7)
   12b20:	ffca2703          	lw	a4,-4(s4)
   12b24:	00ebae23          	sw	a4,28(s7)
   12b28:	000a2703          	lw	a4,0(s4)
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
   12b2c:	00040a93          	mv	s5,s0
   12b30:	000b8b13          	mv	s6,s7
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12b34:	00e7a023          	sw	a4,0(a5)
   12b38:	004a2703          	lw	a4,4(s4)
   12b3c:	00e7a223          	sw	a4,4(a5)
   12b40:	008a2703          	lw	a4,8(s4)
   12b44:	00e7a423          	sw	a4,8(a5)
   12b48:	004ba783          	lw	a5,4(s7)
   12b4c:	e29ff06f          	j	12974 <_realloc_r+0x12c>

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
    {
      prev = prev_chunk(oldp);
   12b50:	ff8a2b83          	lw	s7,-8(s4)
   12b54:	417b0bb3          	sub	s7,s6,s7
      prevsize = chunksize(prev);
   12b58:	004ba783          	lw	a5,4(s7)
   12b5c:	ffc7f793          	andi	a5,a5,-4
          goto split;
        }
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
   12b60:	00fa8433          	add	s0,s5,a5
   12b64:	d8e444e3          	blt	s0,a4,128ec <_realloc_r+0xa4>
      {
        unlink(prev, bck, fwd);
   12b68:	00cba783          	lw	a5,12(s7)
   12b6c:	008ba703          	lw	a4,8(s7)
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12b70:	ffca8613          	addi	a2,s5,-4
   12b74:	02400693          	li	a3,36
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
   12b78:	00f72623          	sw	a5,12(a4)
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
   12b7c:	008b8993          	addi	s3,s7,8
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
   12b80:	00e7a423          	sw	a4,8(a5)
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12b84:	16c6ec63          	bltu	a3,a2,12cfc <_realloc_r+0x4b4>
   12b88:	01300713          	li	a4,19
   12b8c:	00098793          	mv	a5,s3
   12b90:	f8c77ce3          	bleu	a2,a4,12b28 <_realloc_r+0x2e0>
   12b94:	000a2783          	lw	a5,0(s4)
   12b98:	00fba423          	sw	a5,8(s7)
   12b9c:	004a2783          	lw	a5,4(s4)
   12ba0:	00fba623          	sw	a5,12(s7)
   12ba4:	01b00793          	li	a5,27
   12ba8:	1ac7f263          	bleu	a2,a5,12d4c <_realloc_r+0x504>
   12bac:	008a2783          	lw	a5,8(s4)
   12bb0:	00fba823          	sw	a5,16(s7)
   12bb4:	00ca2783          	lw	a5,12(s4)
   12bb8:	00fbaa23          	sw	a5,20(s7)
   12bbc:	f4d60ae3          	beq	a2,a3,12b10 <_realloc_r+0x2c8>
   12bc0:	018b8793          	addi	a5,s7,24
   12bc4:	010a0a13          	addi	s4,s4,16
   12bc8:	f61ff06f          	j	12b28 <_realloc_r+0x2e0>
      nextsize = chunksize(next);

      /* Forward into top only if a remainder */
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
   12bcc:	00452683          	lw	a3,4(a0)
   12bd0:	01090613          	addi	a2,s2,16
   12bd4:	ffc6f693          	andi	a3,a3,-4
   12bd8:	015686b3          	add	a3,a3,s5
   12bdc:	0ec6d063          	ble	a2,a3,12cbc <_realloc_r+0x474>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   12be0:	0017f793          	andi	a5,a5,1
   12be4:	d00794e3          	bnez	a5,128ec <_realloc_r+0xa4>
    {
      prev = prev_chunk(oldp);
   12be8:	ff8a2b83          	lw	s7,-8(s4)
   12bec:	417b0bb3          	sub	s7,s6,s7
      prevsize = chunksize(prev);
   12bf0:	004ba783          	lw	a5,4(s7)
   12bf4:	ffc7f793          	andi	a5,a5,-4
      if (next != 0)
      {
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
   12bf8:	00d78cb3          	add	s9,a5,a3
   12bfc:	f6ccc2e3          	blt	s9,a2,12b60 <_realloc_r+0x318>
          {
            unlink(prev, bck, fwd);
   12c00:	00cba783          	lw	a5,12(s7)
   12c04:	008ba703          	lw	a4,8(s7)
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12c08:	ffca8613          	addi	a2,s5,-4
   12c0c:	02400693          	li	a3,36
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
          {
            unlink(prev, bck, fwd);
   12c10:	00f72623          	sw	a5,12(a4)
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
   12c14:	008b8413          	addi	s0,s7,8
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
          {
            unlink(prev, bck, fwd);
   12c18:	00e7a423          	sw	a4,8(a5)
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12c1c:	14c6ec63          	bltu	a3,a2,12d74 <_realloc_r+0x52c>
   12c20:	01300713          	li	a4,19
   12c24:	00040793          	mv	a5,s0
   12c28:	02c77263          	bleu	a2,a4,12c4c <_realloc_r+0x404>
   12c2c:	000a2783          	lw	a5,0(s4)
   12c30:	00fba423          	sw	a5,8(s7)
   12c34:	004a2783          	lw	a5,4(s4)
   12c38:	00fba623          	sw	a5,12(s7)
   12c3c:	01b00793          	li	a5,27
   12c40:	14c7e263          	bltu	a5,a2,12d84 <_realloc_r+0x53c>
   12c44:	010b8793          	addi	a5,s7,16
   12c48:	008a0a13          	addi	s4,s4,8
   12c4c:	000a2703          	lw	a4,0(s4)
   12c50:	00e7a023          	sw	a4,0(a5)
   12c54:	004a2703          	lw	a4,4(s4)
   12c58:	00e7a223          	sw	a4,4(a5)
   12c5c:	008a2703          	lw	a4,8(s4)
   12c60:	00e7a423          	sw	a4,8(a5)
            top = chunk_at_offset(newp, nb);
            set_head(top, (newsize - nb) | PREV_INUSE);
   12c64:	412c86b3          	sub	a3,s9,s2
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
   12c68:	012b87b3          	add	a5,s7,s2
            set_head(top, (newsize - nb) | PREV_INUSE);
   12c6c:	0016e693          	ori	a3,a3,1
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
   12c70:	00fc2423          	sw	a5,8(s8)
            set_head(top, (newsize - nb) | PREV_INUSE);
   12c74:	00d7a223          	sw	a3,4(a5)
            set_head_size(newp, nb);
   12c78:	004ba703          	lw	a4,4(s7)
	    MALLOC_UNLOCK;
   12c7c:	00048513          	mv	a0,s1
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
            set_head(top, (newsize - nb) | PREV_INUSE);
            set_head_size(newp, nb);
   12c80:	00177713          	andi	a4,a4,1
   12c84:	01276733          	or	a4,a4,s2
   12c88:	00eba223          	sw	a4,4(s7)
	    MALLOC_UNLOCK;
   12c8c:	bb9ff0ef          	jal	12844 <__malloc_unlock>
            return newmem;
   12c90:	00040513          	mv	a0,s0
   12c94:	d15ff06f          	j	129a8 <_realloc_r+0x160>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12c98:	000a2703          	lw	a4,0(s4)
   12c9c:	00e52023          	sw	a4,0(a0)
   12ca0:	004a2703          	lw	a4,4(s4)
   12ca4:	00e52223          	sw	a4,4(a0)
   12ca8:	01b00713          	li	a4,27
   12cac:	06c76663          	bltu	a4,a2,12d18 <_realloc_r+0x4d0>
   12cb0:	00850793          	addi	a5,a0,8
   12cb4:	008a0713          	addi	a4,s4,8
   12cb8:	c79ff06f          	j	12930 <_realloc_r+0xe8>
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
          set_head(top, (newsize - nb) | PREV_INUSE);
   12cbc:	412686b3          	sub	a3,a3,s2
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
   12cc0:	012b0b33          	add	s6,s6,s2
          set_head(top, (newsize - nb) | PREV_INUSE);
   12cc4:	0016e693          	ori	a3,a3,1
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
   12cc8:	016c2423          	sw	s6,8(s8)
          set_head(top, (newsize - nb) | PREV_INUSE);
   12ccc:	00db2223          	sw	a3,4(s6)
          set_head_size(oldp, nb);
   12cd0:	ffca2703          	lw	a4,-4(s4)
	  MALLOC_UNLOCK;
   12cd4:	00048513          	mv	a0,s1
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
          set_head(top, (newsize - nb) | PREV_INUSE);
          set_head_size(oldp, nb);
   12cd8:	00177713          	andi	a4,a4,1
   12cdc:	01276733          	or	a4,a4,s2
   12ce0:	feea2e23          	sw	a4,-4(s4)
	  MALLOC_UNLOCK;
   12ce4:	b61ff0ef          	jal	12844 <__malloc_unlock>
          return chunk2mem(oldp);
   12ce8:	000a0513          	mv	a0,s4
   12cec:	cbdff06f          	j	129a8 <_realloc_r+0x160>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12cf0:	000a0593          	mv	a1,s4
   12cf4:	a2dff0ef          	jal	12720 <memmove>
   12cf8:	c51ff06f          	j	12948 <_realloc_r+0x100>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12cfc:	000a0593          	mv	a1,s4
   12d00:	00098513          	mv	a0,s3
   12d04:	a1dff0ef          	jal	12720 <memmove>
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
   12d08:	00040a93          	mv	s5,s0
   12d0c:	004ba783          	lw	a5,4(s7)
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12d10:	000b8b13          	mv	s6,s7
   12d14:	c61ff06f          	j	12974 <_realloc_r+0x12c>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12d18:	008a2703          	lw	a4,8(s4)
   12d1c:	00e52423          	sw	a4,8(a0)
   12d20:	00ca2703          	lw	a4,12(s4)
   12d24:	00e52623          	sw	a4,12(a0)
   12d28:	02f60863          	beq	a2,a5,12d58 <_realloc_r+0x510>
   12d2c:	01050793          	addi	a5,a0,16
   12d30:	010a0713          	addi	a4,s4,16
   12d34:	bfdff06f          	j	12930 <_realloc_r+0xe8>
    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
    {
      newsize += chunksize(newp);
   12d38:	ffc52703          	lw	a4,-4(a0)
      newp = oldp;
      goto split;
   12d3c:	000a0993          	mv	s3,s4
    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
    {
      newsize += chunksize(newp);
   12d40:	ffc77713          	andi	a4,a4,-4
   12d44:	00ea8ab3          	add	s5,s5,a4
      newp = oldp;
      goto split;
   12d48:	c2dff06f          	j	12974 <_realloc_r+0x12c>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12d4c:	010b8793          	addi	a5,s7,16
   12d50:	008a0a13          	addi	s4,s4,8
   12d54:	dd5ff06f          	j	12b28 <_realloc_r+0x2e0>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12d58:	010a2683          	lw	a3,16(s4)
   12d5c:	01850793          	addi	a5,a0,24
   12d60:	018a0713          	addi	a4,s4,24
   12d64:	00d52823          	sw	a3,16(a0)
   12d68:	014a2683          	lw	a3,20(s4)
   12d6c:	00d52a23          	sw	a3,20(a0)
   12d70:	bc1ff06f          	j	12930 <_realloc_r+0xe8>
          {
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12d74:	000a0593          	mv	a1,s4
   12d78:	00040513          	mv	a0,s0
   12d7c:	9a5ff0ef          	jal	12720 <memmove>
   12d80:	ee5ff06f          	j	12c64 <_realloc_r+0x41c>
   12d84:	008a2783          	lw	a5,8(s4)
   12d88:	00fba823          	sw	a5,16(s7)
   12d8c:	00ca2783          	lw	a5,12(s4)
   12d90:	00fbaa23          	sw	a5,20(s7)
   12d94:	02d60063          	beq	a2,a3,12db4 <_realloc_r+0x56c>
   12d98:	018b8793          	addi	a5,s7,24
   12d9c:	010a0a13          	addi	s4,s4,16
   12da0:	eadff06f          	j	12c4c <_realloc_r+0x404>

    newmem = mALLOc (RCALL bytes);

    if (newmem == 0)  /* propagate failure */
    {
      MALLOC_UNLOCK;
   12da4:	00048513          	mv	a0,s1
   12da8:	a9dff0ef          	jal	12844 <__malloc_unlock>
      return 0;
   12dac:	00000513          	li	a0,0
   12db0:	bf9ff06f          	j	129a8 <_realloc_r+0x160>
          {
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12db4:	010a2703          	lw	a4,16(s4)
   12db8:	020b8793          	addi	a5,s7,32
   12dbc:	018a0a13          	addi	s4,s4,24
   12dc0:	00ebac23          	sw	a4,24(s7)
   12dc4:	ffca2703          	lw	a4,-4(s4)
   12dc8:	00ebae23          	sw	a4,28(s7)
   12dcc:	e81ff06f          	j	12c4c <_realloc_r+0x404>

00012dd0 <__swsetup_r>:
       struct _reent *ptr _AND
       register FILE * fp)
{
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   12dd0:	8101a783          	lw	a5,-2032(gp) # 157d0 <_impure_ptr>

int
_DEFUN(__swsetup_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   12dd4:	ff010113          	addi	sp,sp,-16
   12dd8:	00812423          	sw	s0,8(sp)
   12ddc:	00912223          	sw	s1,4(sp)
   12de0:	00112623          	sw	ra,12(sp)
   12de4:	00050493          	mv	s1,a0
   12de8:	00058413          	mv	s0,a1
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   12dec:	00078663          	beqz	a5,12df8 <__swsetup_r+0x28>
   12df0:	0387a703          	lw	a4,56(a5)
   12df4:	0c070c63          	beqz	a4,12ecc <__swsetup_r+0xfc>

  /*
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
   12df8:	00c41703          	lh	a4,12(s0)
   12dfc:	01071793          	slli	a5,a4,0x10
   12e00:	0107d793          	srli	a5,a5,0x10
   12e04:	0087f693          	andi	a3,a5,8
   12e08:	04068263          	beqz	a3,12e4c <__swsetup_r+0x7c>
   12e0c:	01042683          	lw	a3,16(s0)
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
   12e10:	06068263          	beqz	a3,12e74 <__swsetup_r+0xa4>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
    __smakebuf_r (ptr, fp);

  if (fp->_flags & __SLBF)
   12e14:	0017f713          	andi	a4,a5,1
   12e18:	08071063          	bnez	a4,12e98 <__swsetup_r+0xc8>
       */
      fp->_w = 0;
      fp->_lbfsize = -fp->_bf._size;
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;
   12e1c:	0027f793          	andi	a5,a5,2
   12e20:	00000713          	li	a4,0
   12e24:	00079463          	bnez	a5,12e2c <__swsetup_r+0x5c>
   12e28:	01442703          	lw	a4,20(s0)
   12e2c:	00e42423          	sw	a4,8(s0)
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
      return EOF;
    }
  return 0;
   12e30:	00000513          	li	a0,0
      fp->_lbfsize = -fp->_bf._size;
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;

  if (!fp->_bf._base && (fp->_flags & __SMBF))
   12e34:	06068e63          	beqz	a3,12eb0 <__swsetup_r+0xe0>
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
      return EOF;
    }
  return 0;
}
   12e38:	00c12083          	lw	ra,12(sp)
   12e3c:	00812403          	lw	s0,8(sp)
   12e40:	00412483          	lw	s1,4(sp)
   12e44:	01010113          	addi	sp,sp,16
   12e48:	00008067          	ret
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
   12e4c:	0107f693          	andi	a3,a5,16
   12e50:	0a068e63          	beqz	a3,12f0c <__swsetup_r+0x13c>
        {
	  ptr->_errno = EBADF;
	  fp->_flags |= __SERR;
	  return EOF;
        }
      if (fp->_flags & __SRD)
   12e54:	0047f793          	andi	a5,a5,4
   12e58:	08079063          	bnez	a5,12ed8 <__swsetup_r+0x108>
   12e5c:	01042683          	lw	a3,16(s0)
	    FREEUB (ptr, fp);
	  fp->_flags &= ~(__SRD | __SEOF);
	  fp->_r = 0;
	  fp->_p = fp->_bf._base;
	}
      fp->_flags |= __SWR;
   12e60:	00876793          	ori	a5,a4,8
   12e64:	00f41623          	sh	a5,12(s0)
   12e68:	01079793          	slli	a5,a5,0x10
   12e6c:	0107d793          	srli	a5,a5,0x10
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
   12e70:	fa0692e3          	bnez	a3,12e14 <__swsetup_r+0x44>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
   12e74:	2807f713          	andi	a4,a5,640
   12e78:	20000613          	li	a2,512
   12e7c:	f8c70ce3          	beq	a4,a2,12e14 <__swsetup_r+0x44>
    __smakebuf_r (ptr, fp);
   12e80:	00040593          	mv	a1,s0
   12e84:	00048513          	mv	a0,s1
   12e88:	469000ef          	jal	13af0 <__smakebuf_r>
   12e8c:	00c45783          	lhu	a5,12(s0)
   12e90:	01042683          	lw	a3,16(s0)
   12e94:	f81ff06f          	j	12e14 <__swsetup_r+0x44>
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
      fp->_lbfsize = -fp->_bf._size;
   12e98:	01442783          	lw	a5,20(s0)
      /*
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
   12e9c:	00042423          	sw	zero,8(s0)
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
      return EOF;
    }
  return 0;
   12ea0:	00000513          	li	a0,0
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
      fp->_lbfsize = -fp->_bf._size;
   12ea4:	40f007b3          	neg	a5,a5
   12ea8:	00f42c23          	sw	a5,24(s0)
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;

  if (!fp->_bf._base && (fp->_flags & __SMBF))
   12eac:	f80696e3          	bnez	a3,12e38 <__swsetup_r+0x68>
   12eb0:	00c41783          	lh	a5,12(s0)
   12eb4:	0807f713          	andi	a4,a5,128
   12eb8:	f80700e3          	beqz	a4,12e38 <__swsetup_r+0x68>
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
   12ebc:	0407e793          	ori	a5,a5,64
   12ec0:	00f41623          	sh	a5,12(s0)
      return EOF;
   12ec4:	fff00513          	li	a0,-1
   12ec8:	f71ff06f          	j	12e38 <__swsetup_r+0x68>
       struct _reent *ptr _AND
       register FILE * fp)
{
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   12ecc:	00078513          	mv	a0,a5
   12ed0:	694000ef          	jal	13564 <__sinit>
   12ed4:	f25ff06f          	j	12df8 <__swsetup_r+0x28>
	  return EOF;
        }
      if (fp->_flags & __SRD)
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
   12ed8:	03042583          	lw	a1,48(s0)
   12edc:	00058e63          	beqz	a1,12ef8 <__swsetup_r+0x128>
	    FREEUB (ptr, fp);
   12ee0:	04040793          	addi	a5,s0,64
   12ee4:	00f58863          	beq	a1,a5,12ef4 <__swsetup_r+0x124>
   12ee8:	00048513          	mv	a0,s1
   12eec:	7b8000ef          	jal	136a4 <_free_r>
   12ef0:	00c41703          	lh	a4,12(s0)
   12ef4:	02042823          	sw	zero,48(s0)
	  fp->_flags &= ~(__SRD | __SEOF);
	  fp->_r = 0;
	  fp->_p = fp->_bf._base;
   12ef8:	01042683          	lw	a3,16(s0)
      if (fp->_flags & __SRD)
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
	    FREEUB (ptr, fp);
	  fp->_flags &= ~(__SRD | __SEOF);
   12efc:	fdb77713          	andi	a4,a4,-37
	  fp->_r = 0;
   12f00:	00042223          	sw	zero,4(s0)
	  fp->_p = fp->_bf._base;
   12f04:	00d42023          	sw	a3,0(s0)
   12f08:	f59ff06f          	j	12e60 <__swsetup_r+0x90>
  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
        {
	  ptr->_errno = EBADF;
	  fp->_flags |= __SERR;
   12f0c:	04076713          	ori	a4,a4,64

  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
        {
	  ptr->_errno = EBADF;
   12f10:	00900793          	li	a5,9
   12f14:	00f4a023          	sw	a5,0(s1)
	  fp->_flags |= __SERR;
	  return EOF;
   12f18:	fff00513          	li	a0,-1
  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
        {
	  ptr->_errno = EBADF;
	  fp->_flags |= __SERR;
   12f1c:	00e41623          	sh	a4,12(s0)
	  return EOF;
   12f20:	f19ff06f          	j	12e38 <__swsetup_r+0x68>

00012f24 <__sflush_r>:
  register unsigned char *p;
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
   12f24:	00c59683          	lh	a3,12(a1)
   directly from __srefill. */
int
_DEFUN(__sflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   12f28:	fe010113          	addi	sp,sp,-32
   12f2c:	00812c23          	sw	s0,24(sp)
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
  if ((flags & __SWR) == 0)
   12f30:	01069713          	slli	a4,a3,0x10
   12f34:	01075713          	srli	a4,a4,0x10
   12f38:	00877793          	andi	a5,a4,8
   directly from __srefill. */
int
_DEFUN(__sflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   12f3c:	01312623          	sw	s3,12(sp)
   12f40:	00112e23          	sw	ra,28(sp)
   12f44:	00912a23          	sw	s1,20(sp)
   12f48:	01212823          	sw	s2,16(sp)
   12f4c:	00058413          	mv	s0,a1
   12f50:	00050993          	mv	s3,a0
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
  if ((flags & __SWR) == 0)
   12f54:	10079a63          	bnez	a5,13068 <__sflush_r+0x144>
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
   12f58:	000017b7          	lui	a5,0x1
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   12f5c:	0045a703          	lw	a4,4(a1)
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
   12f60:	80078793          	addi	a5,a5,-2048 # 800 <_reset+0x600>
   12f64:	00f6e7b3          	or	a5,a3,a5
   12f68:	00f59623          	sh	a5,12(a1)
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   12f6c:	1ce05663          	blez	a4,13138 <__sflush_r+0x214>
   12f70:	02842803          	lw	a6,40(s0)
   12f74:	0c080a63          	beqz	a6,13048 <__sflush_r+0x124>
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
	  ptr->_errno = 0;
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
   12f78:	01079793          	slli	a5,a5,0x10
   12f7c:	0107d793          	srli	a5,a5,0x10
   12f80:	01379693          	slli	a3,a5,0x13
#endif

	  /* Save last errno and set errno to 0, so we can check if a device
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
   12f84:	0009a483          	lw	s1,0(s3)
	  ptr->_errno = 0;
   12f88:	0009a023          	sw	zero,0(s3)
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
   12f8c:	1a06dc63          	bgez	a3,13144 <__sflush_r+0x220>
	    curoff = fp->_offset;
   12f90:	05042603          	lw	a2,80(s0)
   12f94:	05442683          	lw	a3,84(s0)
		  else
		    fp->_flags |= __SERR;
		  return result;
		}
            }
          if (fp->_flags & __SRD)
   12f98:	0047f793          	andi	a5,a5,4
   12f9c:	04078263          	beqz	a5,12fe0 <__sflush_r+0xbc>
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
   12fa0:	00442503          	lw	a0,4(s0)
              if (HASUB (fp))
   12fa4:	03042703          	lw	a4,48(s0)
            }
          if (fp->_flags & __SRD)
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
   12fa8:	40a607b3          	sub	a5,a2,a0
   12fac:	41f55513          	srai	a0,a0,0x1f
   12fb0:	00f635b3          	sltu	a1,a2,a5
   12fb4:	40a686b3          	sub	a3,a3,a0
   12fb8:	00078613          	mv	a2,a5
   12fbc:	40b686b3          	sub	a3,a3,a1
              if (HASUB (fp))
   12fc0:	02070063          	beqz	a4,12fe0 <__sflush_r+0xbc>
                curoff -= fp->_ur;
   12fc4:	03c42503          	lw	a0,60(s0)
   12fc8:	40a787b3          	sub	a5,a5,a0
   12fcc:	41f55513          	srai	a0,a0,0x1f
   12fd0:	00f63733          	sltu	a4,a2,a5
   12fd4:	40a686b3          	sub	a3,a3,a0
   12fd8:	00078613          	mv	a2,a5
   12fdc:	40e686b3          	sub	a3,a3,a4
#ifdef __LARGE64_FILES
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
   12fe0:	01c42583          	lw	a1,28(s0)
   12fe4:	00000713          	li	a4,0
   12fe8:	00098513          	mv	a0,s3
   12fec:	000800e7          	jalr	a6
	  if (curoff != -1 || ptr->_errno == 0
   12ff0:	fff00793          	li	a5,-1
   12ff4:	0ef50063          	beq	a0,a5,130d4 <__sflush_r+0x1b0>
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   12ff8:	00c45683          	lhu	a3,12(s0)
   12ffc:	fffff7b7          	lui	a5,0xfffff
   13000:	7ff78793          	addi	a5,a5,2047 # fffff7ff <_gp+0xfffe983f>
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   13004:	01042703          	lw	a4,16(s0)
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   13008:	00f6f7b3          	and	a5,a3,a5
   1300c:	01079793          	slli	a5,a5,0x10
   13010:	4107d793          	srai	a5,a5,0x10
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   13014:	00e42023          	sw	a4,0(s0)
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   13018:	01379713          	slli	a4,a5,0x13
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   1301c:	00f41623          	sh	a5,12(s0)
#endif
	      fp->_r = 0;
   13020:	00042223          	sw	zero,4(s0)
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   13024:	10074463          	bltz	a4,1312c <__sflush_r+0x208>
		fp->_offset = curoff;
	      ptr->_errno = tmp_errno;
	      if (HASUB (fp))
   13028:	03042583          	lw	a1,48(s0)
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
		fp->_offset = curoff;
	      ptr->_errno = tmp_errno;
   1302c:	0099a023          	sw	s1,0(s3)
	      if (HASUB (fp))
   13030:	00058c63          	beqz	a1,13048 <__sflush_r+0x124>
		FREEUB (ptr, fp);
   13034:	04040793          	addi	a5,s0,64
   13038:	00f58663          	beq	a1,a5,13044 <__sflush_r+0x120>
   1303c:	00098513          	mv	a0,s3
   13040:	664000ef          	jal	136a4 <_free_r>
   13044:	02042823          	sw	zero,48(s0)
	    {
	      fp->_flags |= __SERR;
	      return EOF;
	    }
	}
      return 0;
   13048:	00000513          	li	a0,0
	}
      p += t;
      n -= t;
    }
  return 0;
}
   1304c:	01c12083          	lw	ra,28(sp)
   13050:	01812403          	lw	s0,24(sp)
   13054:	01412483          	lw	s1,20(sp)
   13058:	01012903          	lw	s2,16(sp)
   1305c:	00c12983          	lw	s3,12(sp)
   13060:	02010113          	addi	sp,sp,32
   13064:	00008067          	ret
	      return EOF;
	    }
	}
      return 0;
    }
  if ((p = fp->_bf._base) == NULL)
   13068:	0105a903          	lw	s2,16(a1)
   1306c:	fc090ee3          	beqz	s2,13048 <__sflush_r+0x124>
    {
      /* Nothing to flush.  */
      return 0;
    }
  n = fp->_p - p;		/* write this much */
   13070:	0005a483          	lw	s1,0(a1)
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
   13074:	00377713          	andi	a4,a4,3
  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
   13078:	0125a023          	sw	s2,0(a1)
  if ((p = fp->_bf._base) == NULL)
    {
      /* Nothing to flush.  */
      return 0;
    }
  n = fp->_p - p;		/* write this much */
   1307c:	412484b3          	sub	s1,s1,s2
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
   13080:	00000793          	li	a5,0
   13084:	00071463          	bnez	a4,1308c <__sflush_r+0x168>
   13088:	0145a783          	lw	a5,20(a1)
   1308c:	00f42423          	sw	a5,8(s0)

  while (n > 0)
   13090:	00904863          	bgtz	s1,130a0 <__sflush_r+0x17c>
   13094:	fb5ff06f          	j	13048 <__sflush_r+0x124>
      if (t <= 0)
	{
          fp->_flags |= __SERR;
          return EOF;
	}
      p += t;
   13098:	00a90933          	add	s2,s2,a0
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
   1309c:	fa9056e3          	blez	s1,13048 <__sflush_r+0x124>
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
   130a0:	02442783          	lw	a5,36(s0)
   130a4:	01c42583          	lw	a1,28(s0)
   130a8:	00048693          	mv	a3,s1
   130ac:	00090613          	mv	a2,s2
   130b0:	00098513          	mv	a0,s3
   130b4:	000780e7          	jalr	a5
	{
          fp->_flags |= __SERR;
          return EOF;
	}
      p += t;
      n -= t;
   130b8:	40a484b3          	sub	s1,s1,a0
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
      if (t <= 0)
   130bc:	fca04ee3          	bgtz	a0,13098 <__sflush_r+0x174>
	{
          fp->_flags |= __SERR;
   130c0:	00c45783          	lhu	a5,12(s0)
          return EOF;
   130c4:	fff00513          	li	a0,-1
  while (n > 0)
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
      if (t <= 0)
	{
          fp->_flags |= __SERR;
   130c8:	0407e793          	ori	a5,a5,64
   130cc:	00f41623          	sh	a5,12(s0)
          return EOF;
   130d0:	f7dff06f          	j	1304c <__sflush_r+0x128>
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
	  if (curoff != -1 || ptr->_errno == 0
   130d4:	f2a592e3          	bne	a1,a0,12ff8 <__sflush_r+0xd4>
   130d8:	0009a703          	lw	a4,0(s3)
   130dc:	01d00793          	li	a5,29
   130e0:	fee7e0e3          	bltu	a5,a4,130c0 <__sflush_r+0x19c>
   130e4:	204007b7          	lui	a5,0x20400
   130e8:	00178793          	addi	a5,a5,1 # 20400001 <_gp+0x203ea041>
   130ec:	00e7d7b3          	srl	a5,a5,a4
   130f0:	0017f793          	andi	a5,a5,1
   130f4:	fc0786e3          	beqz	a5,130c0 <__sflush_r+0x19c>
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   130f8:	00c45603          	lhu	a2,12(s0)
   130fc:	fffff7b7          	lui	a5,0xfffff
   13100:	7ff78793          	addi	a5,a5,2047 # fffff7ff <_gp+0xfffe983f>
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   13104:	01042683          	lw	a3,16(s0)
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   13108:	00f677b3          	and	a5,a2,a5
   1310c:	01079793          	slli	a5,a5,0x10
   13110:	4107d793          	srai	a5,a5,0x10
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   13114:	00d42023          	sw	a3,0(s0)
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   13118:	01379693          	slli	a3,a5,0x13
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   1311c:	00f41623          	sh	a5,12(s0)
#endif
	      fp->_r = 0;
   13120:	00042223          	sw	zero,4(s0)
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   13124:	f006d2e3          	bgez	a3,13028 <__sflush_r+0x104>
   13128:	f00710e3          	bnez	a4,13028 <__sflush_r+0x104>
		fp->_offset = curoff;
   1312c:	04a42823          	sw	a0,80(s0)
   13130:	04b42a23          	sw	a1,84(s0)
   13134:	ef5ff06f          	j	13028 <__sflush_r+0x104>
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   13138:	03c5a703          	lw	a4,60(a1)
   1313c:	e2e04ae3          	bgtz	a4,12f70 <__sflush_r+0x4c>
   13140:	f09ff06f          	j	13048 <__sflush_r+0x124>
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
   13144:	01c42583          	lw	a1,28(s0)
   13148:	00000613          	li	a2,0
   1314c:	00000693          	li	a3,0
   13150:	00100713          	li	a4,1
   13154:	00098513          	mv	a0,s3
   13158:	000800e7          	jalr	a6
	      if (curoff == -1L && ptr->_errno != 0)
   1315c:	fff00793          	li	a5,-1
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
   13160:	00050613          	mv	a2,a0
   13164:	00058693          	mv	a3,a1
	      if (curoff == -1L && ptr->_errno != 0)
   13168:	00f50863          	beq	a0,a5,13178 <__sflush_r+0x254>
   1316c:	00c45783          	lhu	a5,12(s0)
   13170:	02842803          	lw	a6,40(s0)
   13174:	e25ff06f          	j	12f98 <__sflush_r+0x74>
   13178:	fea59ae3          	bne	a1,a0,1316c <__sflush_r+0x248>
   1317c:	0009a783          	lw	a5,0(s3)
   13180:	fe0786e3          	beqz	a5,1316c <__sflush_r+0x248>
		{
		  int result = EOF;
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
   13184:	01d00713          	li	a4,29
   13188:	00e78663          	beq	a5,a4,13194 <__sflush_r+0x270>
   1318c:	01600713          	li	a4,22
   13190:	00e79863          	bne	a5,a4,131a0 <__sflush_r+0x27c>
		    {
		      result = 0;
		      ptr->_errno = tmp_errno;
   13194:	0099a023          	sw	s1,0(s3)
	      if (curoff == -1L && ptr->_errno != 0)
		{
		  int result = EOF;
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
		    {
		      result = 0;
   13198:	00000513          	li	a0,0
		      ptr->_errno = tmp_errno;
   1319c:	eb1ff06f          	j	1304c <__sflush_r+0x128>
		    }
		  else
		    fp->_flags |= __SERR;
   131a0:	00c45783          	lhu	a5,12(s0)
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
	      if (curoff == -1L && ptr->_errno != 0)
		{
		  int result = EOF;
   131a4:	00058513          	mv	a0,a1
		    {
		      result = 0;
		      ptr->_errno = tmp_errno;
		    }
		  else
		    fp->_flags |= __SERR;
   131a8:	0407e793          	ori	a5,a5,64
   131ac:	00f41623          	sh	a5,12(s0)
   131b0:	e9dff06f          	j	1304c <__sflush_r+0x128>

000131b4 <_fflush_r>:

int
_DEFUN(_fflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   131b4:	fe010113          	addi	sp,sp,-32
   131b8:	00812c23          	sw	s0,24(sp)
   131bc:	00112e23          	sw	ra,28(sp)
   131c0:	00050413          	mv	s0,a0
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
   131c4:	00050663          	beqz	a0,131d0 <_fflush_r+0x1c>
   131c8:	03852783          	lw	a5,56(a0)
   131cc:	02078a63          	beqz	a5,13200 <_fflush_r+0x4c>

  if (!fp->_flags)
   131d0:	00c59783          	lh	a5,12(a1)
   131d4:	00079c63          	bnez	a5,131ec <_fflush_r+0x38>

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
  _newlib_flockfile_end (fp);
  return ret;
}
   131d8:	01c12083          	lw	ra,28(sp)
   131dc:	00000513          	li	a0,0
   131e0:	01812403          	lw	s0,24(sp)
   131e4:	02010113          	addi	sp,sp,32
   131e8:	00008067          	ret

  if (!fp->_flags)
    return 0;

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
   131ec:	00040513          	mv	a0,s0
  _newlib_flockfile_end (fp);
  return ret;
}
   131f0:	01c12083          	lw	ra,28(sp)
   131f4:	01812403          	lw	s0,24(sp)
   131f8:	02010113          	addi	sp,sp,32

  if (!fp->_flags)
    return 0;

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
   131fc:	d29ff06f          	j	12f24 <__sflush_r>
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
   13200:	00b12623          	sw	a1,12(sp)
   13204:	360000ef          	jal	13564 <__sinit>
   13208:	00c12583          	lw	a1,12(sp)
   1320c:	fc5ff06f          	j	131d0 <_fflush_r+0x1c>

00013210 <fflush>:
#ifndef _REENT_ONLY

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
   13210:	00050593          	mv	a1,a0
  if (fp == NULL)
   13214:	00050663          	beqz	a0,13220 <fflush+0x10>
    return _fwalk_reent (_GLOBAL_REENT, _fflush_r);

  return _fflush_r (_REENT, fp);
   13218:	8101a503          	lw	a0,-2032(gp) # 157d0 <_impure_ptr>
   1321c:	f99ff06f          	j	131b4 <_fflush_r>
int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
  if (fp == NULL)
    return _fwalk_reent (_GLOBAL_REENT, _fflush_r);
   13220:	80c1a503          	lw	a0,-2036(gp) # 157cc <_global_impure_ptr>
   13224:	000135b7          	lui	a1,0x13
   13228:	1b458593          	addi	a1,a1,436 # 131b4 <_fflush_r>
   1322c:	0050006f          	j	13a30 <_fwalk_reent>

00013230 <__fp_unlock>:
       FILE * ptr)
{
  _funlockfile (ptr);

  return 0;
}
   13230:	00000513          	li	a0,0
   13234:	00008067          	ret

00013238 <_cleanup_r>:
  cleanup_func = _fflush_r;
#else
  cleanup_func = _fclose_r;
#endif
#endif
  _CAST_VOID _fwalk_reent (ptr, cleanup_func);
   13238:	000145b7          	lui	a1,0x14
   1323c:	ecc58593          	addi	a1,a1,-308 # 13ecc <_fclose_r>
   13240:	7f00006f          	j	13a30 <_fwalk_reent>

00013244 <__sinit.part.1>:
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   13244:	fe010113          	addi	sp,sp,-32
      __sinit_lock_release ();
      return;
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
   13248:	000137b7          	lui	a5,0x13
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   1324c:	00812c23          	sw	s0,24(sp)
      __sinit_lock_release ();
      return;
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
   13250:	23878793          	addi	a5,a5,568 # 13238 <_cleanup_r>
  s->_stdin = __sfp(s);
  s->_stdout = __sfp(s);
  s->_stderr = __sfp(s);
#endif

  std (s->_stdin,  __SRD, 0, s);
   13254:	00452403          	lw	s0,4(a0)
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   13258:	00112e23          	sw	ra,28(sp)
   1325c:	00912a23          	sw	s1,20(sp)
   13260:	01212823          	sw	s2,16(sp)
   13264:	01312623          	sw	s3,12(sp)
   13268:	01412423          	sw	s4,8(sp)
   1326c:	01512223          	sw	s5,4(sp)
   13270:	01612023          	sw	s6,0(sp)
      __sinit_lock_release ();
      return;
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
   13274:	02f52e23          	sw	a5,60(a0)

  s->__sglue._next = NULL;
#ifndef _REENT_SMALL
  s->__sglue._niobs = 3;
   13278:	00300793          	li	a5,3
   1327c:	2ef52223          	sw	a5,740(a0)
  s->__sglue._iobs = &s->__sf[0];
   13280:	2f050713          	addi	a4,a0,752
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   13284:	00400793          	li	a5,4
  s->__cleanup = _cleanup_r;	/* conservative */

  s->__sglue._next = NULL;
#ifndef _REENT_SMALL
  s->__sglue._niobs = 3;
  s->__sglue._iobs = &s->__sf[0];
   13288:	2ee52423          	sw	a4,744(a0)
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */

  s->__sglue._next = NULL;
   1328c:	2e052023          	sw	zero,736(a0)
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   13290:	00050913          	mv	s2,a0
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   13294:	00f41623          	sh	a5,12(s0)
  ptr->_flags2 = 0;
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   13298:	00800613          	li	a2,8
   1329c:	00000593          	li	a1,0
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
  ptr->_p = 0;
   132a0:	00042023          	sw	zero,0(s0)
  ptr->_r = 0;
   132a4:	00042223          	sw	zero,4(s0)
  ptr->_w = 0;
   132a8:	00042423          	sw	zero,8(s0)
  ptr->_flags = flags;
  ptr->_flags2 = 0;
   132ac:	06042423          	sw	zero,104(s0)
  ptr->_file = file;
   132b0:	00041723          	sh	zero,14(s0)
  ptr->_bf._base = 0;
   132b4:	00042823          	sw	zero,16(s0)
  ptr->_bf._size = 0;
   132b8:	00042a23          	sw	zero,20(s0)
  ptr->_lbfsize = 0;
   132bc:	00042c23          	sw	zero,24(s0)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   132c0:	06040513          	addi	a0,s0,96
   132c4:	1bd000ef          	jal	13c80 <memset>
     requires both stdin and stdout to be line-buffered, but tradition
     leaves stdin alone on systems without fcntl.  */
#ifdef HAVE_FCNTL
  std (s->_stdout, __SWR, 1, s);
#else
  std (s->_stdout, __SWR | __SLBF, 1, s);
   132c8:	00892483          	lw	s1,8(s2)
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   132cc:	00014b37          	lui	s6,0x14
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   132d0:	00014ab7          	lui	s5,0x14
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   132d4:	00014a37          	lui	s4,0x14
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   132d8:	000149b7          	lui	s3,0x14
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   132dc:	d5cb0b13          	addi	s6,s6,-676 # 13d5c <__sread>
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   132e0:	de0a8a93          	addi	s5,s5,-544 # 13de0 <__swrite>
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   132e4:	e58a0a13          	addi	s4,s4,-424 # 13e58 <__sseek>
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   132e8:	ec498993          	addi	s3,s3,-316 # 13ec4 <__sclose>
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   132ec:	00900793          	li	a5,9
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   132f0:	03642023          	sw	s6,32(s0)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   132f4:	03542223          	sw	s5,36(s0)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   132f8:	03442423          	sw	s4,40(s0)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   132fc:	03342623          	sw	s3,44(s0)
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
   13300:	00842e23          	sw	s0,28(s0)
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   13304:	00f49623          	sh	a5,12(s1)
  ptr->_flags2 = 0;
  ptr->_file = file;
   13308:	00100793          	li	a5,1
   1330c:	00f49723          	sh	a5,14(s1)
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   13310:	00800613          	li	a2,8
   13314:	00000593          	li	a1,0
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
  ptr->_p = 0;
   13318:	0004a023          	sw	zero,0(s1)
  ptr->_r = 0;
   1331c:	0004a223          	sw	zero,4(s1)
  ptr->_w = 0;
   13320:	0004a423          	sw	zero,8(s1)
  ptr->_flags = flags;
  ptr->_flags2 = 0;
   13324:	0604a423          	sw	zero,104(s1)
  ptr->_file = file;
  ptr->_bf._base = 0;
   13328:	0004a823          	sw	zero,16(s1)
  ptr->_bf._size = 0;
   1332c:	0004aa23          	sw	zero,20(s1)
  ptr->_lbfsize = 0;
   13330:	0004ac23          	sw	zero,24(s1)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   13334:	06048513          	addi	a0,s1,96
   13338:	149000ef          	jal	13c80 <memset>
  std (s->_stdout, __SWR | __SLBF, 1, s);
#endif

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);
   1333c:	00c92403          	lw	s0,12(s2)
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   13340:	01200793          	li	a5,18
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   13344:	0364a023          	sw	s6,32(s1)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   13348:	0354a223          	sw	s5,36(s1)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   1334c:	0344a423          	sw	s4,40(s1)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   13350:	0334a623          	sw	s3,44(s1)
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
   13354:	0094ae23          	sw	s1,28(s1)
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   13358:	00f41623          	sh	a5,12(s0)
  ptr->_flags2 = 0;
  ptr->_file = file;
   1335c:	00200793          	li	a5,2
   13360:	00f41723          	sh	a5,14(s0)
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
  ptr->_p = 0;
   13364:	00042023          	sw	zero,0(s0)
  ptr->_r = 0;
   13368:	00042223          	sw	zero,4(s0)
  ptr->_w = 0;
   1336c:	00042423          	sw	zero,8(s0)
  ptr->_flags = flags;
  ptr->_flags2 = 0;
   13370:	06042423          	sw	zero,104(s0)
  ptr->_file = file;
  ptr->_bf._base = 0;
   13374:	00042823          	sw	zero,16(s0)
  ptr->_bf._size = 0;
   13378:	00042a23          	sw	zero,20(s0)
  ptr->_lbfsize = 0;
   1337c:	00042c23          	sw	zero,24(s0)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   13380:	06040513          	addi	a0,s0,96
   13384:	00800613          	li	a2,8
   13388:	00000593          	li	a1,0
   1338c:	0f5000ef          	jal	13c80 <memset>
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;

  __sinit_lock_release ();
}
   13390:	01c12083          	lw	ra,28(sp)

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;
   13394:	00100793          	li	a5,1
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   13398:	03642023          	sw	s6,32(s0)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   1339c:	03542223          	sw	s5,36(s0)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   133a0:	03442423          	sw	s4,40(s0)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   133a4:	03342623          	sw	s3,44(s0)
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
   133a8:	00842e23          	sw	s0,28(s0)
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;

  __sinit_lock_release ();
}
   133ac:	01412483          	lw	s1,20(sp)

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;
   133b0:	02f92c23          	sw	a5,56(s2)

  __sinit_lock_release ();
}
   133b4:	01812403          	lw	s0,24(sp)
   133b8:	01012903          	lw	s2,16(sp)
   133bc:	00c12983          	lw	s3,12(sp)
   133c0:	00812a03          	lw	s4,8(sp)
   133c4:	00412a83          	lw	s5,4(sp)
   133c8:	00012b03          	lw	s6,0(sp)
   133cc:	02010113          	addi	sp,sp,32
   133d0:	00008067          	ret

000133d4 <__fp_lock>:
   133d4:	00000513          	li	a0,0
   133d8:	00008067          	ret

000133dc <__sfmoreglue>:

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   133dc:	ff010113          	addi	sp,sp,-16
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
   133e0:	fff58793          	addi	a5,a1,-1

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   133e4:	00812423          	sw	s0,8(sp)
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
   133e8:	00479413          	slli	s0,a5,0x4
   133ec:	00779793          	slli	a5,a5,0x7
   133f0:	40878433          	sub	s0,a5,s0

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   133f4:	01212023          	sw	s2,0(sp)
   133f8:	00058913          	mv	s2,a1
  struct glue_with_file *g;

  g = (struct glue_with_file *)
   133fc:	08040593          	addi	a1,s0,128

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   13400:	00912223          	sw	s1,4(sp)
   13404:	00112623          	sw	ra,12(sp)
  struct glue_with_file *g;

  g = (struct glue_with_file *)
   13408:	9adfe0ef          	jal	11db4 <_malloc_r>
   1340c:	00050493          	mv	s1,a0
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  if (g == NULL)
   13410:	02050063          	beqz	a0,13430 <__sfmoreglue+0x54>
    return NULL;
  g->glue._next = NULL;
  g->glue._niobs = n;
  g->glue._iobs = &g->file;
   13414:	01050513          	addi	a0,a0,16

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  if (g == NULL)
    return NULL;
  g->glue._next = NULL;
   13418:	0004a023          	sw	zero,0(s1)
  g->glue._niobs = n;
   1341c:	0124a223          	sw	s2,4(s1)
  g->glue._iobs = &g->file;
   13420:	00a4a423          	sw	a0,8(s1)
  memset (&g->file, 0, n * sizeof (FILE));
   13424:	07040613          	addi	a2,s0,112
   13428:	00000593          	li	a1,0
   1342c:	055000ef          	jal	13c80 <memset>
  return &g->glue;
}
   13430:	00c12083          	lw	ra,12(sp)
   13434:	00048513          	mv	a0,s1
   13438:	00812403          	lw	s0,8(sp)
   1343c:	00412483          	lw	s1,4(sp)
   13440:	00012903          	lw	s2,0(sp)
   13444:	01010113          	addi	sp,sp,16
   13448:	00008067          	ret

0001344c <__sfp>:
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
   1344c:	fe010113          	addi	sp,sp,-32
   13450:	01212823          	sw	s2,16(sp)
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
   13454:	80c1a903          	lw	s2,-2036(gp) # 157cc <_global_impure_ptr>
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
   13458:	01312623          	sw	s3,12(sp)
   1345c:	00112e23          	sw	ra,28(sp)
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
   13460:	03892783          	lw	a5,56(s2)
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
   13464:	00812c23          	sw	s0,24(sp)
   13468:	00912a23          	sw	s1,20(sp)
   1346c:	00050993          	mv	s3,a0
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
   13470:	00079663          	bnez	a5,1347c <__sfp+0x30>
   13474:	00090513          	mv	a0,s2
   13478:	dcdff0ef          	jal	13244 <__sinit.part.1>
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
   1347c:	2e090913          	addi	s2,s2,736
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   13480:	fff00493          	li	s1,-1
   13484:	00492783          	lw	a5,4(s2)
   13488:	00892403          	lw	s0,8(s2)
   1348c:	fff78793          	addi	a5,a5,-1
   13490:	0007da63          	bgez	a5,134a4 <__sfp+0x58>
   13494:	0840006f          	j	13518 <__sfp+0xcc>
   13498:	fff78793          	addi	a5,a5,-1
   1349c:	07040413          	addi	s0,s0,112
   134a0:	06978c63          	beq	a5,s1,13518 <__sfp+0xcc>
	if (fp->_flags == 0)
   134a4:	00c41703          	lh	a4,12(s0)
   134a8:	fe0718e3          	bnez	a4,13498 <__sfp+0x4c>
  _newlib_sfp_lock_exit ();
  d->_errno = ENOMEM;
  return NULL;

found:
  fp->_file = -1;		/* no file */
   134ac:	fff00793          	li	a5,-1
   134b0:	00f41723          	sh	a5,14(s0)
  fp->_flags = 1;		/* reserve this slot; caller sets real flags */
   134b4:	00100793          	li	a5,1
   134b8:	00f41623          	sh	a5,12(s0)
  fp->_flags2 = 0;
   134bc:	06042423          	sw	zero,104(s0)
#ifndef __SINGLE_THREAD__
  __lock_init_recursive (fp->_lock);
#endif
  _newlib_sfp_lock_end ();

  fp->_p = NULL;		/* no current pointer */
   134c0:	00042023          	sw	zero,0(s0)
  fp->_w = 0;			/* nothing to read or write */
   134c4:	00042423          	sw	zero,8(s0)
  fp->_r = 0;
   134c8:	00042223          	sw	zero,4(s0)
  fp->_bf._base = NULL;		/* no buffer */
   134cc:	00042823          	sw	zero,16(s0)
  fp->_bf._size = 0;
   134d0:	00042a23          	sw	zero,20(s0)
  fp->_lbfsize = 0;		/* not line buffered */
   134d4:	00042c23          	sw	zero,24(s0)
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
   134d8:	00800613          	li	a2,8
   134dc:	00000593          	li	a1,0
   134e0:	06040513          	addi	a0,s0,96
   134e4:	79c000ef          	jal	13c80 <memset>
  /* fp->_cookie = <any>; */	/* caller sets cookie, _read/_write etc */
  fp->_ub._base = NULL;		/* no ungetc buffer */
   134e8:	02042823          	sw	zero,48(s0)
  fp->_ub._size = 0;
   134ec:	02042a23          	sw	zero,52(s0)
  fp->_lb._base = NULL;		/* no line buffer */
   134f0:	04042223          	sw	zero,68(s0)
  fp->_lb._size = 0;
   134f4:	04042423          	sw	zero,72(s0)

  return fp;
   134f8:	00040513          	mv	a0,s0
}
   134fc:	01c12083          	lw	ra,28(sp)
   13500:	01812403          	lw	s0,24(sp)
   13504:	01412483          	lw	s1,20(sp)
   13508:	01012903          	lw	s2,16(sp)
   1350c:	00c12983          	lw	s3,12(sp)
   13510:	02010113          	addi	sp,sp,32
   13514:	00008067          	ret
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
   13518:	00092783          	lw	a5,0(s2)
   1351c:	00078663          	beqz	a5,13528 <__sfp+0xdc>
   13520:	00078913          	mv	s2,a5
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
    }
   13524:	f61ff06f          	j	13484 <__sfp+0x38>
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
   13528:	00400593          	li	a1,4
   1352c:	00098513          	mv	a0,s3
   13530:	eadff0ef          	jal	133dc <__sfmoreglue>
   13534:	00a92023          	sw	a0,0(s2)
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
   13538:	00050663          	beqz	a0,13544 <__sfp+0xf8>
   1353c:	00050913          	mv	s2,a0
   13540:	f45ff06f          	j	13484 <__sfp+0x38>
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
    }
  _newlib_sfp_lock_exit ();
  d->_errno = ENOMEM;
   13544:	00c00793          	li	a5,12
   13548:	00f9a023          	sw	a5,0(s3)
  return NULL;
   1354c:	00000513          	li	a0,0
   13550:	fadff06f          	j	134fc <__sfp+0xb0>

00013554 <_cleanup>:
  cleanup_func = _fflush_r;
#else
  cleanup_func = _fclose_r;
#endif
#endif
  _CAST_VOID _fwalk_reent (ptr, cleanup_func);
   13554:	80c1a503          	lw	a0,-2036(gp) # 157cc <_global_impure_ptr>
   13558:	000145b7          	lui	a1,0x14
   1355c:	ecc58593          	addi	a1,a1,-308 # 13ecc <_fclose_r>
   13560:	4d00006f          	j	13a30 <_fwalk_reent>

00013564 <__sinit>:
_DEFUN(__sinit, (s),
       struct _reent *s)
{
  __sinit_lock_acquire ();

  if (s->__sdidinit)
   13564:	03852783          	lw	a5,56(a0)
   13568:	00078463          	beqz	a5,13570 <__sinit+0xc>
   1356c:	00008067          	ret
   13570:	cd5ff06f          	j	13244 <__sinit.part.1>

00013574 <__sfp_lock_acquire>:
   13574:	00008067          	ret

00013578 <__sfp_lock_release>:
   13578:	00008067          	ret

0001357c <__sinit_lock_acquire>:
   1357c:	00008067          	ret

00013580 <__sinit_lock_release>:
  __lock_acquire_recursive (__sinit_lock);
}

_VOID
_DEFUN_VOID(__sinit_lock_release)
{
   13580:	00008067          	ret

00013584 <__fp_lock_all>:
_VOID
_DEFUN_VOID(__fp_lock_all)
{
  __sfp_lock_acquire ();

  _CAST_VOID _fwalk (_REENT, __fp_lock);
   13584:	8101a503          	lw	a0,-2032(gp) # 157d0 <_impure_ptr>
   13588:	000135b7          	lui	a1,0x13
   1358c:	3d458593          	addi	a1,a1,980 # 133d4 <__fp_lock>
   13590:	3f00006f          	j	13980 <_fwalk>

00013594 <__fp_unlock_all>:
}

_VOID
_DEFUN_VOID(__fp_unlock_all)
{
  _CAST_VOID _fwalk (_REENT, __fp_unlock);
   13594:	8101a503          	lw	a0,-2032(gp) # 157d0 <_impure_ptr>
   13598:	000135b7          	lui	a1,0x13
   1359c:	23058593          	addi	a1,a1,560 # 13230 <__fp_unlock>
   135a0:	3e00006f          	j	13980 <_fwalk>

000135a4 <_malloc_trim_r>:
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
   135a4:	fe010113          	addi	sp,sp,-32
   135a8:	01212823          	sw	s2,16(sp)

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;

  top_size = chunksize(top);
   135ac:	00015937          	lui	s2,0x15
   135b0:	3b090913          	addi	s2,s2,944 # 153b0 <__malloc_av_>
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
   135b4:	00812c23          	sw	s0,24(sp)
   135b8:	00912a23          	sw	s1,20(sp)
   135bc:	00058413          	mv	s0,a1
   135c0:	01312623          	sw	s3,12(sp)
   135c4:	00112e23          	sw	ra,28(sp)
   135c8:	00050993          	mv	s3,a0
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;
   135cc:	a74ff0ef          	jal	12840 <__malloc_lock>

  top_size = chunksize(top);
   135d0:	00892703          	lw	a4,8(s2)
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
   135d4:	000017b7          	lui	a5,0x1
   135d8:	fef78593          	addi	a1,a5,-17 # fef <_reset+0xdef>

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;

  top_size = chunksize(top);
   135dc:	00472483          	lw	s1,4(a4)
   135e0:	ffc4f493          	andi	s1,s1,-4
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
   135e4:	40848433          	sub	s0,s1,s0
   135e8:	00b40433          	add	s0,s0,a1
   135ec:	00c45413          	srli	s0,s0,0xc
   135f0:	fff40413          	addi	s0,s0,-1
   135f4:	00c41413          	slli	s0,s0,0xc

  if (extra < (long)pagesz)  /* Not enough memory to release */
   135f8:	00f44c63          	blt	s0,a5,13610 <_malloc_trim_r+0x6c>
  }

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
   135fc:	00000513          	li	a0,0
   13600:	dd1fc0ef          	jal	103d0 <sbrk>
    if (current_brk != (char*)(top) + top_size)
   13604:	00892783          	lw	a5,8(s2)
   13608:	009787b3          	add	a5,a5,s1
   1360c:	02f50663          	beq	a0,a5,13638 <_malloc_trim_r+0x94>
  top_size = chunksize(top);
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;

  if (extra < (long)pagesz)  /* Not enough memory to release */
  {
    MALLOC_UNLOCK;
   13610:	00098513          	mv	a0,s3
   13614:	a30ff0ef          	jal	12844 <__malloc_unlock>
    return 0;
   13618:	00000513          	li	a0,0
	MALLOC_UNLOCK;
        return 1;
      }
    }
  }
}
   1361c:	01c12083          	lw	ra,28(sp)
   13620:	01812403          	lw	s0,24(sp)
   13624:	01412483          	lw	s1,20(sp)
   13628:	01012903          	lw	s2,16(sp)
   1362c:	00c12983          	lw	s3,12(sp)
   13630:	02010113          	addi	sp,sp,32
   13634:	00008067          	ret
      return 0;     /* Apparently we don't own memory; must fail */
    }

    else
    {
      new_brk = (char*)(MORECORE (-extra));
   13638:	40800533          	neg	a0,s0
   1363c:	d95fc0ef          	jal	103d0 <sbrk>
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
   13640:	fff00793          	li	a5,-1
   13644:	02f50863          	beq	a0,a5,13674 <_malloc_trim_r+0xd0>

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
        sbrked_mem -= extra;
   13648:	8501a783          	lw	a5,-1968(gp) # 15810 <__malloc_current_mallinfo>
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
   1364c:	00892683          	lw	a3,8(s2)
   13650:	408484b3          	sub	s1,s1,s0
   13654:	0014e493          	ori	s1,s1,1
        sbrked_mem -= extra;
   13658:	40878433          	sub	s0,a5,s0
        check_chunk(top);
	MALLOC_UNLOCK;
   1365c:	00098513          	mv	a0,s3
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
   13660:	0096a223          	sw	s1,4(a3)
        sbrked_mem -= extra;
   13664:	8481a823          	sw	s0,-1968(gp) # 15810 <__malloc_current_mallinfo>
        check_chunk(top);
	MALLOC_UNLOCK;
   13668:	9dcff0ef          	jal	12844 <__malloc_unlock>
        return 1;
   1366c:	00100513          	li	a0,1
   13670:	fadff06f          	j	1361c <_malloc_trim_r+0x78>
      new_brk = (char*)(MORECORE (-extra));
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
   13674:	00000513          	li	a0,0
   13678:	d59fc0ef          	jal	103d0 <sbrk>
        top_size = current_brk - (char*)top;
   1367c:	00892703          	lw	a4,8(s2)
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
   13680:	00f00693          	li	a3,15
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
        top_size = current_brk - (char*)top;
   13684:	40e507b3          	sub	a5,a0,a4
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
   13688:	f8f6d4e3          	ble	a5,a3,13610 <_malloc_trim_r+0x6c>
        {
          sbrked_mem = current_brk - sbrk_base;
   1368c:	8141a683          	lw	a3,-2028(gp) # 157d4 <__malloc_sbrk_base>
          set_head(top, top_size | PREV_INUSE);
   13690:	0017e793          	ori	a5,a5,1
   13694:	00f72223          	sw	a5,4(a4)
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
        top_size = current_brk - (char*)top;
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
        {
          sbrked_mem = current_brk - sbrk_base;
   13698:	40d50533          	sub	a0,a0,a3
   1369c:	84a1a823          	sw	a0,-1968(gp) # 15810 <__malloc_current_mallinfo>
   136a0:	f71ff06f          	j	13610 <_malloc_trim_r+0x6c>

000136a4 <_free_r>:
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
   136a4:	0e058e63          	beqz	a1,137a0 <_free_r+0xfc>
#if __STD_C
void fREe(RARG Void_t* mem)
#else
void fREe(RARG mem) RDECL Void_t* mem;
#endif
{
   136a8:	ff010113          	addi	sp,sp,-16
   136ac:	00812423          	sw	s0,8(sp)
   136b0:	00058413          	mv	s0,a1
   136b4:	00912223          	sw	s1,4(sp)
   136b8:	00112623          	sw	ra,12(sp)
   136bc:	00050493          	mv	s1,a0
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
    return;

  MALLOC_LOCK;
   136c0:	980ff0ef          	jal	12840 <__malloc_lock>

  p = mem2chunk(mem);
  hd = p->size;
   136c4:	ffc42503          	lw	a0,-4(s0)
  if (mem == 0)                              /* free(0) has no effect */
    return;

  MALLOC_LOCK;

  p = mem2chunk(mem);
   136c8:	ff840613          	addi	a2,s0,-8
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
   136cc:	000155b7          	lui	a1,0x15
  }
#endif
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
   136d0:	ffe57793          	andi	a5,a0,-2
  next = chunk_at_offset(p, sz);
   136d4:	00f606b3          	add	a3,a2,a5
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
   136d8:	3b058593          	addi	a1,a1,944 # 153b0 <__malloc_av_>
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
   136dc:	0046a703          	lw	a4,4(a3)
  
  if (next == top)                            /* merge with top */
   136e0:	0085a803          	lw	a6,8(a1)
  {
    sz += nextsz;

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
   136e4:	00157513          	andi	a0,a0,1
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
   136e8:	ffc77713          	andi	a4,a4,-4
  
  if (next == top)                            /* merge with top */
   136ec:	15068463          	beq	a3,a6,13834 <_free_r+0x190>
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
    return;
  }

  set_head(next, nextsz);                    /* clear inuse bit */
   136f0:	00e6a223          	sw	a4,4(a3)

  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
   136f4:	02051663          	bnez	a0,13720 <_free_r+0x7c>
  {
    prevsz = p->prev_size;
   136f8:	ff842503          	lw	a0,-8(s0)
    p = chunk_at_offset(p, -prevsz);
   136fc:	40a60633          	sub	a2,a2,a0
    sz += prevsz;
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
   13700:	00862803          	lw	a6,8(a2)

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
  {
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -prevsz);
    sz += prevsz;
   13704:	00a787b3          	add	a5,a5,a0
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
   13708:	00015537          	lui	a0,0x15
   1370c:	3b850513          	addi	a0,a0,952 # 153b8 <__malloc_av_+0x8>
   13710:	16a80663          	beq	a6,a0,1387c <_free_r+0x1d8>
      islr = 1;
    else
      unlink(p, bck, fwd);
   13714:	00c62503          	lw	a0,12(a2)
   13718:	00a82623          	sw	a0,12(a6)
   1371c:	01052423          	sw	a6,8(a0)
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
   13720:	00e68533          	add	a0,a3,a4
   13724:	00452503          	lw	a0,4(a0)
   13728:	00157513          	andi	a0,a0,1
   1372c:	0c050a63          	beqz	a0,13800 <_free_r+0x15c>
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   13730:	0017e693          	ori	a3,a5,1
  set_foot(p, sz);
   13734:	00f60733          	add	a4,a2,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   13738:	00d62223          	sw	a3,4(a2)
  set_foot(p, sz);
   1373c:	00f72023          	sw	a5,0(a4)
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   13740:	1ff00713          	li	a4,511
   13744:	06f76063          	bltu	a4,a5,137a4 <_free_r+0x100>
   13748:	0037d793          	srli	a5,a5,0x3
   1374c:	00178713          	addi	a4,a5,1
   13750:	00371713          	slli	a4,a4,0x3
   13754:	0045a683          	lw	a3,4(a1)
   13758:	00e58733          	add	a4,a1,a4
   1375c:	00072803          	lw	a6,0(a4)
   13760:	4027d793          	srai	a5,a5,0x2
   13764:	00100513          	li	a0,1
   13768:	00f517b3          	sll	a5,a0,a5
   1376c:	00d7e7b3          	or	a5,a5,a3
   13770:	ff870693          	addi	a3,a4,-8
   13774:	00d62623          	sw	a3,12(a2)
   13778:	01062423          	sw	a6,8(a2)
   1377c:	00f5a223          	sw	a5,4(a1)
   13780:	00c72023          	sw	a2,0(a4)
   13784:	00c82623          	sw	a2,12(a6)

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
   13788:	00048513          	mv	a0,s1
    frontlink(p, sz, idx, bck, fwd);  

  MALLOC_UNLOCK;

#endif /* MALLOC_PROVIDED */
}
   1378c:	00c12083          	lw	ra,12(sp)
   13790:	00812403          	lw	s0,8(sp)
   13794:	00412483          	lw	s1,4(sp)
   13798:	01010113          	addi	sp,sp,16

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
   1379c:	8a8ff06f          	j	12844 <__malloc_unlock>
   137a0:	00008067          	ret


  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   137a4:	0097d713          	srli	a4,a5,0x9
   137a8:	00400693          	li	a3,4
   137ac:	10e6e463          	bltu	a3,a4,138b4 <_free_r+0x210>
   137b0:	0067d713          	srli	a4,a5,0x6
   137b4:	03970513          	addi	a0,a4,57
   137b8:	03870693          	addi	a3,a4,56
   137bc:	00151513          	slli	a0,a0,0x1
   137c0:	00251513          	slli	a0,a0,0x2
   137c4:	00a58533          	add	a0,a1,a0
   137c8:	00052703          	lw	a4,0(a0)
   137cc:	ff850513          	addi	a0,a0,-8
   137d0:	0ee50e63          	beq	a0,a4,138cc <_free_r+0x228>
   137d4:	00472683          	lw	a3,4(a4)
   137d8:	ffc6f693          	andi	a3,a3,-4
   137dc:	00d7f663          	bleu	a3,a5,137e8 <_free_r+0x144>
   137e0:	00872703          	lw	a4,8(a4)
   137e4:	fee518e3          	bne	a0,a4,137d4 <_free_r+0x130>
   137e8:	00c72503          	lw	a0,12(a4)
   137ec:	00a62623          	sw	a0,12(a2)
   137f0:	00e62423          	sw	a4,8(a2)
   137f4:	00c52423          	sw	a2,8(a0)
   137f8:	00c72623          	sw	a2,12(a4)
   137fc:	f8dff06f          	j	13788 <_free_r+0xe4>
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
   13800:	0086a503          	lw	a0,8(a3)
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
   13804:	00e787b3          	add	a5,a5,a4
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
   13808:	00015737          	lui	a4,0x15
   1380c:	3b870713          	addi	a4,a4,952 # 153b8 <__malloc_av_+0x8>
   13810:	0ce50e63          	beq	a0,a4,138ec <_free_r+0x248>
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   13814:	00c6a803          	lw	a6,12(a3)
  }


  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
   13818:	00f60733          	add	a4,a2,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   1381c:	0017e693          	ori	a3,a5,1
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   13820:	01052623          	sw	a6,12(a0)
   13824:	00a82423          	sw	a0,8(a6)
  }


  set_head(p, sz | PREV_INUSE);
   13828:	00d62223          	sw	a3,4(a2)
  set_foot(p, sz);
   1382c:	00f72023          	sw	a5,0(a4)
   13830:	f11ff06f          	j	13740 <_free_r+0x9c>
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
  {
    sz += nextsz;
   13834:	00e787b3          	add	a5,a5,a4

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
   13838:	02051063          	bnez	a0,13858 <_free_r+0x1b4>
    {
      prevsz = p->prev_size;
   1383c:	ff842503          	lw	a0,-8(s0)
      p = chunk_at_offset(p, -prevsz);
   13840:	40a60633          	sub	a2,a2,a0
      sz += prevsz;
      unlink(p, bck, fwd);
   13844:	00c62703          	lw	a4,12(a2)
   13848:	00862683          	lw	a3,8(a2)

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
    {
      prevsz = p->prev_size;
      p = chunk_at_offset(p, -prevsz);
      sz += prevsz;
   1384c:	00a787b3          	add	a5,a5,a0
      unlink(p, bck, fwd);
   13850:	00e6a623          	sw	a4,12(a3)
   13854:	00d72423          	sw	a3,8(a4)
    }

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
   13858:	8181a703          	lw	a4,-2024(gp) # 157d8 <__malloc_trim_threshold>
      p = chunk_at_offset(p, -prevsz);
      sz += prevsz;
      unlink(p, bck, fwd);
    }

    set_head(p, sz | PREV_INUSE);
   1385c:	0017e693          	ori	a3,a5,1
   13860:	00d62223          	sw	a3,4(a2)
    top = p;
   13864:	00c5a423          	sw	a2,8(a1)
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
   13868:	f2e7e0e3          	bltu	a5,a4,13788 <_free_r+0xe4>
      malloc_trim(RCALL top_pad); 
   1386c:	82c1a583          	lw	a1,-2004(gp) # 157ec <__malloc_top_pad>
   13870:	00048513          	mv	a0,s1
   13874:	d31ff0ef          	jal	135a4 <_malloc_trim_r>
   13878:	f11ff06f          	j	13788 <_free_r+0xe4>
      islr = 1;
    else
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
   1387c:	00e685b3          	add	a1,a3,a4
   13880:	0045a583          	lw	a1,4(a1)
   13884:	0015f593          	andi	a1,a1,1
   13888:	0e059263          	bnez	a1,1396c <_free_r+0x2c8>
   1388c:	0086a583          	lw	a1,8(a3)
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   13890:	00c6a683          	lw	a3,12(a3)
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
   13894:	00f707b3          	add	a5,a4,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   13898:	0017e513          	ori	a0,a5,1
  set_foot(p, sz);
   1389c:	00f60733          	add	a4,a2,a5
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   138a0:	00d5a623          	sw	a3,12(a1)
   138a4:	00b6a423          	sw	a1,8(a3)
  }


  set_head(p, sz | PREV_INUSE);
   138a8:	00a62223          	sw	a0,4(a2)
  set_foot(p, sz);
   138ac:	00f72023          	sw	a5,0(a4)
   138b0:	ed9ff06f          	j	13788 <_free_r+0xe4>
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   138b4:	01400693          	li	a3,20
   138b8:	04e6ec63          	bltu	a3,a4,13910 <_free_r+0x26c>
   138bc:	05c70513          	addi	a0,a4,92
   138c0:	05b70693          	addi	a3,a4,91
   138c4:	00151513          	slli	a0,a0,0x1
   138c8:	ef9ff06f          	j	137c0 <_free_r+0x11c>
   138cc:	0045a783          	lw	a5,4(a1)
   138d0:	4026d713          	srai	a4,a3,0x2
   138d4:	00100693          	li	a3,1
   138d8:	00e69733          	sll	a4,a3,a4
   138dc:	00f76733          	or	a4,a4,a5
   138e0:	00e5a223          	sw	a4,4(a1)
   138e4:	00050713          	mv	a4,a0
   138e8:	f05ff06f          	j	137ec <_free_r+0x148>
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   138ec:	0017e693          	ori	a3,a5,1
  set_foot(p, sz);
   138f0:	00f60733          	add	a4,a2,a5
    sz += nextsz;
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
    {
      islr = 1;
      link_last_remainder(p);   
   138f4:	00c5aa23          	sw	a2,20(a1)
   138f8:	00c5a823          	sw	a2,16(a1)
   138fc:	00a62623          	sw	a0,12(a2)
   13900:	00a62423          	sw	a0,8(a2)
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   13904:	00d62223          	sw	a3,4(a2)
  set_foot(p, sz);
   13908:	00f72023          	sw	a5,0(a4)
   1390c:	e7dff06f          	j	13788 <_free_r+0xe4>
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   13910:	05400693          	li	a3,84
   13914:	00e6ec63          	bltu	a3,a4,1392c <_free_r+0x288>
   13918:	00c7d713          	srli	a4,a5,0xc
   1391c:	06f70513          	addi	a0,a4,111
   13920:	06e70693          	addi	a3,a4,110
   13924:	00151513          	slli	a0,a0,0x1
   13928:	e99ff06f          	j	137c0 <_free_r+0x11c>
   1392c:	15400693          	li	a3,340
   13930:	00e6ec63          	bltu	a3,a4,13948 <_free_r+0x2a4>
   13934:	00f7d713          	srli	a4,a5,0xf
   13938:	07870513          	addi	a0,a4,120
   1393c:	07770693          	addi	a3,a4,119
   13940:	00151513          	slli	a0,a0,0x1
   13944:	e7dff06f          	j	137c0 <_free_r+0x11c>
   13948:	55400813          	li	a6,1364
   1394c:	0fe00513          	li	a0,254
   13950:	07e00693          	li	a3,126
   13954:	e6e866e3          	bltu	a6,a4,137c0 <_free_r+0x11c>
   13958:	0127d713          	srli	a4,a5,0x12
   1395c:	07d70513          	addi	a0,a4,125
   13960:	07c70693          	addi	a3,a4,124
   13964:	00151513          	slli	a0,a0,0x1
   13968:	e59ff06f          	j	137c0 <_free_r+0x11c>
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   1396c:	0017e693          	ori	a3,a5,1
  set_foot(p, sz);
   13970:	00f60733          	add	a4,a2,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   13974:	00d62223          	sw	a3,4(a2)
  set_foot(p, sz);
   13978:	00f72023          	sw	a5,0(a4)
   1397c:	e0dff06f          	j	13788 <_free_r+0xe4>

00013980 <_fwalk>:

int
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
   13980:	fe010113          	addi	sp,sp,-32
   13984:	01512223          	sw	s5,4(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   13988:	2e050a93          	addi	s5,a0,736

int
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
   1398c:	00112e23          	sw	ra,28(sp)
   13990:	00812c23          	sw	s0,24(sp)
   13994:	00912a23          	sw	s1,20(sp)
   13998:	01212823          	sw	s2,16(sp)
   1399c:	01312623          	sw	s3,12(sp)
   139a0:	01412423          	sw	s4,8(sp)
   139a4:	01612023          	sw	s6,0(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   139a8:	080a8063          	beqz	s5,13a28 <_fwalk+0xa8>
   139ac:	00058b13          	mv	s6,a1
   139b0:	00000a13          	li	s4,0
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   139b4:	00100993          	li	s3,1
   139b8:	fff00913          	li	s2,-1
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   139bc:	004aa483          	lw	s1,4(s5)
   139c0:	008aa403          	lw	s0,8(s5)
   139c4:	fff48493          	addi	s1,s1,-1
   139c8:	0204c663          	bltz	s1,139f4 <_fwalk+0x74>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   139cc:	00c45783          	lhu	a5,12(s0)
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   139d0:	fff48493          	addi	s1,s1,-1
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   139d4:	00f9fc63          	bleu	a5,s3,139ec <_fwalk+0x6c>
   139d8:	00e41783          	lh	a5,14(s0)
	ret |= (*function) (fp);
   139dc:	00040513          	mv	a0,s0
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   139e0:	01278663          	beq	a5,s2,139ec <_fwalk+0x6c>
	ret |= (*function) (fp);
   139e4:	000b00e7          	jalr	s6
   139e8:	00aa6a33          	or	s4,s4,a0
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   139ec:	07040413          	addi	s0,s0,112
   139f0:	fd249ee3          	bne	s1,s2,139cc <_fwalk+0x4c>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   139f4:	000aaa83          	lw	s5,0(s5)
   139f8:	fc0a92e3          	bnez	s5,139bc <_fwalk+0x3c>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*function) (fp);

  return ret;
}
   139fc:	01c12083          	lw	ra,28(sp)
   13a00:	000a0513          	mv	a0,s4
   13a04:	01812403          	lw	s0,24(sp)
   13a08:	01412483          	lw	s1,20(sp)
   13a0c:	01012903          	lw	s2,16(sp)
   13a10:	00c12983          	lw	s3,12(sp)
   13a14:	00812a03          	lw	s4,8(sp)
   13a18:	00412a83          	lw	s5,4(sp)
   13a1c:	00012b03          	lw	s6,0(sp)
   13a20:	02010113          	addi	sp,sp,32
   13a24:	00008067          	ret
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
  register FILE *fp;
  register int n, ret = 0;
   13a28:	00000a13          	li	s4,0
   13a2c:	fd1ff06f          	j	139fc <_fwalk+0x7c>

00013a30 <_fwalk_reent>:
   I/O function (e.g. _fclose_r).  */
int
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
   13a30:	fd010113          	addi	sp,sp,-48
   13a34:	01612823          	sw	s6,16(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   13a38:	2e050b13          	addi	s6,a0,736
   I/O function (e.g. _fclose_r).  */
int
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
   13a3c:	02112623          	sw	ra,44(sp)
   13a40:	02812423          	sw	s0,40(sp)
   13a44:	02912223          	sw	s1,36(sp)
   13a48:	03212023          	sw	s2,32(sp)
   13a4c:	01312e23          	sw	s3,28(sp)
   13a50:	01412c23          	sw	s4,24(sp)
   13a54:	01512a23          	sw	s5,20(sp)
   13a58:	01712623          	sw	s7,12(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   13a5c:	080b0663          	beqz	s6,13ae8 <_fwalk_reent+0xb8>
   13a60:	00058b93          	mv	s7,a1
   13a64:	00050a93          	mv	s5,a0
   13a68:	00000a13          	li	s4,0
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   13a6c:	00100993          	li	s3,1
   13a70:	fff00913          	li	s2,-1
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   13a74:	004b2483          	lw	s1,4(s6)
   13a78:	008b2403          	lw	s0,8(s6)
   13a7c:	fff48493          	addi	s1,s1,-1
   13a80:	0204c863          	bltz	s1,13ab0 <_fwalk_reent+0x80>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   13a84:	00c45783          	lhu	a5,12(s0)
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   13a88:	fff48493          	addi	s1,s1,-1
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   13a8c:	00f9fe63          	bleu	a5,s3,13aa8 <_fwalk_reent+0x78>
   13a90:	00e41783          	lh	a5,14(s0)
	ret |= (*reent_function) (ptr, fp);
   13a94:	00040593          	mv	a1,s0
   13a98:	000a8513          	mv	a0,s5
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   13a9c:	01278663          	beq	a5,s2,13aa8 <_fwalk_reent+0x78>
	ret |= (*reent_function) (ptr, fp);
   13aa0:	000b80e7          	jalr	s7
   13aa4:	00aa6a33          	or	s4,s4,a0
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   13aa8:	07040413          	addi	s0,s0,112
   13aac:	fd249ce3          	bne	s1,s2,13a84 <_fwalk_reent+0x54>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   13ab0:	000b2b03          	lw	s6,0(s6)
   13ab4:	fc0b10e3          	bnez	s6,13a74 <_fwalk_reent+0x44>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*reent_function) (ptr, fp);

  return ret;
}
   13ab8:	02c12083          	lw	ra,44(sp)
   13abc:	000a0513          	mv	a0,s4
   13ac0:	02812403          	lw	s0,40(sp)
   13ac4:	02412483          	lw	s1,36(sp)
   13ac8:	02012903          	lw	s2,32(sp)
   13acc:	01c12983          	lw	s3,28(sp)
   13ad0:	01812a03          	lw	s4,24(sp)
   13ad4:	01412a83          	lw	s5,20(sp)
   13ad8:	01012b03          	lw	s6,16(sp)
   13adc:	00c12b83          	lw	s7,12(sp)
   13ae0:	03010113          	addi	sp,sp,48
   13ae4:	00008067          	ret
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
  register FILE *fp;
  register int n, ret = 0;
   13ae8:	00000a13          	li	s4,0
   13aec:	fcdff06f          	j	13ab8 <_fwalk_reent+0x88>

00013af0 <__smakebuf_r>:
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
   13af0:	00c59783          	lh	a5,12(a1)

_VOID
_DEFUN(__smakebuf_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE *fp)
{
   13af4:	f7010113          	addi	sp,sp,-144
   13af8:	08912223          	sw	s1,132(sp)
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
   13afc:	01079493          	slli	s1,a5,0x10
   13b00:	0104d493          	srli	s1,s1,0x10
   13b04:	0024f713          	andi	a4,s1,2

_VOID
_DEFUN(__smakebuf_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE *fp)
{
   13b08:	08112623          	sw	ra,140(sp)
   13b0c:	08812423          	sw	s0,136(sp)
   13b10:	09212023          	sw	s2,128(sp)
   13b14:	07312e23          	sw	s3,124(sp)
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
   13b18:	0e071063          	bnez	a4,13bf8 <__smakebuf_r+0x108>
   13b1c:	00050913          	mv	s2,a0
      return;
    }
#ifdef __USE_INTERNAL_STAT64
  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
   13b20:	00e59503          	lh	a0,14(a1)
   13b24:	00058413          	mv	s0,a1
   13b28:	04054c63          	bltz	a0,13b80 <__smakebuf_r+0x90>
   13b2c:	00010593          	mv	a1,sp
   13b30:	eb4fc0ef          	jal	101e4 <fstat>
   13b34:	04054063          	bltz	a0,13b74 <__smakebuf_r+0x84>
      fp->_flags |= __SNPT;
#endif
    }
  else
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
   13b38:	01012703          	lw	a4,16(sp)
   13b3c:	0000f7b7          	lui	a5,0xf
   13b40:	ffffe9b7          	lui	s3,0xffffe
   13b44:	00f777b3          	and	a5,a4,a5
   13b48:	013789b3          	add	s3,a5,s3
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
   13b4c:	00008737          	lui	a4,0x8
      fp->_flags |= __SNPT;
#endif
    }
  else
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
   13b50:	0019b993          	seqz	s3,s3
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
   13b54:	0ae78e63          	beq	a5,a4,13c10 <__smakebuf_r+0x120>
#else
	  fp->_blksize = 1024;
#endif
	}
      else
	fp->_flags |= __SNPT;
   13b58:	00c45703          	lhu	a4,12(s0)
   13b5c:	000017b7          	lui	a5,0x1
   13b60:	80078793          	addi	a5,a5,-2048 # 800 <_reset+0x600>
   13b64:	00f767b3          	or	a5,a4,a5
   13b68:	00f41623          	sh	a5,12(s0)
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
#ifdef HAVE_BLKSIZE
      size = st.st_blksize <= 0 ? BUFSIZ : st.st_blksize;
#else
      size = BUFSIZ;
   13b6c:	40000493          	li	s1,1024
   13b70:	0340006f          	j	13ba4 <__smakebuf_r+0xb4>
   13b74:	00c41783          	lh	a5,12(s0)
   13b78:	01079493          	slli	s1,a5,0x10
   13b7c:	0104d493          	srli	s1,s1,0x10
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   13b80:	01849493          	slli	s1,s1,0x18
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   13b84:	00001737          	lui	a4,0x1
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   13b88:	41f4d493          	srai	s1,s1,0x1f
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   13b8c:	80070713          	addi	a4,a4,-2048 # 800 <_reset+0x600>
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   13b90:	c404f493          	andi	s1,s1,-960
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   13b94:	00e7e7b3          	or	a5,a5,a4
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   13b98:	40048493          	addi	s1,s1,1024
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   13b9c:	00f41623          	sh	a5,12(s0)
  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
#endif
    {
      couldbetty = 0;
   13ba0:	00000993          	li	s3,0
	}
      else
	fp->_flags |= __SNPT;
#endif
    }
  if ((p = _malloc_r (ptr, size)) == NULL)
   13ba4:	00048593          	mv	a1,s1
   13ba8:	00090513          	mv	a0,s2
   13bac:	a08fe0ef          	jal	11db4 <_malloc_r>
   13bb0:	0a050263          	beqz	a0,13c54 <__smakebuf_r+0x164>
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
      fp->_flags |= __SMBF;
   13bb4:	00c45783          	lhu	a5,12(s0)
	  fp->_bf._size = 1;
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
   13bb8:	00013737          	lui	a4,0x13
   13bbc:	23870713          	addi	a4,a4,568 # 13238 <_cleanup_r>
      fp->_flags |= __SMBF;
   13bc0:	0807e793          	ori	a5,a5,128
	  fp->_bf._size = 1;
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
   13bc4:	02e92e23          	sw	a4,60(s2)
      fp->_flags |= __SMBF;
   13bc8:	00f41623          	sh	a5,12(s0)
      fp->_bf._base = fp->_p = (unsigned char *) p;
   13bcc:	00a42023          	sw	a0,0(s0)
   13bd0:	00a42823          	sw	a0,16(s0)
      fp->_bf._size = size;
   13bd4:	00942a23          	sw	s1,20(s0)
      if (couldbetty && _isatty_r (ptr, fp->_file))
   13bd8:	06099063          	bnez	s3,13c38 <__smakebuf_r+0x148>
	fp->_flags |= __SLBF;
    }
}
   13bdc:	08c12083          	lw	ra,140(sp)
   13be0:	08812403          	lw	s0,136(sp)
   13be4:	08412483          	lw	s1,132(sp)
   13be8:	08012903          	lw	s2,128(sp)
   13bec:	07c12983          	lw	s3,124(sp)
   13bf0:	09010113          	addi	sp,sp,144
   13bf4:	00008067          	ret
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
    {
      fp->_bf._base = fp->_p = fp->_nbuf;
   13bf8:	04358793          	addi	a5,a1,67
   13bfc:	00f5a023          	sw	a5,0(a1)
   13c00:	00f5a823          	sw	a5,16(a1)
      fp->_bf._size = 1;
   13c04:	00100793          	li	a5,1
   13c08:	00f5aa23          	sw	a5,20(a1)
   13c0c:	fd1ff06f          	j	13bdc <__smakebuf_r+0xec>
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
   13c10:	02842703          	lw	a4,40(s0)
   13c14:	000147b7          	lui	a5,0x14
   13c18:	e5878793          	addi	a5,a5,-424 # 13e58 <__sseek>
   13c1c:	f2f71ee3          	bne	a4,a5,13b58 <__smakebuf_r+0x68>
	{
	  fp->_flags |= __SOPT;
   13c20:	00c45783          	lhu	a5,12(s0)
#ifdef HAVE_BLKSIZE
	  fp->_blksize = st.st_blksize;
#else
	  fp->_blksize = 1024;
   13c24:	40000493          	li	s1,1024
   13c28:	04942623          	sw	s1,76(s0)
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
	{
	  fp->_flags |= __SOPT;
   13c2c:	0097e7b3          	or	a5,a5,s1
   13c30:	00f41623          	sh	a5,12(s0)
#ifdef HAVE_BLKSIZE
	  fp->_blksize = st.st_blksize;
#else
	  fp->_blksize = 1024;
   13c34:	f71ff06f          	j	13ba4 <__smakebuf_r+0xb4>
    {
      ptr->__cleanup = _cleanup_r;
      fp->_flags |= __SMBF;
      fp->_bf._base = fp->_p = (unsigned char *) p;
      fp->_bf._size = size;
      if (couldbetty && _isatty_r (ptr, fp->_file))
   13c38:	00e41503          	lh	a0,14(s0)
   13c3c:	dfcfc0ef          	jal	10238 <isatty>
   13c40:	f8050ee3          	beqz	a0,13bdc <__smakebuf_r+0xec>
	fp->_flags |= __SLBF;
   13c44:	00c45783          	lhu	a5,12(s0)
   13c48:	0017e793          	ori	a5,a5,1
   13c4c:	00f41623          	sh	a5,12(s0)
   13c50:	f8dff06f          	j	13bdc <__smakebuf_r+0xec>
	fp->_flags |= __SNPT;
#endif
    }
  if ((p = _malloc_r (ptr, size)) == NULL)
    {
      if (!(fp->_flags & __SSTR))
   13c54:	00c41783          	lh	a5,12(s0)
   13c58:	2007f713          	andi	a4,a5,512
   13c5c:	f80710e3          	bnez	a4,13bdc <__smakebuf_r+0xec>
	{
	  fp->_flags |= __SNBF;
   13c60:	0027e793          	ori	a5,a5,2
	  fp->_bf._base = fp->_p = fp->_nbuf;
   13c64:	04340713          	addi	a4,s0,67
    }
  if ((p = _malloc_r (ptr, size)) == NULL)
    {
      if (!(fp->_flags & __SSTR))
	{
	  fp->_flags |= __SNBF;
   13c68:	00f41623          	sh	a5,12(s0)
	  fp->_bf._base = fp->_p = fp->_nbuf;
	  fp->_bf._size = 1;
   13c6c:	00100793          	li	a5,1
  if ((p = _malloc_r (ptr, size)) == NULL)
    {
      if (!(fp->_flags & __SSTR))
	{
	  fp->_flags |= __SNBF;
	  fp->_bf._base = fp->_p = fp->_nbuf;
   13c70:	00e42023          	sw	a4,0(s0)
   13c74:	00e42823          	sw	a4,16(s0)
	  fp->_bf._size = 1;
   13c78:	00f42a23          	sw	a5,20(s0)
   13c7c:	f61ff06f          	j	13bdc <__smakebuf_r+0xec>

00013c80 <memset>:
   13c80:	00f00813          	li	a6,15
   13c84:	00050713          	mv	a4,a0
   13c88:	02c87e63          	bleu	a2,a6,13cc4 <memset+0x44>
   13c8c:	00f77793          	andi	a5,a4,15
   13c90:	0a079063          	bnez	a5,13d30 <memset+0xb0>
   13c94:	08059263          	bnez	a1,13d18 <memset+0x98>
   13c98:	ff067693          	andi	a3,a2,-16
   13c9c:	00f67613          	andi	a2,a2,15
   13ca0:	00e686b3          	add	a3,a3,a4
   13ca4:	00b72023          	sw	a1,0(a4)
   13ca8:	00b72223          	sw	a1,4(a4)
   13cac:	00b72423          	sw	a1,8(a4)
   13cb0:	00b72623          	sw	a1,12(a4)
   13cb4:	01070713          	addi	a4,a4,16
   13cb8:	fed766e3          	bltu	a4,a3,13ca4 <memset+0x24>
   13cbc:	00061463          	bnez	a2,13cc4 <memset+0x44>
   13cc0:	00008067          	ret
   13cc4:	40c806b3          	sub	a3,a6,a2
   13cc8:	00269693          	slli	a3,a3,0x2
   13ccc:	00000297          	auipc	t0,0x0
   13cd0:	005686b3          	add	a3,a3,t0
   13cd4:	00c68067          	jr	a3,12
   13cd8:	00b70723          	sb	a1,14(a4)
   13cdc:	00b706a3          	sb	a1,13(a4)
   13ce0:	00b70623          	sb	a1,12(a4)
   13ce4:	00b705a3          	sb	a1,11(a4)
   13ce8:	00b70523          	sb	a1,10(a4)
   13cec:	00b704a3          	sb	a1,9(a4)
   13cf0:	00b70423          	sb	a1,8(a4)
   13cf4:	00b703a3          	sb	a1,7(a4)
   13cf8:	00b70323          	sb	a1,6(a4)
   13cfc:	00b702a3          	sb	a1,5(a4)
   13d00:	00b70223          	sb	a1,4(a4)
   13d04:	00b701a3          	sb	a1,3(a4)
   13d08:	00b70123          	sb	a1,2(a4)
   13d0c:	00b700a3          	sb	a1,1(a4)
   13d10:	00b70023          	sb	a1,0(a4)
   13d14:	00008067          	ret
   13d18:	0ff5f593          	andi	a1,a1,255
   13d1c:	00859693          	slli	a3,a1,0x8
   13d20:	00d5e5b3          	or	a1,a1,a3
   13d24:	01059693          	slli	a3,a1,0x10
   13d28:	00d5e5b3          	or	a1,a1,a3
   13d2c:	f6dff06f          	j	13c98 <memset+0x18>
   13d30:	00279693          	slli	a3,a5,0x2
   13d34:	00000297          	auipc	t0,0x0
   13d38:	005686b3          	add	a3,a3,t0
   13d3c:	00008293          	mv	t0,ra
   13d40:	fa0680e7          	jalr	a3,-96
   13d44:	00028093          	mv	ra,t0
   13d48:	ff078793          	addi	a5,a5,-16
   13d4c:	40f70733          	sub	a4,a4,a5
   13d50:	00f60633          	add	a2,a2,a5
   13d54:	f6c878e3          	bleu	a2,a6,13cc4 <memset+0x44>
   13d58:	f3dff06f          	j	13c94 <memset+0x14>

00013d5c <__sread>:
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   13d5c:	00e59503          	lh	a0,14(a1)
_DEFUN(__sread, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   13d60:	ff010113          	addi	sp,sp,-16
   13d64:	00812423          	sw	s0,8(sp)
   13d68:	00058413          	mv	s0,a1
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   13d6c:	00060593          	mv	a1,a2
   13d70:	00068613          	mv	a2,a3
_DEFUN(__sread, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   13d74:	00112623          	sw	ra,12(sp)
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   13d78:	d9cfc0ef          	jal	10314 <read>
    setmode (fp->_file, oldmode);
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
   13d7c:	02054c63          	bltz	a0,13db4 <__sread+0x58>
    fp->_offset += ret;
   13d80:	05042783          	lw	a5,80(s0)
   13d84:	05442683          	lw	a3,84(s0)
   13d88:	41f55613          	srai	a2,a0,0x1f
   13d8c:	00a785b3          	add	a1,a5,a0
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
  return ret;
}
   13d90:	00c12083          	lw	ra,12(sp)
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
    fp->_offset += ret;
   13d94:	00f5b733          	sltu	a4,a1,a5
   13d98:	00c687b3          	add	a5,a3,a2
   13d9c:	00f707b3          	add	a5,a4,a5
   13da0:	04b42823          	sw	a1,80(s0)
   13da4:	04f42a23          	sw	a5,84(s0)
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
  return ret;
}
   13da8:	00812403          	lw	s0,8(sp)
   13dac:	01010113          	addi	sp,sp,16
   13db0:	00008067          	ret
  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
    fp->_offset += ret;
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
   13db4:	00c45703          	lhu	a4,12(s0)
   13db8:	fffff7b7          	lui	a5,0xfffff
  return ret;
}
   13dbc:	00c12083          	lw	ra,12(sp)
  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
    fp->_offset += ret;
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
   13dc0:	fff78793          	addi	a5,a5,-1 # ffffefff <_gp+0xfffe903f>
   13dc4:	00f777b3          	and	a5,a4,a5
   13dc8:	00f41623          	sh	a5,12(s0)
  return ret;
}
   13dcc:	00812403          	lw	s0,8(sp)
   13dd0:	01010113          	addi	sp,sp,16
   13dd4:	00008067          	ret

00013dd8 <__seofread>:
       _PTR cookie _AND
       char *buf   _AND
       _READ_WRITE_BUFSIZE_TYPE len)
{
  return 0;
}
   13dd8:	00000513          	li	a0,0
   13ddc:	00008067          	ret

00013de0 <__swrite>:
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   13de0:	00c59703          	lh	a4,12(a1)
_DEFUN(__swrite, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char const *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   13de4:	ff010113          	addi	sp,sp,-16
   13de8:	00812423          	sw	s0,8(sp)
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   13dec:	10077793          	andi	a5,a4,256
_DEFUN(__swrite, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char const *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   13df0:	00912223          	sw	s1,4(sp)
   13df4:	01212023          	sw	s2,0(sp)
   13df8:	00112623          	sw	ra,12(sp)
   13dfc:	00058413          	mv	s0,a1
   13e00:	00060493          	mv	s1,a2
   13e04:	00068913          	mv	s2,a3
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   13e08:	00078e63          	beqz	a5,13e24 <__swrite+0x44>
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
   13e0c:	00e59503          	lh	a0,14(a1)
   13e10:	00200713          	li	a4,2
   13e14:	00000613          	li	a2,0
   13e18:	00000693          	li	a3,0
   13e1c:	ca0fc0ef          	jal	102bc <lseek>
   13e20:	00c41703          	lh	a4,12(s0)
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
   13e24:	fffff7b7          	lui	a5,0xfffff
   13e28:	fff78793          	addi	a5,a5,-1 # ffffefff <_gp+0xfffe903f>
   13e2c:	00f777b3          	and	a5,a4,a5
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   13e30:	00e41503          	lh	a0,14(s0)
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
   13e34:	00f41623          	sh	a5,12(s0)
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   13e38:	00090613          	mv	a2,s2
   13e3c:	00048593          	mv	a1,s1
  if (oldmode)
    setmode (fp->_file, oldmode);
#endif

  return w;
}
   13e40:	00c12083          	lw	ra,12(sp)
   13e44:	00812403          	lw	s0,8(sp)
   13e48:	00412483          	lw	s1,4(sp)
   13e4c:	00012903          	lw	s2,0(sp)
   13e50:	01010113          	addi	sp,sp,16
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   13e54:	e9cfc06f          	j	104f0 <write>

00013e58 <__sseek>:
       int whence)
{
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
   13e58:	00e59503          	lh	a0,14(a1)
_DEFUN(__sseek, (ptr, cookie, offset, whence),
       struct _reent *ptr _AND
       void *cookie _AND
       _fpos_t offset _AND
       int whence)
{
   13e5c:	ff010113          	addi	sp,sp,-16
   13e60:	00812423          	sw	s0,8(sp)
   13e64:	00112623          	sw	ra,12(sp)
   13e68:	00058413          	mv	s0,a1
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
   13e6c:	c50fc0ef          	jal	102bc <lseek>
  if (ret == -1L)
   13e70:	fff00793          	li	a5,-1
    fp->_flags &= ~__SOFF;
   13e74:	00c45703          	lhu	a4,12(s0)
{
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
   13e78:	02f50463          	beq	a0,a5,13ea0 <__sseek+0x48>
    {
      fp->_flags |= __SOFF;
      fp->_offset = ret;
    }
  return ret;
}
   13e7c:	00c12083          	lw	ra,12(sp)
  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
    fp->_flags &= ~__SOFF;
  else
    {
      fp->_flags |= __SOFF;
   13e80:	000017b7          	lui	a5,0x1
   13e84:	00f767b3          	or	a5,a4,a5
      fp->_offset = ret;
   13e88:	04a42823          	sw	a0,80(s0)
  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
    fp->_flags &= ~__SOFF;
  else
    {
      fp->_flags |= __SOFF;
   13e8c:	00f41623          	sh	a5,12(s0)
      fp->_offset = ret;
   13e90:	04b42a23          	sw	a1,84(s0)
    }
  return ret;
}
   13e94:	00812403          	lw	s0,8(sp)
   13e98:	01010113          	addi	sp,sp,16
   13e9c:	00008067          	ret
{
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
   13ea0:	fca59ee3          	bne	a1,a0,13e7c <__sseek+0x24>
    fp->_flags &= ~__SOFF;
   13ea4:	fffff7b7          	lui	a5,0xfffff
    {
      fp->_flags |= __SOFF;
      fp->_offset = ret;
    }
  return ret;
}
   13ea8:	00c12083          	lw	ra,12(sp)
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
    fp->_flags &= ~__SOFF;
   13eac:	fff78793          	addi	a5,a5,-1 # ffffefff <_gp+0xfffe903f>
   13eb0:	00f777b3          	and	a5,a4,a5
   13eb4:	00f41623          	sh	a5,12(s0)
    {
      fp->_flags |= __SOFF;
      fp->_offset = ret;
    }
  return ret;
}
   13eb8:	00812403          	lw	s0,8(sp)
   13ebc:	01010113          	addi	sp,sp,16
   13ec0:	00008067          	ret

00013ec4 <__sclose>:
       struct _reent *ptr _AND
       void *cookie)
{
  FILE *fp = (FILE *) cookie;

  return _close_r (ptr, fp->_file);
   13ec4:	00e59503          	lh	a0,14(a1)
   13ec8:	a9cfc06f          	j	10164 <close>

00013ecc <_fclose_r>:
      struct _reent *rptr _AND
      register FILE * fp)
{
  int r;

  if (fp == NULL)
   13ecc:	0e058463          	beqz	a1,13fb4 <_fclose_r+0xe8>

int
_DEFUN(_fclose_r, (rptr, fp),
      struct _reent *rptr _AND
      register FILE * fp)
{
   13ed0:	ff010113          	addi	sp,sp,-16
   13ed4:	00812423          	sw	s0,8(sp)
   13ed8:	00912223          	sw	s1,4(sp)
   13edc:	00112623          	sw	ra,12(sp)
   13ee0:	01212023          	sw	s2,0(sp)
   13ee4:	00050493          	mv	s1,a0
   13ee8:	00058413          	mv	s0,a1
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */

  CHECK_INIT (rptr, fp);
   13eec:	00050663          	beqz	a0,13ef8 <_fclose_r+0x2c>
   13ef0:	03852783          	lw	a5,56(a0)
   13ef4:	0a078063          	beqz	a5,13f94 <_fclose_r+0xc8>
  int __oldcancel;
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  _flockfile (fp);

  if (fp->_flags == 0)		/* not open! */
   13ef8:	00c41783          	lh	a5,12(s0)
      register FILE * fp)
{
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */
   13efc:	00000513          	li	a0,0
  int __oldcancel;
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  _flockfile (fp);

  if (fp->_flags == 0)		/* not open! */
   13f00:	00079e63          	bnez	a5,13f1c <_fclose_r+0x50>
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
}
   13f04:	00c12083          	lw	ra,12(sp)
   13f08:	00812403          	lw	s0,8(sp)
   13f0c:	00412483          	lw	s1,4(sp)
   13f10:	00012903          	lw	s2,0(sp)
   13f14:	01010113          	addi	sp,sp,16
   13f18:	00008067          	ret
  r = (fp->_flags & __SWR) ? __sflush_r (rptr, fp) : 0;
#else
  /* Follow POSIX semantics exactly.  Unconditionally flush to allow
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
   13f1c:	00040593          	mv	a1,s0
   13f20:	00048513          	mv	a0,s1
   13f24:	800ff0ef          	jal	12f24 <__sflush_r>
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
   13f28:	02c42783          	lw	a5,44(s0)
  r = (fp->_flags & __SWR) ? __sflush_r (rptr, fp) : 0;
#else
  /* Follow POSIX semantics exactly.  Unconditionally flush to allow
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
   13f2c:	00050913          	mv	s2,a0
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
   13f30:	00078a63          	beqz	a5,13f44 <_fclose_r+0x78>
   13f34:	01c42583          	lw	a1,28(s0)
   13f38:	00048513          	mv	a0,s1
   13f3c:	000780e7          	jalr	a5
   13f40:	04054e63          	bltz	a0,13f9c <_fclose_r+0xd0>
    r = EOF;
  if (fp->_flags & __SMBF)
   13f44:	00c45783          	lhu	a5,12(s0)
   13f48:	0807f793          	andi	a5,a5,128
   13f4c:	04079c63          	bnez	a5,13fa4 <_fclose_r+0xd8>
    _free_r (rptr, (char *) fp->_bf._base);
  if (HASUB (fp))
   13f50:	03042583          	lw	a1,48(s0)
   13f54:	00058c63          	beqz	a1,13f6c <_fclose_r+0xa0>
    FREEUB (rptr, fp);
   13f58:	04040793          	addi	a5,s0,64
   13f5c:	00f58663          	beq	a1,a5,13f68 <_fclose_r+0x9c>
   13f60:	00048513          	mv	a0,s1
   13f64:	f40ff0ef          	jal	136a4 <_free_r>
   13f68:	02042823          	sw	zero,48(s0)
  if (HASLB (fp))
   13f6c:	04442583          	lw	a1,68(s0)
   13f70:	00058863          	beqz	a1,13f80 <_fclose_r+0xb4>
    FREELB (rptr, fp);
   13f74:	00048513          	mv	a0,s1
   13f78:	f2cff0ef          	jal	136a4 <_free_r>
   13f7c:	04042223          	sw	zero,68(s0)
  __sfp_lock_acquire ();
   13f80:	df4ff0ef          	jal	13574 <__sfp_lock_acquire>
  fp->_flags = 0;		/* release this FILE for reuse */
   13f84:	00041623          	sh	zero,12(s0)
  _funlockfile (fp);
#ifndef __SINGLE_THREAD__
  __lock_close_recursive (fp->_lock);
#endif

  __sfp_lock_release ();
   13f88:	df0ff0ef          	jal	13578 <__sfp_lock_release>
   13f8c:	00090513          	mv	a0,s2
   13f90:	f75ff06f          	j	13f04 <_fclose_r+0x38>
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */

  CHECK_INIT (rptr, fp);
   13f94:	dd0ff0ef          	jal	13564 <__sinit>
   13f98:	f61ff06f          	j	13ef8 <_fclose_r+0x2c>
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
    r = EOF;
   13f9c:	fff00913          	li	s2,-1
   13fa0:	fa5ff06f          	j	13f44 <_fclose_r+0x78>
  if (fp->_flags & __SMBF)
    _free_r (rptr, (char *) fp->_bf._base);
   13fa4:	01042583          	lw	a1,16(s0)
   13fa8:	00048513          	mv	a0,s1
   13fac:	ef8ff0ef          	jal	136a4 <_free_r>
   13fb0:	fa1ff06f          	j	13f50 <_fclose_r+0x84>
      register FILE * fp)
{
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */
   13fb4:	00000513          	li	a0,0
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
}
   13fb8:	00008067          	ret

00013fbc <fclose>:

int
_DEFUN(fclose, (fp),
       register FILE * fp)
{
  return _fclose_r(_REENT, fp);
   13fbc:	00050593          	mv	a1,a0
   13fc0:	8101a503          	lw	a0,-2032(gp) # 157d0 <_impure_ptr>
   13fc4:	f09ff06f          	j	13ecc <_fclose_r>

Disassembly of section .startup:

00000000 <_reset-0x200>:
	...

00000200 <_reset>:
 200:	00100137          	lui	sp,0x100
 204:	00016113          	ori	sp,sp,0
 208:	00012023          	sw	zero,0(sp) # 100000 <_gp+0xea040>
 20c:	fe012e23          	sw	zero,-4(sp)
 210:	00003437          	lui	s0,0x3
 214:	00640413          	addi	s0,s0,6 # 3006 <_reset+0x2e06>
 218:	30041073          	csrw	mstatus,s0
 21c:	10000413          	li	s0,256
 220:	0c042023          	sw	zero,192(s0)
 224:	30141073          	csrw	mtvec,s0
 228:	5d90f06f          	j	10000 <_ftext>
