
intOpsTest:     file format elf32-littleriscv
intOpsTest
architecture: riscv, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000200

Program Header:
    LOAD off    0x00001000 vaddr 0x00000000 paddr 0x00000000 align 2**12
         filesz 0x0000022c memsz 0x0000022c flags r-x
    LOAD off    0x00002000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x0003805c memsz 0x000380c8 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000c55c  00010000  00010000  00002000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       000007f4  0001c560  0001c560  0000e560  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init_array   00000008  0001cd54  0001cd54  0000ed54  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .fini_array   00000004  0001cd5c  0001cd5c  0000ed5c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .eh_frame     000013e0  0001cd60  0001cd60  0000ed60  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .jcr          00000004  0001e140  0001e140  00010140  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00029e90  0001e150  0001e150  00010150  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  7 .sdata        0000007c  00047fe0  00047fe0  00039fe0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  8 .sbss         0000001c  00048060  00048060  0003a05c  2**2
                  ALLOC
  9 .bss          0000004c  0004807c  0004807c  0003a05c  2**2
                  ALLOC
 10 .startup      0000022c  00000000  00000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .comment      00000011  00000000  00000000  0003a05c  2**0
                  CONTENTS, READONLY
 12 .debug_info   00017f45  00000000  00000000  0003a06d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 0000520b  00000000  00000000  00051fb2  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00000570  00000000  00000000  000571bd  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0001103e  00000000  00000000  0005772d  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00002ab5  00000000  00000000  0006876b  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    000117cb  00000000  00000000  0006b220  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00000b50  00000000  00000000  0007c9eb  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
0001c560 l    d  .rodata	00000000 .rodata
0001cd54 l    d  .init_array	00000000 .init_array
0001cd5c l    d  .fini_array	00000000 .fini_array
0001cd60 l    d  .eh_frame	00000000 .eh_frame
0001e140 l    d  .jcr	00000000 .jcr
0001e150 l    d  .data	00000000 .data
00047fe0 l    d  .sdata	00000000 .sdata
00048060 l    d  .sbss	00000000 .sbss
0004807c l    d  .bss	00000000 .bss
00000000 l    d  .startup	00000000 .startup
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 crtstuff.c
0001cd60 l     O .eh_frame	00000000 __EH_FRAME_BEGIN__
0001e140 l     O .jcr	00000000 __JCR_LIST__
0001004c l     F .text	00000000 deregister_tm_clones
00010078 l     F .text	00000000 register_tm_clones
000100b0 l     F .text	00000000 __do_global_dtors_aux
0004807c l     O .bss	00000001 completed.3082
0001cd5c l     O .fini_array	00000000 __do_global_dtors_aux_fini_array_entry
000100f4 l     F .text	00000000 frame_dummy
00048080 l     O .bss	00000018 object.3087
0001cd54 l     O .init_array	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 syscalls.c
00048098 l     O .bss	00000004 heap_end.1982
00000000 l    df *ABS*	00000000 htif.c
000106e4 l     F .text	00000068 htif_tohost
0001074c l     F .text	00000044 htif_fromhost
00000000 l    df *ABS*	00000000 riscv_counters.c
00000000 l    df *ABS*	00000000 ns16550.c
00047fe8 l     O .sdata	00000004 pio
000108d4 l     F .text	000000b0 ns16550_init
00000000 l    df *ABS*	00000000 intOpsTest.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 vfprintf.c
00013e68 l     F .text	000000bc __sbprintf
0001c9f8 l     O .rodata	00000010 blanks.4190
0001ca08 l     O .rodata	00000010 zeroes.4191
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 dtoa.c
00014170 l     F .text	000001e8 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
00015b7c l     F .text	00000008 __fp_unlock
00015b90 l     F .text	0000018c __sinit.part.1
00015d20 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
00047720 l     O .data	00000440 impure_data
00000000 l    df *ABS*	00000000 locale.c
00047b60 l     O .data	00000020 lc_ctype_charset
00047b80 l     O .data	00000020 lc_message_charset
00047ba0 l     O .data	00000038 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 mprec.c
0001ca18 l     O .rodata	0000000c p05.2565
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
00018470 l     F .text	000000e8 __sprint_r.part.0
00019598 l     F .text	000000bc __sbprintf
0001cca4 l     O .rodata	00000010 blanks.4133
0001ccb4 l     O .rodata	00000010 zeroes.4134
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 dp-bit.c
0001a884 l     F .text	00000350 _fpadd_parts
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
0001b970 l     F .text	000001c8 _fpadd_parts
00000000 l    df *ABS*	00000000 crtstuff.c
0001e13c l     O .eh_frame	00000000 __FRAME_END__
0001e140 l     O .jcr	00000000 __JCR_END__
00000000 l    df *ABS*	00000000 
0001cd60 l       .fini_array	00000000 __fini_array_end
0001cd5c l       .fini_array	00000000 __fini_array_start
0001cd5c l       .init_array	00000000 __init_array_end
0001cd54 l       .init_array	00000000 __preinit_array_end
0001cd54 l       .init_array	00000000 __init_array_start
0001cd54 l       .init_array	00000000 __preinit_array_start
00017f84 g     F .text	00000078 _mprec_log10
00018064 g     F .text	00000084 __any_on
0001caf0 g     O .rodata	00000028 __mprec_tinytens
0001b4d4 g     F .text	00000048 .hidden __cmpdf2
0001b5e4 g     F .text	00000004 .hidden __eqdf2
00011620 g     F .text	000004d0 .hidden __divdi3
000120d8 g     F .text	00000050 printf
0001e150 g       .data	00000000 _fdata
0001a6bc g     F .text	00000094 _wcrtomb_r
00018258 g     F .text	00000068 __sseek
00015eb0 g     F .text	00000010 __sinit
0001a54c g     F .text	00000160 __swbuf_r
0001643c g     F .text	00000078 _setlocale_r
00015d28 g     F .text	00000070 __sfmoreglue
000170e0 g     F .text	00000004 __malloc_unlock
0001bfac g     F .text	0000012c .hidden __divsf3
00019ea4 g     F .text	00000120 memmove
00015ea0 g     F .text	00000010 _cleanup
000170e4 g     F .text	000000a4 _Balloc
0001c42c g     F .text	0000008c .hidden __fixsfsi
0001b57c g     F .text	00000004 .hidden __gtdf2
00010838 g     F .text	00000034 read_cycle
00010464 g     F .text	00000024 times
000480c4 g     O .bss	00000004 errno
0001b878 g     F .text	00000030 .hidden __make_dp
000181d8 g     F .text	00000008 __seofread
0001cd54 g       .rodata	00000000 _etext
0001c4f0 g     F .text	0000002c .hidden __make_fp
000487e0 g       *ABS*	00000000 _gp
0001bdb4 g     F .text	00000054 .hidden __subsf3
00010178 g     F .text	00000034 execve
00010208 g     F .text	00000020 getpid
00016ee0 g     F .text	00000120 memcpy
00047fe0 g     O .sdata	00000000 .hidden __TMC_END__
00015b84 g     F .text	0000000c _cleanup_r
0001b638 g     F .text	000000c0 .hidden __floatsidf
0001b5dc g     F .text	00000004 .hidden __ltdf2
000180e8 g     F .text	00000074 __fpclassifyd
00017ed8 g     F .text	000000ac __ratio
00010984 g     F .text	00000034 ns16550_rxready
00000000  w      *UND*	00000000 malloc
00012094 g     F .text	00000044 _printf_r
00010228 g     F .text	00000024 isatty
0001ca28 g     O .rodata	000000c8 __mprec_tens
00010644 g     F .text	000000a0 sleep
000164b4 g     F .text	0000000c __locale_charset
0001c248 g     F .text	00000050 .hidden __lesf2
0004807c g       .bss	00000000 _bss_start
00048078 g     O .sbss	00000004 __malloc_top_pad
000109f8 g     F .text	0000004c ns16550_txchar
00047fe0 g     O .sdata	00000000 .hidden __dso_handle
00047ff4 g     O .sdata	00000004 __mb_cur_max
000164dc g     F .text	0000000c _localeconv_r
0001e150 g     O .data	0000004c opcode_names
00010790 g     F .text	00000040 htif_putc
00019a0c g     F .text	00000498 __sfvwrite_r
000174ec g     F .text	00000034 __i2b
0001ae18 g     F .text	00000120 .hidden __unpack_d
0001970c g     F .text	000000f0 _fclose_r
00015b5c g     F .text	00000020 fflush
00048074 g     O .sbss	00000004 __malloc_max_sbrked_mem
0001c51c g     F .text	00000040 .hidden __extendsfdf2
0001af38 g     F .text	00000050 .hidden __adddf3
0001c2a0 g     F .text	00000004 .hidden __nesf2
00017c64 g     F .text	00000130 __b2d
000102ac g     F .text	0000002c lseek
00047fec g     O .sdata	00000004 _global_impure_ptr
00019fc4 g     F .text	00000588 _realloc_r
00011ff4 g     F .text	000000a0 __libc_init_array
00019968 g     F .text	00000028 _fputwc_r
0001cb18 g     O .rodata	00000028 __mprec_bigtens
000172bc g     F .text	00000104 __s2b
0001b6f8 g     F .text	00000088 .hidden __floatunsidf
00017998 g     F .text	00000060 __mcmp
00015ed0 g     F .text	00000010 __fp_lock_all
0001086c g     F .text	00000034 read_time
00010048 g       .text	00000000 _init
00011f94 g     F .text	00000060 __libc_fini_array
0001bc94 g     F .text	000000d8 .hidden __unpack_f
000173c0 g     F .text	0000007c __hi0bits
0001b780 g     F .text	000000bc .hidden __fixdfsi
000104e0 g     F .text	0000006c write
0001c244 g     F .text	00000004 .hidden __gtsf2
00047fe4 g     O .sdata	00000004 environ
000101d4 g     F .text	00000034 fstat
0001024c g     F .text	00000030 kill
0001b580 g     F .text	00000058 .hidden __ledf2
00017710 g     F .text	00000138 __pow5mult
0004806c g     O .sbss	00000004 __nlocale_changed
00000000  w      *UND*	00000000 __deregister_frame_info
0001bb38 g     F .text	0000015c .hidden __pack_f
00000000  w      *UND*	00000000 _ITM_registerTMCloneTable
0001b900 g     F .text	00000070 .hidden __clzsi2
00015ec0 g     F .text	00000000 __sfp_lock_acquire
00016e0c g     F .text	000000d4 memchr
00015ff0 g     F .text	000002dc _free_r
000104b4 g     F .text	0000002c wait
000164c0 g     F .text	00000008 __locale_mb_cur_max
00048068 g     O .sbss	00000004 __mlocale_changed
00010000 g       .text	00000000 _ftext
00047ff8 g     O .sdata	00000004 __malloc_sbrk_base
00010000 g       .text	00000000 _start
00017848 g     F .text	00000150 __lshift
00010304 g     F .text	000000bc read
0001c2f0 g     F .text	000000a4 .hidden __floatsisf
0001407c g     F .text	000000f4 __register_exitproc
000108a0 g     F .text	00000034 read_instret
00017520 g     F .text	000001f0 __multiply
0004809c g     O .bss	00000028 __malloc_current_mallinfo
00010488 g     F .text	0000002c unlink
0001c2a4 g     F .text	00000004 .hidden __eqsf2
00017d94 g     F .text	00000144 __d2b
0001b3ec g     F .text	000000e8 .hidden __fpcmp_parts_d
0001b83c g     F .text	0000003c .hidden __negdf2
000101ac g     F .text	00000028 fork
00013f28 g     F .text	00000154 __swsetup_r
0001b248 g     F .text	000001a4 .hidden __divdf3
0001c4b8 g     F .text	00000038 .hidden __negsf2
00015d98 g     F .text	00000108 __sfp
00017ffc g     F .text	00000068 __copybits
00047bd8 g     O .data	00000408 __malloc_av_
00015ecc g     F .text	00000004 __sinit_lock_release
0001afe4 g     F .text	00000264 .hidden __muldf3
0001815c g     F .text	0000007c __sread
00048060 g     O .sbss	00000004 __env
0001cce0 g     O .rodata	00000010 .hidden __thenan_sf
000170dc g     F .text	00000004 __malloc_lock
00000000  w      *UND*	00000000 _ITM_deregisterTMCloneTable
000103c0 g     F .text	00000070 sbrk
00015b00 g     F .text	0000005c _fflush_r
00019658 g     F .text	000000b4 _calloc_r
0001c1ac g     F .text	00000040 .hidden __cmpsf2
0002be20 g     O .data	0001b900 test_data64
0001054c g     F .text	000000f8 gettimeofday
00017000 g       .text	00000000 memset
00011300 g     F .text	00000320 main
00048070 g     O .sbss	00000004 __malloc_max_total_mem
0001a6ac g     F .text	00000010 __swbuf
0001c29c g     F .text	00000004 .hidden __ltsf2
000182c4 g     F .text	00000008 __sclose
000197fc g     F .text	0000000c fclose
0001b8a8 g     F .text	00000058 .hidden __truncdfsf2
00014358 g     F .text	00001518 _dtoa_r
00016694 g     F .text	00000778 _malloc_r
0001a7f8 g     F .text	00000030 __ascii_wctomb
000162cc g     F .text	000000b0 _fwalk
0001ccc8 g     O .rodata	00000018 .hidden __thenan_df
00015ef0 g     F .text	00000100 _malloc_trim_r
0001be08 g     F .text	000001a4 .hidden __mulsf3
000182cc g       .text	00000000 strcmp
00019584 g     F .text	00000014 vfiprintf
0001b5e0 g     F .text	00000004 .hidden __nedf2
00010048 g       .text	00000000 _fini
0001c794 g     O .rodata	00000100 .hidden __clz_tab
00048064 g     O .sbss	00000004 _PathLocale
00011f80 g     F .text	00000014 atexit
0001c1ec g     F .text	00000058 .hidden __gesf2
000164e8 g     F .text	00000010 setlocale
00010d38 g     F .text	000005c8 compute64
00047ff0 g     O .sdata	00000004 _impure_ptr
00015870 g     F .text	00000290 __sflush_r
000164d4 g     F .text	00000008 __locale_cjk_lang
00017be8 g     F .text	0000007c __ulp
00015ee0 g     F .text	00000010 __fp_unlock_all
000164f8 g     F .text	00000008 localeconv
00010430 g     F .text	00000034 stat
00000200 g       .startup	00000000 _reset
00047fe0 g       .data	00000000 _edata
0001e19c g     O .data	0000dc80 test_data32
000480c8 g       .bss	00000000 _end
0001c2a8 g     F .text	00000044 .hidden __unordsf2
00019808 g     F .text	00000160 __fputwc
00010a78 g     F .text	000002c0 compute32
000181e0 g     F .text	00000078 __swrite
00047ffc g     O .sdata	00000004 __malloc_trim_threshold
0001027c g     F .text	00000030 link
000164c8 g     F .text	0000000c __locale_msgcharset
00010140 g     F .text	00000014 exit
00018570 g     F .text	00001014 _vfiprintf_r
000107d0 g     F .text	00000068 htif_getc
0001637c g     F .text	000000c0 _fwalk_reent
0001c394 g     F .text	00000098 .hidden __floatunsisf
000179f8 g     F .text	000001f0 __mdiff
00015ec4 g     F .text	00000004 __sfp_lock_release
0001b5e8 g     F .text	0000004c .hidden __unorddf2
00011af0 g     F .text	00000490 .hidden __moddi3
0001c0d8 g     F .text	000000d4 .hidden __fpcmp_parts_f
00016504 g     F .text	00000190 __smakebuf_r
000183e0 g     F .text	00000090 strlen
000102d8 g     F .text	0000002c open
0001b51c g     F .text	00000060 .hidden __gedf2
00048000 g     O .sdata	00000004 __wctomb
00018558 g     F .text	00000018 __sprint_r
00010a44 g     F .text	00000034 ns16550_flush
000109b8 g     F .text	00000040 ns16550_rxchar
0001a828 g     F .text	0000005c _wctomb_r
00000000  w      *UND*	00000000 _Jv_RegisterClasses
0001af88 g     F .text	0000005c .hidden __subdf3
00012128 g     F .text	00001d2c _vfprintf_r
0001743c g     F .text	000000b0 __lo0bits
00048060 g       .sbss	00000000 _fbss
00000000  w      *UND*	00000000 __register_frame_info
0001a750 g     F .text	000000a8 wcrtomb
00010154 g     F .text	00000024 close
0001bd6c g     F .text	00000048 .hidden __addsf3
0001abd4 g     F .text	00000244 .hidden __pack_d
00013e54 g     F .text	00000014 vfprintf
00019990 g     F .text	00000078 fputwc
00015ec8 g     F .text	00000004 __sinit_lock_acquire
000171ac g     F .text	00000110 __multadd
00017188 g     F .text	00000024 _Bfree



Disassembly of section .text:

00010000 <_ftext>:
   10000:	00038197          	auipc	gp,0x38
   10004:	7e018193          	addi	gp,gp,2016 # 487e0 <_gp>
   10008:	00038297          	auipc	t0,0x38
   1000c:	05828293          	addi	t0,t0,88 # 48060 <__env>
   10010:	00038317          	auipc	t1,0x38
   10014:	0b830313          	addi	t1,t1,184 # 480c8 <_end>
   10018:	0002a023          	sw	zero,0(t0)
   1001c:	00428293          	addi	t0,t0,4
   10020:	fe62ece3          	bltu	t0,t1,10018 <_ftext+0x18>
   10024:	00002517          	auipc	a0,0x2
   10028:	f7050513          	addi	a0,a0,-144 # 11f94 <__libc_fini_array>
   1002c:	755010ef          	jal	11f80 <atexit>
   10030:	7c5010ef          	jal	11ff4 <__libc_init_array>
   10034:	00012503          	lw	a0,0(sp)
   10038:	00410593          	addi	a1,sp,4
   1003c:	00000613          	li	a2,0
   10040:	2c0010ef          	jal	11300 <main>
   10044:	0fc0006f          	j	10140 <exit>

00010048 <_fini>:
   10048:	00008067          	ret

0001004c <deregister_tm_clones>:
   1004c:	80018713          	addi	a4,gp,-2048 # 47fe0 <_edata>
   10050:	80318793          	addi	a5,gp,-2045 # 47fe3 <_edata+0x3>
   10054:	40e787b3          	sub	a5,a5,a4
   10058:	00600713          	li	a4,6
   1005c:	00f77c63          	bleu	a5,a4,10074 <deregister_tm_clones+0x28>
   10060:	00000293          	li	t0,0
   10064:	00028863          	beqz	t0,10074 <deregister_tm_clones+0x28>
   10068:	80018513          	addi	a0,gp,-2048 # 47fe0 <_edata>
   1006c:	00028313          	mv	t1,t0
   10070:	00030067          	jr	t1
   10074:	00008067          	ret

00010078 <register_tm_clones>:
   10078:	80018593          	addi	a1,gp,-2048 # 47fe0 <_edata>
   1007c:	80018793          	addi	a5,gp,-2048 # 47fe0 <_edata>
   10080:	40b787b3          	sub	a5,a5,a1
   10084:	4027d793          	srai	a5,a5,0x2
   10088:	01f7d593          	srli	a1,a5,0x1f
   1008c:	00f585b3          	add	a1,a1,a5
   10090:	4015d593          	srai	a1,a1,0x1
   10094:	00058c63          	beqz	a1,100ac <register_tm_clones+0x34>
   10098:	00000293          	li	t0,0
   1009c:	00028863          	beqz	t0,100ac <register_tm_clones+0x34>
   100a0:	80018513          	addi	a0,gp,-2048 # 47fe0 <_edata>
   100a4:	00028313          	mv	t1,t0
   100a8:	00030067          	jr	t1
   100ac:	00008067          	ret

000100b0 <__do_global_dtors_aux>:
   100b0:	ff010113          	addi	sp,sp,-16
   100b4:	00812423          	sw	s0,8(sp)
   100b8:	89c1c783          	lbu	a5,-1892(gp) # 4807c <_bss_start>
   100bc:	00112623          	sw	ra,12(sp)
   100c0:	02079263          	bnez	a5,100e4 <__do_global_dtors_aux+0x34>
   100c4:	f89ff0ef          	jal	1004c <deregister_tm_clones>
   100c8:	00000793          	li	a5,0
   100cc:	00078863          	beqz	a5,100dc <__do_global_dtors_aux+0x2c>
   100d0:	0001d537          	lui	a0,0x1d
   100d4:	d6050513          	addi	a0,a0,-672 # 1cd60 <__fini_array_end>
   100d8:	f29ef0ef          	jal	0 <_reset-0x200>
   100dc:	00100793          	li	a5,1
   100e0:	88f18e23          	sb	a5,-1892(gp) # 4807c <_bss_start>
   100e4:	00c12083          	lw	ra,12(sp)
   100e8:	00812403          	lw	s0,8(sp)
   100ec:	01010113          	addi	sp,sp,16
   100f0:	00008067          	ret

000100f4 <frame_dummy>:
   100f4:	ff010113          	addi	sp,sp,-16
   100f8:	00000793          	li	a5,0
   100fc:	00112623          	sw	ra,12(sp)
   10100:	00078a63          	beqz	a5,10114 <frame_dummy+0x20>
   10104:	0001d537          	lui	a0,0x1d
   10108:	8a018593          	addi	a1,gp,-1888 # 48080 <object.3087>
   1010c:	d6050513          	addi	a0,a0,-672 # 1cd60 <__fini_array_end>
   10110:	ef1ef0ef          	jal	0 <_reset-0x200>
   10114:	0001e537          	lui	a0,0x1e
   10118:	14050513          	addi	a0,a0,320 # 1e140 <__JCR_END__>
   1011c:	00052783          	lw	a5,0(a0)
   10120:	00079863          	bnez	a5,10130 <frame_dummy+0x3c>
   10124:	00c12083          	lw	ra,12(sp)
   10128:	01010113          	addi	sp,sp,16
   1012c:	f4dff06f          	j	10078 <register_tm_clones>
   10130:	00000793          	li	a5,0
   10134:	fe0788e3          	beqz	a5,10124 <frame_dummy+0x30>
   10138:	000780e7          	jalr	a5
   1013c:	fe9ff06f          	j	10124 <frame_dummy+0x30>

00010140 <exit>:
register char * stack_ptr asm ("sp");

#undef errno
int errno;

void exit (int status) {
   10140:	fe010113          	addi	sp,sp,-32
   10144:	00812e23          	sw	s0,28(sp)
   10148:	02010413          	addi	s0,sp,32
   1014c:	fea42623          	sw	a0,-20(s0)
  while (1)
    ;
   10150:	0000006f          	j	10150 <exit+0x10>

00010154 <close>:
}

int close(int file) {
   10154:	fe010113          	addi	sp,sp,-32
   10158:	00812e23          	sw	s0,28(sp)
   1015c:	02010413          	addi	s0,sp,32
   10160:	fea42623          	sw	a0,-20(s0)
  return -1;
   10164:	fff00793          	li	a5,-1
}
   10168:	00078513          	mv	a0,a5
   1016c:	01c12403          	lw	s0,28(sp)
   10170:	02010113          	addi	sp,sp,32
   10174:	00008067          	ret

00010178 <execve>:

char *__env[1] = { 0 };
char **environ = __env;

int execve(char *name, char **argv, char **env) {
   10178:	fe010113          	addi	sp,sp,-32
   1017c:	00812e23          	sw	s0,28(sp)
   10180:	02010413          	addi	s0,sp,32
   10184:	fea42623          	sw	a0,-20(s0)
   10188:	feb42423          	sw	a1,-24(s0)
   1018c:	fec42223          	sw	a2,-28(s0)
  errno = ENOMEM;
   10190:	00c00713          	li	a4,12
   10194:	8ee1a223          	sw	a4,-1820(gp) # 480c4 <errno>
  return -1;
   10198:	fff00793          	li	a5,-1
}
   1019c:	00078513          	mv	a0,a5
   101a0:	01c12403          	lw	s0,28(sp)
   101a4:	02010113          	addi	sp,sp,32
   101a8:	00008067          	ret

000101ac <fork>:

int fork(void) {
   101ac:	ff010113          	addi	sp,sp,-16
   101b0:	00812623          	sw	s0,12(sp)
   101b4:	01010413          	addi	s0,sp,16
  errno = EAGAIN;
   101b8:	00b00713          	li	a4,11
   101bc:	8ee1a223          	sw	a4,-1820(gp) # 480c4 <errno>
  return -1;
   101c0:	fff00793          	li	a5,-1
}
   101c4:	00078513          	mv	a0,a5
   101c8:	00c12403          	lw	s0,12(sp)
   101cc:	01010113          	addi	sp,sp,16
   101d0:	00008067          	ret

000101d4 <fstat>:

int fstat(int file, struct stat *st) {
   101d4:	fe010113          	addi	sp,sp,-32
   101d8:	00812e23          	sw	s0,28(sp)
   101dc:	02010413          	addi	s0,sp,32
   101e0:	fea42623          	sw	a0,-20(s0)
   101e4:	feb42423          	sw	a1,-24(s0)
  st->st_mode = S_IFCHR;
   101e8:	fe842783          	lw	a5,-24(s0)
   101ec:	00002737          	lui	a4,0x2
   101f0:	00e7a823          	sw	a4,16(a5)
  return 0;
   101f4:	00000793          	li	a5,0
}
   101f8:	00078513          	mv	a0,a5
   101fc:	01c12403          	lw	s0,28(sp)
   10200:	02010113          	addi	sp,sp,32
   10204:	00008067          	ret

00010208 <getpid>:

int getpid(void) {
   10208:	ff010113          	addi	sp,sp,-16
   1020c:	00812623          	sw	s0,12(sp)
   10210:	01010413          	addi	s0,sp,16
  return 1;
   10214:	00100793          	li	a5,1
}
   10218:	00078513          	mv	a0,a5
   1021c:	00c12403          	lw	s0,12(sp)
   10220:	01010113          	addi	sp,sp,16
   10224:	00008067          	ret

00010228 <isatty>:

int isatty(int file) {
   10228:	fe010113          	addi	sp,sp,-32
   1022c:	00812e23          	sw	s0,28(sp)
   10230:	02010413          	addi	s0,sp,32
   10234:	fea42623          	sw	a0,-20(s0)
  return 1;
   10238:	00100793          	li	a5,1
}
   1023c:	00078513          	mv	a0,a5
   10240:	01c12403          	lw	s0,28(sp)
   10244:	02010113          	addi	sp,sp,32
   10248:	00008067          	ret

0001024c <kill>:

int kill(int pid, int sig) {
   1024c:	fe010113          	addi	sp,sp,-32
   10250:	00812e23          	sw	s0,28(sp)
   10254:	02010413          	addi	s0,sp,32
   10258:	fea42623          	sw	a0,-20(s0)
   1025c:	feb42423          	sw	a1,-24(s0)
  errno = EINVAL;
   10260:	01600713          	li	a4,22
   10264:	8ee1a223          	sw	a4,-1820(gp) # 480c4 <errno>
  return -1;
   10268:	fff00793          	li	a5,-1
}
   1026c:	00078513          	mv	a0,a5
   10270:	01c12403          	lw	s0,28(sp)
   10274:	02010113          	addi	sp,sp,32
   10278:	00008067          	ret

0001027c <link>:

int link(char *old, char *new) {
   1027c:	fe010113          	addi	sp,sp,-32
   10280:	00812e23          	sw	s0,28(sp)
   10284:	02010413          	addi	s0,sp,32
   10288:	fea42623          	sw	a0,-20(s0)
   1028c:	feb42423          	sw	a1,-24(s0)
  errno = EMLINK;
   10290:	01f00713          	li	a4,31
   10294:	8ee1a223          	sw	a4,-1820(gp) # 480c4 <errno>
  return -1;
   10298:	fff00793          	li	a5,-1
}
   1029c:	00078513          	mv	a0,a5
   102a0:	01c12403          	lw	s0,28(sp)
   102a4:	02010113          	addi	sp,sp,32
   102a8:	00008067          	ret

000102ac <lseek>:

int lseek(int file, int ptr, int dir) {
   102ac:	fe010113          	addi	sp,sp,-32
   102b0:	00812e23          	sw	s0,28(sp)
   102b4:	02010413          	addi	s0,sp,32
   102b8:	fea42623          	sw	a0,-20(s0)
   102bc:	feb42423          	sw	a1,-24(s0)
   102c0:	fec42223          	sw	a2,-28(s0)
  return 0;
   102c4:	00000793          	li	a5,0
}
   102c8:	00078513          	mv	a0,a5
   102cc:	01c12403          	lw	s0,28(sp)
   102d0:	02010113          	addi	sp,sp,32
   102d4:	00008067          	ret

000102d8 <open>:

int open(const char *name, int flags, int mode) {
   102d8:	fe010113          	addi	sp,sp,-32
   102dc:	00812e23          	sw	s0,28(sp)
   102e0:	02010413          	addi	s0,sp,32
   102e4:	fea42623          	sw	a0,-20(s0)
   102e8:	feb42423          	sw	a1,-24(s0)
   102ec:	fec42223          	sw	a2,-28(s0)
  return -1;
   102f0:	fff00793          	li	a5,-1
}
   102f4:	00078513          	mv	a0,a5
   102f8:	01c12403          	lw	s0,28(sp)
   102fc:	02010113          	addi	sp,sp,32
   10300:	00008067          	ret

00010304 <read>:

int read(int file, char *ptr, int len) {
   10304:	fd010113          	addi	sp,sp,-48
   10308:	02112623          	sw	ra,44(sp)
   1030c:	02812423          	sw	s0,40(sp)
   10310:	02912223          	sw	s1,36(sp)
   10314:	03010413          	addi	s0,sp,48
   10318:	fca42e23          	sw	a0,-36(s0)
   1031c:	fcb42c23          	sw	a1,-40(s0)
   10320:	fcc42a23          	sw	a2,-44(s0)
  int todo;
  if(len == 0)
   10324:	fd442783          	lw	a5,-44(s0)
   10328:	00079663          	bnez	a5,10334 <read+0x30>
    return 0;
   1032c:	00000793          	li	a5,0
   10330:	0780006f          	j	103a8 <read+0xa4>
    // note: this is always blocking
    *ptr++ = htif_getc();
  }
#endif
#ifdef CONSOLE_UART
  *ptr++ = ns16550_rxchar();
   10334:	fd842483          	lw	s1,-40(s0)
   10338:	00148793          	addi	a5,s1,1
   1033c:	fcf42c23          	sw	a5,-40(s0)
   10340:	678000ef          	jal	109b8 <ns16550_rxchar>
   10344:	00050793          	mv	a5,a0
   10348:	0ff7f793          	andi	a5,a5,255
   1034c:	00f48023          	sb	a5,0(s1)
  for(todo = 1; todo < len; todo++) {
   10350:	00100793          	li	a5,1
   10354:	fef42623          	sw	a5,-20(s0)
   10358:	0380006f          	j	10390 <read+0x8c>
    if (!ns16550_rxready())
   1035c:	628000ef          	jal	10984 <ns16550_rxready>
   10360:	00050793          	mv	a5,a0
   10364:	02078e63          	beqz	a5,103a0 <read+0x9c>
      break;
    *ptr++ = ns16550_rxchar();
   10368:	fd842483          	lw	s1,-40(s0)
   1036c:	00148793          	addi	a5,s1,1
   10370:	fcf42c23          	sw	a5,-40(s0)
   10374:	644000ef          	jal	109b8 <ns16550_rxchar>
   10378:	00050793          	mv	a5,a0
   1037c:	0ff7f793          	andi	a5,a5,255
   10380:	00f48023          	sb	a5,0(s1)
    *ptr++ = htif_getc();
  }
#endif
#ifdef CONSOLE_UART
  *ptr++ = ns16550_rxchar();
  for(todo = 1; todo < len; todo++) {
   10384:	fec42783          	lw	a5,-20(s0)
   10388:	00178793          	addi	a5,a5,1
   1038c:	fef42623          	sw	a5,-20(s0)
   10390:	fec42703          	lw	a4,-20(s0)
   10394:	fd442783          	lw	a5,-44(s0)
   10398:	fcf742e3          	blt	a4,a5,1035c <read+0x58>
   1039c:	0080006f          	j	103a4 <read+0xa0>
    if (!ns16550_rxready())
      break;
   103a0:	00000013          	nop
    *ptr++ = ns16550_rxchar();
  }
#endif
  return todo;
   103a4:	fec42783          	lw	a5,-20(s0)
}
   103a8:	00078513          	mv	a0,a5
   103ac:	02c12083          	lw	ra,44(sp)
   103b0:	02812403          	lw	s0,40(sp)
   103b4:	02412483          	lw	s1,36(sp)
   103b8:	03010113          	addi	sp,sp,48
   103bc:	00008067          	ret

000103c0 <sbrk>:

caddr_t sbrk(int incr) {
   103c0:	fd010113          	addi	sp,sp,-48
   103c4:	02812623          	sw	s0,44(sp)
   103c8:	03010413          	addi	s0,sp,48
   103cc:	fca42e23          	sw	a0,-36(s0)
  extern char _end;		/* Defined by the linker */
  static char *heap_end;
  char *prev_heap_end;

  if (heap_end == 0) {
   103d0:	8b81a783          	lw	a5,-1864(gp) # 48098 <heap_end.1982>
   103d4:	00079663          	bnez	a5,103e0 <sbrk+0x20>
    heap_end = &_end;
   103d8:	8e818713          	addi	a4,gp,-1816 # 480c8 <_end>
   103dc:	8ae1ac23          	sw	a4,-1864(gp) # 48098 <heap_end.1982>
  }
  prev_heap_end = heap_end;
   103e0:	8b81a783          	lw	a5,-1864(gp) # 48098 <heap_end.1982>
   103e4:	fef42623          	sw	a5,-20(s0)
  if (heap_end + incr > stack_ptr) {
   103e8:	8b81a703          	lw	a4,-1864(gp) # 48098 <heap_end.1982>
   103ec:	fdc42783          	lw	a5,-36(s0)
   103f0:	00f707b3          	add	a5,a4,a5
   103f4:	00010713          	mv	a4,sp
   103f8:	00f77a63          	bleu	a5,a4,1040c <sbrk+0x4c>
    errno = ENOMEM;
   103fc:	00c00713          	li	a4,12
   10400:	8ee1a223          	sw	a4,-1820(gp) # 480c4 <errno>
    return (caddr_t) -1;
   10404:	fff00793          	li	a5,-1
   10408:	0180006f          	j	10420 <sbrk+0x60>
  }

  heap_end += incr;
   1040c:	8b81a703          	lw	a4,-1864(gp) # 48098 <heap_end.1982>
   10410:	fdc42783          	lw	a5,-36(s0)
   10414:	00f70733          	add	a4,a4,a5
   10418:	8ae1ac23          	sw	a4,-1864(gp) # 48098 <heap_end.1982>
  return (caddr_t) prev_heap_end;
   1041c:	fec42783          	lw	a5,-20(s0)
}
   10420:	00078513          	mv	a0,a5
   10424:	02c12403          	lw	s0,44(sp)
   10428:	03010113          	addi	sp,sp,48
   1042c:	00008067          	ret

00010430 <stat>:

int stat(const char *file, struct stat *st) {
   10430:	fe010113          	addi	sp,sp,-32
   10434:	00812e23          	sw	s0,28(sp)
   10438:	02010413          	addi	s0,sp,32
   1043c:	fea42623          	sw	a0,-20(s0)
   10440:	feb42423          	sw	a1,-24(s0)
  st->st_mode = S_IFCHR;
   10444:	fe842783          	lw	a5,-24(s0)
   10448:	00002737          	lui	a4,0x2
   1044c:	00e7a823          	sw	a4,16(a5)
  return 0;
   10450:	00000793          	li	a5,0
}
   10454:	00078513          	mv	a0,a5
   10458:	01c12403          	lw	s0,28(sp)
   1045c:	02010113          	addi	sp,sp,32
   10460:	00008067          	ret

00010464 <times>:

clock_t times(struct tms *buf) {
   10464:	fe010113          	addi	sp,sp,-32
   10468:	00812e23          	sw	s0,28(sp)
   1046c:	02010413          	addi	s0,sp,32
   10470:	fea42623          	sw	a0,-20(s0)
  return -1;
   10474:	fff00793          	li	a5,-1
}
   10478:	00078513          	mv	a0,a5
   1047c:	01c12403          	lw	s0,28(sp)
   10480:	02010113          	addi	sp,sp,32
   10484:	00008067          	ret

00010488 <unlink>:

int unlink(char *name) {
   10488:	fe010113          	addi	sp,sp,-32
   1048c:	00812e23          	sw	s0,28(sp)
   10490:	02010413          	addi	s0,sp,32
   10494:	fea42623          	sw	a0,-20(s0)
  errno = ENOENT;
   10498:	00200713          	li	a4,2
   1049c:	8ee1a223          	sw	a4,-1820(gp) # 480c4 <errno>
  return -1;
   104a0:	fff00793          	li	a5,-1
}
   104a4:	00078513          	mv	a0,a5
   104a8:	01c12403          	lw	s0,28(sp)
   104ac:	02010113          	addi	sp,sp,32
   104b0:	00008067          	ret

000104b4 <wait>:

int wait(int *status) {
   104b4:	fe010113          	addi	sp,sp,-32
   104b8:	00812e23          	sw	s0,28(sp)
   104bc:	02010413          	addi	s0,sp,32
   104c0:	fea42623          	sw	a0,-20(s0)
  errno = ECHILD;
   104c4:	00a00713          	li	a4,10
   104c8:	8ee1a223          	sw	a4,-1820(gp) # 480c4 <errno>
  return -1;
   104cc:	fff00793          	li	a5,-1
}
   104d0:	00078513          	mv	a0,a5
   104d4:	01c12403          	lw	s0,28(sp)
   104d8:	02010113          	addi	sp,sp,32
   104dc:	00008067          	ret

000104e0 <write>:

int write(int file, char *ptr, int len) {
   104e0:	fd010113          	addi	sp,sp,-48
   104e4:	02112623          	sw	ra,44(sp)
   104e8:	02812423          	sw	s0,40(sp)
   104ec:	03010413          	addi	s0,sp,48
   104f0:	fca42e23          	sw	a0,-36(s0)
   104f4:	fcb42c23          	sw	a1,-40(s0)
   104f8:	fcc42a23          	sw	a2,-44(s0)
  for (todo = 0; todo < len; todo++) {
    htif_putc (*ptr++);
  }
#endif
#ifdef CONSOLE_UART
  for (todo = 0; todo < len; todo++) {
   104fc:	fe042623          	sw	zero,-20(s0)
   10500:	0280006f          	j	10528 <write+0x48>
    ns16550_txchar (*ptr++);
   10504:	fd842783          	lw	a5,-40(s0)
   10508:	00178713          	addi	a4,a5,1
   1050c:	fce42c23          	sw	a4,-40(s0)
   10510:	0007c783          	lbu	a5,0(a5)
   10514:	00078513          	mv	a0,a5
   10518:	4e0000ef          	jal	109f8 <ns16550_txchar>
  for (todo = 0; todo < len; todo++) {
    htif_putc (*ptr++);
  }
#endif
#ifdef CONSOLE_UART
  for (todo = 0; todo < len; todo++) {
   1051c:	fec42783          	lw	a5,-20(s0)
   10520:	00178793          	addi	a5,a5,1
   10524:	fef42623          	sw	a5,-20(s0)
   10528:	fec42703          	lw	a4,-20(s0)
   1052c:	fd442783          	lw	a5,-44(s0)
   10530:	fcf74ae3          	blt	a4,a5,10504 <write+0x24>
    ns16550_txchar (*ptr++);
  }
#endif
  return len;
   10534:	fd442783          	lw	a5,-44(s0)
}
   10538:	00078513          	mv	a0,a5
   1053c:	02c12083          	lw	ra,44(sp)
   10540:	02812403          	lw	s0,40(sp)
   10544:	03010113          	addi	sp,sp,48
   10548:	00008067          	ret

0001054c <gettimeofday>:

#define CLOCK_PERIOD  (10000000)

int gettimeofday(struct timeval *ptimeval, void *ptimezone)
{
   1054c:	fd010113          	addi	sp,sp,-48
   10550:	02112623          	sw	ra,44(sp)
   10554:	02812423          	sw	s0,40(sp)
   10558:	03010413          	addi	s0,sp,48
   1055c:	fca42e23          	sw	a0,-36(s0)
   10560:	fcb42c23          	sw	a1,-40(s0)
    if (ptimeval)
   10564:	fdc42583          	lw	a1,-36(s0)
   10568:	0c058263          	beqz	a1,1062c <gettimeofday+0xe0>
#ifdef __riscv64
	asm ("rdtime %0" : "=r" (tv));
#else
	unsigned int tvh;
	unsigned int tvl;
	asm ("rdtime %0;"
   1056c:	c0102573          	rdtime	a0
   10570:	c81025f3          	rdtimeh	a1
   10574:	fea42623          	sw	a0,-20(s0)
   10578:	feb42423          	sw	a1,-24(s0)
	    "rdtimeh %1 " : "=r" (tvl), "=r" (tvh));
	tv = ((long long)tvh) << 32 | tvl;
   1057c:	fe842583          	lw	a1,-24(s0)
   10580:	00058813          	mv	a6,a1
   10584:	00000893          	li	a7,0
   10588:	00081793          	slli	a5,a6,0x0
   1058c:	00000713          	li	a4,0
   10590:	fec42583          	lw	a1,-20(s0)
   10594:	00058613          	mv	a2,a1
   10598:	00000693          	li	a3,0
   1059c:	00c765b3          	or	a1,a4,a2
   105a0:	feb42023          	sw	a1,-32(s0)
   105a4:	00d7e7b3          	or	a5,a5,a3
   105a8:	fef42223          	sw	a5,-28(s0)
#endif
	ptimeval->tv_sec = tv / CLOCK_PERIOD;
   105ac:	fe042703          	lw	a4,-32(s0)
   105b0:	fe442783          	lw	a5,-28(s0)
   105b4:	00989637          	lui	a2,0x989
   105b8:	68060613          	addi	a2,a2,1664 # 989680 <_gp+0x940ea0>
   105bc:	00000693          	li	a3,0
   105c0:	00070513          	mv	a0,a4
   105c4:	00078593          	mv	a1,a5
   105c8:	058010ef          	jal	11620 <__divdi3>
   105cc:	00050713          	mv	a4,a0
   105d0:	00058793          	mv	a5,a1
   105d4:	fdc42683          	lw	a3,-36(s0)
   105d8:	00e6a023          	sw	a4,0(a3)
   105dc:	00f6a223          	sw	a5,4(a3)
	ptimeval->tv_usec = tv % CLOCK_PERIOD / (CLOCK_PERIOD / 1000000);
   105e0:	fe042703          	lw	a4,-32(s0)
   105e4:	fe442783          	lw	a5,-28(s0)
   105e8:	00989637          	lui	a2,0x989
   105ec:	68060613          	addi	a2,a2,1664 # 989680 <_gp+0x940ea0>
   105f0:	00000693          	li	a3,0
   105f4:	00070513          	mv	a0,a4
   105f8:	00078593          	mv	a1,a5
   105fc:	4f4010ef          	jal	11af0 <__moddi3>
   10600:	00050713          	mv	a4,a0
   10604:	00058793          	mv	a5,a1
   10608:	00a00613          	li	a2,10
   1060c:	00000693          	li	a3,0
   10610:	00070513          	mv	a0,a4
   10614:	00078593          	mv	a1,a5
   10618:	008010ef          	jal	11620 <__divdi3>
   1061c:	00050713          	mv	a4,a0
   10620:	00058793          	mv	a5,a1
   10624:	fdc42783          	lw	a5,-36(s0)
   10628:	00e7a423          	sw	a4,8(a5)
    }

    return 0;
   1062c:	00000793          	li	a5,0
}
   10630:	00078513          	mv	a0,a5
   10634:	02c12083          	lw	ra,44(sp)
   10638:	02812403          	lw	s0,40(sp)
   1063c:	03010113          	addi	sp,sp,48
   10640:	00008067          	ret

00010644 <sleep>:

unsigned int sleep(unsigned int seconds)
{
   10644:	fd010113          	addi	sp,sp,-48
   10648:	02112623          	sw	ra,44(sp)
   1064c:	02812423          	sw	s0,40(sp)
   10650:	03212223          	sw	s2,36(sp)
   10654:	03312023          	sw	s3,32(sp)
   10658:	03010413          	addi	s0,sp,48
   1065c:	fca42e23          	sw	a0,-36(s0)
    struct timeval tv;
    gettimeofday(&tv, NULL);
   10660:	fe040793          	addi	a5,s0,-32
   10664:	00000593          	li	a1,0
   10668:	00078513          	mv	a0,a5
   1066c:	ee1ff0ef          	jal	1054c <gettimeofday>
    seconds += tv.tv_sec;
   10670:	fe042703          	lw	a4,-32(s0)
   10674:	fe442783          	lw	a5,-28(s0)
   10678:	fdc42783          	lw	a5,-36(s0)
   1067c:	00e787b3          	add	a5,a5,a4
   10680:	fcf42e23          	sw	a5,-36(s0)

    while (tv.tv_sec < seconds)
   10684:	0140006f          	j	10698 <sleep+0x54>
	gettimeofday(&tv, NULL);
   10688:	fe040793          	addi	a5,s0,-32
   1068c:	00000593          	li	a1,0
   10690:	00078513          	mv	a0,a5
   10694:	eb9ff0ef          	jal	1054c <gettimeofday>
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    seconds += tv.tv_sec;

    while (tv.tv_sec < seconds)
   10698:	fe042703          	lw	a4,-32(s0)
   1069c:	fe442783          	lw	a5,-28(s0)
   106a0:	fdc42683          	lw	a3,-36(s0)
   106a4:	00068913          	mv	s2,a3
   106a8:	00000993          	li	s3,0
   106ac:	00078693          	mv	a3,a5
   106b0:	fd36ece3          	bltu	a3,s3,10688 <sleep+0x44>
   106b4:	00078693          	mv	a3,a5
   106b8:	00d99663          	bne	s3,a3,106c4 <sleep+0x80>
   106bc:	00070793          	mv	a5,a4
   106c0:	fd27e4e3          	bltu	a5,s2,10688 <sleep+0x44>
	gettimeofday(&tv, NULL);

    return 0;
   106c4:	00000793          	li	a5,0
}
   106c8:	00078513          	mv	a0,a5
   106cc:	02c12083          	lw	ra,44(sp)
   106d0:	02812403          	lw	s0,40(sp)
   106d4:	02412903          	lw	s2,36(sp)
   106d8:	02012983          	lw	s3,32(sp)
   106dc:	03010113          	addi	sp,sp,48
   106e0:	00008067          	ret

000106e4 <htif_tohost>:
#define HTIF_CMD_WRITE      (0x01UL)
#define HTIF_CMD_IDENTITY   (0xFFUL)

static inline void htif_tohost(unsigned long dev,
	unsigned long cmd, unsigned long data)
{
   106e4:	fd010113          	addi	sp,sp,-48
   106e8:	02812623          	sw	s0,44(sp)
   106ec:	03010413          	addi	s0,sp,48
   106f0:	fca42e23          	sw	a0,-36(s0)
   106f4:	fcb42c23          	sw	a1,-40(s0)
   106f8:	fcc42a23          	sw	a2,-44(s0)
	unsigned long packet;
	packet = (dev << HTIF_DEV_SHIFT) | (cmd << HTIF_CMD_SHIFT) | data;
   106fc:	fdc42783          	lw	a5,-36(s0)
   10700:	01879713          	slli	a4,a5,0x18
   10704:	fd842783          	lw	a5,-40(s0)
   10708:	01079793          	slli	a5,a5,0x10
   1070c:	00f76733          	or	a4,a4,a5
   10710:	fd442783          	lw	a5,-44(s0)
   10714:	00f767b3          	or	a5,a4,a5
   10718:	fef42623          	sw	a5,-20(s0)
	while (csr_swap(mtohost, packet) != 0);
   1071c:	00000013          	nop
   10720:	fec42783          	lw	a5,-20(s0)
   10724:	fef42423          	sw	a5,-24(s0)
   10728:	fe842783          	lw	a5,-24(s0)
   1072c:	780797f3          	csrrw	a5,mtohost,a5
   10730:	fef42423          	sw	a5,-24(s0)
   10734:	fe842783          	lw	a5,-24(s0)
   10738:	fe0794e3          	bnez	a5,10720 <htif_tohost+0x3c>
}
   1073c:	00000013          	nop
   10740:	02c12403          	lw	s0,44(sp)
   10744:	03010113          	addi	sp,sp,48
   10748:	00008067          	ret

0001074c <htif_fromhost>:

static inline unsigned long htif_fromhost(void)
{
   1074c:	fe010113          	addi	sp,sp,-32
   10750:	00812e23          	sw	s0,28(sp)
   10754:	02010413          	addi	s0,sp,32
	unsigned long data;
	while ((data = csr_swap(mfromhost, 0)) == 0);
   10758:	00000013          	nop
   1075c:	fe042623          	sw	zero,-20(s0)
   10760:	fec42783          	lw	a5,-20(s0)
   10764:	781797f3          	csrrw	a5,mfromhost,a5
   10768:	fef42623          	sw	a5,-20(s0)
   1076c:	fec42783          	lw	a5,-20(s0)
   10770:	fef42423          	sw	a5,-24(s0)
   10774:	fe842783          	lw	a5,-24(s0)
   10778:	fe0782e3          	beqz	a5,1075c <htif_fromhost+0x10>
	return data;
   1077c:	fe842783          	lw	a5,-24(s0)
}
   10780:	00078513          	mv	a0,a5
   10784:	01c12403          	lw	s0,28(sp)
   10788:	02010113          	addi	sp,sp,32
   1078c:	00008067          	ret

00010790 <htif_putc>:

#define HTIF_DEV_CONSOLE        (1U)

void htif_putc(char c)
{
   10790:	fe010113          	addi	sp,sp,-32
   10794:	00112e23          	sw	ra,28(sp)
   10798:	00812c23          	sw	s0,24(sp)
   1079c:	02010413          	addi	s0,sp,32
   107a0:	00050793          	mv	a5,a0
   107a4:	fef407a3          	sb	a5,-17(s0)
    htif_tohost(HTIF_DEV_CONSOLE, HTIF_CMD_WRITE, c);
   107a8:	fef44783          	lbu	a5,-17(s0)
   107ac:	00078613          	mv	a2,a5
   107b0:	00100593          	li	a1,1
   107b4:	00100513          	li	a0,1
   107b8:	f2dff0ef          	jal	106e4 <htif_tohost>
}
   107bc:	00000013          	nop
   107c0:	01c12083          	lw	ra,28(sp)
   107c4:	01812403          	lw	s0,24(sp)
   107c8:	02010113          	addi	sp,sp,32
   107cc:	00008067          	ret

000107d0 <htif_getc>:

char htif_getc(void)
{
   107d0:	fe010113          	addi	sp,sp,-32
   107d4:	00112e23          	sw	ra,28(sp)
   107d8:	00812c23          	sw	s0,24(sp)
   107dc:	02010413          	addi	s0,sp,32
    htif_tohost(HTIF_DEV_CONSOLE, HTIF_CMD_READ, 0);
   107e0:	00000613          	li	a2,0
   107e4:	00000593          	li	a1,0
   107e8:	00100513          	li	a0,1
   107ec:	ef9ff0ef          	jal	106e4 <htif_tohost>

    // poll interrupt
    unsigned long mip = csr_read(mip);
   107f0:	344027f3          	csrr	a5,mip
   107f4:	00078093          	mv	ra,a5
   107f8:	00008793          	mv	a5,ra
   107fc:	fef42623          	sw	a5,-20(s0)
    while (!(mip & 0x40000000))
   10800:	00000013          	nop
   10804:	fec42703          	lw	a4,-20(s0)
   10808:	400007b7          	lui	a5,0x40000
   1080c:	00f777b3          	and	a5,a4,a5
   10810:	fe078ae3          	beqz	a5,10804 <htif_getc+0x34>
	;  // nothing

    unsigned long data = htif_fromhost();
   10814:	f39ff0ef          	jal	1074c <htif_fromhost>
   10818:	fea42423          	sw	a0,-24(s0)
    return data;
   1081c:	fe842783          	lw	a5,-24(s0)
   10820:	0ff7f793          	andi	a5,a5,255
}
   10824:	00078513          	mv	a0,a5
   10828:	01c12083          	lw	ra,28(sp)
   1082c:	01812403          	lw	s0,24(sp)
   10830:	02010113          	addi	sp,sp,32
   10834:	00008067          	ret

00010838 <read_cycle>:
// The following are interfaces to inline RISC-V assembly instructions
//     RDCYCLE, RDTIME, RDINSTRET
// For all of them, the result is left in v0 (= x2) per calling convention

uint64_t  read_cycle (void)
{
   10838:	fe010113          	addi	sp,sp,-32
   1083c:	00812e23          	sw	s0,28(sp)
   10840:	02010413          	addi	s0,sp,32
    uint64_t result;

    asm volatile ("RDCYCLE %0" : "=r" (result));
   10844:	c0002773          	rdcycle	a4
   10848:	fee42423          	sw	a4,-24(s0)
   1084c:	fef42623          	sw	a5,-20(s0)
    return result;
   10850:	fe842703          	lw	a4,-24(s0)
   10854:	fec42783          	lw	a5,-20(s0)
}
   10858:	00070513          	mv	a0,a4
   1085c:	00078593          	mv	a1,a5
   10860:	01c12403          	lw	s0,28(sp)
   10864:	02010113          	addi	sp,sp,32
   10868:	00008067          	ret

0001086c <read_time>:

uint64_t  read_time (void)
{
   1086c:	fe010113          	addi	sp,sp,-32
   10870:	00812e23          	sw	s0,28(sp)
   10874:	02010413          	addi	s0,sp,32
    uint64_t result;

    asm volatile ("RDTIME %0" : "=r" (result));
   10878:	c0102773          	rdtime	a4
   1087c:	fee42423          	sw	a4,-24(s0)
   10880:	fef42623          	sw	a5,-20(s0)
    return result;
   10884:	fe842703          	lw	a4,-24(s0)
   10888:	fec42783          	lw	a5,-20(s0)
}
   1088c:	00070513          	mv	a0,a4
   10890:	00078593          	mv	a1,a5
   10894:	01c12403          	lw	s0,28(sp)
   10898:	02010113          	addi	sp,sp,32
   1089c:	00008067          	ret

000108a0 <read_instret>:

uint64_t  read_instret (void)
{
   108a0:	fe010113          	addi	sp,sp,-32
   108a4:	00812e23          	sw	s0,28(sp)
   108a8:	02010413          	addi	s0,sp,32
    uint64_t result;

    asm volatile ("RDINSTRET %0" : "=r" (result));
   108ac:	c0202773          	rdinstret	a4
   108b0:	fee42423          	sw	a4,-24(s0)
   108b4:	fef42623          	sw	a5,-20(s0)
    return result;
   108b8:	fe842703          	lw	a4,-24(s0)
   108bc:	fec42783          	lw	a5,-20(s0)
}
   108c0:	00070513          	mv	a0,a4
   108c4:	00078593          	mv	a1,a5
   108c8:	01c12403          	lw	s0,28(sp)
   108cc:	02010113          	addi	sp,sp,32
   108d0:	00008067          	ret

000108d4 <ns16550_init>:
static struct ns16550_pio * pio = (void*)NS16550_BASE;

#ifdef CONSOLE_UART
__attribute__ ((constructor))
static int ns16550_init(void)
{
   108d4:	fe010113          	addi	sp,sp,-32
   108d8:	00812e23          	sw	s0,28(sp)
   108dc:	02010413          	addi	s0,sp,32
  uint32_t divisor;

  pio->ier = 0;
   108e0:	8081a783          	lw	a5,-2040(gp) # 47fe8 <pio>
   108e4:	00078223          	sb	zero,4(a5) # 40000004 <_gp+0x3ffb7824>

  divisor = NS16550_CLOCK_RATE / (16 * DEFAULT_BAUDRATE);
   108e8:	01a00793          	li	a5,26
   108ec:	fef42623          	sw	a5,-20(s0)
  pio->lcr |= LCR_DLAB;
   108f0:	8081a783          	lw	a5,-2040(gp) # 47fe8 <pio>
   108f4:	8081a703          	lw	a4,-2040(gp) # 47fe8 <pio>
   108f8:	00c74703          	lbu	a4,12(a4) # 200c <_reset+0x1e0c>
   108fc:	0ff77713          	andi	a4,a4,255
   10900:	f8076713          	ori	a4,a4,-128
   10904:	0ff77713          	andi	a4,a4,255
   10908:	00e78623          	sb	a4,12(a5)
  pio->dll = divisor & 0xff;
   1090c:	8081a783          	lw	a5,-2040(gp) # 47fe8 <pio>
   10910:	fec42703          	lw	a4,-20(s0)
   10914:	0ff77713          	andi	a4,a4,255
   10918:	00e78023          	sb	a4,0(a5)
  pio->dlm = (divisor >> 8) & 0xff;
   1091c:	8081a783          	lw	a5,-2040(gp) # 47fe8 <pio>
   10920:	fec42703          	lw	a4,-20(s0)
   10924:	00875713          	srli	a4,a4,0x8
   10928:	0ff77713          	andi	a4,a4,255
   1092c:	00e78223          	sb	a4,4(a5)
  pio->lcr &= ~LCR_DLAB;
   10930:	8081a783          	lw	a5,-2040(gp) # 47fe8 <pio>
   10934:	8081a703          	lw	a4,-2040(gp) # 47fe8 <pio>
   10938:	00c74703          	lbu	a4,12(a4)
   1093c:	0ff77713          	andi	a4,a4,255
   10940:	07f77713          	andi	a4,a4,127
   10944:	0ff77713          	andi	a4,a4,255
   10948:	00e78623          	sb	a4,12(a5)

  pio->lcr = LCR_WLS8;
   1094c:	8081a783          	lw	a5,-2040(gp) # 47fe8 <pio>
   10950:	00300713          	li	a4,3
   10954:	00e78623          	sb	a4,12(a5)
  pio->fcr = FCR_FE;
   10958:	8081a783          	lw	a5,-2040(gp) # 47fe8 <pio>
   1095c:	00100713          	li	a4,1
   10960:	00e78423          	sb	a4,8(a5)
  pio->mcr = MCR_RTS;
   10964:	8081a783          	lw	a5,-2040(gp) # 47fe8 <pio>
   10968:	00200713          	li	a4,2
   1096c:	00e78823          	sb	a4,16(a5)

  return 0;
   10970:	00000793          	li	a5,0
}
   10974:	00078513          	mv	a0,a5
   10978:	01c12403          	lw	s0,28(sp)
   1097c:	02010113          	addi	sp,sp,32
   10980:	00008067          	ret

00010984 <ns16550_rxready>:
#endif


int ns16550_rxready(void)
{
   10984:	ff010113          	addi	sp,sp,-16
   10988:	00812623          	sw	s0,12(sp)
   1098c:	01010413          	addi	s0,sp,16
  return (pio->lsr & LSR_DR) != 0;
   10990:	8081a783          	lw	a5,-2040(gp) # 47fe8 <pio>
   10994:	0147c783          	lbu	a5,20(a5)
   10998:	0ff7f793          	andi	a5,a5,255
   1099c:	0017f793          	andi	a5,a5,1
   109a0:	00f037b3          	snez	a5,a5
   109a4:	0ff7f793          	andi	a5,a5,255
}
   109a8:	00078513          	mv	a0,a5
   109ac:	00c12403          	lw	s0,12(sp)
   109b0:	01010113          	addi	sp,sp,16
   109b4:	00008067          	ret

000109b8 <ns16550_rxchar>:


int ns16550_rxchar(void)
{
   109b8:	ff010113          	addi	sp,sp,-16
   109bc:	00812623          	sw	s0,12(sp)
   109c0:	01010413          	addi	s0,sp,16
  while ((pio->lsr & LSR_DR) == 0)
   109c4:	00000013          	nop
   109c8:	8081a783          	lw	a5,-2040(gp) # 47fe8 <pio>
   109cc:	0147c783          	lbu	a5,20(a5)
   109d0:	0ff7f793          	andi	a5,a5,255
   109d4:	0017f793          	andi	a5,a5,1
   109d8:	fe0788e3          	beqz	a5,109c8 <ns16550_rxchar+0x10>
    ;  // nothing

  return pio->rbr;
   109dc:	8081a783          	lw	a5,-2040(gp) # 47fe8 <pio>
   109e0:	0007c783          	lbu	a5,0(a5)
   109e4:	0ff7f793          	andi	a5,a5,255
}
   109e8:	00078513          	mv	a0,a5
   109ec:	00c12403          	lw	s0,12(sp)
   109f0:	01010113          	addi	sp,sp,16
   109f4:	00008067          	ret

000109f8 <ns16550_txchar>:


int ns16550_txchar(int c)
{
   109f8:	fe010113          	addi	sp,sp,-32
   109fc:	00812e23          	sw	s0,28(sp)
   10a00:	02010413          	addi	s0,sp,32
   10a04:	fea42623          	sw	a0,-20(s0)
  while ((pio->lsr & LSR_THRE) == 0)
   10a08:	00000013          	nop
   10a0c:	8081a783          	lw	a5,-2040(gp) # 47fe8 <pio>
   10a10:	0147c783          	lbu	a5,20(a5)
   10a14:	0ff7f793          	andi	a5,a5,255
   10a18:	0207f793          	andi	a5,a5,32
   10a1c:	fe0788e3          	beqz	a5,10a0c <ns16550_txchar+0x14>
    ;  // nothing

  pio->thr = c;
   10a20:	8081a783          	lw	a5,-2040(gp) # 47fe8 <pio>
   10a24:	fec42703          	lw	a4,-20(s0)
   10a28:	0ff77713          	andi	a4,a4,255
   10a2c:	00e78023          	sb	a4,0(a5)

  return c;
   10a30:	fec42783          	lw	a5,-20(s0)
}
   10a34:	00078513          	mv	a0,a5
   10a38:	01c12403          	lw	s0,28(sp)
   10a3c:	02010113          	addi	sp,sp,32
   10a40:	00008067          	ret

00010a44 <ns16550_flush>:


void ns16550_flush(void)
{
   10a44:	ff010113          	addi	sp,sp,-16
   10a48:	00812623          	sw	s0,12(sp)
   10a4c:	01010413          	addi	s0,sp,16
  while ((pio->lsr & LSR_TEMT) == 0)
   10a50:	00000013          	nop
   10a54:	8081a783          	lw	a5,-2040(gp) # 47fe8 <pio>
   10a58:	0147c783          	lbu	a5,20(a5)
   10a5c:	0ff7f793          	andi	a5,a5,255
   10a60:	0407f793          	andi	a5,a5,64
   10a64:	fe0788e3          	beqz	a5,10a54 <ns16550_flush+0x10>
    ;  // nothing
}
   10a68:	00000013          	nop
   10a6c:	00c12403          	lw	s0,12(sp)
   10a70:	01010113          	addi	sp,sp,16
   10a74:	00008067          	ret

00010a78 <compute32>:
		uint32_t shamt,
		uint32_t u1,
		uint32_t u2,
		uint32_t *p_noop,
		uint32_t *p_result)
{
   10a78:	fc010113          	addi	sp,sp,-64
   10a7c:	02812e23          	sw	s0,60(sp)
   10a80:	04010413          	addi	s0,sp,64
   10a84:	fca42e23          	sw	a0,-36(s0)
   10a88:	fcb42c23          	sw	a1,-40(s0)
   10a8c:	fcc42a23          	sw	a2,-44(s0)
   10a90:	fcd42823          	sw	a3,-48(s0)
   10a94:	fce42623          	sw	a4,-52(s0)
   10a98:	fcf42423          	sw	a5,-56(s0)
    int32_t i1 = u1;
   10a9c:	fd442783          	lw	a5,-44(s0)
   10aa0:	fef42623          	sw	a5,-20(s0)
    int32_t i2 = u2;
   10aa4:	fd042783          	lw	a5,-48(s0)
   10aa8:	fef42423          	sw	a5,-24(s0)
    uint32_t result;

    *p_noop = False;
   10aac:	fcc42783          	lw	a5,-52(s0)
   10ab0:	0007a023          	sw	zero,0(a5)
    switch (op) {
   10ab4:	fdc42703          	lw	a4,-36(s0)
   10ab8:	01100793          	li	a5,17
   10abc:	24e7ee63          	bltu	a5,a4,10d18 <compute32+0x2a0>
   10ac0:	fdc42783          	lw	a5,-36(s0)
   10ac4:	00279713          	slli	a4,a5,0x2
   10ac8:	0001c7b7          	lui	a5,0x1c
   10acc:	5d478793          	addi	a5,a5,1492 # 1c5d4 <__extendsfdf2+0xb8>
   10ad0:	00f707b3          	add	a5,a4,a5
   10ad4:	0007a783          	lw	a5,0(a5)
   10ad8:	00078067          	jr	a5
    case OP_EQ:  *p_result = (i1 == i2); break;
   10adc:	fec42703          	lw	a4,-20(s0)
   10ae0:	fe842783          	lw	a5,-24(s0)
   10ae4:	40f707b3          	sub	a5,a4,a5
   10ae8:	0017b793          	seqz	a5,a5
   10aec:	0ff7f793          	andi	a5,a5,255
   10af0:	00078713          	mv	a4,a5
   10af4:	fc842783          	lw	a5,-56(s0)
   10af8:	00e7a023          	sw	a4,0(a5)
   10afc:	22c0006f          	j	10d28 <compute32+0x2b0>
    case OP_NE:  *p_result = (i1 != i2); break;
   10b00:	fec42703          	lw	a4,-20(s0)
   10b04:	fe842783          	lw	a5,-24(s0)
   10b08:	40f707b3          	sub	a5,a4,a5
   10b0c:	00f037b3          	snez	a5,a5
   10b10:	0ff7f793          	andi	a5,a5,255
   10b14:	00078713          	mv	a4,a5
   10b18:	fc842783          	lw	a5,-56(s0)
   10b1c:	00e7a023          	sw	a4,0(a5)
   10b20:	2080006f          	j	10d28 <compute32+0x2b0>
    case OP_LT:  *p_result = (i1 <  i2); break;
   10b24:	fec42703          	lw	a4,-20(s0)
   10b28:	fe842783          	lw	a5,-24(s0)
   10b2c:	00f727b3          	slt	a5,a4,a5
   10b30:	0ff7f793          	andi	a5,a5,255
   10b34:	00078713          	mv	a4,a5
   10b38:	fc842783          	lw	a5,-56(s0)
   10b3c:	00e7a023          	sw	a4,0(a5)
   10b40:	1e80006f          	j	10d28 <compute32+0x2b0>
    case OP_GE:  *p_result = (i1 >= i2); break;
   10b44:	fec42703          	lw	a4,-20(s0)
   10b48:	fe842783          	lw	a5,-24(s0)
   10b4c:	00f727b3          	slt	a5,a4,a5
   10b50:	0017c793          	xori	a5,a5,1
   10b54:	0ff7f793          	andi	a5,a5,255
   10b58:	00078713          	mv	a4,a5
   10b5c:	fc842783          	lw	a5,-56(s0)
   10b60:	00e7a023          	sw	a4,0(a5)
   10b64:	1c40006f          	j	10d28 <compute32+0x2b0>
    case OP_LTU: *p_result = (u1 <  u2); break;
   10b68:	fd442703          	lw	a4,-44(s0)
   10b6c:	fd042783          	lw	a5,-48(s0)
   10b70:	00f737b3          	sltu	a5,a4,a5
   10b74:	0ff7f793          	andi	a5,a5,255
   10b78:	00078713          	mv	a4,a5
   10b7c:	fc842783          	lw	a5,-56(s0)
   10b80:	00e7a023          	sw	a4,0(a5)
   10b84:	1a40006f          	j	10d28 <compute32+0x2b0>
    case OP_GEU: *p_result = (u1 >= u2); break;
   10b88:	fd442703          	lw	a4,-44(s0)
   10b8c:	fd042783          	lw	a5,-48(s0)
   10b90:	00f737b3          	sltu	a5,a4,a5
   10b94:	0017c793          	xori	a5,a5,1
   10b98:	0ff7f793          	andi	a5,a5,255
   10b9c:	00078713          	mv	a4,a5
   10ba0:	fc842783          	lw	a5,-56(s0)
   10ba4:	00e7a023          	sw	a4,0(a5)
   10ba8:	1800006f          	j	10d28 <compute32+0x2b0>

    case OP_ADD: *p_result = (i1 + i2); break;
   10bac:	fec42703          	lw	a4,-20(s0)
   10bb0:	fe842783          	lw	a5,-24(s0)
   10bb4:	00f707b3          	add	a5,a4,a5
   10bb8:	00078713          	mv	a4,a5
   10bbc:	fc842783          	lw	a5,-56(s0)
   10bc0:	00e7a023          	sw	a4,0(a5)
   10bc4:	1640006f          	j	10d28 <compute32+0x2b0>
    case OP_SUB: *p_result = (i1 - i2); break;
   10bc8:	fec42703          	lw	a4,-20(s0)
   10bcc:	fe842783          	lw	a5,-24(s0)
   10bd0:	40f707b3          	sub	a5,a4,a5
   10bd4:	00078713          	mv	a4,a5
   10bd8:	fc842783          	lw	a5,-56(s0)
   10bdc:	00e7a023          	sw	a4,0(a5)
   10be0:	1480006f          	j	10d28 <compute32+0x2b0>

    case OP_LOGICAL_AND: *p_result = (u1 && u2); break;
   10be4:	fd442783          	lw	a5,-44(s0)
   10be8:	00078a63          	beqz	a5,10bfc <compute32+0x184>
   10bec:	fd042783          	lw	a5,-48(s0)
   10bf0:	00078663          	beqz	a5,10bfc <compute32+0x184>
   10bf4:	00100793          	li	a5,1
   10bf8:	0080006f          	j	10c00 <compute32+0x188>
   10bfc:	00000793          	li	a5,0
   10c00:	00078713          	mv	a4,a5
   10c04:	fc842783          	lw	a5,-56(s0)
   10c08:	00e7a023          	sw	a4,0(a5)
   10c0c:	11c0006f          	j	10d28 <compute32+0x2b0>
    case OP_LOGICAL_OR:  *p_result = (u1 || u2); break;
   10c10:	fd442783          	lw	a5,-44(s0)
   10c14:	00079663          	bnez	a5,10c20 <compute32+0x1a8>
   10c18:	fd042783          	lw	a5,-48(s0)
   10c1c:	00078663          	beqz	a5,10c28 <compute32+0x1b0>
   10c20:	00100793          	li	a5,1
   10c24:	0080006f          	j	10c2c <compute32+0x1b4>
   10c28:	00000793          	li	a5,0
   10c2c:	00078713          	mv	a4,a5
   10c30:	fc842783          	lw	a5,-56(s0)
   10c34:	00e7a023          	sw	a4,0(a5)
   10c38:	0f00006f          	j	10d28 <compute32+0x2b0>
    case OP_LOGICAL_NOT: *p_result = ! (u1); break;
   10c3c:	fd442783          	lw	a5,-44(s0)
   10c40:	0017b793          	seqz	a5,a5
   10c44:	0ff7f793          	andi	a5,a5,255
   10c48:	00078713          	mv	a4,a5
   10c4c:	fc842783          	lw	a5,-56(s0)
   10c50:	00e7a023          	sw	a4,0(a5)
   10c54:	0d40006f          	j	10d28 <compute32+0x2b0>

    case OP_AND: *p_result = (u1 & u2); break;
   10c58:	fd442703          	lw	a4,-44(s0)
   10c5c:	fd042783          	lw	a5,-48(s0)
   10c60:	00f77733          	and	a4,a4,a5
   10c64:	fc842783          	lw	a5,-56(s0)
   10c68:	00e7a023          	sw	a4,0(a5)
   10c6c:	0bc0006f          	j	10d28 <compute32+0x2b0>
    case OP_OR:  *p_result = (u1 | u2); break;
   10c70:	fd442703          	lw	a4,-44(s0)
   10c74:	fd042783          	lw	a5,-48(s0)
   10c78:	00f76733          	or	a4,a4,a5
   10c7c:	fc842783          	lw	a5,-56(s0)
   10c80:	00e7a023          	sw	a4,0(a5)
   10c84:	0a40006f          	j	10d28 <compute32+0x2b0>
    case OP_XOR: *p_result = (u1 ^ u2); break;
   10c88:	fd442703          	lw	a4,-44(s0)
   10c8c:	fd042783          	lw	a5,-48(s0)
   10c90:	00f74733          	xor	a4,a4,a5
   10c94:	fc842783          	lw	a5,-56(s0)
   10c98:	00e7a023          	sw	a4,0(a5)
   10c9c:	08c0006f          	j	10d28 <compute32+0x2b0>
    case OP_NOT: *p_result = ~u1;       break;
   10ca0:	fd442783          	lw	a5,-44(s0)
   10ca4:	fff7c713          	not	a4,a5
   10ca8:	fc842783          	lw	a5,-56(s0)
   10cac:	00e7a023          	sw	a4,0(a5)
   10cb0:	0780006f          	j	10d28 <compute32+0x2b0>

    case OP_SLL: u2 = shamt; *p_result = (u1 << u2); break;
   10cb4:	fd842783          	lw	a5,-40(s0)
   10cb8:	fcf42823          	sw	a5,-48(s0)
   10cbc:	fd442703          	lw	a4,-44(s0)
   10cc0:	fd042783          	lw	a5,-48(s0)
   10cc4:	00f71733          	sll	a4,a4,a5
   10cc8:	fc842783          	lw	a5,-56(s0)
   10ccc:	00e7a023          	sw	a4,0(a5)
   10cd0:	0580006f          	j	10d28 <compute32+0x2b0>
    case OP_SRL: u2 = shamt; *p_result = (u1 >> u2); break;
   10cd4:	fd842783          	lw	a5,-40(s0)
   10cd8:	fcf42823          	sw	a5,-48(s0)
   10cdc:	fd442703          	lw	a4,-44(s0)
   10ce0:	fd042783          	lw	a5,-48(s0)
   10ce4:	00f75733          	srl	a4,a4,a5
   10ce8:	fc842783          	lw	a5,-56(s0)
   10cec:	00e7a023          	sw	a4,0(a5)
   10cf0:	0380006f          	j	10d28 <compute32+0x2b0>
    case OP_SRA: u2 = shamt; *p_result = (i1 >> u2); break;
   10cf4:	fd842783          	lw	a5,-40(s0)
   10cf8:	fcf42823          	sw	a5,-48(s0)
   10cfc:	fec42703          	lw	a4,-20(s0)
   10d00:	fd042783          	lw	a5,-48(s0)
   10d04:	40f757b3          	sra	a5,a4,a5
   10d08:	00078713          	mv	a4,a5
   10d0c:	fc842783          	lw	a5,-56(s0)
   10d10:	00e7a023          	sw	a4,0(a5)
   10d14:	0140006f          	j	10d28 <compute32+0x2b0>

    default: *p_noop = True; break;
   10d18:	fcc42783          	lw	a5,-52(s0)
   10d1c:	00100713          	li	a4,1
   10d20:	00e7a023          	sw	a4,0(a5)
   10d24:	00000013          	nop
    }
}
   10d28:	00000013          	nop
   10d2c:	03c12403          	lw	s0,60(sp)
   10d30:	04010113          	addi	sp,sp,64
   10d34:	00008067          	ret

00010d38 <compute64>:
		uint32_t shamt,
		uint64_t u1,
		uint64_t u2,
		uint32_t *p_noop,
		uint64_t *p_result)
{
   10d38:	f4010113          	addi	sp,sp,-192
   10d3c:	0a812e23          	sw	s0,188(sp)
   10d40:	0b212c23          	sw	s2,184(sp)
   10d44:	0b312a23          	sw	s3,180(sp)
   10d48:	0b412823          	sw	s4,176(sp)
   10d4c:	0b512623          	sw	s5,172(sp)
   10d50:	0b612423          	sw	s6,168(sp)
   10d54:	0b712223          	sw	s7,164(sp)
   10d58:	0b812023          	sw	s8,160(sp)
   10d5c:	09912e23          	sw	s9,156(sp)
   10d60:	09a12c23          	sw	s10,152(sp)
   10d64:	09b12a23          	sw	s11,148(sp)
   10d68:	0c010413          	addi	s0,sp,192
   10d6c:	faa42e23          	sw	a0,-68(s0)
   10d70:	fab42c23          	sw	a1,-72(s0)
   10d74:	fac42823          	sw	a2,-80(s0)
   10d78:	fad42a23          	sw	a3,-76(s0)
   10d7c:	fae42423          	sw	a4,-88(s0)
   10d80:	faf42623          	sw	a5,-84(s0)
   10d84:	fb042223          	sw	a6,-92(s0)
   10d88:	fb142023          	sw	a7,-96(s0)
    int64_t i1 = u1;
   10d8c:	fb042703          	lw	a4,-80(s0)
   10d90:	fb442783          	lw	a5,-76(s0)
   10d94:	fce42423          	sw	a4,-56(s0)
   10d98:	fcf42623          	sw	a5,-52(s0)
    int64_t i2 = u2;
   10d9c:	fa842703          	lw	a4,-88(s0)
   10da0:	fac42783          	lw	a5,-84(s0)
   10da4:	fce42023          	sw	a4,-64(s0)
   10da8:	fcf42223          	sw	a5,-60(s0)
    uint64_t result;

    *p_noop = False;
   10dac:	fa442783          	lw	a5,-92(s0)
   10db0:	0007a023          	sw	zero,0(a5)
    switch (op) {
   10db4:	fbc42703          	lw	a4,-68(s0)
   10db8:	01100793          	li	a5,17
   10dbc:	4ee7ee63          	bltu	a5,a4,112b8 <compute64+0x580>
   10dc0:	fbc42783          	lw	a5,-68(s0)
   10dc4:	00279713          	slli	a4,a5,0x2
   10dc8:	0001c7b7          	lui	a5,0x1c
   10dcc:	61c78793          	addi	a5,a5,1564 # 1c61c <__extendsfdf2+0x100>
   10dd0:	00f707b3          	add	a5,a4,a5
   10dd4:	0007a783          	lw	a5,0(a5)
   10dd8:	00078067          	jr	a5
    case OP_EQ:  *p_result = (i1 == i2); break;
   10ddc:	fc842703          	lw	a4,-56(s0)
   10de0:	fc042783          	lw	a5,-64(s0)
   10de4:	00f74b33          	xor	s6,a4,a5
   10de8:	fcc42703          	lw	a4,-52(s0)
   10dec:	fc442783          	lw	a5,-60(s0)
   10df0:	00f74bb3          	xor	s7,a4,a5
   10df4:	017b67b3          	or	a5,s6,s7
   10df8:	0017b793          	seqz	a5,a5
   10dfc:	0ff7f793          	andi	a5,a5,255
   10e00:	f8f42c23          	sw	a5,-104(s0)
   10e04:	f8042e23          	sw	zero,-100(s0)
   10e08:	fa042783          	lw	a5,-96(s0)
   10e0c:	f9842603          	lw	a2,-104(s0)
   10e10:	f9c42683          	lw	a3,-100(s0)
   10e14:	00c7a023          	sw	a2,0(a5)
   10e18:	00d7a223          	sw	a3,4(a5)
   10e1c:	4ac0006f          	j	112c8 <compute64+0x590>
    case OP_NE:  *p_result = (i1 != i2); break;
   10e20:	fc842703          	lw	a4,-56(s0)
   10e24:	fc042783          	lw	a5,-64(s0)
   10e28:	00f74a33          	xor	s4,a4,a5
   10e2c:	fcc42703          	lw	a4,-52(s0)
   10e30:	fc442783          	lw	a5,-60(s0)
   10e34:	00f74ab3          	xor	s5,a4,a5
   10e38:	015a67b3          	or	a5,s4,s5
   10e3c:	00f037b3          	snez	a5,a5
   10e40:	0ff7f793          	andi	a5,a5,255
   10e44:	f8f42823          	sw	a5,-112(s0)
   10e48:	f8042a23          	sw	zero,-108(s0)
   10e4c:	fa042783          	lw	a5,-96(s0)
   10e50:	f9042603          	lw	a2,-112(s0)
   10e54:	f9442683          	lw	a3,-108(s0)
   10e58:	00c7a023          	sw	a2,0(a5)
   10e5c:	00d7a223          	sw	a3,4(a5)
   10e60:	4680006f          	j	112c8 <compute64+0x590>
    case OP_LT:  *p_result = (i1 <  i2); break;
   10e64:	00100693          	li	a3,1
   10e68:	fc442703          	lw	a4,-60(s0)
   10e6c:	fcc42783          	lw	a5,-52(s0)
   10e70:	02e7c063          	blt	a5,a4,10e90 <compute64+0x158>
   10e74:	fc442703          	lw	a4,-60(s0)
   10e78:	fcc42783          	lw	a5,-52(s0)
   10e7c:	00f71863          	bne	a4,a5,10e8c <compute64+0x154>
   10e80:	fc042703          	lw	a4,-64(s0)
   10e84:	fc842783          	lw	a5,-56(s0)
   10e88:	00e7e463          	bltu	a5,a4,10e90 <compute64+0x158>
   10e8c:	00000693          	li	a3,0
   10e90:	0ff6f793          	andi	a5,a3,255
   10e94:	f8f42423          	sw	a5,-120(s0)
   10e98:	f8042623          	sw	zero,-116(s0)
   10e9c:	fa042783          	lw	a5,-96(s0)
   10ea0:	f8842603          	lw	a2,-120(s0)
   10ea4:	f8c42683          	lw	a3,-116(s0)
   10ea8:	00c7a023          	sw	a2,0(a5)
   10eac:	00d7a223          	sw	a3,4(a5)
   10eb0:	4180006f          	j	112c8 <compute64+0x590>
    case OP_GE:  *p_result = (i1 >= i2); break;
   10eb4:	00100693          	li	a3,1
   10eb8:	fc442703          	lw	a4,-60(s0)
   10ebc:	fcc42783          	lw	a5,-52(s0)
   10ec0:	00e7ce63          	blt	a5,a4,10edc <compute64+0x1a4>
   10ec4:	fc442703          	lw	a4,-60(s0)
   10ec8:	fcc42783          	lw	a5,-52(s0)
   10ecc:	00f71a63          	bne	a4,a5,10ee0 <compute64+0x1a8>
   10ed0:	fc042703          	lw	a4,-64(s0)
   10ed4:	fc842783          	lw	a5,-56(s0)
   10ed8:	00e7f463          	bleu	a4,a5,10ee0 <compute64+0x1a8>
   10edc:	00000693          	li	a3,0
   10ee0:	0ff6f793          	andi	a5,a3,255
   10ee4:	f8f42023          	sw	a5,-128(s0)
   10ee8:	f8042223          	sw	zero,-124(s0)
   10eec:	fa042783          	lw	a5,-96(s0)
   10ef0:	f8042603          	lw	a2,-128(s0)
   10ef4:	f8442683          	lw	a3,-124(s0)
   10ef8:	00c7a023          	sw	a2,0(a5)
   10efc:	00d7a223          	sw	a3,4(a5)
   10f00:	3c80006f          	j	112c8 <compute64+0x590>
    case OP_LTU: *p_result = (u1 <  u2); break;
   10f04:	00100693          	li	a3,1
   10f08:	fac42703          	lw	a4,-84(s0)
   10f0c:	fb442783          	lw	a5,-76(s0)
   10f10:	02e7e063          	bltu	a5,a4,10f30 <compute64+0x1f8>
   10f14:	fac42703          	lw	a4,-84(s0)
   10f18:	fb442783          	lw	a5,-76(s0)
   10f1c:	00f71863          	bne	a4,a5,10f2c <compute64+0x1f4>
   10f20:	fa842703          	lw	a4,-88(s0)
   10f24:	fb042783          	lw	a5,-80(s0)
   10f28:	00e7e463          	bltu	a5,a4,10f30 <compute64+0x1f8>
   10f2c:	00000693          	li	a3,0
   10f30:	0ff6f793          	andi	a5,a3,255
   10f34:	f6f42c23          	sw	a5,-136(s0)
   10f38:	f6042e23          	sw	zero,-132(s0)
   10f3c:	fa042783          	lw	a5,-96(s0)
   10f40:	f7842603          	lw	a2,-136(s0)
   10f44:	f7c42683          	lw	a3,-132(s0)
   10f48:	00c7a023          	sw	a2,0(a5)
   10f4c:	00d7a223          	sw	a3,4(a5)
   10f50:	3780006f          	j	112c8 <compute64+0x590>
    case OP_GEU: *p_result = (u1 >= u2); break;
   10f54:	00100693          	li	a3,1
   10f58:	fac42703          	lw	a4,-84(s0)
   10f5c:	fb442783          	lw	a5,-76(s0)
   10f60:	00e7ee63          	bltu	a5,a4,10f7c <compute64+0x244>
   10f64:	fac42703          	lw	a4,-84(s0)
   10f68:	fb442783          	lw	a5,-76(s0)
   10f6c:	00f71a63          	bne	a4,a5,10f80 <compute64+0x248>
   10f70:	fa842703          	lw	a4,-88(s0)
   10f74:	fb042783          	lw	a5,-80(s0)
   10f78:	00e7f463          	bleu	a4,a5,10f80 <compute64+0x248>
   10f7c:	00000693          	li	a3,0
   10f80:	0ff6f793          	andi	a5,a3,255
   10f84:	f6f42823          	sw	a5,-144(s0)
   10f88:	f6042a23          	sw	zero,-140(s0)
   10f8c:	fa042783          	lw	a5,-96(s0)
   10f90:	f7042603          	lw	a2,-144(s0)
   10f94:	f7442683          	lw	a3,-140(s0)
   10f98:	00c7a023          	sw	a2,0(a5)
   10f9c:	00d7a223          	sw	a3,4(a5)
   10fa0:	3280006f          	j	112c8 <compute64+0x590>

    case OP_ADD: *p_result = (i1 + i2); break;
   10fa4:	fc842603          	lw	a2,-56(s0)
   10fa8:	fcc42683          	lw	a3,-52(s0)
   10fac:	fc042503          	lw	a0,-64(s0)
   10fb0:	fc442583          	lw	a1,-60(s0)
   10fb4:	00a60733          	add	a4,a2,a0
   10fb8:	00c73833          	sltu	a6,a4,a2
   10fbc:	00b687b3          	add	a5,a3,a1
   10fc0:	00f806b3          	add	a3,a6,a5
   10fc4:	00068793          	mv	a5,a3
   10fc8:	fa042683          	lw	a3,-96(s0)
   10fcc:	00e6a023          	sw	a4,0(a3)
   10fd0:	00f6a223          	sw	a5,4(a3)
   10fd4:	2f40006f          	j	112c8 <compute64+0x590>
    case OP_SUB: *p_result = (i1 - i2); break;
   10fd8:	fc842603          	lw	a2,-56(s0)
   10fdc:	fcc42683          	lw	a3,-52(s0)
   10fe0:	fc042503          	lw	a0,-64(s0)
   10fe4:	fc442583          	lw	a1,-60(s0)
   10fe8:	40a60733          	sub	a4,a2,a0
   10fec:	00e63833          	sltu	a6,a2,a4
   10ff0:	40b687b3          	sub	a5,a3,a1
   10ff4:	410786b3          	sub	a3,a5,a6
   10ff8:	00068793          	mv	a5,a3
   10ffc:	fa042683          	lw	a3,-96(s0)
   11000:	00e6a023          	sw	a4,0(a3)
   11004:	00f6a223          	sw	a5,4(a3)
   11008:	2c00006f          	j	112c8 <compute64+0x590>

    case OP_LOGICAL_AND: *p_result = (u1 && u2); break;
   1100c:	fb042783          	lw	a5,-80(s0)
   11010:	fb442703          	lw	a4,-76(s0)
   11014:	00e7e7b3          	or	a5,a5,a4
   11018:	00078e63          	beqz	a5,11034 <compute64+0x2fc>
   1101c:	fa842783          	lw	a5,-88(s0)
   11020:	fac42703          	lw	a4,-84(s0)
   11024:	00e7e7b3          	or	a5,a5,a4
   11028:	00078663          	beqz	a5,11034 <compute64+0x2fc>
   1102c:	00100793          	li	a5,1
   11030:	0080006f          	j	11038 <compute64+0x300>
   11034:	00000793          	li	a5,0
   11038:	f6f42423          	sw	a5,-152(s0)
   1103c:	41f7d793          	srai	a5,a5,0x1f
   11040:	f6f42623          	sw	a5,-148(s0)
   11044:	fa042783          	lw	a5,-96(s0)
   11048:	f6842603          	lw	a2,-152(s0)
   1104c:	f6c42683          	lw	a3,-148(s0)
   11050:	00c7a023          	sw	a2,0(a5)
   11054:	00d7a223          	sw	a3,4(a5)
   11058:	2700006f          	j	112c8 <compute64+0x590>
    case OP_LOGICAL_OR:  *p_result = (u1 || u2); break;
   1105c:	fb042783          	lw	a5,-80(s0)
   11060:	fb442703          	lw	a4,-76(s0)
   11064:	00e7e7b3          	or	a5,a5,a4
   11068:	00079a63          	bnez	a5,1107c <compute64+0x344>
   1106c:	fa842783          	lw	a5,-88(s0)
   11070:	fac42703          	lw	a4,-84(s0)
   11074:	00e7e7b3          	or	a5,a5,a4
   11078:	00078663          	beqz	a5,11084 <compute64+0x34c>
   1107c:	00100793          	li	a5,1
   11080:	0080006f          	j	11088 <compute64+0x350>
   11084:	00000793          	li	a5,0
   11088:	f6f42023          	sw	a5,-160(s0)
   1108c:	41f7d793          	srai	a5,a5,0x1f
   11090:	f6f42223          	sw	a5,-156(s0)
   11094:	fa042783          	lw	a5,-96(s0)
   11098:	f6042603          	lw	a2,-160(s0)
   1109c:	f6442683          	lw	a3,-156(s0)
   110a0:	00c7a023          	sw	a2,0(a5)
   110a4:	00d7a223          	sw	a3,4(a5)
   110a8:	2200006f          	j	112c8 <compute64+0x590>
    case OP_LOGICAL_NOT: *p_result = ! (u1); break;
   110ac:	fb042703          	lw	a4,-80(s0)
   110b0:	fb442783          	lw	a5,-76(s0)
   110b4:	00f767b3          	or	a5,a4,a5
   110b8:	0017b793          	seqz	a5,a5
   110bc:	0ff7f793          	andi	a5,a5,255
   110c0:	f4f42c23          	sw	a5,-168(s0)
   110c4:	f4042e23          	sw	zero,-164(s0)
   110c8:	fa042783          	lw	a5,-96(s0)
   110cc:	f5842603          	lw	a2,-168(s0)
   110d0:	f5c42683          	lw	a3,-164(s0)
   110d4:	00c7a023          	sw	a2,0(a5)
   110d8:	00d7a223          	sw	a3,4(a5)
   110dc:	1ec0006f          	j	112c8 <compute64+0x590>

    case OP_AND: *p_result = (u1 & u2); break;
   110e0:	fb042703          	lw	a4,-80(s0)
   110e4:	fa842783          	lw	a5,-88(s0)
   110e8:	00f777b3          	and	a5,a4,a5
   110ec:	f4f42823          	sw	a5,-176(s0)
   110f0:	fb442703          	lw	a4,-76(s0)
   110f4:	fac42783          	lw	a5,-84(s0)
   110f8:	00f777b3          	and	a5,a4,a5
   110fc:	f4f42a23          	sw	a5,-172(s0)
   11100:	fa042783          	lw	a5,-96(s0)
   11104:	f5042603          	lw	a2,-176(s0)
   11108:	f5442683          	lw	a3,-172(s0)
   1110c:	00c7a023          	sw	a2,0(a5)
   11110:	00d7a223          	sw	a3,4(a5)
   11114:	1b40006f          	j	112c8 <compute64+0x590>
    case OP_OR:  *p_result = (u1 | u2); break;
   11118:	fb042703          	lw	a4,-80(s0)
   1111c:	fa842783          	lw	a5,-88(s0)
   11120:	00f767b3          	or	a5,a4,a5
   11124:	f4f42423          	sw	a5,-184(s0)
   11128:	fb442703          	lw	a4,-76(s0)
   1112c:	fac42783          	lw	a5,-84(s0)
   11130:	00f767b3          	or	a5,a4,a5
   11134:	f4f42623          	sw	a5,-180(s0)
   11138:	fa042783          	lw	a5,-96(s0)
   1113c:	f4842603          	lw	a2,-184(s0)
   11140:	f4c42683          	lw	a3,-180(s0)
   11144:	00c7a023          	sw	a2,0(a5)
   11148:	00d7a223          	sw	a3,4(a5)
   1114c:	17c0006f          	j	112c8 <compute64+0x590>
    case OP_XOR: *p_result = (u1 ^ u2); break;
   11150:	fb042703          	lw	a4,-80(s0)
   11154:	fa842783          	lw	a5,-88(s0)
   11158:	00f74d33          	xor	s10,a4,a5
   1115c:	fb442703          	lw	a4,-76(s0)
   11160:	fac42783          	lw	a5,-84(s0)
   11164:	00f74db3          	xor	s11,a4,a5
   11168:	fa042783          	lw	a5,-96(s0)
   1116c:	01a7a023          	sw	s10,0(a5)
   11170:	01b7a223          	sw	s11,4(a5)
   11174:	1540006f          	j	112c8 <compute64+0x590>
    case OP_NOT: *p_result = ~u1;       break;
   11178:	fb042783          	lw	a5,-80(s0)
   1117c:	fff7cc13          	not	s8,a5
   11180:	fb442783          	lw	a5,-76(s0)
   11184:	fff7cc93          	not	s9,a5
   11188:	fa042783          	lw	a5,-96(s0)
   1118c:	0187a023          	sw	s8,0(a5)
   11190:	0197a223          	sw	s9,4(a5)
   11194:	1340006f          	j	112c8 <compute64+0x590>

    case OP_SLL: u2 = shamt; *p_result = (u1 << u2); break;
   11198:	fb842783          	lw	a5,-72(s0)
   1119c:	faf42423          	sw	a5,-88(s0)
   111a0:	fa042623          	sw	zero,-84(s0)
   111a4:	fa842783          	lw	a5,-88(s0)
   111a8:	0207f713          	andi	a4,a5,32
   111ac:	00070a63          	beqz	a4,111c0 <compute64+0x488>
   111b0:	fb042703          	lw	a4,-80(s0)
   111b4:	00f719b3          	sll	s3,a4,a5
   111b8:	00000913          	li	s2,0
   111bc:	0280006f          	j	111e4 <compute64+0x4ac>
   111c0:	fb042703          	lw	a4,-80(s0)
   111c4:	00175693          	srli	a3,a4,0x1
   111c8:	fff7c713          	not	a4,a5
   111cc:	00e6d733          	srl	a4,a3,a4
   111d0:	fb442683          	lw	a3,-76(s0)
   111d4:	00f699b3          	sll	s3,a3,a5
   111d8:	013769b3          	or	s3,a4,s3
   111dc:	fb042703          	lw	a4,-80(s0)
   111e0:	00f71933          	sll	s2,a4,a5
   111e4:	fa042783          	lw	a5,-96(s0)
   111e8:	0127a023          	sw	s2,0(a5)
   111ec:	0137a223          	sw	s3,4(a5)
   111f0:	0d80006f          	j	112c8 <compute64+0x590>
    case OP_SRL: u2 = shamt; *p_result = (u1 >> u2); break;
   111f4:	fb842783          	lw	a5,-72(s0)
   111f8:	faf42423          	sw	a5,-88(s0)
   111fc:	fa042623          	sw	zero,-84(s0)
   11200:	fa842783          	lw	a5,-88(s0)
   11204:	0207f713          	andi	a4,a5,32
   11208:	00070a63          	beqz	a4,1121c <compute64+0x4e4>
   1120c:	fb442703          	lw	a4,-76(s0)
   11210:	00f75f33          	srl	t5,a4,a5
   11214:	00000f93          	li	t6,0
   11218:	0280006f          	j	11240 <compute64+0x508>
   1121c:	fb442703          	lw	a4,-76(s0)
   11220:	00171693          	slli	a3,a4,0x1
   11224:	fff7c713          	not	a4,a5
   11228:	00e69733          	sll	a4,a3,a4
   1122c:	fb042683          	lw	a3,-80(s0)
   11230:	00f6df33          	srl	t5,a3,a5
   11234:	01e76f33          	or	t5,a4,t5
   11238:	fb442703          	lw	a4,-76(s0)
   1123c:	00f75fb3          	srl	t6,a4,a5
   11240:	fa042783          	lw	a5,-96(s0)
   11244:	01e7a023          	sw	t5,0(a5)
   11248:	01f7a223          	sw	t6,4(a5)
   1124c:	07c0006f          	j	112c8 <compute64+0x590>
    case OP_SRA: u2 = shamt; *p_result = (i1 >> u2); break;
   11250:	fb842783          	lw	a5,-72(s0)
   11254:	faf42423          	sw	a5,-88(s0)
   11258:	fa042623          	sw	zero,-84(s0)
   1125c:	fa842783          	lw	a5,-88(s0)
   11260:	0207f713          	andi	a4,a5,32
   11264:	00070c63          	beqz	a4,1127c <compute64+0x544>
   11268:	fcc42703          	lw	a4,-52(s0)
   1126c:	40f75e33          	sra	t3,a4,a5
   11270:	fcc42783          	lw	a5,-52(s0)
   11274:	41f7de93          	srai	t4,a5,0x1f
   11278:	0280006f          	j	112a0 <compute64+0x568>
   1127c:	fcc42703          	lw	a4,-52(s0)
   11280:	00171693          	slli	a3,a4,0x1
   11284:	fff7c713          	not	a4,a5
   11288:	00e69733          	sll	a4,a3,a4
   1128c:	fc842683          	lw	a3,-56(s0)
   11290:	00f6de33          	srl	t3,a3,a5
   11294:	01c76e33          	or	t3,a4,t3
   11298:	fcc42703          	lw	a4,-52(s0)
   1129c:	40f75eb3          	sra	t4,a4,a5
   112a0:	000e0713          	mv	a4,t3
   112a4:	000e8793          	mv	a5,t4
   112a8:	fa042683          	lw	a3,-96(s0)
   112ac:	00e6a023          	sw	a4,0(a3)
   112b0:	00f6a223          	sw	a5,4(a3)
   112b4:	0140006f          	j	112c8 <compute64+0x590>

    default: *p_noop = True; break;
   112b8:	fa442783          	lw	a5,-92(s0)
   112bc:	00100713          	li	a4,1
   112c0:	00e7a023          	sw	a4,0(a5)
   112c4:	00000013          	nop
    }
}
   112c8:	00000013          	nop
   112cc:	0bc12403          	lw	s0,188(sp)
   112d0:	0b812903          	lw	s2,184(sp)
   112d4:	0b412983          	lw	s3,180(sp)
   112d8:	0b012a03          	lw	s4,176(sp)
   112dc:	0ac12a83          	lw	s5,172(sp)
   112e0:	0a812b03          	lw	s6,168(sp)
   112e4:	0a412b83          	lw	s7,164(sp)
   112e8:	0a012c03          	lw	s8,160(sp)
   112ec:	09c12c83          	lw	s9,156(sp)
   112f0:	09812d03          	lw	s10,152(sp)
   112f4:	09412d83          	lw	s11,148(sp)
   112f8:	0c010113          	addi	sp,sp,192
   112fc:	00008067          	ret

00011300 <main>:

#include "opcodes.h"
#include "test_data.h"

int main (int argc, char *argv[])
{
   11300:	fa010113          	addi	sp,sp,-96
   11304:	04112e23          	sw	ra,92(sp)
   11308:	04812c23          	sw	s0,88(sp)
   1130c:	06010413          	addi	s0,sp,96
   11310:	faa42623          	sw	a0,-84(s0)
   11314:	fab42423          	sw	a1,-88(s0)
    uint32_t j, op, shamt, noop;
    uint32_t u32a, u32b, result32, exp32;
    uint64_t u64a, u64b, result64, exp64;

    for (j = 0; j < N; j++) {
   11318:	fe042623          	sw	zero,-20(s0)
   1131c:	1180006f          	j	11434 <main+0x134>
	op    = test_data32 [j][0];
   11320:	0001e7b7          	lui	a5,0x1e
   11324:	fec42703          	lw	a4,-20(s0)
   11328:	00471713          	slli	a4,a4,0x4
   1132c:	19c78793          	addi	a5,a5,412 # 1e19c <test_data32>
   11330:	00f707b3          	add	a5,a4,a5
   11334:	0007a783          	lw	a5,0(a5)
   11338:	fef42423          	sw	a5,-24(s0)
	u32a  = test_data32 [j][1];
   1133c:	0001e7b7          	lui	a5,0x1e
   11340:	fec42703          	lw	a4,-20(s0)
   11344:	00471713          	slli	a4,a4,0x4
   11348:	19c78793          	addi	a5,a5,412 # 1e19c <test_data32>
   1134c:	00f707b3          	add	a5,a4,a5
   11350:	0047a783          	lw	a5,4(a5)
   11354:	fef42223          	sw	a5,-28(s0)
	u32b  = test_data32 [j][2];
   11358:	0001e7b7          	lui	a5,0x1e
   1135c:	fec42703          	lw	a4,-20(s0)
   11360:	00471713          	slli	a4,a4,0x4
   11364:	19c78793          	addi	a5,a5,412 # 1e19c <test_data32>
   11368:	00f707b3          	add	a5,a4,a5
   1136c:	0087a783          	lw	a5,8(a5)
   11370:	fef42023          	sw	a5,-32(s0)
	exp32 = test_data32 [j][3];
   11374:	0001e7b7          	lui	a5,0x1e
   11378:	fec42703          	lw	a4,-20(s0)
   1137c:	00471713          	slli	a4,a4,0x4
   11380:	19c78793          	addi	a5,a5,412 # 1e19c <test_data32>
   11384:	00f707b3          	add	a5,a4,a5
   11388:	00c7a783          	lw	a5,12(a5)
   1138c:	fcf42e23          	sw	a5,-36(s0)
	shamt = u32b;
   11390:	fe042783          	lw	a5,-32(s0)
   11394:	fcf42c23          	sw	a5,-40(s0)
	noop = False;
   11398:	fa042e23          	sw	zero,-68(s0)

	compute32 (op, shamt, u32a, u32b, & noop, & result32);
   1139c:	fb840793          	addi	a5,s0,-72
   113a0:	fbc40713          	addi	a4,s0,-68
   113a4:	fe042683          	lw	a3,-32(s0)
   113a8:	fe442603          	lw	a2,-28(s0)
   113ac:	fd842583          	lw	a1,-40(s0)
   113b0:	fe842503          	lw	a0,-24(s0)
   113b4:	ec4ff0ef          	jal	10a78 <compute32>

	if ((! noop) && (result32 != exp32)) {
   113b8:	fbc42783          	lw	a5,-68(s0)
   113bc:	06079663          	bnez	a5,11428 <main+0x128>
   113c0:	fb842703          	lw	a4,-72(s0)
   113c4:	fdc42783          	lw	a5,-36(s0)
   113c8:	06f70063          	beq	a4,a5,11428 <main+0x128>
	    printf ("ERROR: test_data32 [%0d]: %s, 0x%016llx, 0x%016llx\n",
   113cc:	0001e7b7          	lui	a5,0x1e
   113d0:	fe842703          	lw	a4,-24(s0)
   113d4:	00271713          	slli	a4,a4,0x2
   113d8:	15078793          	addi	a5,a5,336 # 1e150 <_fdata>
   113dc:	00f707b3          	add	a5,a4,a5
   113e0:	0007a783          	lw	a5,0(a5)
   113e4:	fe042703          	lw	a4,-32(s0)
   113e8:	fe442683          	lw	a3,-28(s0)
   113ec:	00078613          	mv	a2,a5
   113f0:	fec42583          	lw	a1,-20(s0)
   113f4:	0001c7b7          	lui	a5,0x1c
   113f8:	66478513          	addi	a0,a5,1636 # 1c664 <__extendsfdf2+0x148>
   113fc:	4dd000ef          	jal	120d8 <printf>
		    j, opcode_names [op], u32a, u32b);
	    printf ("Actual result32:   0x%016llx\n", result32);
   11400:	fb842783          	lw	a5,-72(s0)
   11404:	00078593          	mv	a1,a5
   11408:	0001c7b7          	lui	a5,0x1c
   1140c:	69878513          	addi	a0,a5,1688 # 1c698 <__extendsfdf2+0x17c>
   11410:	4c9000ef          	jal	120d8 <printf>
	    printf ("Expected result32: 0x%016llx\n", exp32);
   11414:	fdc42583          	lw	a1,-36(s0)
   11418:	0001c7b7          	lui	a5,0x1c
   1141c:	6b878513          	addi	a0,a5,1720 # 1c6b8 <__extendsfdf2+0x19c>
   11420:	4b9000ef          	jal	120d8 <printf>
	    break;
   11424:	0200006f          	j	11444 <main+0x144>
{
    uint32_t j, op, shamt, noop;
    uint32_t u32a, u32b, result32, exp32;
    uint64_t u64a, u64b, result64, exp64;

    for (j = 0; j < N; j++) {
   11428:	fec42783          	lw	a5,-20(s0)
   1142c:	00178793          	addi	a5,a5,1
   11430:	fef42623          	sw	a5,-20(s0)
   11434:	fec42703          	lw	a4,-20(s0)
   11438:	000017b7          	lui	a5,0x1
   1143c:	dc778793          	addi	a5,a5,-569 # dc7 <_reset+0xbc7>
   11440:	eee7f0e3          	bleu	a4,a5,11320 <main+0x20>
	    printf ("Actual result32:   0x%016llx\n", result32);
	    printf ("Expected result32: 0x%016llx\n", exp32);
	    break;
	}
    }
    if (j == N)
   11444:	fec42703          	lw	a4,-20(s0)
   11448:	000017b7          	lui	a5,0x1
   1144c:	dc878793          	addi	a5,a5,-568 # dc8 <_reset+0xbc8>
   11450:	00f71c63          	bne	a4,a5,11468 <main+0x168>
	printf ("Verify: all %0d 32-bit tests ok\n", N);
   11454:	000017b7          	lui	a5,0x1
   11458:	dc878593          	addi	a1,a5,-568 # dc8 <_reset+0xbc8>
   1145c:	0001c7b7          	lui	a5,0x1c
   11460:	6d878513          	addi	a0,a5,1752 # 1c6d8 <__extendsfdf2+0x1bc>
   11464:	475000ef          	jal	120d8 <printf>

    for (j = 0; j < N; j++) {
   11468:	fe042623          	sw	zero,-20(s0)
   1146c:	1680006f          	j	115d4 <main+0x2d4>
	op    = test_data64 [j][0];
   11470:	0002c7b7          	lui	a5,0x2c
   11474:	fec42703          	lw	a4,-20(s0)
   11478:	00571713          	slli	a4,a4,0x5
   1147c:	e2078793          	addi	a5,a5,-480 # 2be20 <test_data64>
   11480:	00f707b3          	add	a5,a4,a5
   11484:	0007a703          	lw	a4,0(a5)
   11488:	0047a783          	lw	a5,4(a5)
   1148c:	fee42423          	sw	a4,-24(s0)
	u64a  = test_data64 [j][1];
   11490:	0002c7b7          	lui	a5,0x2c
   11494:	fec42703          	lw	a4,-20(s0)
   11498:	00571713          	slli	a4,a4,0x5
   1149c:	e2078793          	addi	a5,a5,-480 # 2be20 <test_data64>
   114a0:	00f707b3          	add	a5,a4,a5
   114a4:	0087a703          	lw	a4,8(a5)
   114a8:	00c7a783          	lw	a5,12(a5)
   114ac:	fce42823          	sw	a4,-48(s0)
   114b0:	fcf42a23          	sw	a5,-44(s0)
	u64b  = test_data64 [j][2];
   114b4:	0002c7b7          	lui	a5,0x2c
   114b8:	fec42703          	lw	a4,-20(s0)
   114bc:	00571713          	slli	a4,a4,0x5
   114c0:	e2078793          	addi	a5,a5,-480 # 2be20 <test_data64>
   114c4:	00f707b3          	add	a5,a4,a5
   114c8:	0107a703          	lw	a4,16(a5)
   114cc:	0147a783          	lw	a5,20(a5)
   114d0:	fce42423          	sw	a4,-56(s0)
   114d4:	fcf42623          	sw	a5,-52(s0)
	exp64 = test_data64 [j][3];
   114d8:	0002c7b7          	lui	a5,0x2c
   114dc:	fec42703          	lw	a4,-20(s0)
   114e0:	00571713          	slli	a4,a4,0x5
   114e4:	e2078793          	addi	a5,a5,-480 # 2be20 <test_data64>
   114e8:	00f707b3          	add	a5,a4,a5
   114ec:	0187a703          	lw	a4,24(a5)
   114f0:	01c7a783          	lw	a5,28(a5)
   114f4:	fce42023          	sw	a4,-64(s0)
   114f8:	fcf42223          	sw	a5,-60(s0)
	shamt = u64b;
   114fc:	fc842783          	lw	a5,-56(s0)
   11500:	fcf42c23          	sw	a5,-40(s0)
	noop = False;
   11504:	fa042e23          	sw	zero,-68(s0)

	compute64 (op, shamt, u64a, u64b, & noop, & result64);
   11508:	fb040713          	addi	a4,s0,-80
   1150c:	fbc40793          	addi	a5,s0,-68
   11510:	00070893          	mv	a7,a4
   11514:	00078813          	mv	a6,a5
   11518:	fc842703          	lw	a4,-56(s0)
   1151c:	fcc42783          	lw	a5,-52(s0)
   11520:	fd042603          	lw	a2,-48(s0)
   11524:	fd442683          	lw	a3,-44(s0)
   11528:	fd842583          	lw	a1,-40(s0)
   1152c:	fe842503          	lw	a0,-24(s0)
   11530:	809ff0ef          	jal	10d38 <compute64>

	if ((! noop) && (result64 != exp64)) {
   11534:	fbc42783          	lw	a5,-68(s0)
   11538:	08079863          	bnez	a5,115c8 <main+0x2c8>
   1153c:	fb042703          	lw	a4,-80(s0)
   11540:	fb442783          	lw	a5,-76(s0)
   11544:	fc042683          	lw	a3,-64(s0)
   11548:	00070613          	mv	a2,a4
   1154c:	00c69663          	bne	a3,a2,11558 <main+0x258>
   11550:	fc442683          	lw	a3,-60(s0)
   11554:	06f68a63          	beq	a3,a5,115c8 <main+0x2c8>
	    printf ("ERROR: test_data64 [%0d]: %s, 0x%016llx, 0x%016llx\n",
   11558:	0001e7b7          	lui	a5,0x1e
   1155c:	fe842703          	lw	a4,-24(s0)
   11560:	00271713          	slli	a4,a4,0x2
   11564:	15078793          	addi	a5,a5,336 # 1e150 <_fdata>
   11568:	00f707b3          	add	a5,a4,a5
   1156c:	0007a683          	lw	a3,0(a5)
   11570:	fc842803          	lw	a6,-56(s0)
   11574:	fcc42883          	lw	a7,-52(s0)
   11578:	fd042703          	lw	a4,-48(s0)
   1157c:	fd442783          	lw	a5,-44(s0)
   11580:	00068613          	mv	a2,a3
   11584:	fec42583          	lw	a1,-20(s0)
   11588:	0001c6b7          	lui	a3,0x1c
   1158c:	6fc68513          	addi	a0,a3,1788 # 1c6fc <__extendsfdf2+0x1e0>
   11590:	349000ef          	jal	120d8 <printf>
		    j, opcode_names [op], u64a, u64b);
	    printf ("Actual result64:   0x%016llx\n", result64);
   11594:	fb042703          	lw	a4,-80(s0)
   11598:	fb442783          	lw	a5,-76(s0)
   1159c:	00070613          	mv	a2,a4
   115a0:	00078693          	mv	a3,a5
   115a4:	0001c7b7          	lui	a5,0x1c
   115a8:	73078513          	addi	a0,a5,1840 # 1c730 <__extendsfdf2+0x214>
   115ac:	32d000ef          	jal	120d8 <printf>
	    printf ("Expected result64: 0x%016llx\n", exp64);
   115b0:	fc042603          	lw	a2,-64(s0)
   115b4:	fc442683          	lw	a3,-60(s0)
   115b8:	0001c7b7          	lui	a5,0x1c
   115bc:	75078513          	addi	a0,a5,1872 # 1c750 <__extendsfdf2+0x234>
   115c0:	319000ef          	jal	120d8 <printf>
	    break;
   115c4:	0200006f          	j	115e4 <main+0x2e4>
	}
    }
    if (j == N)
	printf ("Verify: all %0d 32-bit tests ok\n", N);

    for (j = 0; j < N; j++) {
   115c8:	fec42783          	lw	a5,-20(s0)
   115cc:	00178793          	addi	a5,a5,1
   115d0:	fef42623          	sw	a5,-20(s0)
   115d4:	fec42703          	lw	a4,-20(s0)
   115d8:	000017b7          	lui	a5,0x1
   115dc:	dc778793          	addi	a5,a5,-569 # dc7 <_reset+0xbc7>
   115e0:	e8e7f8e3          	bleu	a4,a5,11470 <main+0x170>
	    printf ("Actual result64:   0x%016llx\n", result64);
	    printf ("Expected result64: 0x%016llx\n", exp64);
	    break;
	}
    }
    if (j == N)
   115e4:	fec42703          	lw	a4,-20(s0)
   115e8:	000017b7          	lui	a5,0x1
   115ec:	dc878793          	addi	a5,a5,-568 # dc8 <_reset+0xbc8>
   115f0:	00f71c63          	bne	a4,a5,11608 <main+0x308>
	printf ("Verify: all %0d 64-bit tests ok\n", N);
   115f4:	000017b7          	lui	a5,0x1
   115f8:	dc878593          	addi	a1,a5,-568 # dc8 <_reset+0xbc8>
   115fc:	0001c7b7          	lui	a5,0x1c
   11600:	77078513          	addi	a0,a5,1904 # 1c770 <__extendsfdf2+0x254>
   11604:	2d5000ef          	jal	120d8 <printf>
   11608:	00000793          	li	a5,0
}
   1160c:	00078513          	mv	a0,a5
   11610:	05c12083          	lw	ra,92(sp)
   11614:	05812403          	lw	s0,88(sp)
   11618:	06010113          	addi	sp,sp,96
   1161c:	00008067          	ret

00011620 <__divdi3>:
  Wtype c = 0;
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
   11620:	2605ce63          	bltz	a1,1189c <__divdi3+0x27c>
   11624:	00050313          	mv	t1,a0
   11628:	00058793          	mv	a5,a1

#ifdef L_divdi3
DWtype
__divdi3 (DWtype u, DWtype v)
{
  Wtype c = 0;
   1162c:	00000893          	li	a7,0
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
   11630:	2406ca63          	bltz	a3,11884 <__divdi3+0x264>
  DWunion rr;
  UWtype d0, d1, n0, n1, n2;
  UWtype q0, q1;
  UWtype b, bm;

  d0 = dd.s.low;
   11634:	00060293          	mv	t0,a2
  d1 = dd.s.high;
  n0 = nn.s.low;
   11638:	00030393          	mv	t2,t1
  n1 = nn.s.high;
   1163c:	00078593          	mv	a1,a5
	}
    }

#else /* UDIV_NEEDS_NORMALIZATION */

  if (d1 == 0)
   11640:	0e069e63          	bnez	a3,1173c <__divdi3+0x11c>
    {
      if (d0 > n1)
   11644:	16c7f263          	bleu	a2,a5,117a8 <__divdi3+0x188>
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   11648:	00010737          	lui	a4,0x10
   1164c:	26e66c63          	bltu	a2,a4,118c4 <__divdi3+0x2a4>
   11650:	01000737          	lui	a4,0x1000
   11654:	00e63733          	sltu	a4,a2,a4
   11658:	00174713          	xori	a4,a4,1
   1165c:	40e00733          	neg	a4,a4
   11660:	00877713          	andi	a4,a4,8
   11664:	01070713          	addi	a4,a4,16 # 1000010 <_gp+0xfb7830>
   11668:	0001c6b7          	lui	a3,0x1c
   1166c:	00e65533          	srl	a0,a2,a4
   11670:	79468693          	addi	a3,a3,1940 # 1c794 <__clz_tab>
   11674:	00d506b3          	add	a3,a0,a3
   11678:	0006c683          	lbu	a3,0(a3)
   1167c:	00e68733          	add	a4,a3,a4
   11680:	02000693          	li	a3,32
   11684:	40e686b3          	sub	a3,a3,a4

	  if (bm != 0)
   11688:	00068c63          	beqz	a3,116a0 <__divdi3+0x80>
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   1168c:	00d797b3          	sll	a5,a5,a3
   11690:	00e35733          	srl	a4,t1,a4
	  if (bm != 0)
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
   11694:	00d612b3          	sll	t0,a2,a3
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   11698:	00f765b3          	or	a1,a4,a5
	      n0 = n0 << bm;
   1169c:	00d313b3          	sll	t2,t1,a3
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   116a0:	0102d613          	srli	a2,t0,0x10
   116a4:	02c5d533          	divu	a0,a1,a2
   116a8:	01029693          	slli	a3,t0,0x10
   116ac:	0106d693          	srli	a3,a3,0x10
   116b0:	0103d713          	srli	a4,t2,0x10
   116b4:	02c5f7b3          	remu	a5,a1,a2
   116b8:	02a68833          	mul	a6,a3,a0
   116bc:	01079793          	slli	a5,a5,0x10
   116c0:	00f765b3          	or	a1,a4,a5
   116c4:	0105fc63          	bleu	a6,a1,116dc <__divdi3+0xbc>
   116c8:	005585b3          	add	a1,a1,t0
   116cc:	fff50793          	addi	a5,a0,-1
   116d0:	0055e463          	bltu	a1,t0,116d8 <__divdi3+0xb8>
   116d4:	4105e263          	bltu	a1,a6,11ad8 <__divdi3+0x4b8>
   116d8:	00078513          	mv	a0,a5
   116dc:	410585b3          	sub	a1,a1,a6
   116e0:	02c5d7b3          	divu	a5,a1,a2
   116e4:	01039393          	slli	t2,t2,0x10
   116e8:	0103d393          	srli	t2,t2,0x10
   116ec:	02c5f5b3          	remu	a1,a1,a2
   116f0:	02f686b3          	mul	a3,a3,a5
   116f4:	01059593          	slli	a1,a1,0x10
   116f8:	00b3e5b3          	or	a1,t2,a1
   116fc:	00d5fe63          	bleu	a3,a1,11718 <__divdi3+0xf8>
   11700:	00b285b3          	add	a1,t0,a1
   11704:	fff78713          	addi	a4,a5,-1
   11708:	0055e663          	bltu	a1,t0,11714 <__divdi3+0xf4>
   1170c:	ffe78793          	addi	a5,a5,-2
   11710:	00d5e463          	bltu	a1,a3,11718 <__divdi3+0xf8>
   11714:	00070793          	mv	a5,a4
   11718:	01051513          	slli	a0,a0,0x10
   1171c:	00f56533          	or	a0,a0,a5
   11720:	00000593          	li	a1,0
  if (vv.s.high < 0)
    c = ~c,
    vv.ll = -vv.ll;

  w = __udivmoddi4 (uu.ll, vv.ll, (UDWtype *) 0);
  if (c)
   11724:	00088a63          	beqz	a7,11738 <__divdi3+0x118>
    w = -w;
   11728:	40a00533          	neg	a0,a0
   1172c:	00a037b3          	snez	a5,a0
   11730:	40b005b3          	neg	a1,a1
   11734:	40f585b3          	sub	a1,a1,a5

  return w;
}
   11738:	00008067          	ret
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
   1173c:	00d7f863          	bleu	a3,a5,1174c <__divdi3+0x12c>
   11740:	00000593          	li	a1,0
   11744:	00000513          	li	a0,0
   11748:	fddff06f          	j	11724 <__divdi3+0x104>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   1174c:	00010737          	lui	a4,0x10
   11750:	18e6e263          	bltu	a3,a4,118d4 <__divdi3+0x2b4>
   11754:	01000737          	lui	a4,0x1000
   11758:	00e6b733          	sltu	a4,a3,a4
   1175c:	00174713          	xori	a4,a4,1
   11760:	40e00733          	neg	a4,a4
   11764:	00877713          	andi	a4,a4,8
   11768:	01070713          	addi	a4,a4,16 # 1000010 <_gp+0xfb7830>
   1176c:	0001c5b7          	lui	a1,0x1c
   11770:	00e6d533          	srl	a0,a3,a4
   11774:	79458593          	addi	a1,a1,1940 # 1c794 <__clz_tab>
   11778:	00b505b3          	add	a1,a0,a1
   1177c:	0005c803          	lbu	a6,0(a1)
   11780:	02000293          	li	t0,32
   11784:	00e80833          	add	a6,a6,a4
   11788:	410282b3          	sub	t0,t0,a6
	  if (bm == 0)
   1178c:	14029c63          	bnez	t0,118e4 <__divdi3+0x2c4>

		 This special case is necessary, not an optimization.  */

	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
   11790:	00000593          	li	a1,0
   11794:	00100513          	li	a0,1
   11798:	f8f6e6e3          	bltu	a3,a5,11724 <__divdi3+0x104>
   1179c:	00c33533          	sltu	a0,t1,a2
   117a0:	00154513          	xori	a0,a0,1
   117a4:	f81ff06f          	j	11724 <__divdi3+0x104>
	}
      else
	{
	  /* qq = NN / 0d */

	  if (d0 == 0)
   117a8:	00061663          	bnez	a2,117b4 <__divdi3+0x194>
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
   117ac:	00100293          	li	t0,1
   117b0:	02d2d2b3          	divu	t0,t0,a3

	  count_leading_zeros (bm, d0);
   117b4:	00010737          	lui	a4,0x10
   117b8:	0ee2ee63          	bltu	t0,a4,118b4 <__divdi3+0x294>
   117bc:	01000737          	lui	a4,0x1000
   117c0:	00e2b733          	sltu	a4,t0,a4
   117c4:	00174713          	xori	a4,a4,1
   117c8:	40e00733          	neg	a4,a4
   117cc:	00877713          	andi	a4,a4,8
   117d0:	01070713          	addi	a4,a4,16 # 1000010 <_gp+0xfb7830>
   117d4:	0001c6b7          	lui	a3,0x1c
   117d8:	00e2d633          	srl	a2,t0,a4
   117dc:	79468693          	addi	a3,a3,1940 # 1c794 <__clz_tab>
   117e0:	00d606b3          	add	a3,a2,a3
   117e4:	0006c503          	lbu	a0,0(a3)
   117e8:	02000e13          	li	t3,32
   117ec:	00e50533          	add	a0,a0,a4
   117f0:	40ae0e33          	sub	t3,t3,a0

	  if (bm == 0)
   117f4:	1e0e1663          	bnez	t3,119e0 <__divdi3+0x3c0>
   117f8:	01029813          	slli	a6,t0,0x10
		 leading quotient digit q1 = 1).

		 This special case is necessary, not an optimization.
		 (Shifts counts of W_TYPE_SIZE are undefined.)  */

	      n1 -= d0;
   117fc:	405786b3          	sub	a3,a5,t0
   11800:	0102d613          	srli	a2,t0,0x10
   11804:	01085813          	srli	a6,a6,0x10
   11808:	00100593          	li	a1,1
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   1180c:	0103d793          	srli	a5,t2,0x10
   11810:	02c6d533          	divu	a0,a3,a2
   11814:	02c6f6b3          	remu	a3,a3,a2
   11818:	03050733          	mul	a4,a0,a6
   1181c:	01069693          	slli	a3,a3,0x10
   11820:	00d7e7b3          	or	a5,a5,a3
   11824:	00e7fc63          	bleu	a4,a5,1183c <__divdi3+0x21c>
   11828:	005787b3          	add	a5,a5,t0
   1182c:	fff50693          	addi	a3,a0,-1
   11830:	0057e463          	bltu	a5,t0,11838 <__divdi3+0x218>
   11834:	2ae7e863          	bltu	a5,a4,11ae4 <__divdi3+0x4c4>
   11838:	00068513          	mv	a0,a3
   1183c:	40e78733          	sub	a4,a5,a4
   11840:	02c757b3          	divu	a5,a4,a2
   11844:	01039393          	slli	t2,t2,0x10
   11848:	0103d393          	srli	t2,t2,0x10
   1184c:	02c77733          	remu	a4,a4,a2
   11850:	03078833          	mul	a6,a5,a6
   11854:	01071713          	slli	a4,a4,0x10
   11858:	00e3e733          	or	a4,t2,a4
   1185c:	01077e63          	bleu	a6,a4,11878 <__divdi3+0x258>
   11860:	00e28733          	add	a4,t0,a4
   11864:	fff78693          	addi	a3,a5,-1
   11868:	00576663          	bltu	a4,t0,11874 <__divdi3+0x254>
   1186c:	ffe78793          	addi	a5,a5,-2
   11870:	01076463          	bltu	a4,a6,11878 <__divdi3+0x258>
   11874:	00068793          	mv	a5,a3
   11878:	01051513          	slli	a0,a0,0x10
   1187c:	00f56533          	or	a0,a0,a5
   11880:	ea5ff06f          	j	11724 <__divdi3+0x104>
  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    c = ~c,
    vv.ll = -vv.ll;
   11884:	40c00633          	neg	a2,a2
   11888:	00c03733          	snez	a4,a2
   1188c:	40d006b3          	neg	a3,a3

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    c = ~c,
   11890:	fff8c893          	not	a7,a7
    vv.ll = -vv.ll;
   11894:	40e686b3          	sub	a3,a3,a4
   11898:	d9dff06f          	j	11634 <__divdi3+0x14>
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
   1189c:	40a00333          	neg	t1,a0
   118a0:	00603733          	snez	a4,t1
   118a4:	40b007b3          	neg	a5,a1
   118a8:	40e787b3          	sub	a5,a5,a4
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
   118ac:	fff00893          	li	a7,-1
   118b0:	d81ff06f          	j	11630 <__divdi3+0x10>
	  /* qq = NN / 0d */

	  if (d0 == 0)
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */

	  count_leading_zeros (bm, d0);
   118b4:	0ff00713          	li	a4,255
   118b8:	00573733          	sltu	a4,a4,t0
   118bc:	00371713          	slli	a4,a4,0x3
   118c0:	f15ff06f          	j	117d4 <__divdi3+0x1b4>
    {
      if (d0 > n1)
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   118c4:	0ff00713          	li	a4,255
   118c8:	00c73733          	sltu	a4,a4,a2
   118cc:	00371713          	slli	a4,a4,0x3
   118d0:	d99ff06f          	j	11668 <__divdi3+0x48>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   118d4:	0ff00713          	li	a4,255
   118d8:	00d73733          	sltu	a4,a4,a3
   118dc:	00371713          	slli	a4,a4,0x3
   118e0:	e8dff06f          	j	1176c <__divdi3+0x14c>
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
   118e4:	01065733          	srl	a4,a2,a6
   118e8:	005696b3          	sll	a3,a3,t0
   118ec:	00e6e6b3          	or	a3,a3,a4
	      d0 = d0 << bm;
	      n2 = n1 >> b;
   118f0:	0107d5b3          	srl	a1,a5,a6
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   118f4:	0106de93          	srli	t4,a3,0x10
   118f8:	03d5de33          	divu	t3,a1,t4
   118fc:	01069393          	slli	t2,a3,0x10
   11900:	0103d393          	srli	t2,t2,0x10
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   11904:	005797b3          	sll	a5,a5,t0
   11908:	01035833          	srl	a6,t1,a6
   1190c:	00f867b3          	or	a5,a6,a5
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11910:	0107d713          	srli	a4,a5,0x10
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
   11914:	00561633          	sll	a2,a2,t0
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11918:	03d5f5b3          	remu	a1,a1,t4
   1191c:	03c38533          	mul	a0,t2,t3
   11920:	01059593          	slli	a1,a1,0x10
   11924:	00b76733          	or	a4,a4,a1
   11928:	00a77e63          	bleu	a0,a4,11944 <__divdi3+0x324>
   1192c:	00d70733          	add	a4,a4,a3
   11930:	fffe0593          	addi	a1,t3,-1
   11934:	18d76e63          	bltu	a4,a3,11ad0 <__divdi3+0x4b0>
   11938:	18a77c63          	bleu	a0,a4,11ad0 <__divdi3+0x4b0>
   1193c:	ffee0e13          	addi	t3,t3,-2
   11940:	00d70733          	add	a4,a4,a3
   11944:	40a70733          	sub	a4,a4,a0
   11948:	03d75833          	divu	a6,a4,t4
   1194c:	01079793          	slli	a5,a5,0x10
   11950:	0107d793          	srli	a5,a5,0x10
   11954:	03d77733          	remu	a4,a4,t4
   11958:	030385b3          	mul	a1,t2,a6
   1195c:	01071713          	slli	a4,a4,0x10
   11960:	00e7e7b3          	or	a5,a5,a4
   11964:	00b7fe63          	bleu	a1,a5,11980 <__divdi3+0x360>
   11968:	00d787b3          	add	a5,a5,a3
   1196c:	fff80713          	addi	a4,a6,-1
   11970:	14d7e863          	bltu	a5,a3,11ac0 <__divdi3+0x4a0>
   11974:	14b7f663          	bleu	a1,a5,11ac0 <__divdi3+0x4a0>
   11978:	ffe80813          	addi	a6,a6,-2
   1197c:	00d787b3          	add	a5,a5,a3
   11980:	010e1e13          	slli	t3,t3,0x10
	      umul_ppmm (m1, m0, q0, d0);
   11984:	000103b7          	lui	t2,0x10
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11988:	010e6533          	or	a0,t3,a6
	      umul_ppmm (m1, m0, q0, d0);
   1198c:	fff38713          	addi	a4,t2,-1 # ffff <_reset+0xfdff>
   11990:	00e576b3          	and	a3,a0,a4
   11994:	01055813          	srli	a6,a0,0x10
   11998:	00e67733          	and	a4,a2,a4
   1199c:	01065613          	srli	a2,a2,0x10
   119a0:	02e68e33          	mul	t3,a3,a4
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   119a4:	40b787b3          	sub	a5,a5,a1
   119a8:	02c686b3          	mul	a3,a3,a2
	      umul_ppmm (m1, m0, q0, d0);
   119ac:	010e5593          	srli	a1,t3,0x10
   119b0:	02e80733          	mul	a4,a6,a4
   119b4:	00e686b3          	add	a3,a3,a4
   119b8:	00d586b3          	add	a3,a1,a3
   119bc:	02c80633          	mul	a2,a6,a2
   119c0:	00e6f463          	bleu	a4,a3,119c8 <__divdi3+0x3a8>
   119c4:	00760633          	add	a2,a2,t2
   119c8:	0106d813          	srli	a6,a3,0x10
   119cc:	00c80633          	add	a2,a6,a2

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   119d0:	0cc7ee63          	bltu	a5,a2,11aac <__divdi3+0x48c>
   119d4:	0ac78c63          	beq	a5,a2,11a8c <__divdi3+0x46c>
		{
		  q0--;
   119d8:	00000593          	li	a1,0
   119dc:	d49ff06f          	j	11724 <__divdi3+0x104>
	    {
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
   119e0:	01c292b3          	sll	t0,t0,t3
	      n2 = n1 >> b;
   119e4:	00a7d833          	srl	a6,a5,a0
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   119e8:	0102d713          	srli	a4,t0,0x10
   119ec:	02e85eb3          	divu	t4,a6,a4
   119f0:	01029f13          	slli	t5,t0,0x10

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   119f4:	01c796b3          	sll	a3,a5,t3
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   119f8:	010f5f13          	srli	t5,t5,0x10

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   119fc:	00a35533          	srl	a0,t1,a0
   11a00:	00d56533          	or	a0,a0,a3
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11a04:	01055613          	srli	a2,a0,0x10
	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;
   11a08:	01c313b3          	sll	t2,t1,t3

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11a0c:	02e87833          	remu	a6,a6,a4
   11a10:	03df06b3          	mul	a3,t5,t4
   11a14:	01081813          	slli	a6,a6,0x10
   11a18:	01066633          	or	a2,a2,a6
   11a1c:	00d67e63          	bleu	a3,a2,11a38 <__divdi3+0x418>
   11a20:	00560633          	add	a2,a2,t0
   11a24:	fffe8793          	addi	a5,t4,-1
   11a28:	0a566063          	bltu	a2,t0,11ac8 <__divdi3+0x4a8>
   11a2c:	08d67e63          	bleu	a3,a2,11ac8 <__divdi3+0x4a8>
   11a30:	ffee8e93          	addi	t4,t4,-2
   11a34:	00560633          	add	a2,a2,t0
   11a38:	40d60633          	sub	a2,a2,a3
   11a3c:	02e655b3          	divu	a1,a2,a4
   11a40:	01051513          	slli	a0,a0,0x10
   11a44:	01055513          	srli	a0,a0,0x10
   11a48:	02e67633          	remu	a2,a2,a4
   11a4c:	02bf07b3          	mul	a5,t5,a1
   11a50:	01061613          	slli	a2,a2,0x10
   11a54:	00c566b3          	or	a3,a0,a2
   11a58:	00f6fe63          	bleu	a5,a3,11a74 <__divdi3+0x454>
   11a5c:	005686b3          	add	a3,a3,t0
   11a60:	fff58613          	addi	a2,a1,-1
   11a64:	0456ea63          	bltu	a3,t0,11ab8 <__divdi3+0x498>
   11a68:	04f6f863          	bleu	a5,a3,11ab8 <__divdi3+0x498>
   11a6c:	ffe58593          	addi	a1,a1,-2
   11a70:	005686b3          	add	a3,a3,t0
   11a74:	010e9e93          	slli	t4,t4,0x10
   11a78:	40f686b3          	sub	a3,a3,a5
   11a7c:	00bee5b3          	or	a1,t4,a1
   11a80:	000f0813          	mv	a6,t5
   11a84:	00070613          	mv	a2,a4
   11a88:	d85ff06f          	j	1180c <__divdi3+0x1ec>
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   11a8c:	000107b7          	lui	a5,0x10
   11a90:	fff78793          	addi	a5,a5,-1 # ffff <_reset+0xfdff>
   11a94:	00f6f6b3          	and	a3,a3,a5
   11a98:	01069693          	slli	a3,a3,0x10
   11a9c:	00fe77b3          	and	a5,t3,a5
   11aa0:	00531333          	sll	t1,t1,t0
   11aa4:	00f687b3          	add	a5,a3,a5
   11aa8:	f2f378e3          	bleu	a5,t1,119d8 <__divdi3+0x3b8>
   11aac:	fff50513          	addi	a0,a0,-1
		{
		  q0--;
   11ab0:	00000593          	li	a1,0
   11ab4:	c71ff06f          	j	11724 <__divdi3+0x104>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11ab8:	00060593          	mv	a1,a2
   11abc:	fb9ff06f          	j	11a74 <__divdi3+0x454>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11ac0:	00070813          	mv	a6,a4
   11ac4:	ebdff06f          	j	11980 <__divdi3+0x360>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11ac8:	00078e93          	mv	t4,a5
   11acc:	f6dff06f          	j	11a38 <__divdi3+0x418>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11ad0:	00058e13          	mv	t3,a1
   11ad4:	e71ff06f          	j	11944 <__divdi3+0x324>
	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
	      n0 = n0 << bm;
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11ad8:	ffe50513          	addi	a0,a0,-2
   11adc:	005585b3          	add	a1,a1,t0
   11ae0:	bfdff06f          	j	116dc <__divdi3+0xbc>
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11ae4:	ffe50513          	addi	a0,a0,-2
   11ae8:	005787b3          	add	a5,a5,t0
   11aec:	d51ff06f          	j	1183c <__divdi3+0x21c>

00011af0 <__moddi3>:

#ifdef L_moddi3
DWtype
__moddi3 (DWtype u, DWtype v)
{
  Wtype c = 0;
   11af0:	00000813          	li	a6,0
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
   11af4:	1605c863          	bltz	a1,11c64 <__moddi3+0x174>
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
   11af8:	1806c263          	bltz	a3,11c7c <__moddi3+0x18c>
  DWunion rr;
  UWtype d0, d1, n0, n1, n2;
  UWtype q0, q1;
  UWtype b, bm;

  d0 = dd.s.low;
   11afc:	00060893          	mv	a7,a2
  d1 = dd.s.high;
  n0 = nn.s.low;
   11b00:	00050313          	mv	t1,a0
  n1 = nn.s.high;
   11b04:	00058393          	mv	t2,a1
	}
    }

#else /* UDIV_NEEDS_NORMALIZATION */

  if (d1 == 0)
   11b08:	0e069663          	bnez	a3,11bf4 <__moddi3+0x104>
    {
      if (d0 > n1)
   11b0c:	18c5f263          	bleu	a2,a1,11c90 <__moddi3+0x1a0>
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   11b10:	000107b7          	lui	a5,0x10
   11b14:	24f66063          	bltu	a2,a5,11d54 <__moddi3+0x264>
   11b18:	010002b7          	lui	t0,0x1000
   11b1c:	005632b3          	sltu	t0,a2,t0
   11b20:	0012c293          	xori	t0,t0,1
   11b24:	405002b3          	neg	t0,t0
   11b28:	0082f293          	andi	t0,t0,8
   11b2c:	01028293          	addi	t0,t0,16 # 1000010 <_gp+0xfb7830>
   11b30:	0001c7b7          	lui	a5,0x1c
   11b34:	00565733          	srl	a4,a2,t0
   11b38:	79478793          	addi	a5,a5,1940 # 1c794 <__clz_tab>
   11b3c:	00f707b3          	add	a5,a4,a5
   11b40:	0007c783          	lbu	a5,0(a5)
   11b44:	005787b3          	add	a5,a5,t0
   11b48:	02000293          	li	t0,32
   11b4c:	40f282b3          	sub	t0,t0,a5

	  if (bm != 0)
   11b50:	00028c63          	beqz	t0,11b68 <__moddi3+0x78>
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   11b54:	005595b3          	sll	a1,a1,t0
   11b58:	00f557b3          	srl	a5,a0,a5
	  if (bm != 0)
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
   11b5c:	005618b3          	sll	a7,a2,t0
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   11b60:	00b7e3b3          	or	t2,a5,a1
	      n0 = n0 << bm;
   11b64:	00551333          	sll	t1,a0,t0
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11b68:	0108de13          	srli	t3,a7,0x10
   11b6c:	03c3d633          	divu	a2,t2,t3
   11b70:	01089693          	slli	a3,a7,0x10
   11b74:	0106d693          	srli	a3,a3,0x10
   11b78:	01035713          	srli	a4,t1,0x10
   11b7c:	03c3f5b3          	remu	a1,t2,t3
   11b80:	02c68633          	mul	a2,a3,a2
   11b84:	01059593          	slli	a1,a1,0x10
   11b88:	00b76733          	or	a4,a4,a1
   11b8c:	00c77863          	bleu	a2,a4,11b9c <__moddi3+0xac>
   11b90:	01170733          	add	a4,a4,a7
   11b94:	01176463          	bltu	a4,a7,11b9c <__moddi3+0xac>
   11b98:	3cc76863          	bltu	a4,a2,11f68 <__moddi3+0x478>
   11b9c:	40c70733          	sub	a4,a4,a2
   11ba0:	03c757b3          	divu	a5,a4,t3
   11ba4:	01031313          	slli	t1,t1,0x10
   11ba8:	01035313          	srli	t1,t1,0x10
   11bac:	03c77733          	remu	a4,a4,t3
   11bb0:	02f68533          	mul	a0,a3,a5
   11bb4:	01071713          	slli	a4,a4,0x10
   11bb8:	00e367b3          	or	a5,t1,a4
   11bbc:	00a7fa63          	bleu	a0,a5,11bd0 <__moddi3+0xe0>
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11bc0:	011787b3          	add	a5,a5,a7
   11bc4:	0117e663          	bltu	a5,a7,11bd0 <__moddi3+0xe0>
   11bc8:	00a7f463          	bleu	a0,a5,11bd0 <__moddi3+0xe0>
   11bcc:	011787b3          	add	a5,a5,a7
   11bd0:	40a787b3          	sub	a5,a5,a0
	  /* Remainder in n0 >> bm.  */
	}

      if (rp != 0)
	{
	  rr.s.low = n0 >> bm;
   11bd4:	0057d533          	srl	a0,a5,t0
	  rr.s.high = 0;
	  *rp = rr.ll;
   11bd8:	00000593          	li	a1,0
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    vv.ll = -vv.ll;

  (void) __udivmoddi4 (uu.ll, vv.ll, (UDWtype*)&w);
  if (c)
   11bdc:	00080a63          	beqz	a6,11bf0 <__moddi3+0x100>
    w = -w;
   11be0:	40a00533          	neg	a0,a0
   11be4:	00a037b3          	snez	a5,a0
   11be8:	40b005b3          	neg	a1,a1
   11bec:	40f585b3          	sub	a1,a1,a5

  return w;
}
   11bf0:	00008067          	ret
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
   11bf4:	fed5e4e3          	bltu	a1,a3,11bdc <__moddi3+0xec>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   11bf8:	000107b7          	lui	a5,0x10
   11bfc:	16f6e463          	bltu	a3,a5,11d64 <__moddi3+0x274>
   11c00:	010008b7          	lui	a7,0x1000
   11c04:	0116b8b3          	sltu	a7,a3,a7
   11c08:	0018c893          	xori	a7,a7,1
   11c0c:	411008b3          	neg	a7,a7
   11c10:	0088f893          	andi	a7,a7,8
   11c14:	01088893          	addi	a7,a7,16 # 1000010 <_gp+0xfb7830>
   11c18:	0001c7b7          	lui	a5,0x1c
   11c1c:	0116d733          	srl	a4,a3,a7
   11c20:	79478793          	addi	a5,a5,1940 # 1c794 <__clz_tab>
   11c24:	00f707b3          	add	a5,a4,a5
   11c28:	0007ce83          	lbu	t4,0(a5)
   11c2c:	02000e13          	li	t3,32
   11c30:	011e8eb3          	add	t4,t4,a7
   11c34:	41de0e33          	sub	t3,t3,t4
	  if (bm == 0)
   11c38:	1c0e1863          	bnez	t3,11e08 <__moddi3+0x318>

		 This special case is necessary, not an optimization.  */

	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
   11c3c:	00b6e663          	bltu	a3,a1,11c48 <__moddi3+0x158>
   11c40:	00050793          	mv	a5,a0
   11c44:	00c56a63          	bltu	a0,a2,11c58 <__moddi3+0x168>
		{
		  q0 = 1;
		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
   11c48:	40c507b3          	sub	a5,a0,a2
   11c4c:	40d585b3          	sub	a1,a1,a3
   11c50:	00f53533          	sltu	a0,a0,a5
   11c54:	40a583b3          	sub	t2,a1,a0

	      if (rp != 0)
		{
		  rr.s.low = n0;
		  rr.s.high = n1;
		  *rp = rr.ll;
   11c58:	00078513          	mv	a0,a5
   11c5c:	00038593          	mv	a1,t2
   11c60:	f7dff06f          	j	11bdc <__moddi3+0xec>
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
   11c64:	40a00533          	neg	a0,a0
   11c68:	00a037b3          	snez	a5,a0
   11c6c:	40b00733          	neg	a4,a1
   11c70:	40f705b3          	sub	a1,a4,a5
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
   11c74:	fff00813          	li	a6,-1
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
   11c78:	e806d2e3          	bgez	a3,11afc <__moddi3+0xc>
    vv.ll = -vv.ll;
   11c7c:	40c00633          	neg	a2,a2
   11c80:	00c037b3          	snez	a5,a2
   11c84:	40d006b3          	neg	a3,a3
   11c88:	40f686b3          	sub	a3,a3,a5
   11c8c:	e71ff06f          	j	11afc <__moddi3+0xc>
	}
      else
	{
	  /* qq = NN / 0d */

	  if (d0 == 0)
   11c90:	00061663          	bnez	a2,11c9c <__moddi3+0x1ac>
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
   11c94:	00100893          	li	a7,1
   11c98:	02d8d8b3          	divu	a7,a7,a3

	  count_leading_zeros (bm, d0);
   11c9c:	000107b7          	lui	a5,0x10
   11ca0:	0af8e263          	bltu	a7,a5,11d44 <__moddi3+0x254>
   11ca4:	010007b7          	lui	a5,0x1000
   11ca8:	00f8b7b3          	sltu	a5,a7,a5
   11cac:	0017c793          	xori	a5,a5,1
   11cb0:	40f007b3          	neg	a5,a5
   11cb4:	0087f793          	andi	a5,a5,8
   11cb8:	01078793          	addi	a5,a5,16 # 1000010 <_gp+0xfb7830>
   11cbc:	0001c737          	lui	a4,0x1c
   11cc0:	00f8d6b3          	srl	a3,a7,a5
   11cc4:	79470713          	addi	a4,a4,1940 # 1c794 <__clz_tab>
   11cc8:	00e68733          	add	a4,a3,a4
   11ccc:	00074703          	lbu	a4,0(a4)
   11cd0:	02000293          	li	t0,32
   11cd4:	00f707b3          	add	a5,a4,a5
   11cd8:	40f282b3          	sub	t0,t0,a5

	  if (bm == 0)
   11cdc:	08029c63          	bnez	t0,11d74 <__moddi3+0x284>
   11ce0:	01089793          	slli	a5,a7,0x10
		 leading quotient digit q1 = 1).

		 This special case is necessary, not an optimization.
		 (Shifts counts of W_TYPE_SIZE are undefined.)  */

	      n1 -= d0;
   11ce4:	411585b3          	sub	a1,a1,a7
   11ce8:	0108d693          	srli	a3,a7,0x10
   11cec:	0107d793          	srli	a5,a5,0x10
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11cf0:	01035713          	srli	a4,t1,0x10
   11cf4:	02d5d633          	divu	a2,a1,a3
   11cf8:	02d5f5b3          	remu	a1,a1,a3
   11cfc:	02f60633          	mul	a2,a2,a5
   11d00:	01059593          	slli	a1,a1,0x10
   11d04:	00b76733          	or	a4,a4,a1
   11d08:	00c77a63          	bleu	a2,a4,11d1c <__moddi3+0x22c>
   11d0c:	01170733          	add	a4,a4,a7
   11d10:	01176663          	bltu	a4,a7,11d1c <__moddi3+0x22c>
   11d14:	00c77463          	bleu	a2,a4,11d1c <__moddi3+0x22c>
   11d18:	01170733          	add	a4,a4,a7
   11d1c:	40c70733          	sub	a4,a4,a2
   11d20:	02d75633          	divu	a2,a4,a3
   11d24:	01031313          	slli	t1,t1,0x10
   11d28:	01035313          	srli	t1,t1,0x10
   11d2c:	02d77733          	remu	a4,a4,a3
   11d30:	02f60533          	mul	a0,a2,a5
   11d34:	01071713          	slli	a4,a4,0x10
   11d38:	00e367b3          	or	a5,t1,a4
   11d3c:	e8a7fae3          	bleu	a0,a5,11bd0 <__moddi3+0xe0>
   11d40:	e81ff06f          	j	11bc0 <__moddi3+0xd0>
	  /* qq = NN / 0d */

	  if (d0 == 0)
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */

	  count_leading_zeros (bm, d0);
   11d44:	0ff00793          	li	a5,255
   11d48:	0117b7b3          	sltu	a5,a5,a7
   11d4c:	00379793          	slli	a5,a5,0x3
   11d50:	f6dff06f          	j	11cbc <__moddi3+0x1cc>
    {
      if (d0 > n1)
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   11d54:	0ff00293          	li	t0,255
   11d58:	00c2b2b3          	sltu	t0,t0,a2
   11d5c:	00329293          	slli	t0,t0,0x3
   11d60:	dd1ff06f          	j	11b30 <__moddi3+0x40>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   11d64:	0ff00893          	li	a7,255
   11d68:	00d8b8b3          	sltu	a7,a7,a3
   11d6c:	00389893          	slli	a7,a7,0x3
   11d70:	ea9ff06f          	j	11c18 <__moddi3+0x128>
	    {
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
   11d74:	005898b3          	sll	a7,a7,t0
	      n2 = n1 >> b;
   11d78:	00f5de33          	srl	t3,a1,a5
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11d7c:	0108d713          	srli	a4,a7,0x10
   11d80:	02ee5633          	divu	a2,t3,a4
   11d84:	01089393          	slli	t2,a7,0x10

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   11d88:	005595b3          	sll	a1,a1,t0
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11d8c:	0103d393          	srli	t2,t2,0x10

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   11d90:	00f557b3          	srl	a5,a0,a5
   11d94:	00b7e7b3          	or	a5,a5,a1
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11d98:	0107d693          	srli	a3,a5,0x10
	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;
   11d9c:	00551333          	sll	t1,a0,t0

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11da0:	02ee7e33          	remu	t3,t3,a4
   11da4:	02c385b3          	mul	a1,t2,a2
   11da8:	010e1e13          	slli	t3,t3,0x10
   11dac:	01c6e633          	or	a2,a3,t3
   11db0:	00b67a63          	bleu	a1,a2,11dc4 <__moddi3+0x2d4>
   11db4:	01160633          	add	a2,a2,a7
   11db8:	01166663          	bltu	a2,a7,11dc4 <__moddi3+0x2d4>
   11dbc:	00b67463          	bleu	a1,a2,11dc4 <__moddi3+0x2d4>
   11dc0:	01160633          	add	a2,a2,a7
   11dc4:	40b60633          	sub	a2,a2,a1
   11dc8:	02e655b3          	divu	a1,a2,a4
   11dcc:	01079793          	slli	a5,a5,0x10
   11dd0:	0107d793          	srli	a5,a5,0x10
   11dd4:	02e67633          	remu	a2,a2,a4
   11dd8:	02b385b3          	mul	a1,t2,a1
   11ddc:	01061613          	slli	a2,a2,0x10
   11de0:	00c7e6b3          	or	a3,a5,a2
   11de4:	00b6fa63          	bleu	a1,a3,11df8 <__moddi3+0x308>
   11de8:	011686b3          	add	a3,a3,a7
   11dec:	0116e663          	bltu	a3,a7,11df8 <__moddi3+0x308>
   11df0:	00b6f463          	bleu	a1,a3,11df8 <__moddi3+0x308>
   11df4:	011686b3          	add	a3,a3,a7
   11df8:	40b685b3          	sub	a1,a3,a1
   11dfc:	00038793          	mv	a5,t2
   11e00:	00070693          	mv	a3,a4
   11e04:	eedff06f          	j	11cf0 <__moddi3+0x200>
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
   11e08:	01c696b3          	sll	a3,a3,t3
   11e0c:	01d653b3          	srl	t2,a2,t4
   11e10:	0076e3b3          	or	t2,a3,t2
	      d0 = d0 << bm;
	      n2 = n1 >> b;
   11e14:	01d5d333          	srl	t1,a1,t4
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11e18:	0103d893          	srli	a7,t2,0x10
   11e1c:	031357b3          	divu	a5,t1,a7
   11e20:	01039713          	slli	a4,t2,0x10
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   11e24:	01c596b3          	sll	a3,a1,t3
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11e28:	01075713          	srli	a4,a4,0x10
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   11e2c:	01d555b3          	srl	a1,a0,t4
   11e30:	00d5e6b3          	or	a3,a1,a3
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11e34:	0106d293          	srli	t0,a3,0x10
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
   11e38:	01c61633          	sll	a2,a2,t3
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;
   11e3c:	01c51533          	sll	a0,a0,t3

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11e40:	03137333          	remu	t1,t1,a7
   11e44:	02f705b3          	mul	a1,a4,a5
   11e48:	01031313          	slli	t1,t1,0x10
   11e4c:	0062e2b3          	or	t0,t0,t1
   11e50:	00b2fe63          	bleu	a1,t0,11e6c <__moddi3+0x37c>
   11e54:	007282b3          	add	t0,t0,t2
   11e58:	fff78313          	addi	t1,a5,-1
   11e5c:	1072e263          	bltu	t0,t2,11f60 <__moddi3+0x470>
   11e60:	10b2f063          	bleu	a1,t0,11f60 <__moddi3+0x470>
   11e64:	ffe78793          	addi	a5,a5,-2
   11e68:	007282b3          	add	t0,t0,t2
   11e6c:	40b282b3          	sub	t0,t0,a1
   11e70:	0312d333          	divu	t1,t0,a7
   11e74:	01069693          	slli	a3,a3,0x10
   11e78:	0106d693          	srli	a3,a3,0x10
   11e7c:	0312f2b3          	remu	t0,t0,a7
   11e80:	02670733          	mul	a4,a4,t1
   11e84:	01029893          	slli	a7,t0,0x10
   11e88:	0116e8b3          	or	a7,a3,a7
   11e8c:	00e8fe63          	bleu	a4,a7,11ea8 <__moddi3+0x3b8>
   11e90:	007888b3          	add	a7,a7,t2
   11e94:	fff30693          	addi	a3,t1,-1
   11e98:	0c78e063          	bltu	a7,t2,11f58 <__moddi3+0x468>
   11e9c:	0ae8fe63          	bleu	a4,a7,11f58 <__moddi3+0x468>
   11ea0:	ffe30313          	addi	t1,t1,-2
   11ea4:	007888b3          	add	a7,a7,t2
   11ea8:	01079793          	slli	a5,a5,0x10
	      umul_ppmm (m1, m0, q0, d0);
   11eac:	00010fb7          	lui	t6,0x10
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11eb0:	0067e333          	or	t1,a5,t1
	      umul_ppmm (m1, m0, q0, d0);
   11eb4:	ffff8793          	addi	a5,t6,-1 # ffff <_reset+0xfdff>
   11eb8:	00f376b3          	and	a3,t1,a5
   11ebc:	01065593          	srli	a1,a2,0x10
   11ec0:	01035313          	srli	t1,t1,0x10
   11ec4:	00f677b3          	and	a5,a2,a5
   11ec8:	02f68f33          	mul	t5,a3,a5
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11ecc:	40e88733          	sub	a4,a7,a4
	      umul_ppmm (m1, m0, q0, d0);
   11ed0:	02f307b3          	mul	a5,t1,a5
   11ed4:	010f5293          	srli	t0,t5,0x10
   11ed8:	02b686b3          	mul	a3,a3,a1
   11edc:	00f686b3          	add	a3,a3,a5
   11ee0:	00d288b3          	add	a7,t0,a3
   11ee4:	02b30333          	mul	t1,t1,a1
   11ee8:	00f8f463          	bleu	a5,a7,11ef0 <__moddi3+0x400>
   11eec:	01f30333          	add	t1,t1,t6
   11ef0:	000106b7          	lui	a3,0x10
   11ef4:	fff68793          	addi	a5,a3,-1 # ffff <_reset+0xfdff>
   11ef8:	0108d693          	srli	a3,a7,0x10
   11efc:	00f8f8b3          	and	a7,a7,a5
   11f00:	01089293          	slli	t0,a7,0x10
   11f04:	00668333          	add	t1,a3,t1
   11f08:	00ff78b3          	and	a7,t5,a5
   11f0c:	011288b3          	add	a7,t0,a7

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   11f10:	00676a63          	bltu	a4,t1,11f24 <__moddi3+0x434>
   11f14:	04670e63          	beq	a4,t1,11f70 <__moddi3+0x480>
   11f18:	40670733          	sub	a4,a4,t1
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);
   11f1c:	00088793          	mv	a5,a7
   11f20:	0180006f          	j	11f38 <__moddi3+0x448>

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
		{
		  q0--;
		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
   11f24:	40c887b3          	sub	a5,a7,a2
   11f28:	40730333          	sub	t1,t1,t2
   11f2c:	00f8b8b3          	sltu	a7,a7,a5
   11f30:	411308b3          	sub	a7,t1,a7
   11f34:	41170733          	sub	a4,a4,a7
	      q1 = 0;

	      /* Remainder in (n1n0 - m1m0) >> bm.  */
	      if (rp != 0)
		{
		  sub_ddmmss (n1, n0, n1, n0, m1, m0);
   11f38:	40f507b3          	sub	a5,a0,a5
   11f3c:	00f53533          	sltu	a0,a0,a5
   11f40:	40a70733          	sub	a4,a4,a0
		  rr.s.low = (n1 << b) | (n0 >> bm);
   11f44:	01d71533          	sll	a0,a4,t4
   11f48:	01c7d7b3          	srl	a5,a5,t3
		  rr.s.high = n1 >> bm;
		  *rp = rr.ll;
   11f4c:	00f56533          	or	a0,a0,a5
   11f50:	01c755b3          	srl	a1,a4,t3
   11f54:	c89ff06f          	j	11bdc <__moddi3+0xec>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11f58:	00068313          	mv	t1,a3
   11f5c:	f4dff06f          	j	11ea8 <__moddi3+0x3b8>
   11f60:	00030793          	mv	a5,t1
   11f64:	f09ff06f          	j	11e6c <__moddi3+0x37c>
	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
	      n0 = n0 << bm;
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11f68:	01170733          	add	a4,a4,a7
   11f6c:	c31ff06f          	j	11b9c <__moddi3+0xac>
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   11f70:	fb156ae3          	bltu	a0,a7,11f24 <__moddi3+0x434>
   11f74:	00088793          	mv	a5,a7
   11f78:	00000713          	li	a4,0
   11f7c:	fbdff06f          	j	11f38 <__moddi3+0x448>

00011f80 <atexit>:
int
_DEFUN (atexit,
	(fn),
	_VOID _EXFNPTR(fn, (_VOID)))
{
  return __register_exitproc (__et_atexit, fn, NULL, NULL);
   11f80:	00050593          	mv	a1,a0
   11f84:	00000693          	li	a3,0
   11f88:	00000613          	li	a2,0
   11f8c:	00000513          	li	a0,0
   11f90:	0ec0206f          	j	1407c <__register_exitproc>

00011f94 <__libc_fini_array>:
extern void _fini (void);

/* Run all the cleanup routines.  */
void
__libc_fini_array (void)
{
   11f94:	ff010113          	addi	sp,sp,-16
   11f98:	00812423          	sw	s0,8(sp)
   11f9c:	00912223          	sw	s1,4(sp)
  size_t count;
  size_t i;
  
  count = __fini_array_end - __fini_array_start;
   11fa0:	0001d437          	lui	s0,0x1d
   11fa4:	0001d4b7          	lui	s1,0x1d
   11fa8:	d5c48493          	addi	s1,s1,-676 # 1cd5c <__init_array_end>
   11fac:	d6040413          	addi	s0,s0,-672 # 1cd60 <__fini_array_end>
   11fb0:	40940433          	sub	s0,s0,s1
   11fb4:	40245413          	srai	s0,s0,0x2
   11fb8:	00241793          	slli	a5,s0,0x2
   11fbc:	ffc78793          	addi	a5,a5,-4
extern void _fini (void);

/* Run all the cleanup routines.  */
void
__libc_fini_array (void)
{
   11fc0:	00112623          	sw	ra,12(sp)
   11fc4:	009784b3          	add	s1,a5,s1
  size_t count;
  size_t i;
  
  count = __fini_array_end - __fini_array_start;
  for (i = count; i > 0; i--)
   11fc8:	00040c63          	beqz	s0,11fe0 <__libc_fini_array+0x4c>
    __fini_array_start[i-1] ();
   11fcc:	0004a783          	lw	a5,0(s1)
   11fd0:	fff40413          	addi	s0,s0,-1
   11fd4:	ffc48493          	addi	s1,s1,-4
   11fd8:	000780e7          	jalr	a5
{
  size_t count;
  size_t i;
  
  count = __fini_array_end - __fini_array_start;
  for (i = count; i > 0; i--)
   11fdc:	fe0418e3          	bnez	s0,11fcc <__libc_fini_array+0x38>
    __fini_array_start[i-1] ();

  _fini ();
}
   11fe0:	00c12083          	lw	ra,12(sp)
   11fe4:	00812403          	lw	s0,8(sp)
   11fe8:	00412483          	lw	s1,4(sp)
   11fec:	01010113          	addi	sp,sp,16
  
  count = __fini_array_end - __fini_array_start;
  for (i = count; i > 0; i--)
    __fini_array_start[i-1] ();

  _fini ();
   11ff0:	858fe06f          	j	10048 <_fini>

00011ff4 <__libc_init_array>:
extern void _init (void);

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
   11ff4:	ff010113          	addi	sp,sp,-16
   11ff8:	00812423          	sw	s0,8(sp)
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
   11ffc:	0001d7b7          	lui	a5,0x1d
   12000:	0001d437          	lui	s0,0x1d
extern void _init (void);

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
   12004:	01212023          	sw	s2,0(sp)
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
   12008:	d5478793          	addi	a5,a5,-684 # 1cd54 <_etext>
   1200c:	d5440913          	addi	s2,s0,-684 # 1cd54 <_etext>
   12010:	41278933          	sub	s2,a5,s2
   12014:	40295913          	srai	s2,s2,0x2
extern void _init (void);

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
   12018:	00912223          	sw	s1,4(sp)
   1201c:	00112623          	sw	ra,12(sp)
   12020:	d5440413          	addi	s0,s0,-684
   12024:	00000493          	li	s1,0
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
   12028:	00090c63          	beqz	s2,12040 <__libc_init_array+0x4c>
    __preinit_array_start[i] ();
   1202c:	00042783          	lw	a5,0(s0)
{
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
   12030:	00148493          	addi	s1,s1,1
   12034:	00440413          	addi	s0,s0,4
    __preinit_array_start[i] ();
   12038:	000780e7          	jalr	a5
{
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
   1203c:	fe9918e3          	bne	s2,s1,1202c <__libc_init_array+0x38>
    __preinit_array_start[i] ();

  _init ();

  count = __init_array_end - __init_array_start;
   12040:	0001d437          	lui	s0,0x1d

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
    __preinit_array_start[i] ();

  _init ();
   12044:	804fe0ef          	jal	10048 <_fini>

  count = __init_array_end - __init_array_start;
   12048:	0001d7b7          	lui	a5,0x1d
   1204c:	d5440913          	addi	s2,s0,-684 # 1cd54 <_etext>
   12050:	d5c78793          	addi	a5,a5,-676 # 1cd5c <__init_array_end>
   12054:	41278933          	sub	s2,a5,s2
   12058:	40295913          	srai	s2,s2,0x2
   1205c:	d5440413          	addi	s0,s0,-684
  for (i = 0; i < count; i++)
   12060:	00000493          	li	s1,0
   12064:	00090c63          	beqz	s2,1207c <__libc_init_array+0x88>
    __init_array_start[i] ();
   12068:	00042783          	lw	a5,0(s0)
    __preinit_array_start[i] ();

  _init ();

  count = __init_array_end - __init_array_start;
  for (i = 0; i < count; i++)
   1206c:	00148493          	addi	s1,s1,1
   12070:	00440413          	addi	s0,s0,4
    __init_array_start[i] ();
   12074:	000780e7          	jalr	a5
    __preinit_array_start[i] ();

  _init ();

  count = __init_array_end - __init_array_start;
  for (i = 0; i < count; i++)
   12078:	fe9918e3          	bne	s2,s1,12068 <__libc_init_array+0x74>
    __init_array_start[i] ();
}
   1207c:	00c12083          	lw	ra,12(sp)
   12080:	00812403          	lw	s0,8(sp)
   12084:	00412483          	lw	s1,4(sp)
   12088:	00012903          	lw	s2,0(sp)
   1208c:	01010113          	addi	sp,sp,16
   12090:	00008067          	ret

00012094 <_printf_r>:

int
_DEFUN(_printf_r, (ptr, fmt),
       struct _reent *ptr _AND
       const char *__restrict fmt _DOTS)
{
   12094:	fc010113          	addi	sp,sp,-64
   12098:	02c12423          	sw	a2,40(sp)
   1209c:	02d12623          	sw	a3,44(sp)
   120a0:	02f12a23          	sw	a5,52(sp)
   120a4:	02e12823          	sw	a4,48(sp)
   120a8:	03012c23          	sw	a6,56(sp)
   120ac:	03112e23          	sw	a7,60(sp)
  int ret;
  va_list ap;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   120b0:	00058613          	mv	a2,a1
   120b4:	00852583          	lw	a1,8(a0)
{
  int ret;
  va_list ap;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
   120b8:	02810793          	addi	a5,sp,40
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   120bc:	00078693          	mv	a3,a5

int
_DEFUN(_printf_r, (ptr, fmt),
       struct _reent *ptr _AND
       const char *__restrict fmt _DOTS)
{
   120c0:	00112e23          	sw	ra,28(sp)
  int ret;
  va_list ap;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
   120c4:	00f12623          	sw	a5,12(sp)
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   120c8:	060000ef          	jal	12128 <_vfprintf_r>
  va_end (ap);
  return ret;
}
   120cc:	01c12083          	lw	ra,28(sp)
   120d0:	04010113          	addi	sp,sp,64
   120d4:	00008067          	ret

000120d8 <printf>:
_DEFUN(printf, (fmt),
       const char *__restrict fmt _DOTS)
{
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;
   120d8:	8101a283          	lw	t0,-2032(gp) # 47ff0 <_impure_ptr>
#ifndef _REENT_ONLY

int
_DEFUN(printf, (fmt),
       const char *__restrict fmt _DOTS)
{
   120dc:	fc010113          	addi	sp,sp,-64
   120e0:	02c12423          	sw	a2,40(sp)
   120e4:	02d12623          	sw	a3,44(sp)
   120e8:	02f12a23          	sw	a5,52(sp)
   120ec:	02b12223          	sw	a1,36(sp)
   120f0:	02e12823          	sw	a4,48(sp)
   120f4:	03012c23          	sw	a6,56(sp)
   120f8:	03112e23          	sw	a7,60(sp)
  va_list ap;
  struct _reent *ptr = _REENT;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   120fc:	0082a583          	lw	a1,8(t0)
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
   12100:	02410793          	addi	a5,sp,36
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   12104:	00050613          	mv	a2,a0
   12108:	00078693          	mv	a3,a5
   1210c:	00028513          	mv	a0,t0
#ifndef _REENT_ONLY

int
_DEFUN(printf, (fmt),
       const char *__restrict fmt _DOTS)
{
   12110:	00112e23          	sw	ra,28(sp)
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
   12114:	00f12623          	sw	a5,12(sp)
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   12118:	010000ef          	jal	12128 <_vfprintf_r>
  va_end (ap);
  return ret;
}
   1211c:	01c12083          	lw	ra,28(sp)
   12120:	04010113          	addi	sp,sp,64
   12124:	00008067          	ret

00012128 <_vfprintf_r>:
_DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
       struct _reent *data _AND
       FILE * fp           _AND
       _CONST char *fmt0   _AND
       va_list ap)
{
   12128:	ec010113          	addi	sp,sp,-320
   1212c:	12112e23          	sw	ra,316(sp)
   12130:	12912a23          	sw	s1,308(sp)
   12134:	13412423          	sw	s4,296(sp)
   12138:	11812c23          	sw	s8,280(sp)
   1213c:	00058a13          	mv	s4,a1
   12140:	00060493          	mv	s1,a2
   12144:	02d12823          	sw	a3,48(sp)
   12148:	12812c23          	sw	s0,312(sp)
   1214c:	13212823          	sw	s2,304(sp)
   12150:	13312623          	sw	s3,300(sp)
   12154:	13512223          	sw	s5,292(sp)
   12158:	13612023          	sw	s6,288(sp)
   1215c:	11712e23          	sw	s7,284(sp)
   12160:	11912a23          	sw	s9,276(sp)
   12164:	11a12823          	sw	s10,272(sp)
   12168:	11b12623          	sw	s11,268(sp)
   1216c:	00050c13          	mv	s8,a0
	char *thousands_sep = NULL;
	size_t thsnd_len = 0;
	const char *grouping = NULL;
#endif
#ifdef FLOATING_POINT
	char *decimal_point = _localeconv_r (data)->decimal_point;
   12170:	36c040ef          	jal	164dc <_localeconv_r>
   12174:	00052503          	lw	a0,0(a0)
   12178:	04a12223          	sw	a0,68(sp)
	size_t decp_len = strlen (decimal_point);
   1217c:	264060ef          	jal	183e0 <strlen>
   12180:	04a12623          	sw	a0,76(sp)
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
   12184:	000c0663          	beqz	s8,12190 <_vfprintf_r+0x68>
   12188:	038c2783          	lw	a5,56(s8)
   1218c:	2a078863          	beqz	a5,1243c <_vfprintf_r+0x314>
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);
   12190:	00ca1683          	lh	a3,12(s4)
   12194:	01069793          	slli	a5,a3,0x10
   12198:	0107d793          	srli	a5,a5,0x10
   1219c:	01279613          	slli	a2,a5,0x12
   121a0:	02064663          	bltz	a2,121cc <_vfprintf_r+0xa4>
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
	_newlib_flockfile_start (fp);
   121a4:	068a2603          	lw	a2,104(s4)

	ORIENT(fp, -1);
   121a8:	000027b7          	lui	a5,0x2
   121ac:	ffffe737          	lui	a4,0xffffe
   121b0:	00f6e7b3          	or	a5,a3,a5
   121b4:	fff70713          	addi	a4,a4,-1 # ffffdfff <_gp+0xfffb581f>
   121b8:	00e67733          	and	a4,a2,a4
   121bc:	00fa1623          	sh	a5,12(s4)
   121c0:	01079793          	slli	a5,a5,0x10
   121c4:	06ea2423          	sw	a4,104(s4)
   121c8:	0107d793          	srli	a5,a5,0x10

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   121cc:	0087f713          	andi	a4,a5,8
   121d0:	1a070263          	beqz	a4,12374 <_vfprintf_r+0x24c>
   121d4:	010a2703          	lw	a4,16(s4)
   121d8:	18070e63          	beqz	a4,12374 <_vfprintf_r+0x24c>
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   121dc:	01a7f793          	andi	a5,a5,26
   121e0:	00a00713          	li	a4,10
   121e4:	1ae78a63          	beq	a5,a4,12398 <_vfprintf_r+0x270>
   121e8:	0001d7b7          	lui	a5,0x1d
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   121ec:	0c010693          	addi	a3,sp,192
   121f0:	9f878b93          	addi	s7,a5,-1544 # 1c9f8 <blanks.4190>
   121f4:	0001d7b7          	lui	a5,0x1d
   121f8:	00d12e23          	sw	a3,28(sp)
   121fc:	08d12623          	sw	a3,140(sp)
	uio.uio_resid = 0;
   12200:	08012a23          	sw	zero,148(sp)
	uio.uio_iovcnt = 0;
   12204:	08012823          	sw	zero,144(sp)
	int expsize = 0;	/* character count for expstr */
	char expstr[MAXEXPLEN];	/* buffer for exponent string */
	int lead;		/* sig figs before decimal or group sep */
#endif /* FLOATING_POINT */
#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
	int ndig = 0;		/* actual number of digits returned by cvt */
   12208:	04012023          	sw	zero,64(sp)
#endif
#ifdef FLOATING_POINT
	char *decimal_point = _localeconv_r (data)->decimal_point;
	size_t decp_len = strlen (decimal_point);
	char softsign;		/* temporary negative sign for floats */
	union { int i; _PRINTF_FLOAT_TYPE fp; } _double_ = {0};
   1220c:	04012823          	sw	zero,80(sp)
   12210:	04012a23          	sw	zero,84(sp)
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   12214:	00068293          	mv	t0,a3
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
   12218:	04012c23          	sw	zero,88(sp)
	size_t decp_len = strlen (decimal_point);
	char softsign;		/* temporary negative sign for floats */
	union { int i; _PRINTF_FLOAT_TYPE fp; } _double_ = {0};
# define _fpvalue (_double_.fp)
	int expt;		/* integer value of exponent */
	int expsize = 0;	/* character count for expstr */
   1221c:	04012e23          	sw	zero,92(sp)
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
	uio.uio_resid = 0;
	uio.uio_iovcnt = 0;
#endif
	ret = 0;
   12220:	02012a23          	sw	zero,52(sp)
   12224:	a0878d13          	addi	s10,a5,-1528 # 1ca08 <zeroes.4191>
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   12228:	0004c783          	lbu	a5,0(s1)
   1222c:	6c078263          	beqz	a5,128f0 <_vfprintf_r+0x7c8>
   12230:	02500713          	li	a4,37
   12234:	00048413          	mv	s0,s1
   12238:	00e79663          	bne	a5,a4,12244 <_vfprintf_r+0x11c>
   1223c:	0540006f          	j	12290 <_vfprintf_r+0x168>
   12240:	00e78863          	beq	a5,a4,12250 <_vfprintf_r+0x128>
                    fmt += 1;
   12244:	00140413          	addi	s0,s0,1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   12248:	00044783          	lbu	a5,0(s0)
   1224c:	fe079ae3          	bnez	a5,12240 <_vfprintf_r+0x118>
   12250:	40940933          	sub	s2,s0,s1
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
   12254:	02090e63          	beqz	s2,12290 <_vfprintf_r+0x168>
			PRINT (cp, m);
   12258:	09412703          	lw	a4,148(sp)
   1225c:	09012783          	lw	a5,144(sp)
   12260:	0092a023          	sw	s1,0(t0)
   12264:	01270733          	add	a4,a4,s2
   12268:	00178793          	addi	a5,a5,1
   1226c:	08e12a23          	sw	a4,148(sp)
   12270:	00700713          	li	a4,7
   12274:	0122a223          	sw	s2,4(t0)
   12278:	08f12823          	sw	a5,144(sp)
   1227c:	00828293          	addi	t0,t0,8
   12280:	12f74c63          	blt	a4,a5,123b8 <_vfprintf_r+0x290>
			ret += m;
   12284:	03412703          	lw	a4,52(sp)
   12288:	01270733          	add	a4,a4,s2
   1228c:	02e12a23          	sw	a4,52(sp)
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
   12290:	00044783          	lbu	a5,0(s0)
   12294:	14078063          	beqz	a5,123d4 <_vfprintf_r+0x2ac>
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
   12298:	fff00793          	li	a5,-1
#else
                if (*fmt == '\0')
                    goto done;
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */
   1229c:	00140493          	addi	s1,s0,1

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
   122a0:	060107a3          	sb	zero,111(sp)
   122a4:	00000593          	li	a1,0
   122a8:	00000513          	li	a0,0
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
   122ac:	02f12423          	sw	a5,40(sp)
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
   122b0:	00000b13          	li	s6,0
                    goto done;
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
   122b4:	00000913          	li	s2,0
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   122b8:	05800693          	li	a3,88
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			} while (is_digit (ch));
   122bc:	00900613          	li	a2,9
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
   122c0:	02a00813          	li	a6,42
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
   122c4:	0004c983          	lbu	s3,0(s1)
   122c8:	00148493          	addi	s1,s1,1
reswitch:	switch (ch) {
   122cc:	fe098793          	addi	a5,s3,-32
   122d0:	1ef6e0e3          	bltu	a3,a5,12cb0 <_vfprintf_r+0xb88>
   122d4:	0001d737          	lui	a4,0x1d
   122d8:	00279793          	slli	a5,a5,0x2
   122dc:	89470713          	addi	a4,a4,-1900 # 1c894 <__clz_tab+0x100>
   122e0:	00e787b3          	add	a5,a5,a4
   122e4:	0007a783          	lw	a5,0(a5)
   122e8:	00078067          	jr	a5
			} else
#endif
				flags |= LONGINT;
			goto rflag;
		case 'q': /* extension */
			flags |= QUADINT;
   122ec:	01096913          	ori	s2,s2,16
			goto rflag;
   122f0:	fd5ff06f          	j	122c4 <_vfprintf_r+0x19c>
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   122f4:	03012783          	lw	a5,48(sp)
   122f8:	0007ab03          	lw	s6,0(a5)
   122fc:	00478793          	addi	a5,a5,4
   12300:	02f12823          	sw	a5,48(sp)
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
   12304:	fc0b50e3          	bgez	s6,122c4 <_vfprintf_r+0x19c>
				goto rflag;
			width = -width;
   12308:	41600b33          	neg	s6,s6
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
   1230c:	00496913          	ori	s2,s2,4
			goto rflag;
   12310:	fb5ff06f          	j	122c4 <_vfprintf_r+0x19c>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   12314:	03012683          	lw	a3,48(sp)
			base = HEX;
			xdigs = "0123456789abcdef";
			flags |= HEXPREFIX;
   12318:	00296613          	ori	a2,s2,2

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   1231c:	060107a3          	sb	zero,111(sp)
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   12320:	00468713          	addi	a4,a3,4
   12324:	0006a783          	lw	a5,0(a3)
			base = HEX;
			xdigs = "0123456789abcdef";
			flags |= HEXPREFIX;
			ox[0] = '0';
   12328:	03000693          	li	a3,48
   1232c:	06d10823          	sb	a3,112(sp)
			ox[1] = ch = 'x';
   12330:	07800693          	li	a3,120
   12334:	06d108a3          	sb	a3,113(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12338:	02812683          	lw	a3,40(sp)
   1233c:	1806cae3          	bltz	a3,12cd0 <_vfprintf_r+0xba8>
   12340:	f7f97913          	andi	s2,s2,-129
				flags &= ~ZEROPAD;
   12344:	00296913          	ori	s2,s2,2
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   12348:	02e12823          	sw	a4,48(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   1234c:	140796e3          	bnez	a5,12c98 <_vfprintf_r+0xb70>
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   12350:	0001d7b7          	lui	a5,0x1d
   12354:	d1478793          	addi	a5,a5,-748 # 1cd14 <__thenan_sf+0x34>
   12358:	04f12c23          	sw	a5,88(sp)
			flags |= HEXPREFIX;
			ox[0] = '0';
			ox[1] = ch = 'x';
   1235c:	07800993          	li	s3,120
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12360:	02812783          	lw	a5,40(sp)
   12364:	00000613          	li	a2,0
   12368:	7e078063          	beqz	a5,12b48 <_vfprintf_r+0xa20>
   1236c:	00000793          	li	a5,0
   12370:	7140006f          	j	12a84 <_vfprintf_r+0x95c>
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   12374:	000a0593          	mv	a1,s4
   12378:	000c0513          	mv	a0,s8
   1237c:	3ad010ef          	jal	13f28 <__swsetup_r>
   12380:	00050463          	beqz	a0,12388 <_vfprintf_r+0x260>
   12384:	3e00106f          	j	13764 <_vfprintf_r+0x163c>
   12388:	00ca5783          	lhu	a5,12(s4)
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   1238c:	00a00713          	li	a4,10
   12390:	01a7f793          	andi	a5,a5,26
   12394:	e4e79ae3          	bne	a5,a4,121e8 <_vfprintf_r+0xc0>
   12398:	00ea1783          	lh	a5,14(s4)
   1239c:	e407c6e3          	bltz	a5,121e8 <_vfprintf_r+0xc0>
	    fp->_file >= 0) {
		_newlib_flockfile_exit (fp);
		return (__sbprintf (data, fp, fmt0, ap));
   123a0:	03012683          	lw	a3,48(sp)
   123a4:	00048613          	mv	a2,s1
   123a8:	000a0593          	mv	a1,s4
   123ac:	000c0513          	mv	a0,s8
   123b0:	2b9010ef          	jal	13e68 <__sbprintf>
   123b4:	04c0006f          	j	12400 <_vfprintf_r+0x2d8>
#else
                while (*fmt != '\0' && *fmt != '%')
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
			PRINT (cp, m);
   123b8:	08c10613          	addi	a2,sp,140
   123bc:	000a0593          	mv	a1,s4
   123c0:	000c0513          	mv	a0,s8
   123c4:	194060ef          	jal	18558 <__sprint_r>
   123c8:	02051263          	bnez	a0,123ec <_vfprintf_r+0x2c4>
   123cc:	0c010293          	addi	t0,sp,192
   123d0:	eb5ff06f          	j	12284 <_vfprintf_r+0x15c>
			_free_r (data, malloc_buf);
			malloc_buf = NULL;
		}
	}
done:
	FLUSH ();
   123d4:	09412783          	lw	a5,148(sp)
   123d8:	00078a63          	beqz	a5,123ec <_vfprintf_r+0x2c4>
   123dc:	08c10613          	addi	a2,sp,140
   123e0:	000a0593          	mv	a1,s4
   123e4:	000c0513          	mv	a0,s8
   123e8:	170060ef          	jal	18558 <__sprint_r>
	if (malloc_buf != NULL)
		_free_r (data, malloc_buf);
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
   123ec:	00ca5783          	lhu	a5,12(s4)
   123f0:	0407f793          	andi	a5,a5,64
   123f4:	00078463          	beqz	a5,123fc <_vfprintf_r+0x2d4>
   123f8:	36c0106f          	j	13764 <_vfprintf_r+0x163c>
   123fc:	03412503          	lw	a0,52(sp)
	/* NOTREACHED */
}
   12400:	13c12083          	lw	ra,316(sp)
   12404:	13812403          	lw	s0,312(sp)
   12408:	13412483          	lw	s1,308(sp)
   1240c:	13012903          	lw	s2,304(sp)
   12410:	12c12983          	lw	s3,300(sp)
   12414:	12812a03          	lw	s4,296(sp)
   12418:	12412a83          	lw	s5,292(sp)
   1241c:	12012b03          	lw	s6,288(sp)
   12420:	11c12b83          	lw	s7,284(sp)
   12424:	11812c03          	lw	s8,280(sp)
   12428:	11412c83          	lw	s9,276(sp)
   1242c:	11012d03          	lw	s10,272(sp)
   12430:	10c12d83          	lw	s11,268(sp)
   12434:	14010113          	addi	sp,sp,320
   12438:	00008067          	ret
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
   1243c:	000c0513          	mv	a0,s8
   12440:	271030ef          	jal	15eb0 <__sinit>
   12444:	d4dff06f          	j	12190 <_vfprintf_r+0x68>
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   12448:	00100593          	li	a1,1
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
			goto rflag;
		case '+':
			sign = '+';
   1244c:	02b00513          	li	a0,43
   12450:	e75ff06f          	j	122c4 <_vfprintf_r+0x19c>
   12454:	00058463          	beqz	a1,1245c <_vfprintf_r+0x334>
   12458:	1d50106f          	j	13e2c <_vfprintf_r+0x1d04>
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   1245c:	01097793          	andi	a5,s2,16
   12460:	54078463          	beqz	a5,129a8 <_vfprintf_r+0x880>
   12464:	03012683          	lw	a3,48(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12468:	02812603          	lw	a2,40(sp)
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   1246c:	0006a783          	lw	a5,0(a3)
   12470:	00468713          	addi	a4,a3,4

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   12474:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12478:	54064863          	bltz	a2,129c8 <_vfprintf_r+0x8a0>
				flags &= ~ZEROPAD;
   1247c:	f7f97913          	andi	s2,s2,-129
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   12480:	02e12823          	sw	a4,48(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12484:	54079863          	bnez	a5,129d4 <_vfprintf_r+0x8ac>
   12488:	02812683          	lw	a3,40(sp)
   1248c:	00000613          	li	a2,0
   12490:	00000793          	li	a5,0
   12494:	00069463          	bnez	a3,1249c <_vfprintf_r+0x374>
   12498:	3c40106f          	j	1385c <_vfprintf_r+0x1734>
   1249c:	0c010413          	addi	s0,sp,192
				 * a variable; hence this switch.
				 */
				switch (base) {
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   124a0:	0077f713          	andi	a4,a5,7
   124a4:	fff40413          	addi	s0,s0,-1
   124a8:	03070713          	addi	a4,a4,48
						_uquad >>= 3;
   124ac:	0037d793          	srli	a5,a5,0x3
				 * a variable; hence this switch.
				 */
				switch (base) {
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   124b0:	00e40023          	sb	a4,0(s0)
						_uquad >>= 3;
					} while (_uquad);
   124b4:	fe0796e3          	bnez	a5,124a0 <_vfprintf_r+0x378>
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
   124b8:	00197793          	andi	a5,s2,1
   124bc:	3e0780e3          	beqz	a5,1309c <_vfprintf_r+0xf74>
   124c0:	03000793          	li	a5,48
   124c4:	48f70a63          	beq	a4,a5,12958 <_vfprintf_r+0x830>
   124c8:	01c12683          	lw	a3,28(sp)
						*--cp = '0';
   124cc:	fff40713          	addi	a4,s0,-1
   124d0:	fef40fa3          	sb	a5,-1(s0)
   124d4:	40e686b3          	sub	a3,a3,a4
   124d8:	02d12623          	sw	a3,44(sp)
   124dc:	00070413          	mv	s0,a4
   124e0:	5d40006f          	j	12ab4 <_vfprintf_r+0x98c>
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
   124e4:	0004c983          	lbu	s3,0(s1)
   124e8:	00148493          	addi	s1,s1,1
   124ec:	01099463          	bne	s3,a6,124f4 <_vfprintf_r+0x3cc>
   124f0:	0b90106f          	j	13da8 <_vfprintf_r+0x1c80>
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   124f4:	fd098893          	addi	a7,s3,-48
   124f8:	00000793          	li	a5,0
   124fc:	01167463          	bleu	a7,a2,12504 <_vfprintf_r+0x3dc>
   12500:	6300106f          	j	13b30 <_vfprintf_r+0x1a08>
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
   12504:	00148493          	addi	s1,s1,1
   12508:	fff4c983          	lbu	s3,-1(s1)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
				n = 10 * n + to_digit (ch);
   1250c:	00179713          	slli	a4,a5,0x1
   12510:	00379793          	slli	a5,a5,0x3
   12514:	00f707b3          	add	a5,a4,a5
   12518:	011787b3          	add	a5,a5,a7
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   1251c:	fd098893          	addi	a7,s3,-48
   12520:	ff1672e3          	bleu	a7,a2,12504 <_vfprintf_r+0x3dc>
   12524:	0007d463          	bgez	a5,1252c <_vfprintf_r+0x404>
   12528:	42c0106f          	j	13954 <_vfprintf_r+0x182c>
   1252c:	02f12423          	sw	a5,40(sp)
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			}
			prec = n < 0 ? -1 : n;
			goto reswitch;
   12530:	d9dff06f          	j	122cc <_vfprintf_r+0x1a4>
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
   12534:	08096913          	ori	s2,s2,128
			goto rflag;
   12538:	d8dff06f          	j	122c4 <_vfprintf_r+0x19c>
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
   1253c:	d80514e3          	bnez	a0,122c4 <_vfprintf_r+0x19c>
   12540:	00100593          	li	a1,1
				sign = ' ';
   12544:	02000513          	li	a0,32
   12548:	d7dff06f          	j	122c4 <_vfprintf_r+0x19c>
			goto rflag;
		case '#':
			flags |= ALT;
   1254c:	00196913          	ori	s2,s2,1
			goto rflag;
   12550:	d75ff06f          	j	122c4 <_vfprintf_r+0x19c>
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   12554:	03012703          	lw	a4,48(sp)
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
   12558:	060107a3          	sb	zero,111(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   1255c:	00072403          	lw	s0,0(a4)
   12560:	00470c93          	addi	s9,a4,4
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
   12564:	00041463          	bnez	s0,1256c <_vfprintf_r+0x444>
   12568:	4240106f          	j	1398c <_vfprintf_r+0x1864>
				}
				cp[size] = '\0';
			}
			else
#endif /* _MB_CAPABLE */
			if (prec >= 0) {
   1256c:	02812783          	lw	a5,40(sp)
   12570:	0007d463          	bgez	a5,12578 <_vfprintf_r+0x450>
   12574:	3400106f          	j	138b4 <_vfprintf_r+0x178c>
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);
   12578:	00078613          	mv	a2,a5
   1257c:	00000593          	li	a1,0
   12580:	00040513          	mv	a0,s0
   12584:	00512a23          	sw	t0,20(sp)
   12588:	085040ef          	jal	16e0c <memchr>

				if (p != NULL)
   1258c:	01412283          	lw	t0,20(sp)
   12590:	00051463          	bnez	a0,12598 <_vfprintf_r+0x470>
   12594:	4c80106f          	j	13a5c <_vfprintf_r+0x1934>
					size = p - cp;
   12598:	40850533          	sub	a0,a0,s0
   1259c:	02a12623          	sw	a0,44(sp)
   125a0:	00050a93          	mv	s5,a0
   125a4:	00055463          	bgez	a0,125ac <_vfprintf_r+0x484>
   125a8:	32c0106f          	j	138d4 <_vfprintf_r+0x17ac>
   125ac:	06f14603          	lbu	a2,111(sp)
				else
					size = prec;
			} else
				size = strlen (cp);
   125b0:	03512023          	sw	s5,32(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   125b4:	03912823          	sw	s9,48(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   125b8:	02012423          	sw	zero,40(sp)
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   125bc:	02012e23          	sw	zero,60(sp)
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
		if (sign)
   125c0:	00060863          	beqz	a2,125d0 <_vfprintf_r+0x4a8>
			realsz++;
   125c4:	02012783          	lw	a5,32(sp)
   125c8:	00178793          	addi	a5,a5,1
   125cc:	02f12023          	sw	a5,32(sp)
		if (flags & HEXPREFIX)
   125d0:	00297693          	andi	a3,s2,2
   125d4:	02d12223          	sw	a3,36(sp)
   125d8:	00068863          	beqz	a3,125e8 <_vfprintf_r+0x4c0>
			realsz+= 2;
   125dc:	02012703          	lw	a4,32(sp)
   125e0:	00270713          	addi	a4,a4,2
   125e4:	02e12023          	sw	a4,32(sp)

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   125e8:	08497793          	andi	a5,s2,132
   125ec:	02f12c23          	sw	a5,56(sp)
   125f0:	70079e63          	bnez	a5,12d0c <_vfprintf_r+0xbe4>
			PAD (width - realsz, blanks);
   125f4:	02012703          	lw	a4,32(sp)
   125f8:	40eb0db3          	sub	s11,s6,a4
   125fc:	71b05863          	blez	s11,12d0c <_vfprintf_r+0xbe4>
   12600:	01000813          	li	a6,16
   12604:	09412783          	lw	a5,148(sp)
   12608:	09012703          	lw	a4,144(sp)
   1260c:	05712423          	sw	s7,72(sp)
   12610:	07b85063          	ble	s11,a6,12670 <_vfprintf_r+0x548>
   12614:	00080c93          	mv	s9,a6
   12618:	00700a93          	li	s5,7
   1261c:	00c0006f          	j	12628 <_vfprintf_r+0x500>
   12620:	ff0d8d93          	addi	s11,s11,-16
   12624:	05bcd663          	ble	s11,s9,12670 <_vfprintf_r+0x548>
   12628:	01078793          	addi	a5,a5,16
   1262c:	00170713          	addi	a4,a4,1
   12630:	0172a023          	sw	s7,0(t0)
   12634:	0192a223          	sw	s9,4(t0)
   12638:	08f12a23          	sw	a5,148(sp)
   1263c:	08e12823          	sw	a4,144(sp)
   12640:	00828293          	addi	t0,t0,8
   12644:	fceadee3          	ble	a4,s5,12620 <_vfprintf_r+0x4f8>
   12648:	08c10613          	addi	a2,sp,140
   1264c:	000a0593          	mv	a1,s4
   12650:	000c0513          	mv	a0,s8
   12654:	705050ef          	jal	18558 <__sprint_r>
   12658:	d8051ae3          	bnez	a0,123ec <_vfprintf_r+0x2c4>
   1265c:	ff0d8d93          	addi	s11,s11,-16
   12660:	09412783          	lw	a5,148(sp)
   12664:	09012703          	lw	a4,144(sp)
   12668:	0c010293          	addi	t0,sp,192
   1266c:	fbbccee3          	blt	s9,s11,12628 <_vfprintf_r+0x500>
   12670:	04812683          	lw	a3,72(sp)
   12674:	00fd87b3          	add	a5,s11,a5
   12678:	00170713          	addi	a4,a4,1
   1267c:	00d2a023          	sw	a3,0(t0)
   12680:	00700693          	li	a3,7
   12684:	01b2a223          	sw	s11,4(t0)
   12688:	08f12a23          	sw	a5,148(sp)
   1268c:	08e12823          	sw	a4,144(sp)
   12690:	2ee6c8e3          	blt	a3,a4,13180 <_vfprintf_r+0x1058>
   12694:	06f14603          	lbu	a2,111(sp)
   12698:	00828293          	addi	t0,t0,8

		/* prefix */
		if (sign)
   1269c:	02060a63          	beqz	a2,126d0 <_vfprintf_r+0x5a8>
			PRINT (&sign, 1);
   126a0:	09012703          	lw	a4,144(sp)
   126a4:	06f10693          	addi	a3,sp,111
   126a8:	00d2a023          	sw	a3,0(t0)
   126ac:	00100693          	li	a3,1
   126b0:	00d2a223          	sw	a3,4(t0)
   126b4:	00178793          	addi	a5,a5,1
   126b8:	00170713          	addi	a4,a4,1
   126bc:	00700693          	li	a3,7
   126c0:	08f12a23          	sw	a5,148(sp)
   126c4:	08e12823          	sw	a4,144(sp)
   126c8:	00828293          	addi	t0,t0,8
   126cc:	18e6c0e3          	blt	a3,a4,1304c <_vfprintf_r+0xf24>
		if (flags & HEXPREFIX)
   126d0:	02412703          	lw	a4,36(sp)
   126d4:	02070a63          	beqz	a4,12708 <_vfprintf_r+0x5e0>
			PRINT (ox, 2);
   126d8:	09012703          	lw	a4,144(sp)
   126dc:	07010693          	addi	a3,sp,112
   126e0:	00d2a023          	sw	a3,0(t0)
   126e4:	00200693          	li	a3,2
   126e8:	00d2a223          	sw	a3,4(t0)
   126ec:	00278793          	addi	a5,a5,2
   126f0:	00170713          	addi	a4,a4,1
   126f4:	00700693          	li	a3,7
   126f8:	08f12a23          	sw	a5,148(sp)
   126fc:	08e12823          	sw	a4,144(sp)
   12700:	00828293          	addi	t0,t0,8
   12704:	16e6c4e3          	blt	a3,a4,1306c <_vfprintf_r+0xf44>

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   12708:	03812683          	lw	a3,56(sp)
   1270c:	08000713          	li	a4,128
   12710:	02e682e3          	beq	a3,a4,12f34 <_vfprintf_r+0xe0c>
			PAD (width - realsz, zeroes);

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   12714:	02812703          	lw	a4,40(sp)
   12718:	02c12683          	lw	a3,44(sp)
   1271c:	40d70cb3          	sub	s9,a4,a3
   12720:	0b905863          	blez	s9,127d0 <_vfprintf_r+0x6a8>
   12724:	01000d93          	li	s11,16
   12728:	09012703          	lw	a4,144(sp)
   1272c:	03a12223          	sw	s10,36(sp)
   12730:	059dde63          	ble	s9,s11,1278c <_vfprintf_r+0x664>
   12734:	00700a93          	li	s5,7
   12738:	00c0006f          	j	12744 <_vfprintf_r+0x61c>
   1273c:	ff0c8c93          	addi	s9,s9,-16
   12740:	059dd663          	ble	s9,s11,1278c <_vfprintf_r+0x664>
   12744:	01078793          	addi	a5,a5,16
   12748:	00170713          	addi	a4,a4,1
   1274c:	01a2a023          	sw	s10,0(t0)
   12750:	01b2a223          	sw	s11,4(t0)
   12754:	08f12a23          	sw	a5,148(sp)
   12758:	08e12823          	sw	a4,144(sp)
   1275c:	00828293          	addi	t0,t0,8
   12760:	fceadee3          	ble	a4,s5,1273c <_vfprintf_r+0x614>
   12764:	08c10613          	addi	a2,sp,140
   12768:	000a0593          	mv	a1,s4
   1276c:	000c0513          	mv	a0,s8
   12770:	5e9050ef          	jal	18558 <__sprint_r>
   12774:	c6051ce3          	bnez	a0,123ec <_vfprintf_r+0x2c4>
   12778:	ff0c8c93          	addi	s9,s9,-16
   1277c:	09412783          	lw	a5,148(sp)
   12780:	09012703          	lw	a4,144(sp)
   12784:	0c010293          	addi	t0,sp,192
   12788:	fb9dcee3          	blt	s11,s9,12744 <_vfprintf_r+0x61c>
   1278c:	02412683          	lw	a3,36(sp)
   12790:	019787b3          	add	a5,a5,s9
   12794:	00170713          	addi	a4,a4,1
   12798:	00d2a023          	sw	a3,0(t0)
   1279c:	00700693          	li	a3,7
   127a0:	0192a223          	sw	s9,4(t0)
   127a4:	08f12a23          	sw	a5,148(sp)
   127a8:	08e12823          	sw	a4,144(sp)
   127ac:	00828293          	addi	t0,t0,8
   127b0:	02e6d063          	ble	a4,a3,127d0 <_vfprintf_r+0x6a8>
   127b4:	08c10613          	addi	a2,sp,140
   127b8:	000a0593          	mv	a1,s4
   127bc:	000c0513          	mv	a0,s8
   127c0:	599050ef          	jal	18558 <__sprint_r>
   127c4:	c20514e3          	bnez	a0,123ec <_vfprintf_r+0x2c4>
   127c8:	09412783          	lw	a5,148(sp)
   127cc:	0c010293          	addi	t0,sp,192

		/* the string or number proper */
#ifdef FLOATING_POINT
		if ((flags & FPT) == 0) {
   127d0:	10097713          	andi	a4,s2,256
   127d4:	64071263          	bnez	a4,12e18 <_vfprintf_r+0xcf0>
			PRINT (cp, size);
   127d8:	02c12703          	lw	a4,44(sp)
   127dc:	02c12683          	lw	a3,44(sp)
   127e0:	0082a023          	sw	s0,0(t0)
   127e4:	00e787b3          	add	a5,a5,a4
   127e8:	09012703          	lw	a4,144(sp)
   127ec:	00d2a223          	sw	a3,4(t0)
   127f0:	00700693          	li	a3,7
   127f4:	00170713          	addi	a4,a4,1
   127f8:	08f12a23          	sw	a5,148(sp)
   127fc:	08e12823          	sw	a4,144(sp)
   12800:	5ee6cc63          	blt	a3,a4,12df8 <_vfprintf_r+0xcd0>
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
   12804:	00828293          	addi	t0,t0,8
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   12808:	00497913          	andi	s2,s2,4
   1280c:	0a090a63          	beqz	s2,128c0 <_vfprintf_r+0x798>
			PAD (width - realsz, blanks);
   12810:	02012703          	lw	a4,32(sp)
   12814:	40eb0433          	sub	s0,s6,a4
   12818:	0a805463          	blez	s0,128c0 <_vfprintf_r+0x798>
   1281c:	01000913          	li	s2,16
   12820:	09012703          	lw	a4,144(sp)
   12824:	05712423          	sw	s7,72(sp)
   12828:	04895e63          	ble	s0,s2,12884 <_vfprintf_r+0x75c>
   1282c:	00700993          	li	s3,7
   12830:	00c0006f          	j	1283c <_vfprintf_r+0x714>
   12834:	ff040413          	addi	s0,s0,-16
   12838:	04895663          	ble	s0,s2,12884 <_vfprintf_r+0x75c>
   1283c:	01078793          	addi	a5,a5,16
   12840:	00170713          	addi	a4,a4,1
   12844:	0172a023          	sw	s7,0(t0)
   12848:	0122a223          	sw	s2,4(t0)
   1284c:	08f12a23          	sw	a5,148(sp)
   12850:	08e12823          	sw	a4,144(sp)
   12854:	00828293          	addi	t0,t0,8
   12858:	fce9dee3          	ble	a4,s3,12834 <_vfprintf_r+0x70c>
   1285c:	08c10613          	addi	a2,sp,140
   12860:	000a0593          	mv	a1,s4
   12864:	000c0513          	mv	a0,s8
   12868:	4f1050ef          	jal	18558 <__sprint_r>
   1286c:	b80510e3          	bnez	a0,123ec <_vfprintf_r+0x2c4>
   12870:	ff040413          	addi	s0,s0,-16
   12874:	09412783          	lw	a5,148(sp)
   12878:	09012703          	lw	a4,144(sp)
   1287c:	0c010293          	addi	t0,sp,192
   12880:	fa894ee3          	blt	s2,s0,1283c <_vfprintf_r+0x714>
   12884:	04812683          	lw	a3,72(sp)
   12888:	008787b3          	add	a5,a5,s0
   1288c:	00170713          	addi	a4,a4,1
   12890:	00d2a023          	sw	a3,0(t0)
   12894:	00700693          	li	a3,7
   12898:	0082a223          	sw	s0,4(t0)
   1289c:	08f12a23          	sw	a5,148(sp)
   128a0:	08e12823          	sw	a4,144(sp)
   128a4:	00e6de63          	ble	a4,a3,128c0 <_vfprintf_r+0x798>
   128a8:	08c10613          	addi	a2,sp,140
   128ac:	000a0593          	mv	a1,s4
   128b0:	000c0513          	mv	a0,s8
   128b4:	4a5050ef          	jal	18558 <__sprint_r>
   128b8:	b2051ae3          	bnez	a0,123ec <_vfprintf_r+0x2c4>
   128bc:	09412783          	lw	a5,148(sp)

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   128c0:	02012603          	lw	a2,32(sp)
   128c4:	000b0713          	mv	a4,s6
   128c8:	00cb5463          	ble	a2,s6,128d0 <_vfprintf_r+0x7a8>
   128cc:	00060713          	mv	a4,a2
   128d0:	03412683          	lw	a3,52(sp)
   128d4:	00e686b3          	add	a3,a3,a4
   128d8:	02d12a23          	sw	a3,52(sp)

		FLUSH ();	/* copy out the I/O vectors */
   128dc:	74079c63          	bnez	a5,13034 <_vfprintf_r+0xf0c>
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   128e0:	0004c783          	lbu	a5,0(s1)
			PAD (width - realsz, blanks);

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;

		FLUSH ();	/* copy out the I/O vectors */
   128e4:	08012823          	sw	zero,144(sp)
   128e8:	0c010293          	addi	t0,sp,192
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   128ec:	940792e3          	bnez	a5,12230 <_vfprintf_r+0x108>
   128f0:	00048413          	mv	s0,s1
   128f4:	99dff06f          	j	12290 <_vfprintf_r+0x168>
   128f8:	00058463          	beqz	a1,12900 <_vfprintf_r+0x7d8>
   128fc:	5200106f          	j	13e1c <_vfprintf_r+0x1cf4>
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   12900:	01097793          	andi	a5,s2,16
   12904:	0e078663          	beqz	a5,129f0 <_vfprintf_r+0x8c8>
   12908:	03012683          	lw	a3,48(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   1290c:	02812603          	lw	a2,40(sp)
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   12910:	0006a783          	lw	a5,0(a3)
   12914:	00468713          	addi	a4,a3,4

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   12918:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   1291c:	0e064a63          	bltz	a2,12a10 <_vfprintf_r+0x8e8>
				flags &= ~ZEROPAD;
   12920:	f7f97913          	andi	s2,s2,-129
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   12924:	02e12823          	sw	a4,48(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12928:	00000613          	li	a2,0
   1292c:	20078a63          	beqz	a5,12b40 <_vfprintf_r+0xa18>
						*--cp = '0';
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   12930:	00900713          	li	a4,9
   12934:	0c010413          	addi	s0,sp,192
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   12938:	00a00693          	li	a3,10
						*--cp = '0';
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   1293c:	74f77a63          	bleu	a5,a4,13090 <_vfprintf_r+0xf68>
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   12940:	02d7f733          	remu	a4,a5,a3
   12944:	fff40413          	addi	s0,s0,-1
					       next cases. */
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
   12948:	02d7d7b3          	divu	a5,a5,a3
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   1294c:	03070713          	addi	a4,a4,48
   12950:	00e40023          	sb	a4,0(s0)
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
					} while (_uquad != 0);
   12954:	fe0796e3          	bnez	a5,12940 <_vfprintf_r+0x818>
   12958:	01c12783          	lw	a5,28(sp)
   1295c:	408787b3          	sub	a5,a5,s0
   12960:	02f12623          	sw	a5,44(sp)
   12964:	1500006f          	j	12ab4 <_vfprintf_r+0x98c>
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   12968:	00000b13          	li	s6,0
   1296c:	fd098893          	addi	a7,s3,-48
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
   12970:	00148493          	addi	s1,s1,1
   12974:	fff4c983          	lbu	s3,-1(s1)
			goto rflag;
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
   12978:	001b1793          	slli	a5,s6,0x1
   1297c:	003b1b13          	slli	s6,s6,0x3
   12980:	01678b33          	add	s6,a5,s6
   12984:	01688b33          	add	s6,a7,s6
				ch = *fmt++;
			} while (is_digit (ch));
   12988:	fd098893          	addi	a7,s3,-48
   1298c:	ff1672e3          	bleu	a7,a2,12970 <_vfprintf_r+0x848>
   12990:	93dff06f          	j	122cc <_vfprintf_r+0x1a4>
   12994:	00058463          	beqz	a1,1299c <_vfprintf_r+0x874>
   12998:	4780106f          	j	13e10 <_vfprintf_r+0x1ce8>
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
   1299c:	01096913          	ori	s2,s2,16
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   129a0:	01097793          	andi	a5,s2,16
   129a4:	ac0790e3          	bnez	a5,12464 <_vfprintf_r+0x33c>
   129a8:	03012683          	lw	a3,48(sp)
   129ac:	04097793          	andi	a5,s2,64
   129b0:	00468713          	addi	a4,a3,4
   129b4:	200788e3          	beqz	a5,133c4 <_vfprintf_r+0x129c>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   129b8:	02812603          	lw	a2,40(sp)
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   129bc:	0006d783          	lhu	a5,0(a3)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   129c0:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   129c4:	aa065ce3          	bgez	a2,1247c <_vfprintf_r+0x354>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   129c8:	02e12823          	sw	a4,48(sp)
   129cc:	00000613          	li	a2,0
   129d0:	32078263          	beqz	a5,12cf4 <_vfprintf_r+0xbcc>
   129d4:	00000613          	li	a2,0
   129d8:	ac5ff06f          	j	1249c <_vfprintf_r+0x374>
   129dc:	00058463          	beqz	a1,129e4 <_vfprintf_r+0x8bc>
   129e0:	4240106f          	j	13e04 <_vfprintf_r+0x1cdc>
			} else
				size = strlen (cp);

			break;
		case 'U': /* extension */
			flags |= LONGINT;
   129e4:	01096913          	ori	s2,s2,16
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   129e8:	01097793          	andi	a5,s2,16
   129ec:	f0079ee3          	bnez	a5,12908 <_vfprintf_r+0x7e0>
   129f0:	03012683          	lw	a3,48(sp)
   129f4:	04097793          	andi	a5,s2,64
   129f8:	00468713          	addi	a4,a3,4
   129fc:	1a078ae3          	beqz	a5,133b0 <_vfprintf_r+0x1288>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12a00:	02812603          	lw	a2,40(sp)
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   12a04:	0006d783          	lhu	a5,0(a3)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   12a08:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12a0c:	f0065ae3          	bgez	a2,12920 <_vfprintf_r+0x7f8>
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   12a10:	02e12823          	sw	a4,48(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12a14:	00000613          	li	a2,0
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12a18:	f0079ce3          	bnez	a5,12930 <_vfprintf_r+0x808>
   12a1c:	00100793          	li	a5,1
   12a20:	2d40006f          	j	12cf4 <_vfprintf_r+0xbcc>
   12a24:	00058463          	beqz	a1,12a2c <_vfprintf_r+0x904>
   12a28:	3d40106f          	j	13dfc <_vfprintf_r+0x1cd4>
		case 'u':
			_uquad = UARG ();
			base = DEC;
			goto nosign;
		case 'X':
			xdigs = "0123456789ABCDEF";
   12a2c:	0001d7b7          	lui	a5,0x1d
   12a30:	d0078793          	addi	a5,a5,-768 # 1cd00 <__thenan_sf+0x20>
   12a34:	04f12c23          	sw	a5,88(sp)
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
   12a38:	01097793          	andi	a5,s2,16
   12a3c:	12078c63          	beqz	a5,12b74 <_vfprintf_r+0xa4c>
   12a40:	03012683          	lw	a3,48(sp)
   12a44:	0006a783          	lw	a5,0(a3)
   12a48:	00468693          	addi	a3,a3,4
   12a4c:	02d12823          	sw	a3,48(sp)
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
   12a50:	00197713          	andi	a4,s2,1
   12a54:	64070c63          	beqz	a4,130ac <_vfprintf_r+0xf84>
   12a58:	400780e3          	beqz	a5,13658 <_vfprintf_r+0x1530>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12a5c:	02812603          	lw	a2,40(sp)
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
				ox[0] = '0';
   12a60:	03000713          	li	a4,48
   12a64:	06e10823          	sb	a4,112(sp)
				ox[1] = ch;
   12a68:	073108a3          	sb	s3,113(sp)
				flags |= HEXPREFIX;
   12a6c:	00296713          	ori	a4,s2,2

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   12a70:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12a74:	760648e3          	bltz	a2,139e4 <_vfprintf_r+0x18bc>
   12a78:	f7f97913          	andi	s2,s2,-129
				flags &= ~ZEROPAD;
   12a7c:	00296913          	ori	s2,s2,2
   12a80:	00000613          	li	a2,0
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12a84:	05812683          	lw	a3,88(sp)
   12a88:	0c010413          	addi	s0,sp,192
					} while (_uquad != 0);
					break;

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   12a8c:	00f7f713          	andi	a4,a5,15
   12a90:	00e68733          	add	a4,a3,a4
   12a94:	00074703          	lbu	a4,0(a4)
   12a98:	fff40413          	addi	s0,s0,-1
						_uquad >>= 4;
   12a9c:	0047d793          	srli	a5,a5,0x4
					} while (_uquad != 0);
					break;

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   12aa0:	00e40023          	sb	a4,0(s0)
						_uquad >>= 4;
					} while (_uquad);
   12aa4:	fe0794e3          	bnez	a5,12a8c <_vfprintf_r+0x964>
   12aa8:	01c12683          	lw	a3,28(sp)
   12aac:	408686b3          	sub	a3,a3,s0
   12ab0:	02d12623          	sw	a3,44(sp)
   12ab4:	02c12a83          	lw	s5,44(sp)
   12ab8:	02812783          	lw	a5,40(sp)
   12abc:	00fad463          	ble	a5,s5,12ac4 <_vfprintf_r+0x99c>
   12ac0:	00078a93          	mv	s5,a5
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   12ac4:	03512023          	sw	s5,32(sp)
   12ac8:	02012e23          	sw	zero,60(sp)
   12acc:	af5ff06f          	j	125c0 <_vfprintf_r+0x498>
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   12ad0:	03012603          	lw	a2,48(sp)
				size = 1;
			}
			sign = '\0';
			break;
   12ad4:	00100713          	li	a4,1
   12ad8:	02e12023          	sw	a4,32(sp)
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   12adc:	00062783          	lw	a5,0(a2)
   12ae0:	00460613          	addi	a2,a2,4
				size = 1;
			}
			sign = '\0';
   12ae4:	060107a3          	sb	zero,111(sp)
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   12ae8:	08f10c23          	sb	a5,152(sp)
   12aec:	02c12823          	sw	a2,48(sp)
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
   12af0:	00000613          	li	a2,0
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
   12af4:	02e12623          	sw	a4,44(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   12af8:	02012423          	sw	zero,40(sp)
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   12afc:	02012e23          	sw	zero,60(sp)
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
   12b00:	09810413          	addi	s0,sp,152
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
   12b04:	acdff06f          	j	125d0 <_vfprintf_r+0x4a8>
   12b08:	00058463          	beqz	a1,12b10 <_vfprintf_r+0x9e8>
   12b0c:	2cc0106f          	j	13dd8 <_vfprintf_r+0x1cb0>
		case 'D':  /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   12b10:	01097793          	andi	a5,s2,16
   12b14:	12078a63          	beqz	a5,12c48 <_vfprintf_r+0xb20>
   12b18:	03012603          	lw	a2,48(sp)
   12b1c:	00062783          	lw	a5,0(a2)
   12b20:	00460613          	addi	a2,a2,4
   12b24:	02c12823          	sw	a2,48(sp)
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
#else
			if ((long) _uquad < 0)
   12b28:	1207c4e3          	bltz	a5,13450 <_vfprintf_r+0x1328>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12b2c:	02812683          	lw	a3,40(sp)
   12b30:	06f14603          	lbu	a2,111(sp)
   12b34:	ee06c2e3          	bltz	a3,12a18 <_vfprintf_r+0x8f0>
				flags &= ~ZEROPAD;
   12b38:	f7f97913          	andi	s2,s2,-129
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12b3c:	de079ae3          	bnez	a5,12930 <_vfprintf_r+0x808>
   12b40:	02812703          	lw	a4,40(sp)
   12b44:	54071463          	bnez	a4,1308c <_vfprintf_r+0xf64>
   12b48:	02012423          	sw	zero,40(sp)
   12b4c:	02012623          	sw	zero,44(sp)
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   12b50:	0c010413          	addi	s0,sp,192
   12b54:	f61ff06f          	j	12ab4 <_vfprintf_r+0x98c>
   12b58:	00058463          	beqz	a1,12b60 <_vfprintf_r+0xa38>
   12b5c:	2980106f          	j	13df4 <_vfprintf_r+0x1ccc>
			goto nosign;
		case 'X':
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
   12b60:	0001d7b7          	lui	a5,0x1d
   12b64:	d1478793          	addi	a5,a5,-748 # 1cd14 <__thenan_sf+0x34>
   12b68:	04f12c23          	sw	a5,88(sp)
hex:			_uquad = UARG ();
   12b6c:	01097793          	andi	a5,s2,16
   12b70:	ec0798e3          	bnez	a5,12a40 <_vfprintf_r+0x918>
   12b74:	04097793          	andi	a5,s2,64
   12b78:	2c0786e3          	beqz	a5,13644 <_vfprintf_r+0x151c>
   12b7c:	03012703          	lw	a4,48(sp)
   12b80:	00075783          	lhu	a5,0(a4)
   12b84:	00470713          	addi	a4,a4,4
   12b88:	02e12823          	sw	a4,48(sp)
   12b8c:	ec5ff06f          	j	12a50 <_vfprintf_r+0x928>
   12b90:	00058463          	beqz	a1,12b98 <_vfprintf_r+0xa70>
   12b94:	2580106f          	j	13dec <_vfprintf_r+0x1cc4>
		case 'E':
		case 'f':
		case 'g':
		case 'G':
# ifdef _NO_LONGDBL
			if (flags & LONGDBL) {
   12b98:	00897793          	andi	a5,s2,8
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
   12b9c:	03012603          	lw	a2,48(sp)
		case 'E':
		case 'f':
		case 'g':
		case 'G':
# ifdef _NO_LONGDBL
			if (flags & LONGDBL) {
   12ba0:	280780e3          	beqz	a5,13620 <_vfprintf_r+0x14f8>
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
   12ba4:	00760793          	addi	a5,a2,7
   12ba8:	ff87f793          	andi	a5,a5,-8
   12bac:	00878693          	addi	a3,a5,8
   12bb0:	0007a703          	lw	a4,0(a5)
   12bb4:	0047a783          	lw	a5,4(a5)
   12bb8:	02d12823          	sw	a3,48(sp)
   12bbc:	04e12823          	sw	a4,80(sp)
   12bc0:	04f12a23          	sw	a5,84(sp)

			   If the output is infinite or NaN, leading
			   zeros are not permitted.  Otherwise, scanf
			   could not read what printf wrote.
			 */
			if (isinf (_fpvalue)) {
   12bc4:	05012503          	lw	a0,80(sp)
   12bc8:	05412583          	lw	a1,84(sp)
   12bcc:	00512a23          	sw	t0,20(sp)
   12bd0:	00100413          	li	s0,1
   12bd4:	514050ef          	jal	180e8 <__fpclassifyd>
   12bd8:	01412283          	lw	t0,20(sp)
   12bdc:	08851ae3          	bne	a0,s0,13470 <_vfprintf_r+0x1348>
				if (_fpvalue < 0)
   12be0:	05012503          	lw	a0,80(sp)
   12be4:	05412583          	lw	a1,84(sp)
   12be8:	00000613          	li	a2,0
   12bec:	00000693          	li	a3,0
   12bf0:	1ed080ef          	jal	1b5dc <__ltdf2>
   12bf4:	01412283          	lw	t0,20(sp)
   12bf8:	600544e3          	bltz	a0,13a00 <_vfprintf_r+0x18d8>
   12bfc:	06f14603          	lbu	a2,111(sp)
					sign = '-';
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
   12c00:	04700793          	li	a5,71
   12c04:	3b37dae3          	ble	s3,a5,137b8 <_vfprintf_r+0x1690>
					cp = "INF";
				else
					cp = "inf";
   12c08:	0001d437          	lui	s0,0x1d
   12c0c:	cf440413          	addi	s0,s0,-780 # 1ccf4 <__thenan_sf+0x14>
				size = 3;
				flags &= ~ZEROPAD;
				break;
   12c10:	00300793          	li	a5,3
   12c14:	02f12023          	sw	a5,32(sp)
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "INF";
				else
					cp = "inf";
				size = 3;
				flags &= ~ZEROPAD;
   12c18:	f7f97913          	andi	s2,s2,-129
					sign = '-';
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "INF";
				else
					cp = "inf";
				size = 3;
   12c1c:	02f12623          	sw	a5,44(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   12c20:	02012423          	sw	zero,40(sp)
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   12c24:	02012e23          	sw	zero,60(sp)
					cp = "INF";
				else
					cp = "inf";
				size = 3;
				flags &= ~ZEROPAD;
				break;
   12c28:	999ff06f          	j	125c0 <_vfprintf_r+0x498>
#endif /* !_NO_POS_ARGS */
			width = n;
			goto reswitch;
#ifdef FLOATING_POINT
		case 'L':
			flags |= LONGDBL;
   12c2c:	00896913          	ori	s2,s2,8
			goto rflag;
   12c30:	e94ff06f          	j	122c4 <_vfprintf_r+0x19c>
   12c34:	00058463          	beqz	a1,12c3c <_vfprintf_r+0xb14>
   12c38:	1a80106f          	j	13de0 <_vfprintf_r+0x1cb8>
				size = 1;
			}
			sign = '\0';
			break;
		case 'D':  /* extension */
			flags |= LONGINT;
   12c3c:	01096913          	ori	s2,s2,16
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   12c40:	01097793          	andi	a5,s2,16
   12c44:	ec079ae3          	bnez	a5,12b18 <_vfprintf_r+0x9f0>
   12c48:	04097793          	andi	a5,s2,64
   12c4c:	1c0780e3          	beqz	a5,1360c <_vfprintf_r+0x14e4>
   12c50:	03012683          	lw	a3,48(sp)
   12c54:	00069783          	lh	a5,0(a3)
   12c58:	00468693          	addi	a3,a3,4
   12c5c:	02d12823          	sw	a3,48(sp)
   12c60:	ec9ff06f          	j	12b28 <_vfprintf_r+0xa00>
   12c64:	00058463          	beqz	a1,12c6c <_vfprintf_r+0xb44>
   12c68:	1e40106f          	j	13e4c <_vfprintf_r+0x1d24>
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
				*GET_ARG (N, ap, quad_ptr_t) = ret;
			else
#endif
			if (flags & LONGINT)
   12c6c:	01097793          	andi	a5,s2,16
   12c70:	16078ce3          	beqz	a5,135e8 <_vfprintf_r+0x14c0>
				*GET_ARG (N, ap, long_ptr_t) = ret;
   12c74:	03012683          	lw	a3,48(sp)
   12c78:	03412703          	lw	a4,52(sp)
   12c7c:	0006a783          	lw	a5,0(a3)
   12c80:	00468693          	addi	a3,a3,4
   12c84:	02d12823          	sw	a3,48(sp)
   12c88:	00e7a023          	sw	a4,0(a5)
   12c8c:	d9cff06f          	j	12228 <_vfprintf_r+0x100>
			if (*fmt == 'h') {
				fmt++;
				flags |= CHARINT;
			} else
#endif
				flags |= SHORTINT;
   12c90:	04096913          	ori	s2,s2,64
			goto rflag;
   12c94:	e30ff06f          	j	122c4 <_vfprintf_r+0x19c>
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   12c98:	0001d737          	lui	a4,0x1d
   12c9c:	d1470713          	addi	a4,a4,-748 # 1cd14 <__thenan_sf+0x34>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12ca0:	00000613          	li	a2,0
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   12ca4:	04e12c23          	sw	a4,88(sp)
			flags |= HEXPREFIX;
			ox[0] = '0';
			ox[1] = ch = 'x';
   12ca8:	07800993          	li	s3,120
   12cac:	dd9ff06f          	j	12a84 <_vfprintf_r+0x95c>
   12cb0:	00058463          	beqz	a1,12cb8 <_vfprintf_r+0xb90>
   12cb4:	1900106f          	j	13e44 <_vfprintf_r+0x1d1c>

			size = buf + BUF - cp;
		skipsize:
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
   12cb8:	f0098e63          	beqz	s3,123d4 <_vfprintf_r+0x2ac>
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
   12cbc:	00100713          	li	a4,1
   12cc0:	02e12023          	sw	a4,32(sp)
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
   12cc4:	09310c23          	sb	s3,152(sp)
			size = 1;
			sign = '\0';
   12cc8:	060107a3          	sb	zero,111(sp)
   12ccc:	e25ff06f          	j	12af0 <_vfprintf_r+0x9c8>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   12cd0:	02e12823          	sw	a4,48(sp)
			base = HEX;
			xdigs = "0123456789abcdef";
   12cd4:	0001d737          	lui	a4,0x1d
   12cd8:	d1470713          	addi	a4,a4,-748 # 1cd14 <__thenan_sf+0x34>
			flags |= HEXPREFIX;
   12cdc:	00060913          	mv	s2,a2
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   12ce0:	04e12c23          	sw	a4,88(sp)
			flags |= HEXPREFIX;
			ox[0] = '0';
			ox[1] = ch = 'x';
   12ce4:	07800993          	li	s3,120
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   12ce8:	3c079c63          	bnez	a5,130c0 <_vfprintf_r+0xf98>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   12cec:	00000613          	li	a2,0
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
   12cf0:	00200793          	li	a5,2
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   12cf4:	00100713          	li	a4,1
   12cf8:	38e78a63          	beq	a5,a4,1308c <_vfprintf_r+0xf64>
   12cfc:	00200713          	li	a4,2
   12d00:	e6e78663          	beq	a5,a4,1236c <_vfprintf_r+0x244>
   12d04:	00000793          	li	a5,0
   12d08:	f94ff06f          	j	1249c <_vfprintf_r+0x374>
   12d0c:	09412783          	lw	a5,148(sp)
   12d10:	98dff06f          	j	1269c <_vfprintf_r+0x574>
					PRINTANDPAD (cp, convbuf + ndig,
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
   12d14:	09012983          	lw	s3,144(sp)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
   12d18:	04012603          	lw	a2,64(sp)
   12d1c:	00100713          	li	a4,1
					PRINT (cp, 1);
   12d20:	00178793          	addi	a5,a5,1
   12d24:	00198993          	addi	s3,s3,1
   12d28:	0082a023          	sw	s0,0(t0)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
   12d2c:	2cc75263          	ble	a2,a4,12ff0 <_vfprintf_r+0xec8>
					PRINT (cp, 1);
   12d30:	00100713          	li	a4,1
   12d34:	00e2a223          	sw	a4,4(t0)
   12d38:	00700713          	li	a4,7
   12d3c:	08f12a23          	sw	a5,148(sp)
   12d40:	09312823          	sw	s3,144(sp)
   12d44:	00828293          	addi	t0,t0,8
   12d48:	69374863          	blt	a4,s3,133d8 <_vfprintf_r+0x12b0>
					cp++;
					PRINT (decimal_point, decp_len);
   12d4c:	04c12683          	lw	a3,76(sp)
   12d50:	04412703          	lw	a4,68(sp)
   12d54:	00198993          	addi	s3,s3,1
   12d58:	00f687b3          	add	a5,a3,a5
   12d5c:	00e2a023          	sw	a4,0(t0)
   12d60:	00700713          	li	a4,7
   12d64:	00d2a223          	sw	a3,4(t0)
   12d68:	08f12a23          	sw	a5,148(sp)
   12d6c:	09312823          	sw	s3,144(sp)
   12d70:	00828c93          	addi	s9,t0,8
   12d74:	69374663          	blt	a4,s3,13400 <_vfprintf_r+0x12d8>
					if (_fpvalue) {
   12d78:	05012503          	lw	a0,80(sp)
   12d7c:	05412583          	lw	a1,84(sp)
   12d80:	00000613          	li	a2,0
   12d84:	00000693          	li	a3,0
   12d88:	00f12c23          	sw	a5,24(sp)
   12d8c:	055080ef          	jal	1b5e0 <__nedf2>
   12d90:	01812783          	lw	a5,24(sp)
   12d94:	40050863          	beqz	a0,131a4 <_vfprintf_r+0x107c>
						PRINT (cp, ndig - 1);
   12d98:	04012603          	lw	a2,64(sp)
   12d9c:	00140413          	addi	s0,s0,1
   12da0:	00198993          	addi	s3,s3,1
   12da4:	fff60713          	addi	a4,a2,-1
   12da8:	00e787b3          	add	a5,a5,a4
   12dac:	00eca223          	sw	a4,4(s9)
   12db0:	00700713          	li	a4,7
   12db4:	008ca023          	sw	s0,0(s9)
   12db8:	08f12a23          	sw	a5,148(sp)
   12dbc:	09312823          	sw	s3,144(sp)
   12dc0:	25374863          	blt	a4,s3,13010 <_vfprintf_r+0xee8>
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
   12dc4:	008c8c93          	addi	s9,s9,8
				} else	/* XeYYY */
					PRINT (cp, 1);
				PRINT (expstr, expsize);
   12dc8:	05c12703          	lw	a4,92(sp)
   12dcc:	05c12603          	lw	a2,92(sp)
   12dd0:	00198993          	addi	s3,s3,1
   12dd4:	00f707b3          	add	a5,a4,a5
   12dd8:	07c10713          	addi	a4,sp,124
   12ddc:	00eca023          	sw	a4,0(s9)
   12de0:	00700713          	li	a4,7
   12de4:	00cca223          	sw	a2,4(s9)
   12de8:	08f12a23          	sw	a5,148(sp)
   12dec:	09312823          	sw	s3,144(sp)
   12df0:	008c8293          	addi	t0,s9,8
   12df4:	a1375ae3          	ble	s3,a4,12808 <_vfprintf_r+0x6e0>
   12df8:	08c10613          	addi	a2,sp,140
   12dfc:	000a0593          	mv	a1,s4
   12e00:	000c0513          	mv	a0,s8
   12e04:	754050ef          	jal	18558 <__sprint_r>
   12e08:	de051263          	bnez	a0,123ec <_vfprintf_r+0x2c4>
   12e0c:	09412783          	lw	a5,148(sp)
   12e10:	0c010293          	addi	t0,sp,192
   12e14:	9f5ff06f          	j	12808 <_vfprintf_r+0x6e0>
		/* the string or number proper */
#ifdef FLOATING_POINT
		if ((flags & FPT) == 0) {
			PRINT (cp, size);
		} else {	/* glue together f_p fragments */
			if (ch >= 'f') {	/* 'f' or 'g' */
   12e18:	06500713          	li	a4,101
   12e1c:	ef375ce3          	ble	s3,a4,12d14 <_vfprintf_r+0xbec>
				if (_fpvalue == 0) {
   12e20:	05012503          	lw	a0,80(sp)
   12e24:	05412583          	lw	a1,84(sp)
   12e28:	00000613          	li	a2,0
   12e2c:	00000693          	li	a3,0
   12e30:	00512a23          	sw	t0,20(sp)
   12e34:	00f12c23          	sw	a5,24(sp)
   12e38:	7ac080ef          	jal	1b5e4 <__eqdf2>
   12e3c:	01412283          	lw	t0,20(sp)
   12e40:	01812783          	lw	a5,24(sp)
   12e44:	28051263          	bnez	a0,130c8 <_vfprintf_r+0xfa0>
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
   12e48:	09012703          	lw	a4,144(sp)
   12e4c:	00100693          	li	a3,1
   12e50:	0001d637          	lui	a2,0x1d
   12e54:	00d2a223          	sw	a3,4(t0)
   12e58:	00178793          	addi	a5,a5,1
   12e5c:	00170713          	addi	a4,a4,1
   12e60:	d3060613          	addi	a2,a2,-720 # 1cd30 <__thenan_sf+0x50>
   12e64:	00700693          	li	a3,7
   12e68:	00c2a023          	sw	a2,0(t0)
   12e6c:	08f12a23          	sw	a5,148(sp)
   12e70:	08e12823          	sw	a4,144(sp)
   12e74:	00828293          	addi	t0,t0,8
   12e78:	7ee6ca63          	blt	a3,a4,1366c <_vfprintf_r+0x1544>
					if (expt < ndig || flags & ALT) {
   12e7c:	07412703          	lw	a4,116(sp)
   12e80:	04012683          	lw	a3,64(sp)
   12e84:	00d74663          	blt	a4,a3,12e90 <_vfprintf_r+0xd68>
   12e88:	00197713          	andi	a4,s2,1
   12e8c:	96070ee3          	beqz	a4,12808 <_vfprintf_r+0x6e0>
						PRINT (decimal_point, decp_len);
   12e90:	04c12703          	lw	a4,76(sp)
   12e94:	04c12683          	lw	a3,76(sp)
   12e98:	04412603          	lw	a2,68(sp)
   12e9c:	00e787b3          	add	a5,a5,a4
   12ea0:	09012703          	lw	a4,144(sp)
   12ea4:	00d2a223          	sw	a3,4(t0)
   12ea8:	00700693          	li	a3,7
   12eac:	00170713          	addi	a4,a4,1
   12eb0:	00c2a023          	sw	a2,0(t0)
   12eb4:	08f12a23          	sw	a5,148(sp)
   12eb8:	08e12823          	sw	a4,144(sp)
   12ebc:	00828293          	addi	t0,t0,8
   12ec0:	1ce6c8e3          	blt	a3,a4,13890 <_vfprintf_r+0x1768>
						PAD (ndig - 1, zeroes);
   12ec4:	04012703          	lw	a4,64(sp)
   12ec8:	fff70413          	addi	s0,a4,-1
   12ecc:	92805ee3          	blez	s0,12808 <_vfprintf_r+0x6e0>
   12ed0:	01000993          	li	s3,16
   12ed4:	09012703          	lw	a4,144(sp)
   12ed8:	03a12223          	sw	s10,36(sp)
   12edc:	3289de63          	ble	s0,s3,13218 <_vfprintf_r+0x10f0>
   12ee0:	00700c93          	li	s9,7
   12ee4:	00c0006f          	j	12ef0 <_vfprintf_r+0xdc8>
   12ee8:	ff040413          	addi	s0,s0,-16
   12eec:	3289d663          	ble	s0,s3,13218 <_vfprintf_r+0x10f0>
   12ef0:	01078793          	addi	a5,a5,16
   12ef4:	00170713          	addi	a4,a4,1
   12ef8:	01a2a023          	sw	s10,0(t0)
   12efc:	0132a223          	sw	s3,4(t0)
   12f00:	08f12a23          	sw	a5,148(sp)
   12f04:	08e12823          	sw	a4,144(sp)
   12f08:	00828293          	addi	t0,t0,8
   12f0c:	fcecdee3          	ble	a4,s9,12ee8 <_vfprintf_r+0xdc0>
   12f10:	08c10613          	addi	a2,sp,140
   12f14:	000a0593          	mv	a1,s4
   12f18:	000c0513          	mv	a0,s8
   12f1c:	63c050ef          	jal	18558 <__sprint_r>
   12f20:	cc051663          	bnez	a0,123ec <_vfprintf_r+0x2c4>
   12f24:	09412783          	lw	a5,148(sp)
   12f28:	09012703          	lw	a4,144(sp)
   12f2c:	0c010293          	addi	t0,sp,192
   12f30:	fb9ff06f          	j	12ee8 <_vfprintf_r+0xdc0>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   12f34:	02012703          	lw	a4,32(sp)
   12f38:	40eb0cb3          	sub	s9,s6,a4
   12f3c:	fd905c63          	blez	s9,12714 <_vfprintf_r+0x5ec>
   12f40:	01000d93          	li	s11,16
   12f44:	09012703          	lw	a4,144(sp)
   12f48:	03a12223          	sw	s10,36(sp)
   12f4c:	059dde63          	ble	s9,s11,12fa8 <_vfprintf_r+0xe80>
   12f50:	00700a93          	li	s5,7
   12f54:	00c0006f          	j	12f60 <_vfprintf_r+0xe38>
   12f58:	ff0c8c93          	addi	s9,s9,-16
   12f5c:	059dd663          	ble	s9,s11,12fa8 <_vfprintf_r+0xe80>
   12f60:	01078793          	addi	a5,a5,16
   12f64:	00170713          	addi	a4,a4,1
   12f68:	01a2a023          	sw	s10,0(t0)
   12f6c:	01b2a223          	sw	s11,4(t0)
   12f70:	08f12a23          	sw	a5,148(sp)
   12f74:	08e12823          	sw	a4,144(sp)
   12f78:	00828293          	addi	t0,t0,8
   12f7c:	fceadee3          	ble	a4,s5,12f58 <_vfprintf_r+0xe30>
   12f80:	08c10613          	addi	a2,sp,140
   12f84:	000a0593          	mv	a1,s4
   12f88:	000c0513          	mv	a0,s8
   12f8c:	5cc050ef          	jal	18558 <__sprint_r>
   12f90:	c4051e63          	bnez	a0,123ec <_vfprintf_r+0x2c4>
   12f94:	ff0c8c93          	addi	s9,s9,-16
   12f98:	09412783          	lw	a5,148(sp)
   12f9c:	09012703          	lw	a4,144(sp)
   12fa0:	0c010293          	addi	t0,sp,192
   12fa4:	fb9dcee3          	blt	s11,s9,12f60 <_vfprintf_r+0xe38>
   12fa8:	02412683          	lw	a3,36(sp)
   12fac:	019787b3          	add	a5,a5,s9
   12fb0:	00170713          	addi	a4,a4,1
   12fb4:	00d2a023          	sw	a3,0(t0)
   12fb8:	00700693          	li	a3,7
   12fbc:	0192a223          	sw	s9,4(t0)
   12fc0:	08f12a23          	sw	a5,148(sp)
   12fc4:	08e12823          	sw	a4,144(sp)
   12fc8:	00828293          	addi	t0,t0,8
   12fcc:	f4e6d463          	ble	a4,a3,12714 <_vfprintf_r+0x5ec>
   12fd0:	08c10613          	addi	a2,sp,140
   12fd4:	000a0593          	mv	a1,s4
   12fd8:	000c0513          	mv	a0,s8
   12fdc:	57c050ef          	jal	18558 <__sprint_r>
   12fe0:	c0051663          	bnez	a0,123ec <_vfprintf_r+0x2c4>
   12fe4:	09412783          	lw	a5,148(sp)
   12fe8:	0c010293          	addi	t0,sp,192
   12fec:	f28ff06f          	j	12714 <_vfprintf_r+0x5ec>
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
   12ff0:	00e976b3          	and	a3,s2,a4
   12ff4:	d2069ee3          	bnez	a3,12d30 <_vfprintf_r+0xc08>
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
				} else	/* XeYYY */
					PRINT (cp, 1);
   12ff8:	00e2a223          	sw	a4,4(t0)
   12ffc:	00700713          	li	a4,7
   13000:	08f12a23          	sw	a5,148(sp)
   13004:	09312823          	sw	s3,144(sp)
   13008:	00828c93          	addi	s9,t0,8
   1300c:	db375ee3          	ble	s3,a4,12dc8 <_vfprintf_r+0xca0>
   13010:	08c10613          	addi	a2,sp,140
   13014:	000a0593          	mv	a1,s4
   13018:	000c0513          	mv	a0,s8
   1301c:	53c050ef          	jal	18558 <__sprint_r>
   13020:	bc051663          	bnez	a0,123ec <_vfprintf_r+0x2c4>
   13024:	09412783          	lw	a5,148(sp)
   13028:	09012983          	lw	s3,144(sp)
   1302c:	0c010c93          	addi	s9,sp,192
   13030:	d99ff06f          	j	12dc8 <_vfprintf_r+0xca0>
			PAD (width - realsz, blanks);

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;

		FLUSH ();	/* copy out the I/O vectors */
   13034:	08c10613          	addi	a2,sp,140
   13038:	000a0593          	mv	a1,s4
   1303c:	000c0513          	mv	a0,s8
   13040:	518050ef          	jal	18558 <__sprint_r>
   13044:	88050ee3          	beqz	a0,128e0 <_vfprintf_r+0x7b8>
   13048:	ba4ff06f          	j	123ec <_vfprintf_r+0x2c4>
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
   1304c:	08c10613          	addi	a2,sp,140
   13050:	000a0593          	mv	a1,s4
   13054:	000c0513          	mv	a0,s8
   13058:	500050ef          	jal	18558 <__sprint_r>
   1305c:	b8051863          	bnez	a0,123ec <_vfprintf_r+0x2c4>
   13060:	09412783          	lw	a5,148(sp)
   13064:	0c010293          	addi	t0,sp,192
   13068:	e68ff06f          	j	126d0 <_vfprintf_r+0x5a8>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);
   1306c:	08c10613          	addi	a2,sp,140
   13070:	000a0593          	mv	a1,s4
   13074:	000c0513          	mv	a0,s8
   13078:	4e0050ef          	jal	18558 <__sprint_r>
   1307c:	b6051863          	bnez	a0,123ec <_vfprintf_r+0x2c4>
   13080:	09412783          	lw	a5,148(sp)
   13084:	0c010293          	addi	t0,sp,192
   13088:	e80ff06f          	j	12708 <_vfprintf_r+0x5e0>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   1308c:	00000793          	li	a5,0
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
						*--cp = to_char(_uquad);
   13090:	03078793          	addi	a5,a5,48
   13094:	0bf10413          	addi	s0,sp,191
   13098:	0af10fa3          	sb	a5,191(sp)
   1309c:	01c12703          	lw	a4,28(sp)
   130a0:	40870733          	sub	a4,a4,s0
   130a4:	02e12623          	sw	a4,44(sp)
						break;
   130a8:	a0dff06f          	j	12ab4 <_vfprintf_r+0x98c>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   130ac:	02812683          	lw	a3,40(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   130b0:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   130b4:	c206cae3          	bltz	a3,12ce8 <_vfprintf_r+0xbc0>
				flags &= ~ZEROPAD;
   130b8:	f7f97913          	andi	s2,s2,-129
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   130bc:	aa078263          	beqz	a5,12360 <_vfprintf_r+0x238>
   130c0:	00000613          	li	a2,0
   130c4:	9c1ff06f          	j	12a84 <_vfprintf_r+0x95c>
					PRINT ("0", 1);
					if (expt < ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
   130c8:	07412983          	lw	s3,116(sp)
   130cc:	5d305263          	blez	s3,13690 <_vfprintf_r+0x1568>
   130d0:	03c12983          	lw	s3,60(sp)
   130d4:	04012703          	lw	a4,64(sp)
   130d8:	01375463          	ble	s3,a4,130e0 <_vfprintf_r+0xfb8>
   130dc:	00070993          	mv	s3,a4
						PAD (-expt, zeroes);
						PRINT (cp, ndig);
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
   130e0:	03305663          	blez	s3,1310c <_vfprintf_r+0xfe4>
   130e4:	09012703          	lw	a4,144(sp)
   130e8:	013787b3          	add	a5,a5,s3
   130ec:	00700693          	li	a3,7
   130f0:	00170713          	addi	a4,a4,1
   130f4:	0082a023          	sw	s0,0(t0)
   130f8:	0132a223          	sw	s3,4(t0)
   130fc:	08f12a23          	sw	a5,148(sp)
   13100:	08e12823          	sw	a4,144(sp)
   13104:	00828293          	addi	t0,t0,8
   13108:	6ae6ce63          	blt	a3,a4,137c4 <_vfprintf_r+0x169c>
   1310c:	0409c8e3          	bltz	s3,1395c <_vfprintf_r+0x1834>
   13110:	03c12703          	lw	a4,60(sp)
   13114:	413709b3          	sub	s3,a4,s3
   13118:	17305663          	blez	s3,13284 <_vfprintf_r+0x115c>
   1311c:	01000c93          	li	s9,16
   13120:	09012703          	lw	a4,144(sp)
   13124:	03a12223          	sw	s10,36(sp)
   13128:	113cdc63          	ble	s3,s9,13240 <_vfprintf_r+0x1118>
   1312c:	00700d93          	li	s11,7
   13130:	00c0006f          	j	1313c <_vfprintf_r+0x1014>
   13134:	ff098993          	addi	s3,s3,-16
   13138:	113cd463          	ble	s3,s9,13240 <_vfprintf_r+0x1118>
   1313c:	01078793          	addi	a5,a5,16
   13140:	00170713          	addi	a4,a4,1
   13144:	01a2a023          	sw	s10,0(t0)
   13148:	0192a223          	sw	s9,4(t0)
   1314c:	08f12a23          	sw	a5,148(sp)
   13150:	08e12823          	sw	a4,144(sp)
   13154:	00828293          	addi	t0,t0,8
   13158:	fceddee3          	ble	a4,s11,13134 <_vfprintf_r+0x100c>
   1315c:	08c10613          	addi	a2,sp,140
   13160:	000a0593          	mv	a1,s4
   13164:	000c0513          	mv	a0,s8
   13168:	3f0050ef          	jal	18558 <__sprint_r>
   1316c:	a8051063          	bnez	a0,123ec <_vfprintf_r+0x2c4>
   13170:	09412783          	lw	a5,148(sp)
   13174:	09012703          	lw	a4,144(sp)
   13178:	0c010293          	addi	t0,sp,192
   1317c:	fb9ff06f          	j	13134 <_vfprintf_r+0x100c>
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   13180:	08c10613          	addi	a2,sp,140
   13184:	000a0593          	mv	a1,s4
   13188:	000c0513          	mv	a0,s8
   1318c:	3cc050ef          	jal	18558 <__sprint_r>
   13190:	a4051e63          	bnez	a0,123ec <_vfprintf_r+0x2c4>
   13194:	06f14603          	lbu	a2,111(sp)
   13198:	09412783          	lw	a5,148(sp)
   1319c:	0c010293          	addi	t0,sp,192
   131a0:	cfcff06f          	j	1269c <_vfprintf_r+0x574>
					PRINT (decimal_point, decp_len);
					if (_fpvalue) {
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
   131a4:	04012703          	lw	a4,64(sp)
   131a8:	fff70413          	addi	s0,a4,-1
   131ac:	c0805ee3          	blez	s0,12dc8 <_vfprintf_r+0xca0>
   131b0:	01000d93          	li	s11,16
   131b4:	03a12223          	sw	s10,36(sp)
   131b8:	268dd863          	ble	s0,s11,13428 <_vfprintf_r+0x1300>
   131bc:	00700713          	li	a4,7
   131c0:	00c0006f          	j	131cc <_vfprintf_r+0x10a4>
   131c4:	ff040413          	addi	s0,s0,-16
   131c8:	268dd063          	ble	s0,s11,13428 <_vfprintf_r+0x1300>
   131cc:	01078793          	addi	a5,a5,16
   131d0:	00198993          	addi	s3,s3,1
   131d4:	01aca023          	sw	s10,0(s9)
   131d8:	01bca223          	sw	s11,4(s9)
   131dc:	08f12a23          	sw	a5,148(sp)
   131e0:	09312823          	sw	s3,144(sp)
   131e4:	008c8c93          	addi	s9,s9,8
   131e8:	fd375ee3          	ble	s3,a4,131c4 <_vfprintf_r+0x109c>
   131ec:	08c10613          	addi	a2,sp,140
   131f0:	000a0593          	mv	a1,s4
   131f4:	000c0513          	mv	a0,s8
   131f8:	00e12c23          	sw	a4,24(sp)
   131fc:	35c050ef          	jal	18558 <__sprint_r>
   13200:	01812703          	lw	a4,24(sp)
   13204:	9e051463          	bnez	a0,123ec <_vfprintf_r+0x2c4>
   13208:	09412783          	lw	a5,148(sp)
   1320c:	09012983          	lw	s3,144(sp)
   13210:	0c010c93          	addi	s9,sp,192
   13214:	fb1ff06f          	j	131c4 <_vfprintf_r+0x109c>
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
   13218:	02412683          	lw	a3,36(sp)
   1321c:	008787b3          	add	a5,a5,s0
   13220:	00170713          	addi	a4,a4,1
   13224:	00d2a023          	sw	a3,0(t0)
   13228:	00700693          	li	a3,7
   1322c:	0082a223          	sw	s0,4(t0)
   13230:	08f12a23          	sw	a5,148(sp)
   13234:	08e12823          	sw	a4,144(sp)
   13238:	dce6d663          	ble	a4,a3,12804 <_vfprintf_r+0x6dc>
   1323c:	bbdff06f          	j	12df8 <_vfprintf_r+0xcd0>
						PAD (-expt, zeroes);
						PRINT (cp, ndig);
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
   13240:	02412683          	lw	a3,36(sp)
   13244:	013787b3          	add	a5,a5,s3
   13248:	00170713          	addi	a4,a4,1
   1324c:	00d2a023          	sw	a3,0(t0)
   13250:	00700693          	li	a3,7
   13254:	0132a223          	sw	s3,4(t0)
   13258:	08f12a23          	sw	a5,148(sp)
   1325c:	08e12823          	sw	a4,144(sp)
   13260:	00828293          	addi	t0,t0,8
   13264:	02e6d063          	ble	a4,a3,13284 <_vfprintf_r+0x115c>
   13268:	08c10613          	addi	a2,sp,140
   1326c:	000a0593          	mv	a1,s4
   13270:	000c0513          	mv	a0,s8
   13274:	2e4050ef          	jal	18558 <__sprint_r>
   13278:	96051a63          	bnez	a0,123ec <_vfprintf_r+0x2c4>
   1327c:	09412783          	lw	a5,148(sp)
   13280:	0c010293          	addi	t0,sp,192
						    lead, zeroes);
					cp += lead;
   13284:	03c12603          	lw	a2,60(sp)
					    }
					    if (cp > convbuf + ndig)
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
   13288:	07412703          	lw	a4,116(sp)
   1328c:	04012683          	lw	a3,64(sp)
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
						    lead, zeroes);
					cp += lead;
   13290:	00c409b3          	add	s3,s0,a2
					    }
					    if (cp > convbuf + ndig)
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
   13294:	0cd74063          	blt	a4,a3,13354 <_vfprintf_r+0x122c>
   13298:	00197693          	andi	a3,s2,1
   1329c:	0a069c63          	bnez	a3,13354 <_vfprintf_r+0x122c>
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
   132a0:	04012683          	lw	a3,64(sp)
   132a4:	00d40433          	add	s0,s0,a3
   132a8:	40e68733          	sub	a4,a3,a4
   132ac:	41340433          	sub	s0,s0,s3
   132b0:	00875463          	ble	s0,a4,132b8 <_vfprintf_r+0x1190>
   132b4:	00070413          	mv	s0,a4
   132b8:	02805663          	blez	s0,132e4 <_vfprintf_r+0x11bc>
   132bc:	09012683          	lw	a3,144(sp)
   132c0:	008787b3          	add	a5,a5,s0
   132c4:	00700613          	li	a2,7
   132c8:	00168693          	addi	a3,a3,1
   132cc:	0132a023          	sw	s3,0(t0)
   132d0:	0082a223          	sw	s0,4(t0)
   132d4:	08f12a23          	sw	a5,148(sp)
   132d8:	08d12823          	sw	a3,144(sp)
   132dc:	00828293          	addi	t0,t0,8
   132e0:	52d64063          	blt	a2,a3,13800 <_vfprintf_r+0x16d8>
   132e4:	68044063          	bltz	s0,13964 <_vfprintf_r+0x183c>
   132e8:	40870433          	sub	s0,a4,s0
   132ec:	d0805e63          	blez	s0,12808 <_vfprintf_r+0x6e0>
   132f0:	01000993          	li	s3,16
   132f4:	09012703          	lw	a4,144(sp)
   132f8:	03a12223          	sw	s10,36(sp)
   132fc:	f089dee3          	ble	s0,s3,13218 <_vfprintf_r+0x10f0>
   13300:	00700c93          	li	s9,7
   13304:	00c0006f          	j	13310 <_vfprintf_r+0x11e8>
   13308:	ff040413          	addi	s0,s0,-16
   1330c:	f089d6e3          	ble	s0,s3,13218 <_vfprintf_r+0x10f0>
   13310:	01078793          	addi	a5,a5,16
   13314:	00170713          	addi	a4,a4,1
   13318:	01a2a023          	sw	s10,0(t0)
   1331c:	0132a223          	sw	s3,4(t0)
   13320:	08f12a23          	sw	a5,148(sp)
   13324:	08e12823          	sw	a4,144(sp)
   13328:	00828293          	addi	t0,t0,8
   1332c:	fcecdee3          	ble	a4,s9,13308 <_vfprintf_r+0x11e0>
   13330:	08c10613          	addi	a2,sp,140
   13334:	000a0593          	mv	a1,s4
   13338:	000c0513          	mv	a0,s8
   1333c:	21c050ef          	jal	18558 <__sprint_r>
   13340:	8a051663          	bnez	a0,123ec <_vfprintf_r+0x2c4>
   13344:	09412783          	lw	a5,148(sp)
   13348:	09012703          	lw	a4,144(sp)
   1334c:	0c010293          	addi	t0,sp,192
   13350:	fb9ff06f          	j	13308 <_vfprintf_r+0x11e0>
					    if (cp > convbuf + ndig)
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
   13354:	04c12603          	lw	a2,76(sp)
   13358:	09012683          	lw	a3,144(sp)
   1335c:	00828293          	addi	t0,t0,8
   13360:	00c787b3          	add	a5,a5,a2
   13364:	04412603          	lw	a2,68(sp)
   13368:	00168693          	addi	a3,a3,1
   1336c:	08f12a23          	sw	a5,148(sp)
   13370:	fec2ac23          	sw	a2,-8(t0)
   13374:	04c12603          	lw	a2,76(sp)
   13378:	08d12823          	sw	a3,144(sp)
   1337c:	fec2ae23          	sw	a2,-4(t0)
   13380:	00700613          	li	a2,7
   13384:	f0d65ee3          	ble	a3,a2,132a0 <_vfprintf_r+0x1178>
   13388:	08c10613          	addi	a2,sp,140
   1338c:	000a0593          	mv	a1,s4
   13390:	000c0513          	mv	a0,s8
   13394:	1c4050ef          	jal	18558 <__sprint_r>
   13398:	00050463          	beqz	a0,133a0 <_vfprintf_r+0x1278>
   1339c:	850ff06f          	j	123ec <_vfprintf_r+0x2c4>
   133a0:	07412703          	lw	a4,116(sp)
   133a4:	09412783          	lw	a5,148(sp)
   133a8:	0c010293          	addi	t0,sp,192
   133ac:	ef5ff06f          	j	132a0 <_vfprintf_r+0x1178>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   133b0:	02812603          	lw	a2,40(sp)
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   133b4:	0006a783          	lw	a5,0(a3)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   133b8:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   133bc:	d6065263          	bgez	a2,12920 <_vfprintf_r+0x7f8>
   133c0:	e50ff06f          	j	12a10 <_vfprintf_r+0x8e8>
   133c4:	02812603          	lw	a2,40(sp)
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   133c8:	0006a783          	lw	a5,0(a3)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   133cc:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   133d0:	8a065663          	bgez	a2,1247c <_vfprintf_r+0x354>
   133d4:	df4ff06f          	j	129c8 <_vfprintf_r+0x8a0>
					PRINTANDPAD (cp, convbuf + ndig,
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
   133d8:	08c10613          	addi	a2,sp,140
   133dc:	000a0593          	mv	a1,s4
   133e0:	000c0513          	mv	a0,s8
   133e4:	174050ef          	jal	18558 <__sprint_r>
   133e8:	00050463          	beqz	a0,133f0 <_vfprintf_r+0x12c8>
   133ec:	800ff06f          	j	123ec <_vfprintf_r+0x2c4>
   133f0:	09412783          	lw	a5,148(sp)
   133f4:	09012983          	lw	s3,144(sp)
   133f8:	0c010293          	addi	t0,sp,192
   133fc:	951ff06f          	j	12d4c <_vfprintf_r+0xc24>
					cp++;
					PRINT (decimal_point, decp_len);
   13400:	08c10613          	addi	a2,sp,140
   13404:	000a0593          	mv	a1,s4
   13408:	000c0513          	mv	a0,s8
   1340c:	14c050ef          	jal	18558 <__sprint_r>
   13410:	00050463          	beqz	a0,13418 <_vfprintf_r+0x12f0>
   13414:	fd9fe06f          	j	123ec <_vfprintf_r+0x2c4>
   13418:	09412783          	lw	a5,148(sp)
   1341c:	09012983          	lw	s3,144(sp)
   13420:	0c010c93          	addi	s9,sp,192
   13424:	955ff06f          	j	12d78 <_vfprintf_r+0xc50>
					if (_fpvalue) {
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
   13428:	02412683          	lw	a3,36(sp)
   1342c:	008787b3          	add	a5,a5,s0
   13430:	00198993          	addi	s3,s3,1
   13434:	00700713          	li	a4,7
   13438:	00dca023          	sw	a3,0(s9)
   1343c:	008ca223          	sw	s0,4(s9)
   13440:	08f12a23          	sw	a5,148(sp)
   13444:	09312823          	sw	s3,144(sp)
   13448:	97375ee3          	ble	s3,a4,12dc4 <_vfprintf_r+0xc9c>
   1344c:	bc5ff06f          	j	13010 <_vfprintf_r+0xee8>
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
				sign = '-';
   13450:	02d00713          	li	a4,45
   13454:	06e107a3          	sb	a4,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   13458:	02812703          	lw	a4,40(sp)
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
   1345c:	40f007b3          	neg	a5,a5
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   13460:	50074663          	bltz	a4,1396c <_vfprintf_r+0x1844>
				flags &= ~ZEROPAD;
   13464:	f7f97913          	andi	s2,s2,-129
   13468:	02d00613          	li	a2,45
   1346c:	cc4ff06f          	j	12930 <_vfprintf_r+0x808>
					cp = "inf";
				size = 3;
				flags &= ~ZEROPAD;
				break;
			}
			if (isnan (_fpvalue)) {
   13470:	05012503          	lw	a0,80(sp)
   13474:	05412583          	lw	a1,84(sp)
   13478:	00512a23          	sw	t0,20(sp)
   1347c:	46d040ef          	jal	180e8 <__fpclassifyd>
   13480:	01412283          	lw	t0,20(sp)
   13484:	2e050463          	beqz	a0,1376c <_vfprintf_r+0x1644>
				  }
				else
				  cp = buf;
			} else
# endif /* _WANT_IO_C99_FORMATS */
			if (prec == -1) {
   13488:	02812603          	lw	a2,40(sp)
   1348c:	fff00793          	li	a5,-1
   13490:	6af60463          	beq	a2,a5,13b38 <_vfprintf_r+0x1a10>
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
   13494:	fdf9f793          	andi	a5,s3,-33
   13498:	02f12023          	sw	a5,32(sp)
   1349c:	02012603          	lw	a2,32(sp)
   134a0:	04700793          	li	a5,71
   134a4:	64f60863          	beq	a2,a5,13af4 <_vfprintf_r+0x19cc>
	int mode, dsgn;
	char *digits, *bp, *rve;
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
   134a8:	05412a83          	lw	s5,84(sp)
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
				prec = 1;
			}

			flags |= FPT;
   134ac:	10096713          	ori	a4,s2,256
   134b0:	02e12223          	sw	a4,36(sp)
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
		value = -value;
   134b4:	05012c83          	lw	s9,80(sp)
	char *digits, *bp, *rve;
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
   134b8:	6e0ac663          	bltz	s5,13ba4 <_vfprintf_r+0x1a7c>
		value = -value;
		*sign = '-';
	} else
		*sign = '\000';
   134bc:	02012c23          	sw	zero,56(sp)
		}
		*length = bp - buf;
		return buf;
	}
# endif /* _WANT_IO_C99_FORMATS */
	if (ch == 'f' || ch == 'F') {
   134c0:	06600793          	li	a5,102
   134c4:	68f98463          	beq	s3,a5,13b4c <_vfprintf_r+0x1a24>
   134c8:	04600793          	li	a5,70
   134cc:	7cf98463          	beq	s3,a5,13c94 <_vfprintf_r+0x1b6c>
		/* To obtain ndigits after the decimal point for the 'e'
		 * and 'E' formats, round to ndigits + 1 significant
		 * figures.
		 */
		if (ch == 'e' || ch == 'E') {
			ndigits++;
   134d0:	02012683          	lw	a3,32(sp)
   134d4:	02812703          	lw	a4,40(sp)
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   134d8:	08410793          	addi	a5,sp,132
		/* To obtain ndigits after the decimal point for the 'e'
		 * and 'E' formats, round to ndigits + 1 significant
		 * figures.
		 */
		if (ch == 'e' || ch == 'E') {
			ndigits++;
   134dc:	fbb68313          	addi	t1,a3,-69
   134e0:	00133313          	seqz	t1,t1
   134e4:	00670333          	add	t1,a4,t1
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   134e8:	00f12023          	sw	a5,0(sp)
   134ec:	000c8613          	mv	a2,s9
   134f0:	00030793          	mv	a5,t1
   134f4:	000a8693          	mv	a3,s5
   134f8:	07810893          	addi	a7,sp,120
   134fc:	07410813          	addi	a6,sp,116
   13500:	00200713          	li	a4,2
   13504:	000c0513          	mv	a0,s8
   13508:	00512a23          	sw	t0,20(sp)
   1350c:	00612c23          	sw	t1,24(sp)
   13510:	649000ef          	jal	14358 <_dtoa_r>

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   13514:	06700793          	li	a5,103
			ndigits++;
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   13518:	00050413          	mv	s0,a0

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   1351c:	01412283          	lw	t0,20(sp)
   13520:	01812303          	lw	t1,24(sp)
   13524:	4ef98663          	beq	s3,a5,13a10 <_vfprintf_r+0x18e8>
   13528:	04700793          	li	a5,71
		bp = digits + ndigits;
   1352c:	00650db3          	add	s11,a0,t1
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   13530:	4ef98a63          	beq	s3,a5,13a24 <_vfprintf_r+0x18fc>
		if (ch == 'f' || ch == 'F') {
			if (*digits == '0' && value)
				*decpt = -ndigits + 1;
			bp += *decpt;
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
   13534:	000c8513          	mv	a0,s9
   13538:	000a8593          	mv	a1,s5
   1353c:	00000613          	li	a2,0
   13540:	00000693          	li	a3,0
   13544:	00512a23          	sw	t0,20(sp)
   13548:	09c080ef          	jal	1b5e4 <__eqdf2>
   1354c:	000d8793          	mv	a5,s11
   13550:	01412283          	lw	t0,20(sp)
   13554:	02050263          	beqz	a0,13578 <_vfprintf_r+0x1450>
			rve = bp;
		while (rve < bp)
   13558:	08412783          	lw	a5,132(sp)
   1355c:	01b7fe63          	bleu	s11,a5,13578 <_vfprintf_r+0x1450>
			*rve++ = '0';
   13560:	03000693          	li	a3,48
   13564:	00178713          	addi	a4,a5,1
   13568:	08e12223          	sw	a4,132(sp)
   1356c:	00d78023          	sb	a3,0(a5)
				*decpt = -ndigits + 1;
			bp += *decpt;
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
			rve = bp;
		while (rve < bp)
   13570:	08412783          	lw	a5,132(sp)
   13574:	ffb7e8e3          	bltu	a5,s11,13564 <_vfprintf_r+0x143c>
			flags |= FPT;

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
   13578:	02012603          	lw	a2,32(sp)
		if (value == 0)	/* kludge for __dtoa irregularity */
			rve = bp;
		while (rve < bp)
			*rve++ = '0';
	}
	*length = rve - digits;
   1357c:	408787b3          	sub	a5,a5,s0
   13580:	04f12023          	sw	a5,64(sp)
			flags |= FPT;

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
   13584:	04700793          	li	a5,71
   13588:	4af60c63          	beq	a2,a5,13a40 <_vfprintf_r+0x1918>
			}
# ifdef _WANT_IO_C99_FORMATS
			else if (ch == 'F')
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
   1358c:	06500793          	li	a5,101
   13590:	0b37d6e3          	ble	s3,a5,13e3c <_vfprintf_r+0x1d14>
					++size;
# ifdef _WANT_IO_C99_FORMATS
				flags &= ~GROUPING;
# endif
			} else {
				if (ch == 'f') {		/* f fmt */
   13594:	06600793          	li	a5,102
   13598:	66f98663          	beq	s3,a5,13c04 <_vfprintf_r+0x1adc>
   1359c:	07412703          	lw	a4,116(sp)
   135a0:	02e12e23          	sw	a4,60(sp)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
							  ? prec + 2
							  : 1;
				} else if (expt >= ndig) { /* fixed g fmt */
   135a4:	03c12703          	lw	a4,60(sp)
   135a8:	04012783          	lw	a5,64(sp)
   135ac:	60f74863          	blt	a4,a5,13bbc <_vfprintf_r+0x1a94>
					size = expt;
					if (flags & ALT)
   135b0:	00197913          	andi	s2,s2,1
   135b4:	62091863          	bnez	s2,13be4 <_vfprintf_r+0x1abc>
   135b8:	00070a93          	mv	s5,a4
   135bc:	060744e3          	bltz	a4,13e24 <_vfprintf_r+0x1cfc>
   135c0:	03c12703          	lw	a4,60(sp)
   135c4:	06700993          	li	s3,103
   135c8:	02e12623          	sw	a4,44(sp)
				} else
# endif
					lead = expt;
			}

			if (softsign)
   135cc:	03812603          	lw	a2,56(sp)
   135d0:	3e061c63          	bnez	a2,139c8 <_vfprintf_r+0x18a0>
   135d4:	06f14603          	lbu	a2,111(sp)
   135d8:	03512023          	sw	s5,32(sp)
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
				prec = 1;
			}

			flags |= FPT;
   135dc:	02412903          	lw	s2,36(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   135e0:	02012423          	sw	zero,40(sp)
   135e4:	fddfe06f          	j	125c0 <_vfprintf_r+0x498>
				*GET_ARG (N, ap, quad_ptr_t) = ret;
			else
#endif
			if (flags & LONGINT)
				*GET_ARG (N, ap, long_ptr_t) = ret;
			else if (flags & SHORTINT)
   135e8:	04097913          	andi	s2,s2,64
   135ec:	1a090863          	beqz	s2,1379c <_vfprintf_r+0x1674>
				*GET_ARG (N, ap, short_ptr_t) = ret;
   135f0:	03012603          	lw	a2,48(sp)
   135f4:	03412683          	lw	a3,52(sp)
   135f8:	00062783          	lw	a5,0(a2)
   135fc:	00460613          	addi	a2,a2,4
   13600:	02c12823          	sw	a2,48(sp)
   13604:	00d79023          	sh	a3,0(a5)
   13608:	c21fe06f          	j	12228 <_vfprintf_r+0x100>
		case 'D':  /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   1360c:	03012703          	lw	a4,48(sp)
   13610:	00072783          	lw	a5,0(a4)
   13614:	00470713          	addi	a4,a4,4
   13618:	02e12823          	sw	a4,48(sp)
   1361c:	d0cff06f          	j	12b28 <_vfprintf_r+0xa00>
		case 'G':
# ifdef _NO_LONGDBL
			if (flags & LONGDBL) {
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
			} else {
				_fpvalue = GET_ARG (N, ap, double);
   13620:	00760793          	addi	a5,a2,7
   13624:	ff87f793          	andi	a5,a5,-8
   13628:	0007a683          	lw	a3,0(a5)
   1362c:	0047a703          	lw	a4,4(a5)
   13630:	00878793          	addi	a5,a5,8
   13634:	04d12823          	sw	a3,80(sp)
   13638:	04e12a23          	sw	a4,84(sp)
   1363c:	02f12823          	sw	a5,48(sp)
   13640:	d84ff06f          	j	12bc4 <_vfprintf_r+0xa9c>
		case 'X':
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
   13644:	03012603          	lw	a2,48(sp)
   13648:	00062783          	lw	a5,0(a2)
   1364c:	00460613          	addi	a2,a2,4
   13650:	02c12823          	sw	a2,48(sp)
   13654:	bfcff06f          	j	12a50 <_vfprintf_r+0x928>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   13658:	02812683          	lw	a3,40(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   1365c:	060107a3          	sb	zero,111(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   13660:	e806c663          	bltz	a3,12cec <_vfprintf_r+0xbc4>
				flags &= ~ZEROPAD;
   13664:	f7f97913          	andi	s2,s2,-129
   13668:	cf9fe06f          	j	12360 <_vfprintf_r+0x238>
			PRINT (cp, size);
		} else {	/* glue together f_p fragments */
			if (ch >= 'f') {	/* 'f' or 'g' */
				if (_fpvalue == 0) {
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
   1366c:	08c10613          	addi	a2,sp,140
   13670:	000a0593          	mv	a1,s4
   13674:	000c0513          	mv	a0,s8
   13678:	6e1040ef          	jal	18558 <__sprint_r>
   1367c:	00050463          	beqz	a0,13684 <_vfprintf_r+0x155c>
   13680:	d6dfe06f          	j	123ec <_vfprintf_r+0x2c4>
   13684:	09412783          	lw	a5,148(sp)
   13688:	0c010293          	addi	t0,sp,192
   1368c:	ff0ff06f          	j	12e7c <_vfprintf_r+0xd54>
					if (expt < ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
   13690:	09012703          	lw	a4,144(sp)
   13694:	00100693          	li	a3,1
   13698:	0001d637          	lui	a2,0x1d
   1369c:	00d2a223          	sw	a3,4(t0)
   136a0:	00178793          	addi	a5,a5,1
   136a4:	00170713          	addi	a4,a4,1
   136a8:	d3060613          	addi	a2,a2,-720 # 1cd30 <__thenan_sf+0x50>
   136ac:	00700693          	li	a3,7
   136b0:	00c2a023          	sw	a2,0(t0)
   136b4:	08f12a23          	sw	a5,148(sp)
   136b8:	08e12823          	sw	a4,144(sp)
   136bc:	00828293          	addi	t0,t0,8
   136c0:	16e6c863          	blt	a3,a4,13830 <_vfprintf_r+0x1708>
					if (expt || ndig || flags & ALT) {
   136c4:	12098263          	beqz	s3,137e8 <_vfprintf_r+0x16c0>
						PRINT (decimal_point, decp_len);
   136c8:	04c12603          	lw	a2,76(sp)
   136cc:	09012703          	lw	a4,144(sp)
   136d0:	04412683          	lw	a3,68(sp)
   136d4:	00f607b3          	add	a5,a2,a5
   136d8:	00170713          	addi	a4,a4,1
   136dc:	00d2a023          	sw	a3,0(t0)
   136e0:	00700693          	li	a3,7
   136e4:	00c2a223          	sw	a2,4(t0)
   136e8:	08f12a23          	sw	a5,148(sp)
   136ec:	08e12823          	sw	a4,144(sp)
   136f0:	00828293          	addi	t0,t0,8
   136f4:	40e6c863          	blt	a3,a4,13b04 <_vfprintf_r+0x19dc>
						PAD (-expt, zeroes);
   136f8:	413009b3          	neg	s3,s3
   136fc:	23305663          	blez	s3,13928 <_vfprintf_r+0x1800>
   13700:	01000c93          	li	s9,16
   13704:	03a12223          	sw	s10,36(sp)
   13708:	1d3cda63          	ble	s3,s9,138dc <_vfprintf_r+0x17b4>
   1370c:	00700d93          	li	s11,7
   13710:	00c0006f          	j	1371c <_vfprintf_r+0x15f4>
   13714:	ff098993          	addi	s3,s3,-16
   13718:	1d3cd263          	ble	s3,s9,138dc <_vfprintf_r+0x17b4>
   1371c:	01078793          	addi	a5,a5,16
   13720:	00170713          	addi	a4,a4,1
   13724:	01a2a023          	sw	s10,0(t0)
   13728:	0192a223          	sw	s9,4(t0)
   1372c:	08f12a23          	sw	a5,148(sp)
   13730:	08e12823          	sw	a4,144(sp)
   13734:	00828293          	addi	t0,t0,8
   13738:	fceddee3          	ble	a4,s11,13714 <_vfprintf_r+0x15ec>
   1373c:	08c10613          	addi	a2,sp,140
   13740:	000a0593          	mv	a1,s4
   13744:	000c0513          	mv	a0,s8
   13748:	611040ef          	jal	18558 <__sprint_r>
   1374c:	00050463          	beqz	a0,13754 <_vfprintf_r+0x162c>
   13750:	c9dfe06f          	j	123ec <_vfprintf_r+0x2c4>
   13754:	09412783          	lw	a5,148(sp)
   13758:	09012703          	lw	a4,144(sp)
   1375c:	0c010293          	addi	t0,sp,192
   13760:	fb5ff06f          	j	13714 <_vfprintf_r+0x15ec>
	ORIENT(fp, -1);

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
		_newlib_flockfile_exit (fp);
		return (EOF);
   13764:	fff00513          	li	a0,-1
   13768:	c99fe06f          	j	12400 <_vfprintf_r+0x2d8>
				size = 3;
				flags &= ~ZEROPAD;
				break;
			}
			if (isnan (_fpvalue)) {
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
   1376c:	04700793          	li	a5,71
   13770:	2937c263          	blt	a5,s3,139f4 <_vfprintf_r+0x18cc>
					cp = "NAN";
   13774:	0001d437          	lui	s0,0x1d
   13778:	cf840413          	addi	s0,s0,-776 # 1ccf8 <__thenan_sf+0x18>
				else
					cp = "nan";
				size = 3;
				flags &= ~ZEROPAD;
				break;
   1377c:	00300713          	li	a4,3
   13780:	02e12023          	sw	a4,32(sp)
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "NAN";
				else
					cp = "nan";
				size = 3;
				flags &= ~ZEROPAD;
   13784:	f7f97913          	andi	s2,s2,-129
   13788:	06f14603          	lbu	a2,111(sp)
			if (isnan (_fpvalue)) {
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "NAN";
				else
					cp = "nan";
				size = 3;
   1378c:	02e12623          	sw	a4,44(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   13790:	02012423          	sw	zero,40(sp)
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   13794:	02012e23          	sw	zero,60(sp)
					cp = "NAN";
				else
					cp = "nan";
				size = 3;
				flags &= ~ZEROPAD;
				break;
   13798:	e29fe06f          	j	125c0 <_vfprintf_r+0x498>
#ifdef _WANT_IO_C99_FORMATS
			else if (flags & CHARINT)
				*GET_ARG (N, ap, char_ptr_t) = ret;
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
   1379c:	03012703          	lw	a4,48(sp)
   137a0:	03412603          	lw	a2,52(sp)
   137a4:	00072783          	lw	a5,0(a4)
   137a8:	00470713          	addi	a4,a4,4
   137ac:	02e12823          	sw	a4,48(sp)
   137b0:	00c7a023          	sw	a2,0(a5)
   137b4:	a75fe06f          	j	12228 <_vfprintf_r+0x100>
			 */
			if (isinf (_fpvalue)) {
				if (_fpvalue < 0)
					sign = '-';
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "INF";
   137b8:	0001d437          	lui	s0,0x1d
   137bc:	cf040413          	addi	s0,s0,-784 # 1ccf0 <__thenan_sf+0x10>
   137c0:	c50ff06f          	j	12c10 <_vfprintf_r+0xae8>
						PAD (-expt, zeroes);
						PRINT (cp, ndig);
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
   137c4:	08c10613          	addi	a2,sp,140
   137c8:	000a0593          	mv	a1,s4
   137cc:	000c0513          	mv	a0,s8
   137d0:	589040ef          	jal	18558 <__sprint_r>
   137d4:	00050463          	beqz	a0,137dc <_vfprintf_r+0x16b4>
   137d8:	c15fe06f          	j	123ec <_vfprintf_r+0x2c4>
   137dc:	09412783          	lw	a5,148(sp)
   137e0:	0c010293          	addi	t0,sp,192
   137e4:	929ff06f          	j	1310c <_vfprintf_r+0xfe4>
						PRINT (decimal_point, decp_len);
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
					if (expt || ndig || flags & ALT) {
   137e8:	04012703          	lw	a4,64(sp)
   137ec:	ec071ee3          	bnez	a4,136c8 <_vfprintf_r+0x15a0>
   137f0:	00197713          	andi	a4,s2,1
   137f4:	00071463          	bnez	a4,137fc <_vfprintf_r+0x16d4>
   137f8:	810ff06f          	j	12808 <_vfprintf_r+0x6e0>
   137fc:	ecdff06f          	j	136c8 <_vfprintf_r+0x15a0>
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
   13800:	08c10613          	addi	a2,sp,140
   13804:	000a0593          	mv	a1,s4
   13808:	000c0513          	mv	a0,s8
   1380c:	54d040ef          	jal	18558 <__sprint_r>
   13810:	00050463          	beqz	a0,13818 <_vfprintf_r+0x16f0>
   13814:	bd9fe06f          	j	123ec <_vfprintf_r+0x2c4>
   13818:	07412703          	lw	a4,116(sp)
   1381c:	04012603          	lw	a2,64(sp)
   13820:	09412783          	lw	a5,148(sp)
   13824:	0c010293          	addi	t0,sp,192
   13828:	40e60733          	sub	a4,a2,a4
   1382c:	ab9ff06f          	j	132e4 <_vfprintf_r+0x11bc>
					if (expt < ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
   13830:	08c10613          	addi	a2,sp,140
   13834:	000a0593          	mv	a1,s4
   13838:	000c0513          	mv	a0,s8
   1383c:	51d040ef          	jal	18558 <__sprint_r>
   13840:	00050463          	beqz	a0,13848 <_vfprintf_r+0x1720>
   13844:	ba9fe06f          	j	123ec <_vfprintf_r+0x2c4>
   13848:	07412983          	lw	s3,116(sp)
   1384c:	09412783          	lw	a5,148(sp)
   13850:	0c010293          	addi	t0,sp,192
					if (expt || ndig || flags & ALT) {
   13854:	e6099ae3          	bnez	s3,136c8 <_vfprintf_r+0x15a0>
   13858:	f91ff06f          	j	137e8 <_vfprintf_r+0x16c0>
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   1385c:	00197793          	andi	a5,s2,1
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   13860:	00068613          	mv	a2,a3
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   13864:	02078063          	beqz	a5,13884 <_vfprintf_r+0x175c>
   13868:	01c12703          	lw	a4,28(sp)
   1386c:	0bf10413          	addi	s0,sp,191
                         *--cp = '0';
   13870:	03000793          	li	a5,48
   13874:	40870733          	sub	a4,a4,s0
   13878:	0af10fa3          	sb	a5,191(sp)
   1387c:	02e12623          	sw	a4,44(sp)
   13880:	a34ff06f          	j	12ab4 <_vfprintf_r+0x98c>
   13884:	02012623          	sw	zero,44(sp)
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   13888:	0c010413          	addi	s0,sp,192
   1388c:	a28ff06f          	j	12ab4 <_vfprintf_r+0x98c>
			if (ch >= 'f') {	/* 'f' or 'g' */
				if (_fpvalue == 0) {
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
					if (expt < ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
   13890:	08c10613          	addi	a2,sp,140
   13894:	000a0593          	mv	a1,s4
   13898:	000c0513          	mv	a0,s8
   1389c:	4bd040ef          	jal	18558 <__sprint_r>
   138a0:	00050463          	beqz	a0,138a8 <_vfprintf_r+0x1780>
   138a4:	b49fe06f          	j	123ec <_vfprintf_r+0x2c4>
   138a8:	09412783          	lw	a5,148(sp)
   138ac:	0c010293          	addi	t0,sp,192
   138b0:	e14ff06f          	j	12ec4 <_vfprintf_r+0xd9c>
				if (p != NULL)
					size = p - cp;
				else
					size = prec;
			} else
				size = strlen (cp);
   138b4:	00040513          	mv	a0,s0
   138b8:	00512a23          	sw	t0,20(sp)
   138bc:	325040ef          	jal	183e0 <strlen>
   138c0:	02a12623          	sw	a0,44(sp)
   138c4:	01412283          	lw	t0,20(sp)
   138c8:	00050a93          	mv	s5,a0
   138cc:	00054463          	bltz	a0,138d4 <_vfprintf_r+0x17ac>
   138d0:	cddfe06f          	j	125ac <_vfprintf_r+0x484>
   138d4:	00000a93          	li	s5,0
   138d8:	cd5fe06f          	j	125ac <_vfprintf_r+0x484>
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
					if (expt || ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
						PAD (-expt, zeroes);
   138dc:	02412683          	lw	a3,36(sp)
   138e0:	013787b3          	add	a5,a5,s3
   138e4:	00170713          	addi	a4,a4,1
   138e8:	00d2a023          	sw	a3,0(t0)
   138ec:	00700693          	li	a3,7
   138f0:	0132a223          	sw	s3,4(t0)
   138f4:	08f12a23          	sw	a5,148(sp)
   138f8:	08e12823          	sw	a4,144(sp)
   138fc:	00828293          	addi	t0,t0,8
   13900:	02e6d463          	ble	a4,a3,13928 <_vfprintf_r+0x1800>
   13904:	08c10613          	addi	a2,sp,140
   13908:	000a0593          	mv	a1,s4
   1390c:	000c0513          	mv	a0,s8
   13910:	449040ef          	jal	18558 <__sprint_r>
   13914:	00050463          	beqz	a0,1391c <_vfprintf_r+0x17f4>
   13918:	ad5fe06f          	j	123ec <_vfprintf_r+0x2c4>
   1391c:	09412783          	lw	a5,148(sp)
   13920:	09012703          	lw	a4,144(sp)
   13924:	0c010293          	addi	t0,sp,192
						PRINT (cp, ndig);
   13928:	04012603          	lw	a2,64(sp)
   1392c:	00170713          	addi	a4,a4,1
   13930:	00700693          	li	a3,7
   13934:	00f607b3          	add	a5,a2,a5
   13938:	0082a023          	sw	s0,0(t0)
   1393c:	00c2a223          	sw	a2,4(t0)
   13940:	08f12a23          	sw	a5,148(sp)
   13944:	08e12823          	sw	a4,144(sp)
   13948:	00e6c463          	blt	a3,a4,13950 <_vfprintf_r+0x1828>
   1394c:	eb9fe06f          	j	12804 <_vfprintf_r+0x6dc>
   13950:	ca8ff06f          	j	12df8 <_vfprintf_r+0xcd0>
   13954:	fff00793          	li	a5,-1
   13958:	bd5fe06f          	j	1252c <_vfprintf_r+0x404>
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
   1395c:	00000993          	li	s3,0
   13960:	fb0ff06f          	j	13110 <_vfprintf_r+0xfe8>
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
					PRINTANDPAD (cp, convbuf + ndig,
   13964:	00000413          	li	s0,0
   13968:	981ff06f          	j	132e8 <_vfprintf_r+0x11c0>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   1396c:	02d00613          	li	a2,45
			{

				_uquad = -_uquad;
				sign = '-';
			}
			base = DEC;
   13970:	00100713          	li	a4,1
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   13974:	00100693          	li	a3,1
   13978:	00d71463          	bne	a4,a3,13980 <_vfprintf_r+0x1858>
   1397c:	fb5fe06f          	j	12930 <_vfprintf_r+0x808>
   13980:	00200693          	li	a3,2
   13984:	90d70063          	beq	a4,a3,12a84 <_vfprintf_r+0x95c>
   13988:	b15fe06f          	j	1249c <_vfprintf_r+0x374>
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
				size = ((unsigned) prec > 6U) ? 6 : prec;
   1398c:	02812503          	lw	a0,40(sp)
   13990:	00600793          	li	a5,6
   13994:	00a7f463          	bleu	a0,a5,1399c <_vfprintf_r+0x1874>
   13998:	00078513          	mv	a0,a5
   1399c:	02a12623          	sw	a0,44(sp)
   139a0:	00050a93          	mv	s5,a0
   139a4:	38054c63          	bltz	a0,13d3c <_vfprintf_r+0x1c14>
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
   139a8:	0001d437          	lui	s0,0x1d
   139ac:	03512023          	sw	s5,32(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   139b0:	03912823          	sw	s9,48(sp)
   139b4:	00000613          	li	a2,0
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   139b8:	02012423          	sw	zero,40(sp)
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   139bc:	02012e23          	sw	zero,60(sp)
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
   139c0:	d2840413          	addi	s0,s0,-728 # 1cd28 <__thenan_sf+0x48>
   139c4:	c0dfe06f          	j	125d0 <_vfprintf_r+0x4a8>
# endif
					lead = expt;
			}

			if (softsign)
				sign = '-';
   139c8:	02d00793          	li	a5,45
   139cc:	06f107a3          	sb	a5,111(sp)
   139d0:	03512023          	sw	s5,32(sp)
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
				prec = 1;
			}

			flags |= FPT;
   139d4:	02412903          	lw	s2,36(sp)
# endif
					lead = expt;
			}

			if (softsign)
				sign = '-';
   139d8:	02d00613          	li	a2,45
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   139dc:	02012423          	sw	zero,40(sp)
   139e0:	be5fe06f          	j	125c4 <_vfprintf_r+0x49c>
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
				ox[0] = '0';
				ox[1] = ch;
				flags |= HEXPREFIX;
   139e4:	00070913          	mv	s2,a4
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   139e8:	00000613          	li	a2,0
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
   139ec:	00200713          	li	a4,2
   139f0:	f85ff06f          	j	13974 <_vfprintf_r+0x184c>
			}
			if (isnan (_fpvalue)) {
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
					cp = "NAN";
				else
					cp = "nan";
   139f4:	0001d437          	lui	s0,0x1d
   139f8:	cfc40413          	addi	s0,s0,-772 # 1ccfc <__thenan_sf+0x1c>
   139fc:	d81ff06f          	j	1377c <_vfprintf_r+0x1654>
			   zeros are not permitted.  Otherwise, scanf
			   could not read what printf wrote.
			 */
			if (isinf (_fpvalue)) {
				if (_fpvalue < 0)
					sign = '-';
   13a00:	02d00793          	li	a5,45
   13a04:	06f107a3          	sb	a5,111(sp)
   13a08:	02d00613          	li	a2,45
   13a0c:	9f4ff06f          	j	12c00 <_vfprintf_r+0xad8>
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   13a10:	00197793          	andi	a5,s2,1
		bp = digits + ndigits;
   13a14:	00650db3          	add	s11,a0,t1
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   13a18:	b0079ee3          	bnez	a5,13534 <_vfprintf_r+0x140c>
   13a1c:	08412783          	lw	a5,132(sp)
   13a20:	b59ff06f          	j	13578 <_vfprintf_r+0x1450>
   13a24:	00197793          	andi	a5,s2,1
   13a28:	2a079263          	bnez	a5,13ccc <_vfprintf_r+0x1ba4>
		if (value == 0)	/* kludge for __dtoa irregularity */
			rve = bp;
		while (rve < bp)
			*rve++ = '0';
	}
	*length = rve - digits;
   13a2c:	08412783          	lw	a5,132(sp)
   13a30:	408787b3          	sub	a5,a5,s0
   13a34:	04f12023          	sw	a5,64(sp)
			flags |= FPT;

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
   13a38:	02012783          	lw	a5,32(sp)
   13a3c:	41379063          	bne	a5,s3,13e3c <_vfprintf_r+0x1d14>
				if (expt <= -4 || expt > prec)
   13a40:	07412783          	lw	a5,116(sp)
   13a44:	ffd00713          	li	a4,-3
   13a48:	02e7ca63          	blt	a5,a4,13a7c <_vfprintf_r+0x1954>
   13a4c:	02812683          	lw	a3,40(sp)
   13a50:	02f6c663          	blt	a3,a5,13a7c <_vfprintf_r+0x1954>
   13a54:	02f12e23          	sw	a5,60(sp)
   13a58:	b4dff06f          	j	135a4 <_vfprintf_r+0x147c>
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);

				if (p != NULL)
   13a5c:	02812603          	lw	a2,40(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   13a60:	03912823          	sw	s9,48(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   13a64:	02012423          	sw	zero,40(sp)
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);

				if (p != NULL)
   13a68:	02c12023          	sw	a2,32(sp)
   13a6c:	02c12623          	sw	a2,44(sp)
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   13a70:	02012e23          	sw	zero,60(sp)
   13a74:	06f14603          	lbu	a2,111(sp)
   13a78:	b49fe06f          	j	125c0 <_vfprintf_r+0x498>
			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
				if (expt <= -4 || expt > prec)
					ch -= 2; /* 'e' or 'E' */
   13a7c:	ffe98993          	addi	s3,s3,-2
# ifdef _WANT_IO_C99_FORMATS
			else if (ch == 'F')
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
   13a80:	fff78793          	addi	a5,a5,-1
   13a84:	06f12a23          	sw	a5,116(sp)
# else
#  define isa 0
# endif

	p = p0;
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   13a88:	07310e23          	sb	s3,124(sp)
	if (exp < 0) {
   13a8c:	2e07ca63          	bltz	a5,13d80 <_vfprintf_r+0x1c58>
		exp = -exp;
		*p++ = '-';
	}
	else
		*p++ = '+';
   13a90:	02b00713          	li	a4,43
   13a94:	06e10ea3          	sb	a4,125(sp)
	t = expbuf + MAXEXPLEN;
	if (exp > 9) {
   13a98:	00900613          	li	a2,9
   13a9c:	18f64863          	blt	a2,a5,13c2c <_vfprintf_r+0x1b04>
		*--t = to_char (exp);
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
	}
	else {
		if (!isa)
			*p++ = '0';
   13aa0:	03000713          	li	a4,48
		*p++ = to_char (exp);
   13aa4:	03078793          	addi	a5,a5,48
		*--t = to_char (exp);
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
	}
	else {
		if (!isa)
			*p++ = '0';
   13aa8:	06e10f23          	sb	a4,126(sp)
		*p++ = to_char (exp);
   13aac:	06f10fa3          	sb	a5,127(sp)
   13ab0:	08010713          	addi	a4,sp,128
	}
	return (p - p0);
   13ab4:	07c10793          	addi	a5,sp,124
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
   13ab8:	04012683          	lw	a3,64(sp)
	else {
		if (!isa)
			*p++ = '0';
		*p++ = to_char (exp);
	}
	return (p - p0);
   13abc:	40f707b3          	sub	a5,a4,a5
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
				if (ndig > 1 || flags & ALT)
   13ac0:	04012703          	lw	a4,64(sp)
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
   13ac4:	00d786b3          	add	a3,a5,a3
	else {
		if (!isa)
			*p++ = '0';
		*p++ = to_char (exp);
	}
	return (p - p0);
   13ac8:	04f12e23          	sw	a5,92(sp)
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
				if (ndig > 1 || flags & ALT)
   13acc:	00100793          	li	a5,1
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
   13ad0:	02d12623          	sw	a3,44(sp)
				if (ndig > 1 || flags & ALT)
   13ad4:	2ae7de63          	ble	a4,a5,13d90 <_vfprintf_r+0x1c68>
					++size;
   13ad8:	02c12783          	lw	a5,44(sp)
   13adc:	00178793          	addi	a5,a5,1
   13ae0:	02f12623          	sw	a5,44(sp)
   13ae4:	00078a93          	mv	s5,a5
   13ae8:	2a07cc63          	bltz	a5,13da0 <_vfprintf_r+0x1c78>
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
#ifdef FLOATING_POINT
		lead = 0;
   13aec:	02012e23          	sw	zero,60(sp)
   13af0:	addff06f          	j	135cc <_vfprintf_r+0x14a4>
				  cp = buf;
			} else
# endif /* _WANT_IO_C99_FORMATS */
			if (prec == -1) {
				prec = DEFPREC;
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
   13af4:	02812683          	lw	a3,40(sp)
   13af8:	9a0698e3          	bnez	a3,134a8 <_vfprintf_r+0x1380>
				prec = 1;
   13afc:	02812423          	sw	s0,40(sp)
   13b00:	9a9ff06f          	j	134a8 <_vfprintf_r+0x1380>
						PAD (ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
					if (expt || ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
   13b04:	08c10613          	addi	a2,sp,140
   13b08:	000a0593          	mv	a1,s4
   13b0c:	000c0513          	mv	a0,s8
   13b10:	249040ef          	jal	18558 <__sprint_r>
   13b14:	00050463          	beqz	a0,13b1c <_vfprintf_r+0x19f4>
   13b18:	8d5fe06f          	j	123ec <_vfprintf_r+0x2c4>
   13b1c:	07412983          	lw	s3,116(sp)
   13b20:	09412783          	lw	a5,148(sp)
   13b24:	09012703          	lw	a4,144(sp)
   13b28:	0c010293          	addi	t0,sp,192
   13b2c:	bcdff06f          	j	136f8 <_vfprintf_r+0x15d0>
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   13b30:	02012423          	sw	zero,40(sp)
   13b34:	f98fe06f          	j	122cc <_vfprintf_r+0x1a4>
   13b38:	fdf9f693          	andi	a3,s3,-33
				else
				  cp = buf;
			} else
# endif /* _WANT_IO_C99_FORMATS */
			if (prec == -1) {
				prec = DEFPREC;
   13b3c:	00600713          	li	a4,6
   13b40:	02d12023          	sw	a3,32(sp)
   13b44:	02e12423          	sw	a4,40(sp)
   13b48:	961ff06f          	j	134a8 <_vfprintf_r+0x1380>
			ndigits++;
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   13b4c:	08410793          	addi	a5,sp,132
   13b50:	00f12023          	sw	a5,0(sp)
   13b54:	02812783          	lw	a5,40(sp)
   13b58:	00300713          	li	a4,3
   13b5c:	000c8613          	mv	a2,s9
   13b60:	000a8693          	mv	a3,s5
   13b64:	07810893          	addi	a7,sp,120
   13b68:	07410813          	addi	a6,sp,116
   13b6c:	000c0513          	mv	a0,s8
   13b70:	00512a23          	sw	t0,20(sp)
   13b74:	7e4000ef          	jal	14358 <_dtoa_r>

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
   13b78:	02812703          	lw	a4,40(sp)
   13b7c:	01412283          	lw	t0,20(sp)
			ndigits++;
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   13b80:	00050413          	mv	s0,a0

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
   13b84:	00e50db3          	add	s11,a0,a4
   13b88:	00070313          	mv	t1,a4
		if (ch == 'f' || ch == 'F') {
			if (*digits == '0' && value)
   13b8c:	00044703          	lbu	a4,0(s0)
   13b90:	03000793          	li	a5,48
   13b94:	16f70663          	beq	a4,a5,13d00 <_vfprintf_r+0x1bd8>
   13b98:	07412303          	lw	t1,116(sp)
				*decpt = -ndigits + 1;
			bp += *decpt;
   13b9c:	006d8db3          	add	s11,s11,t1
   13ba0:	995ff06f          	j	13534 <_vfprintf_r+0x140c>
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
		value = -value;
   13ba4:	05412783          	lw	a5,84(sp)
   13ba8:	80000ab7          	lui	s5,0x80000
		*sign = '-';
   13bac:	02d00613          	li	a2,45
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
		value = -value;
   13bb0:	0157cab3          	xor	s5,a5,s5
		*sign = '-';
   13bb4:	02c12c23          	sw	a2,56(sp)
   13bb8:	909ff06f          	j	134c0 <_vfprintf_r+0x1398>
					size = expt;
					if (flags & ALT)
						++size;
				} else
					size = ndig + (expt > 0 ?
						1 : 2 - expt);
   13bbc:	03c12703          	lw	a4,60(sp)
   13bc0:	00100513          	li	a0,1
   13bc4:	1ae05863          	blez	a4,13d74 <_vfprintf_r+0x1c4c>
				} else if (expt >= ndig) { /* fixed g fmt */
					size = expt;
					if (flags & ALT)
						++size;
				} else
					size = ndig + (expt > 0 ?
   13bc8:	04012783          	lw	a5,64(sp)
   13bcc:	00f50533          	add	a0,a0,a5
   13bd0:	02a12623          	sw	a0,44(sp)
   13bd4:	00050a93          	mv	s5,a0
   13bd8:	02054063          	bltz	a0,13bf8 <_vfprintf_r+0x1ad0>
   13bdc:	06700993          	li	s3,103
   13be0:	9edff06f          	j	135cc <_vfprintf_r+0x14a4>
							  ? prec + 2
							  : 1;
				} else if (expt >= ndig) { /* fixed g fmt */
					size = expt;
					if (flags & ALT)
						++size;
   13be4:	03c12783          	lw	a5,60(sp)
   13be8:	00178793          	addi	a5,a5,1
   13bec:	02f12623          	sw	a5,44(sp)
   13bf0:	00078a93          	mv	s5,a5
   13bf4:	fe07d4e3          	bgez	a5,13bdc <_vfprintf_r+0x1ab4>
   13bf8:	00000a93          	li	s5,0
				} else
					size = ndig + (expt > 0 ?
   13bfc:	06700993          	li	s3,103
   13c00:	9cdff06f          	j	135cc <_vfprintf_r+0x14a4>
# ifdef _WANT_IO_C99_FORMATS
				flags &= ~GROUPING;
# endif
			} else {
				if (ch == 'f') {		/* f fmt */
					if (expt > 0) {
   13c04:	07412783          	lw	a5,116(sp)
   13c08:	02f12e23          	sw	a5,60(sp)
   13c0c:	12f05c63          	blez	a5,13d44 <_vfprintf_r+0x1c1c>
						size = expt;
						if (prec || flags & ALT)
   13c10:	02812603          	lw	a2,40(sp)
   13c14:	0c061463          	bnez	a2,13cdc <_vfprintf_r+0x1bb4>
   13c18:	00197913          	andi	s2,s2,1
   13c1c:	0c091063          	bnez	s2,13cdc <_vfprintf_r+0x1bb4>
   13c20:	00078a93          	mv	s5,a5
   13c24:	02f12623          	sw	a5,44(sp)
   13c28:	9a5ff06f          	j	135cc <_vfprintf_r+0x14a4>
		*p++ = '-';
	}
	else
		*p++ = '+';
	t = expbuf + MAXEXPLEN;
	if (exp > 9) {
   13c2c:	08b10593          	addi	a1,sp,139
   13c30:	00058713          	mv	a4,a1
		do {
			*--t = to_char (exp % 10);
   13c34:	00a00513          	li	a0,10
   13c38:	02a7e6b3          	rem	a3,a5,a0
   13c3c:	fff70713          	addi	a4,a4,-1
		} while ((exp /= 10) > 9);
   13c40:	02a7c7b3          	div	a5,a5,a0
	else
		*p++ = '+';
	t = expbuf + MAXEXPLEN;
	if (exp > 9) {
		do {
			*--t = to_char (exp % 10);
   13c44:	03068693          	addi	a3,a3,48
   13c48:	00d70023          	sb	a3,0(a4)
		} while ((exp /= 10) > 9);
   13c4c:	fef646e3          	blt	a2,a5,13c38 <_vfprintf_r+0x1b10>
		*--t = to_char (exp);
   13c50:	03078793          	addi	a5,a5,48
   13c54:	0ff7f793          	andi	a5,a5,255
   13c58:	fff70693          	addi	a3,a4,-1
   13c5c:	fef70fa3          	sb	a5,-1(a4)
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
   13c60:	1cb6fa63          	bleu	a1,a3,13e34 <_vfprintf_r+0x1d0c>
   13c64:	07e10613          	addi	a2,sp,126
   13c68:	0080006f          	j	13c70 <_vfprintf_r+0x1b48>
   13c6c:	0006c783          	lbu	a5,0(a3)
   13c70:	00160613          	addi	a2,a2,1
   13c74:	00168693          	addi	a3,a3,1
   13c78:	fef60fa3          	sb	a5,-1(a2)
   13c7c:	feb698e3          	bne	a3,a1,13c6c <_vfprintf_r+0x1b44>
   13c80:	08c10793          	addi	a5,sp,140
   13c84:	40e78733          	sub	a4,a5,a4
   13c88:	07e10793          	addi	a5,sp,126
   13c8c:	00e78733          	add	a4,a5,a4
   13c90:	e25ff06f          	j	13ab4 <_vfprintf_r+0x198c>
			ndigits++;
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   13c94:	08410793          	addi	a5,sp,132
   13c98:	00f12023          	sw	a5,0(sp)
   13c9c:	02812783          	lw	a5,40(sp)
   13ca0:	000c8613          	mv	a2,s9
   13ca4:	000a8693          	mv	a3,s5
   13ca8:	07810893          	addi	a7,sp,120
   13cac:	07410813          	addi	a6,sp,116
   13cb0:	00300713          	li	a4,3
   13cb4:	000c0513          	mv	a0,s8
   13cb8:	00512a23          	sw	t0,20(sp)
   13cbc:	69c000ef          	jal	14358 <_dtoa_r>
   13cc0:	02812303          	lw	t1,40(sp)
   13cc4:	01412283          	lw	t0,20(sp)
   13cc8:	00050413          	mv	s0,a0

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
		if (ch == 'f' || ch == 'F') {
   13ccc:	04600793          	li	a5,70
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
   13cd0:	00640db3          	add	s11,s0,t1
		if (ch == 'f' || ch == 'F') {
   13cd4:	eaf98ce3          	beq	s3,a5,13b8c <_vfprintf_r+0x1a64>
   13cd8:	85dff06f          	j	13534 <_vfprintf_r+0x140c>
			} else {
				if (ch == 'f') {		/* f fmt */
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
   13cdc:	02812683          	lw	a3,40(sp)
   13ce0:	03c12703          	lw	a4,60(sp)
   13ce4:	00168513          	addi	a0,a3,1
   13ce8:	00a70533          	add	a0,a4,a0
   13cec:	02a12623          	sw	a0,44(sp)
   13cf0:	00050a93          	mv	s5,a0
   13cf4:	8c055ce3          	bgez	a0,135cc <_vfprintf_r+0x14a4>
   13cf8:	00000a93          	li	s5,0
					} else	/* "0.X" */
						size = (prec || flags & ALT)
							  ? prec + 2
							  : 1;
   13cfc:	8d1ff06f          	j	135cc <_vfprintf_r+0x14a4>
	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
		bp = digits + ndigits;
		if (ch == 'f' || ch == 'F') {
			if (*digits == '0' && value)
   13d00:	000c8513          	mv	a0,s9
   13d04:	000a8593          	mv	a1,s5
   13d08:	00000613          	li	a2,0
   13d0c:	00000693          	li	a3,0
   13d10:	00512a23          	sw	t0,20(sp)
   13d14:	00612c23          	sw	t1,24(sp)
   13d18:	0c9070ef          	jal	1b5e0 <__nedf2>
   13d1c:	01412283          	lw	t0,20(sp)
   13d20:	01812303          	lw	t1,24(sp)
   13d24:	e6050ae3          	beqz	a0,13b98 <_vfprintf_r+0x1a70>
				*decpt = -ndigits + 1;
   13d28:	00100793          	li	a5,1
   13d2c:	40678333          	sub	t1,a5,t1
   13d30:	06612a23          	sw	t1,116(sp)
			bp += *decpt;
   13d34:	006d8db3          	add	s11,s11,t1
   13d38:	ffcff06f          	j	13534 <_vfprintf_r+0x140c>
   13d3c:	00000a93          	li	s5,0
   13d40:	c69ff06f          	j	139a8 <_vfprintf_r+0x1880>
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
							  ? prec + 2
							  : 1;
   13d44:	02812783          	lw	a5,40(sp)
   13d48:	00079a63          	bnez	a5,13d5c <_vfprintf_r+0x1c34>
   13d4c:	00100a93          	li	s5,1
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
   13d50:	01597933          	and	s2,s2,s5
							  ? prec + 2
							  : 1;
   13d54:	03512623          	sw	s5,44(sp)
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
   13d58:	86090ae3          	beqz	s2,135cc <_vfprintf_r+0x14a4>
							  ? prec + 2
							  : 1;
   13d5c:	02812683          	lw	a3,40(sp)
   13d60:	00268693          	addi	a3,a3,2
   13d64:	02d12623          	sw	a3,44(sp)
   13d68:	00068a93          	mv	s5,a3
   13d6c:	8606d0e3          	bgez	a3,135cc <_vfprintf_r+0x14a4>
   13d70:	f89ff06f          	j	13cf8 <_vfprintf_r+0x1bd0>
					size = expt;
					if (flags & ALT)
						++size;
				} else
					size = ndig + (expt > 0 ?
						1 : 2 - expt);
   13d74:	00200513          	li	a0,2
   13d78:	40e50533          	sub	a0,a0,a4
   13d7c:	e4dff06f          	j	13bc8 <_vfprintf_r+0x1aa0>

	p = p0;
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
	if (exp < 0) {
		exp = -exp;
		*p++ = '-';
   13d80:	02d00713          	li	a4,45
# endif

	p = p0;
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
	if (exp < 0) {
		exp = -exp;
   13d84:	40f007b3          	neg	a5,a5
		*p++ = '-';
   13d88:	06e10ea3          	sb	a4,125(sp)
   13d8c:	d0dff06f          	j	13a98 <_vfprintf_r+0x1970>
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
				--expt;
				expsize = exponent (expstr, expt, ch);
				size = expsize + ndig;
				if (ndig > 1 || flags & ALT)
   13d90:	00f97933          	and	s2,s2,a5
   13d94:	d40912e3          	bnez	s2,13ad8 <_vfprintf_r+0x19b0>
   13d98:	00068a93          	mv	s5,a3
   13d9c:	d406d8e3          	bgez	a3,13aec <_vfprintf_r+0x19c4>
   13da0:	00000a93          	li	s5,0
   13da4:	d49ff06f          	j	13aec <_vfprintf_r+0x19c4>
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
   13da8:	03012703          	lw	a4,48(sp)
   13dac:	00072703          	lw	a4,0(a4)
   13db0:	02e12423          	sw	a4,40(sp)
   13db4:	03012703          	lw	a4,48(sp)
   13db8:	00470793          	addi	a5,a4,4
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
   13dbc:	02812703          	lw	a4,40(sp)
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
   13dc0:	02f12823          	sw	a5,48(sp)
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
   13dc4:	00074463          	bltz	a4,13dcc <_vfprintf_r+0x1ca4>
   13dc8:	cfcfe06f          	j	122c4 <_vfprintf_r+0x19c>
					prec = -1;
   13dcc:	fff00713          	li	a4,-1
   13dd0:	02e12423          	sw	a4,40(sp)
   13dd4:	cf0fe06f          	j	122c4 <_vfprintf_r+0x19c>
   13dd8:	06a107a3          	sb	a0,111(sp)
   13ddc:	d35fe06f          	j	12b10 <_vfprintf_r+0x9e8>
   13de0:	06a107a3          	sb	a0,111(sp)
				size = 1;
			}
			sign = '\0';
			break;
		case 'D':  /* extension */
			flags |= LONGINT;
   13de4:	01096913          	ori	s2,s2,16
   13de8:	e59fe06f          	j	12c40 <_vfprintf_r+0xb18>
   13dec:	06a107a3          	sb	a0,111(sp)
   13df0:	da9fe06f          	j	12b98 <_vfprintf_r+0xa70>
   13df4:	06a107a3          	sb	a0,111(sp)
   13df8:	d69fe06f          	j	12b60 <_vfprintf_r+0xa38>
   13dfc:	06a107a3          	sb	a0,111(sp)
   13e00:	c2dfe06f          	j	12a2c <_vfprintf_r+0x904>
   13e04:	06a107a3          	sb	a0,111(sp)
			} else
				size = strlen (cp);

			break;
		case 'U': /* extension */
			flags |= LONGINT;
   13e08:	01096913          	ori	s2,s2,16
   13e0c:	bddfe06f          	j	129e8 <_vfprintf_r+0x8c0>
   13e10:	06a107a3          	sb	a0,111(sp)
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
   13e14:	01096913          	ori	s2,s2,16
   13e18:	b89fe06f          	j	129a0 <_vfprintf_r+0x878>
   13e1c:	06a107a3          	sb	a0,111(sp)
   13e20:	ae1fe06f          	j	12900 <_vfprintf_r+0x7d8>
   13e24:	00000a93          	li	s5,0
   13e28:	f98ff06f          	j	135c0 <_vfprintf_r+0x1498>
   13e2c:	06a107a3          	sb	a0,111(sp)
   13e30:	e2cfe06f          	j	1245c <_vfprintf_r+0x334>
	if (exp > 9) {
		do {
			*--t = to_char (exp % 10);
		} while ((exp /= 10) > 9);
		*--t = to_char (exp);
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
   13e34:	07e10713          	addi	a4,sp,126
   13e38:	c7dff06f          	j	13ab4 <_vfprintf_r+0x198c>
   13e3c:	07412783          	lw	a5,116(sp)
   13e40:	c41ff06f          	j	13a80 <_vfprintf_r+0x1958>
   13e44:	06a107a3          	sb	a0,111(sp)
   13e48:	e71fe06f          	j	12cb8 <_vfprintf_r+0xb90>
   13e4c:	06a107a3          	sb	a0,111(sp)
   13e50:	e1dfe06f          	j	12c6c <_vfprintf_r+0xb44>

00013e54 <vfprintf>:
       FILE * fp         _AND
       _CONST char *fmt0 _AND
       va_list ap)
{
  int result;
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
   13e54:	00060693          	mv	a3,a2
   13e58:	00058613          	mv	a2,a1
   13e5c:	00050593          	mv	a1,a0
   13e60:	8101a503          	lw	a0,-2032(gp) # 47ff0 <_impure_ptr>
   13e64:	ac4fe06f          	j	12128 <_vfprintf_r>

00013e68 <__sbprintf>:
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   13e68:	00c5d783          	lhu	a5,12(a1)
	fake._flags2 = fp->_flags2;
   13e6c:	0685a303          	lw	t1,104(a1)
	fake._file = fp->_file;
   13e70:	00e5d283          	lhu	t0,14(a1)
	fake._cookie = fp->_cookie;
   13e74:	01c5a883          	lw	a7,28(a1)
	fake._write = fp->_write;
   13e78:	0245a803          	lw	a6,36(a1)
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   13e7c:	b8010113          	addi	sp,sp,-1152
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   13e80:	ffd7f793          	andi	a5,a5,-3
	fake._cookie = fp->_cookie;
	fake._write = fp->_write;

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
	fake._bf._size = fake._w = sizeof (buf);
   13e84:	40000713          	li	a4,1024
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   13e88:	46812c23          	sw	s0,1144(sp)
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   13e8c:	00f11623          	sh	a5,12(sp)
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   13e90:	00058413          	mv	s0,a1
	fake._file = fp->_file;
	fake._cookie = fp->_cookie;
	fake._write = fp->_write;

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
   13e94:	07010793          	addi	a5,sp,112
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   13e98:	00010593          	mv	a1,sp
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   13e9c:	46912a23          	sw	s1,1140(sp)
   13ea0:	47212823          	sw	s2,1136(sp)
   13ea4:	46112e23          	sw	ra,1148(sp)
   13ea8:	00050913          	mv	s2,a0
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
	fake._flags2 = fp->_flags2;
   13eac:	06612423          	sw	t1,104(sp)
	fake._file = fp->_file;
   13eb0:	00511723          	sh	t0,14(sp)
	fake._cookie = fp->_cookie;
   13eb4:	01112e23          	sw	a7,28(sp)
	fake._write = fp->_write;
   13eb8:	03012223          	sw	a6,36(sp)

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
   13ebc:	00f12023          	sw	a5,0(sp)
   13ec0:	00f12823          	sw	a5,16(sp)
	fake._bf._size = fake._w = sizeof (buf);
   13ec4:	00e12423          	sw	a4,8(sp)
   13ec8:	00e12a23          	sw	a4,20(sp)
	fake._lbfsize = 0;	/* not actually used, but Just In Case */
   13ecc:	00012c23          	sw	zero,24(sp)
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   13ed0:	a58fe0ef          	jal	12128 <_vfprintf_r>
   13ed4:	00050493          	mv	s1,a0
	if (ret >= 0 && _fflush_r (rptr, &fake))
   13ed8:	00054a63          	bltz	a0,13eec <__sbprintf+0x84>
   13edc:	00010593          	mv	a1,sp
   13ee0:	00090513          	mv	a0,s2
   13ee4:	41d010ef          	jal	15b00 <_fflush_r>
   13ee8:	02051c63          	bnez	a0,13f20 <__sbprintf+0xb8>
		ret = EOF;
	if (fake._flags & __SERR)
   13eec:	00c15783          	lhu	a5,12(sp)
   13ef0:	0407f793          	andi	a5,a5,64
   13ef4:	00078863          	beqz	a5,13f04 <__sbprintf+0x9c>
		fp->_flags |= __SERR;
   13ef8:	00c45783          	lhu	a5,12(s0)
   13efc:	0407e793          	ori	a5,a5,64
   13f00:	00f41623          	sh	a5,12(s0)

#ifndef __SINGLE_THREAD__
	__lock_close_recursive (fake._lock);
#endif
	return (ret);
}
   13f04:	47c12083          	lw	ra,1148(sp)
   13f08:	00048513          	mv	a0,s1
   13f0c:	47812403          	lw	s0,1144(sp)
   13f10:	47412483          	lw	s1,1140(sp)
   13f14:	47012903          	lw	s2,1136(sp)
   13f18:	48010113          	addi	sp,sp,1152
   13f1c:	00008067          	ret
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
	if (ret >= 0 && _fflush_r (rptr, &fake))
		ret = EOF;
   13f20:	fff00493          	li	s1,-1
   13f24:	fc9ff06f          	j	13eec <__sbprintf+0x84>

00013f28 <__swsetup_r>:
       struct _reent *ptr _AND
       register FILE * fp)
{
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   13f28:	8101a783          	lw	a5,-2032(gp) # 47ff0 <_impure_ptr>

int
_DEFUN(__swsetup_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   13f2c:	ff010113          	addi	sp,sp,-16
   13f30:	00812423          	sw	s0,8(sp)
   13f34:	00912223          	sw	s1,4(sp)
   13f38:	00112623          	sw	ra,12(sp)
   13f3c:	00050493          	mv	s1,a0
   13f40:	00058413          	mv	s0,a1
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   13f44:	00078663          	beqz	a5,13f50 <__swsetup_r+0x28>
   13f48:	0387a703          	lw	a4,56(a5)
   13f4c:	0c070c63          	beqz	a4,14024 <__swsetup_r+0xfc>

  /*
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
   13f50:	00c41703          	lh	a4,12(s0)
   13f54:	01071793          	slli	a5,a4,0x10
   13f58:	0107d793          	srli	a5,a5,0x10
   13f5c:	0087f693          	andi	a3,a5,8
   13f60:	04068263          	beqz	a3,13fa4 <__swsetup_r+0x7c>
   13f64:	01042683          	lw	a3,16(s0)
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
   13f68:	06068263          	beqz	a3,13fcc <__swsetup_r+0xa4>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
    __smakebuf_r (ptr, fp);

  if (fp->_flags & __SLBF)
   13f6c:	0017f713          	andi	a4,a5,1
   13f70:	08071063          	bnez	a4,13ff0 <__swsetup_r+0xc8>
       */
      fp->_w = 0;
      fp->_lbfsize = -fp->_bf._size;
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;
   13f74:	0027f793          	andi	a5,a5,2
   13f78:	00000713          	li	a4,0
   13f7c:	00079463          	bnez	a5,13f84 <__swsetup_r+0x5c>
   13f80:	01442703          	lw	a4,20(s0)
   13f84:	00e42423          	sw	a4,8(s0)
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
      return EOF;
    }
  return 0;
   13f88:	00000513          	li	a0,0
      fp->_lbfsize = -fp->_bf._size;
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;

  if (!fp->_bf._base && (fp->_flags & __SMBF))
   13f8c:	06068e63          	beqz	a3,14008 <__swsetup_r+0xe0>
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
      return EOF;
    }
  return 0;
}
   13f90:	00c12083          	lw	ra,12(sp)
   13f94:	00812403          	lw	s0,8(sp)
   13f98:	00412483          	lw	s1,4(sp)
   13f9c:	01010113          	addi	sp,sp,16
   13fa0:	00008067          	ret
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
   13fa4:	0107f693          	andi	a3,a5,16
   13fa8:	0a068e63          	beqz	a3,14064 <__swsetup_r+0x13c>
        {
	  ptr->_errno = EBADF;
	  fp->_flags |= __SERR;
	  return EOF;
        }
      if (fp->_flags & __SRD)
   13fac:	0047f793          	andi	a5,a5,4
   13fb0:	08079063          	bnez	a5,14030 <__swsetup_r+0x108>
   13fb4:	01042683          	lw	a3,16(s0)
	    FREEUB (ptr, fp);
	  fp->_flags &= ~(__SRD | __SEOF);
	  fp->_r = 0;
	  fp->_p = fp->_bf._base;
	}
      fp->_flags |= __SWR;
   13fb8:	00876793          	ori	a5,a4,8
   13fbc:	00f41623          	sh	a5,12(s0)
   13fc0:	01079793          	slli	a5,a5,0x10
   13fc4:	0107d793          	srli	a5,a5,0x10
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
   13fc8:	fa0692e3          	bnez	a3,13f6c <__swsetup_r+0x44>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
   13fcc:	2807f713          	andi	a4,a5,640
   13fd0:	20000613          	li	a2,512
   13fd4:	f8c70ce3          	beq	a4,a2,13f6c <__swsetup_r+0x44>
    __smakebuf_r (ptr, fp);
   13fd8:	00040593          	mv	a1,s0
   13fdc:	00048513          	mv	a0,s1
   13fe0:	524020ef          	jal	16504 <__smakebuf_r>
   13fe4:	00c45783          	lhu	a5,12(s0)
   13fe8:	01042683          	lw	a3,16(s0)
   13fec:	f81ff06f          	j	13f6c <__swsetup_r+0x44>
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
      fp->_lbfsize = -fp->_bf._size;
   13ff0:	01442783          	lw	a5,20(s0)
      /*
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
   13ff4:	00042423          	sw	zero,8(s0)
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
      return EOF;
    }
  return 0;
   13ff8:	00000513          	li	a0,0
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
      fp->_lbfsize = -fp->_bf._size;
   13ffc:	40f007b3          	neg	a5,a5
   14000:	00f42c23          	sw	a5,24(s0)
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;

  if (!fp->_bf._base && (fp->_flags & __SMBF))
   14004:	f80696e3          	bnez	a3,13f90 <__swsetup_r+0x68>
   14008:	00c41783          	lh	a5,12(s0)
   1400c:	0807f713          	andi	a4,a5,128
   14010:	f80700e3          	beqz	a4,13f90 <__swsetup_r+0x68>
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
   14014:	0407e793          	ori	a5,a5,64
   14018:	00f41623          	sh	a5,12(s0)
      return EOF;
   1401c:	fff00513          	li	a0,-1
   14020:	f71ff06f          	j	13f90 <__swsetup_r+0x68>
       struct _reent *ptr _AND
       register FILE * fp)
{
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   14024:	00078513          	mv	a0,a5
   14028:	689010ef          	jal	15eb0 <__sinit>
   1402c:	f25ff06f          	j	13f50 <__swsetup_r+0x28>
	  return EOF;
        }
      if (fp->_flags & __SRD)
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
   14030:	03042583          	lw	a1,48(s0)
   14034:	00058e63          	beqz	a1,14050 <__swsetup_r+0x128>
	    FREEUB (ptr, fp);
   14038:	04040793          	addi	a5,s0,64
   1403c:	00f58863          	beq	a1,a5,1404c <__swsetup_r+0x124>
   14040:	00048513          	mv	a0,s1
   14044:	7ad010ef          	jal	15ff0 <_free_r>
   14048:	00c41703          	lh	a4,12(s0)
   1404c:	02042823          	sw	zero,48(s0)
	  fp->_flags &= ~(__SRD | __SEOF);
	  fp->_r = 0;
	  fp->_p = fp->_bf._base;
   14050:	01042683          	lw	a3,16(s0)
      if (fp->_flags & __SRD)
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
	    FREEUB (ptr, fp);
	  fp->_flags &= ~(__SRD | __SEOF);
   14054:	fdb77713          	andi	a4,a4,-37
	  fp->_r = 0;
   14058:	00042223          	sw	zero,4(s0)
	  fp->_p = fp->_bf._base;
   1405c:	00d42023          	sw	a3,0(s0)
   14060:	f59ff06f          	j	13fb8 <__swsetup_r+0x90>
  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
        {
	  ptr->_errno = EBADF;
	  fp->_flags |= __SERR;
   14064:	04076713          	ori	a4,a4,64

  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
        {
	  ptr->_errno = EBADF;
   14068:	00900793          	li	a5,9
   1406c:	00f4a023          	sw	a5,0(s1)
	  fp->_flags |= __SERR;
	  return EOF;
   14070:	fff00513          	li	a0,-1
  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
        {
	  ptr->_errno = EBADF;
	  fp->_flags |= __SERR;
   14074:	00e41623          	sh	a4,12(s0)
	  return EOF;
   14078:	f19ff06f          	j	13f90 <__swsetup_r+0x68>

0001407c <__register_exitproc>:
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
   1407c:	fe010113          	addi	sp,sp,-32
   14080:	00812c23          	sw	s0,24(sp)

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
   14084:	80c1a403          	lw	s0,-2036(gp) # 47fec <_global_impure_ptr>
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
   14088:	00912a23          	sw	s1,20(sp)
   1408c:	00050493          	mv	s1,a0

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
   14090:	14842503          	lw	a0,328(s0)
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
   14094:	00112e23          	sw	ra,28(sp)
#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
  if (p == NULL)
   14098:	0c050263          	beqz	a0,1415c <__register_exitproc+0xe0>
    _GLOBAL_ATEXIT = p = _GLOBAL_ATEXIT0;
  if (p->_ind >= _ATEXIT_SIZE)
   1409c:	00452783          	lw	a5,4(a0)
   140a0:	01f00713          	li	a4,31
   140a4:	00178813          	addi	a6,a5,1
   140a8:	04f75863          	ble	a5,a4,140f8 <__register_exitproc+0x7c>
#ifndef _ATEXIT_DYNAMIC_ALLOC
      return -1;
#else
      /* Don't dynamically allocate the atexit array if malloc is not
	 available.  */
      if (!malloc)
   140ac:	00000793          	li	a5,0
   140b0:	0a078c63          	beqz	a5,14168 <__register_exitproc+0xec>
	return -1;

      p = (struct _atexit *) malloc (sizeof *p);
   140b4:	19000513          	li	a0,400
   140b8:	00b12623          	sw	a1,12(sp)
   140bc:	00c12423          	sw	a2,8(sp)
   140c0:	00d12223          	sw	a3,4(sp)
   140c4:	f3deb0ef          	jal	0 <_reset-0x200>
      if (p == NULL)
   140c8:	00c12583          	lw	a1,12(sp)
   140cc:	00812603          	lw	a2,8(sp)
   140d0:	00412683          	lw	a3,4(sp)
   140d4:	08050a63          	beqz	a0,14168 <__register_exitproc+0xec>
	  __lock_release_recursive(__atexit_lock);
#endif
	  return -1;
	}
      p->_ind = 0;
      p->_next = _GLOBAL_ATEXIT;
   140d8:	14842783          	lw	a5,328(s0)
      _GLOBAL_ATEXIT = p;
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
      p->_on_exit_args._is_cxa = 0;
   140dc:	00100813          	li	a6,1
#ifndef __SINGLE_THREAD__
	  __lock_release_recursive(__atexit_lock);
#endif
	  return -1;
	}
      p->_ind = 0;
   140e0:	00052223          	sw	zero,4(a0)
      p->_next = _GLOBAL_ATEXIT;
   140e4:	00f52023          	sw	a5,0(a0)
      _GLOBAL_ATEXIT = p;
   140e8:	14a42423          	sw	a0,328(s0)
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
      p->_on_exit_args._is_cxa = 0;
   140ec:	00000793          	li	a5,0
	}
      p->_ind = 0;
      p->_next = _GLOBAL_ATEXIT;
      _GLOBAL_ATEXIT = p;
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
   140f0:	18052423          	sw	zero,392(a0)
      p->_on_exit_args._is_cxa = 0;
   140f4:	18052623          	sw	zero,396(a0)
   140f8:	00279713          	slli	a4,a5,0x2
      p->_on_exit_args_ptr = NULL;
#endif
#endif
    }

  if (type != __et_atexit)
   140fc:	02049463          	bnez	s1,14124 <__register_exitproc+0xa8>
      args->_fntypes |= (1 << p->_ind);
      args->_dso_handle[p->_ind] = d;
      if (type == __et_cxa)
	args->_is_cxa |= (1 << p->_ind);
    }
  p->_fns[p->_ind++] = fn;
   14100:	00e50733          	add	a4,a0,a4
   14104:	01052223          	sw	a6,4(a0)
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif
  return 0;
   14108:	00000513          	li	a0,0
      args->_fntypes |= (1 << p->_ind);
      args->_dso_handle[p->_ind] = d;
      if (type == __et_cxa)
	args->_is_cxa |= (1 << p->_ind);
    }
  p->_fns[p->_ind++] = fn;
   1410c:	00b72423          	sw	a1,8(a4)
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif
  return 0;
}
   14110:	01c12083          	lw	ra,28(sp)
   14114:	01812403          	lw	s0,24(sp)
   14118:	01412483          	lw	s1,20(sp)
   1411c:	02010113          	addi	sp,sp,32
   14120:	00008067          	ret
   14124:	00e502b3          	add	t0,a0,a4
	  p->_on_exit_args_ptr = args;
	}
#else
      args = &p->_on_exit_args;
#endif
      args->_fnargs[p->_ind] = arg;
   14128:	08c2a423          	sw	a2,136(t0)
      args->_fntypes |= (1 << p->_ind);
   1412c:	18852883          	lw	a7,392(a0)
   14130:	00100613          	li	a2,1
   14134:	00f617b3          	sll	a5,a2,a5
   14138:	00f8e633          	or	a2,a7,a5
   1413c:	18c52423          	sw	a2,392(a0)
      args->_dso_handle[p->_ind] = d;
   14140:	10d2a423          	sw	a3,264(t0)
      if (type == __et_cxa)
   14144:	00200693          	li	a3,2
   14148:	fad49ce3          	bne	s1,a3,14100 <__register_exitproc+0x84>
	args->_is_cxa |= (1 << p->_ind);
   1414c:	18c52683          	lw	a3,396(a0)
   14150:	00f6e7b3          	or	a5,a3,a5
   14154:	18f52623          	sw	a5,396(a0)
   14158:	fa9ff06f          	j	14100 <__register_exitproc+0x84>
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
  if (p == NULL)
    _GLOBAL_ATEXIT = p = _GLOBAL_ATEXIT0;
   1415c:	14c40513          	addi	a0,s0,332
   14160:	14a42423          	sw	a0,328(s0)
   14164:	f39ff06f          	j	1409c <__register_exitproc+0x20>
      return -1;
#else
      /* Don't dynamically allocate the atexit array if malloc is not
	 available.  */
      if (!malloc)
	return -1;
   14168:	fff00513          	li	a0,-1
   1416c:	fa5ff06f          	j	14110 <__register_exitproc+0x94>

00014170 <quorem>:

static int
_DEFUN (quorem,
	(b, S),
	_Bigint * b _AND _Bigint * S)
{
   14170:	fe010113          	addi	sp,sp,-32
   14174:	01212823          	sw	s2,16(sp)
  n = S->_wds;
#ifdef DEBUG
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
   14178:	01052783          	lw	a5,16(a0)
#ifdef Pack_32
  __Long z;
  __ULong si, zs;
#endif

  n = S->_wds;
   1417c:	0105a903          	lw	s2,16(a1)

static int
_DEFUN (quorem,
	(b, S),
	_Bigint * b _AND _Bigint * S)
{
   14180:	00112e23          	sw	ra,28(sp)
   14184:	00812c23          	sw	s0,24(sp)
   14188:	00912a23          	sw	s1,20(sp)
   1418c:	01312623          	sw	s3,12(sp)
   14190:	01412423          	sw	s4,8(sp)
   14194:	01512223          	sw	s5,4(sp)
  n = S->_wds;
#ifdef DEBUG
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
   14198:	1b27cc63          	blt	a5,s2,14350 <quorem+0x1e0>
    return 0;
  sx = S->_x;
  sxe = sx + --n;
   1419c:	fff90913          	addi	s2,s2,-1
   141a0:	00291e13          	slli	t3,s2,0x2
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
    return 0;
  sx = S->_x;
   141a4:	01458413          	addi	s0,a1,20
  sxe = sx + --n;
   141a8:	01c409b3          	add	s3,s0,t3
  bx = b->_x;
   141ac:	01450a13          	addi	s4,a0,20
  bxe = bx + n;
   141b0:	01ca0e33          	add	t3,s4,t3
  q = *bxe / (*sxe + 1);	/* ensure q <= true quotient */
   141b4:	0009a783          	lw	a5,0(s3)
   141b8:	000e2483          	lw	s1,0(t3)
   141bc:	00178793          	addi	a5,a5,1
   141c0:	02f4d4b3          	divu	s1,s1,a5
#ifdef DEBUG
  /*debug*/ if (q > 9)
    /*debug*/ Bug ("oversized quotient in quorem");
#endif
  if (q)
   141c4:	0a048e63          	beqz	s1,14280 <quorem+0x110>
      carry = 0;
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
   141c8:	000102b7          	lui	t0,0x10
   141cc:	00040393          	mv	t2,s0
#endif
  if (b->_wds < n)
    return 0;
  sx = S->_x;
  sxe = sx + --n;
  bx = b->_x;
   141d0:	000a0313          	mv	t1,s4
   141d4:	00000693          	li	a3,0
   141d8:	00000793          	li	a5,0
      carry = 0;
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
   141dc:	fff28293          	addi	t0,t0,-1 # ffff <_reset+0xfdff>
      borrow = 0;
      carry = 0;
      do
	{
#ifdef Pack_32
	  si = *sx++;
   141e0:	00438393          	addi	t2,t2,4
   141e4:	ffc3a603          	lw	a2,-4(t2)
	  ys = (si & 0xffff) * q + carry;
	  zs = (si >> 16) * q + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   141e8:	00032703          	lw	a4,0(t1)
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
	  borrow = z >> 16;
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   141ec:	00430313          	addi	t1,t1,4
      carry = 0;
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
   141f0:	005678b3          	and	a7,a2,t0
   141f4:	029888b3          	mul	a7,a7,s1
	  zs = (si >> 16) * q + (ys >> 16);
   141f8:	01065613          	srli	a2,a2,0x10
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   141fc:	00577833          	and	a6,a4,t0
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   14200:	01075713          	srli	a4,a4,0x10
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
	  zs = (si >> 16) * q + (ys >> 16);
   14204:	02960633          	mul	a2,a2,s1
      carry = 0;
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
   14208:	00d888b3          	add	a7,a7,a3
	  zs = (si >> 16) * q + (ys >> 16);
   1420c:	0108d693          	srli	a3,a7,0x10
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   14210:	0058f8b3          	and	a7,a7,t0
   14214:	411787b3          	sub	a5,a5,a7
   14218:	01078833          	add	a6,a5,a6
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   1421c:	41085893          	srai	a7,a6,0x10
	  borrow = z >> 16;
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   14220:	00587833          	and	a6,a6,t0
      do
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
	  zs = (si >> 16) * q + (ys >> 16);
   14224:	00d606b3          	add	a3,a2,a3
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   14228:	0056f7b3          	and	a5,a3,t0
   1422c:	40f70733          	sub	a4,a4,a5
   14230:	011707b3          	add	a5,a4,a7
	  borrow = z >> 16;
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   14234:	01079713          	slli	a4,a5,0x10
   14238:	01076833          	or	a6,a4,a6
	{
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) * q + carry;
	  zs = (si >> 16) * q + (ys >> 16);
	  carry = zs >> 16;
   1423c:	0106d693          	srli	a3,a3,0x10
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
	  borrow = z >> 16;
   14240:	4107d793          	srai	a5,a5,0x10
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   14244:	ff032e23          	sw	a6,-4(t1)
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
   14248:	f879fce3          	bleu	t2,s3,141e0 <quorem+0x70>
      if (!*bxe)
   1424c:	000e2783          	lw	a5,0(t3)
   14250:	02079863          	bnez	a5,14280 <quorem+0x110>
	{
	  bx = b->_x;
	  while (--bxe > bx && !*bxe)
   14254:	ffce0793          	addi	a5,t3,-4
   14258:	02fa7263          	bleu	a5,s4,1427c <quorem+0x10c>
   1425c:	ffce2703          	lw	a4,-4(t3)
   14260:	00070863          	beqz	a4,14270 <quorem+0x100>
   14264:	0180006f          	j	1427c <quorem+0x10c>
   14268:	0007a703          	lw	a4,0(a5)
   1426c:	00071863          	bnez	a4,1427c <quorem+0x10c>
   14270:	ffc78793          	addi	a5,a5,-4
	    --n;
   14274:	fff90913          	addi	s2,s2,-1
	}
      while (sx <= sxe);
      if (!*bxe)
	{
	  bx = b->_x;
	  while (--bxe > bx && !*bxe)
   14278:	fefa68e3          	bltu	s4,a5,14268 <quorem+0xf8>
	    --n;
	  b->_wds = n;
   1427c:	01252823          	sw	s2,16(a0)
   14280:	00050a93          	mv	s5,a0
	}
    }
  if (cmp (b, S) >= 0)
   14284:	714030ef          	jal	17998 <__mcmp>
   14288:	0a054063          	bltz	a0,14328 <quorem+0x1b8>
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) + carry;
	  zs = (si >> 16) + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   1428c:	00010837          	lui	a6,0x10
	  b->_wds = n;
	}
    }
  if (cmp (b, S) >= 0)
    {
      q++;
   14290:	00148493          	addi	s1,s1,1
#endif
  if (b->_wds < n)
    return 0;
  sx = S->_x;
  sxe = sx + --n;
  bx = b->_x;
   14294:	000a0593          	mv	a1,s4
	}
    }
  if (cmp (b, S) >= 0)
    {
      q++;
      borrow = 0;
   14298:	00000793          	li	a5,0
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) + carry;
	  zs = (si >> 16) + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   1429c:	fff80813          	addi	a6,a6,-1 # ffff <_reset+0xfdff>
      bx = b->_x;
      sx = S->_x;
      do
	{
#ifdef Pack_32
	  si = *sx++;
   142a0:	00440413          	addi	s0,s0,4
   142a4:	ffc42603          	lw	a2,-4(s0)
	  ys = (si & 0xffff) + carry;
	  zs = (si >> 16) + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   142a8:	0005a703          	lw	a4,0(a1)
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
	  borrow = z >> 16;
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   142ac:	00458593          	addi	a1,a1,4
#ifdef Pack_32
	  si = *sx++;
	  ys = (si & 0xffff) + carry;
	  zs = (si >> 16) + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   142b0:	010676b3          	and	a3,a2,a6
   142b4:	40d787b3          	sub	a5,a5,a3
   142b8:	010776b3          	and	a3,a4,a6
   142bc:	00d786b3          	add	a3,a5,a3
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   142c0:	01075713          	srli	a4,a4,0x10
   142c4:	01065793          	srli	a5,a2,0x10
   142c8:	40f70733          	sub	a4,a4,a5
   142cc:	4106d793          	srai	a5,a3,0x10
   142d0:	00f707b3          	add	a5,a4,a5
	  borrow = z >> 16;
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   142d4:	01079713          	slli	a4,a5,0x10
   142d8:	0106f6b3          	and	a3,a3,a6
   142dc:	00d766b3          	or	a3,a4,a3
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
	  borrow = z >> 16;
   142e0:	4107d793          	srai	a5,a5,0x10
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   142e4:	fed5ae23          	sw	a3,-4(a1)
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
   142e8:	fa89fce3          	bleu	s0,s3,142a0 <quorem+0x130>
      bx = b->_x;
      bxe = bx + n;
   142ec:	00291713          	slli	a4,s2,0x2
   142f0:	00ea0733          	add	a4,s4,a4
      if (!*bxe)
   142f4:	00072783          	lw	a5,0(a4)
   142f8:	02079863          	bnez	a5,14328 <quorem+0x1b8>
	{
	  while (--bxe > bx && !*bxe)
   142fc:	ffc70793          	addi	a5,a4,-4
   14300:	02fa7263          	bleu	a5,s4,14324 <quorem+0x1b4>
   14304:	ffc72703          	lw	a4,-4(a4)
   14308:	00070863          	beqz	a4,14318 <quorem+0x1a8>
   1430c:	0180006f          	j	14324 <quorem+0x1b4>
   14310:	0007a703          	lw	a4,0(a5)
   14314:	00071863          	bnez	a4,14324 <quorem+0x1b4>
   14318:	ffc78793          	addi	a5,a5,-4
	    --n;
   1431c:	fff90913          	addi	s2,s2,-1
      while (sx <= sxe);
      bx = b->_x;
      bxe = bx + n;
      if (!*bxe)
	{
	  while (--bxe > bx && !*bxe)
   14320:	fefa68e3          	bltu	s4,a5,14310 <quorem+0x1a0>
	    --n;
	  b->_wds = n;
   14324:	012aa823          	sw	s2,16(s5) # 80000010 <_gp+0x7ffb7830>
	}
    }
  return q;
   14328:	00048513          	mv	a0,s1
}
   1432c:	01c12083          	lw	ra,28(sp)
   14330:	01812403          	lw	s0,24(sp)
   14334:	01412483          	lw	s1,20(sp)
   14338:	01012903          	lw	s2,16(sp)
   1433c:	00c12983          	lw	s3,12(sp)
   14340:	00812a03          	lw	s4,8(sp)
   14344:	00412a83          	lw	s5,4(sp)
   14348:	02010113          	addi	sp,sp,32
   1434c:	00008067          	ret
#ifdef DEBUG
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
    return 0;
   14350:	00000513          	li	a0,0
   14354:	fd9ff06f          	j	1432c <quorem+0x1bc>

00014358 <_dtoa_r>:
  char *s, *s0;

  d.d = _d;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
   14358:	04052283          	lw	t0,64(a0)
	int mode _AND
	int ndigits _AND
	int *decpt _AND
	int *sign _AND
	char **rve)
{
   1435c:	f6010113          	addi	sp,sp,-160
   14360:	08812c23          	sw	s0,152(sp)
   14364:	09212823          	sw	s2,144(sp)
   14368:	09312623          	sw	s3,140(sp)
   1436c:	07712e23          	sw	s7,124(sp)
   14370:	07b12623          	sw	s11,108(sp)
   14374:	08112e23          	sw	ra,156(sp)
   14378:	08912a23          	sw	s1,148(sp)
   1437c:	09412423          	sw	s4,136(sp)
   14380:	09512223          	sw	s5,132(sp)
   14384:	09612023          	sw	s6,128(sp)
   14388:	07812c23          	sw	s8,120(sp)
   1438c:	07912a23          	sw	s9,116(sp)
   14390:	07a12823          	sw	s10,112(sp)
   14394:	00050413          	mv	s0,a0
   14398:	00070d93          	mv	s11,a4
   1439c:	00078b93          	mv	s7,a5
   143a0:	01012a23          	sw	a6,20(sp)
#endif
  _Bigint *b, *b1, *delta, *mlo = NULL, *mhi, *S;
  double ds;
  char *s, *s0;

  d.d = _d;
   143a4:	00060913          	mv	s2,a2
   143a8:	00068993          	mv	s3,a3

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
   143ac:	02028663          	beqz	t0,143d8 <_dtoa_r+0x80>
    {
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
   143b0:	04452703          	lw	a4,68(a0)
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
   143b4:	00100793          	li	a5,1
      Bfree (ptr, _REENT_MP_RESULT(ptr));
   143b8:	00028593          	mv	a1,t0

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
    {
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
   143bc:	00e797b3          	sll	a5,a5,a4
  d.d = _d;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
    {
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
   143c0:	00e2a223          	sw	a4,4(t0)
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
   143c4:	00f2a423          	sw	a5,8(t0)
      Bfree (ptr, _REENT_MP_RESULT(ptr));
   143c8:	01112423          	sw	a7,8(sp)
   143cc:	5bd020ef          	jal	17188 <_Bfree>
      _REENT_MP_RESULT(ptr) = 0;
   143d0:	00812883          	lw	a7,8(sp)
   143d4:	04042023          	sw	zero,64(s0)
    }

  if (word0 (d) & Sign_bit)
   143d8:	00098b13          	mv	s6,s3
   143dc:	0c09c863          	bltz	s3,144ac <_dtoa_r+0x154>
      /* set sign for everything, including 0's and NaNs */
      *sign = 1;
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
    }
  else
    *sign = 0;
   143e0:	0008a023          	sw	zero,0(a7)

#if defined(IEEE_Arith) + defined(VAX)
#ifdef IEEE_Arith
  if ((word0 (d) & Exp_mask) == Exp_mask)
   143e4:	7ff007b7          	lui	a5,0x7ff00
   143e8:	00fb7733          	and	a4,s6,a5
   143ec:	08f70063          	beq	a4,a5,1446c <_dtoa_r+0x114>
    }
#endif
#ifdef IBM
  d.d += 0;			/* normalize */
#endif
  if (!d.d)
   143f0:	00000613          	li	a2,0
   143f4:	00000693          	li	a3,0
   143f8:	00090513          	mv	a0,s2
   143fc:	00098593          	mv	a1,s3
   14400:	1e4070ef          	jal	1b5e4 <__eqdf2>
   14404:	0c051263          	bnez	a0,144c8 <_dtoa_r+0x170>
    {
      *decpt = 1;
   14408:	01412583          	lw	a1,20(sp)
      s = "0";
      if (rve)
   1440c:	0a012603          	lw	a2,160(sp)
#ifdef IBM
  d.d += 0;			/* normalize */
#endif
  if (!d.d)
    {
      *decpt = 1;
   14410:	00100793          	li	a5,1
   14414:	00f5a023          	sw	a5,0(a1)
      s = "0";
      if (rve)
   14418:	62060863          	beqz	a2,14a48 <_dtoa_r+0x6f0>
	*rve = s + 1;
   1441c:	0001d7b7          	lui	a5,0x1d
   14420:	d3178793          	addi	a5,a5,-719 # 1cd31 <__thenan_sf+0x51>
      return s;
   14424:	0001d537          	lui	a0,0x1d
  if (!d.d)
    {
      *decpt = 1;
      s = "0";
      if (rve)
	*rve = s + 1;
   14428:	00f62023          	sw	a5,0(a2)
      return s;
   1442c:	d3050513          	addi	a0,a0,-720 # 1cd30 <__thenan_sf+0x50>
  *s = 0;
  *decpt = k + 1;
  if (rve)
    *rve = s;
  return s0;
}
   14430:	09c12083          	lw	ra,156(sp)
   14434:	09812403          	lw	s0,152(sp)
   14438:	09412483          	lw	s1,148(sp)
   1443c:	09012903          	lw	s2,144(sp)
   14440:	08c12983          	lw	s3,140(sp)
   14444:	08812a03          	lw	s4,136(sp)
   14448:	08412a83          	lw	s5,132(sp)
   1444c:	08012b03          	lw	s6,128(sp)
   14450:	07c12b83          	lw	s7,124(sp)
   14454:	07812c03          	lw	s8,120(sp)
   14458:	07412c83          	lw	s9,116(sp)
   1445c:	07012d03          	lw	s10,112(sp)
   14460:	06c12d83          	lw	s11,108(sp)
   14464:	0a010113          	addi	sp,sp,160
   14468:	00008067          	ret
#else
  if (word0 (d) == 0x8000)
#endif
    {
      /* Infinity or NaN */
      *decpt = 9999;
   1446c:	01412583          	lw	a1,20(sp)
   14470:	000027b7          	lui	a5,0x2
   14474:	70f78793          	addi	a5,a5,1807 # 270f <_reset+0x250f>
   14478:	00f5a023          	sw	a5,0(a1)
      s =
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
   1447c:	56090663          	beqz	s2,149e8 <_dtoa_r+0x690>
   14480:	0001d537          	lui	a0,0x1d
   14484:	d4050513          	addi	a0,a0,-704 # 1cd40 <__thenan_sf+0x60>
#endif
	"NaN";
      if (rve)
   14488:	0a012683          	lw	a3,160(sp)
   1448c:	fa0682e3          	beqz	a3,14430 <_dtoa_r+0xd8>
	*rve =
#ifdef IEEE_Arith
	  s[3] ? s + 8 :
   14490:	00354703          	lbu	a4,3(a0)
   14494:	00350793          	addi	a5,a0,3
   14498:	00070463          	beqz	a4,144a0 <_dtoa_r+0x148>
   1449c:	00850793          	addi	a5,a0,8
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
#endif
	"NaN";
      if (rve)
	*rve =
   144a0:	0a012703          	lw	a4,160(sp)
   144a4:	00f72023          	sw	a5,0(a4)
   144a8:	f89ff06f          	j	14430 <_dtoa_r+0xd8>

  if (word0 (d) & Sign_bit)
    {
      /* set sign for everything, including 0's and NaNs */
      *sign = 1;
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
   144ac:	80000b37          	lui	s6,0x80000
   144b0:	fffb4b13          	not	s6,s6
   144b4:	013b7b33          	and	s6,s6,s3
    }

  if (word0 (d) & Sign_bit)
    {
      /* set sign for everything, including 0's and NaNs */
      *sign = 1;
   144b8:	00100793          	li	a5,1
   144bc:	00f8a023          	sw	a5,0(a7)
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
   144c0:	000b0993          	mv	s3,s6
   144c4:	f21ff06f          	j	143e4 <_dtoa_r+0x8c>
      if (rve)
	*rve = s + 1;
      return s;
    }

  b = d2b (ptr, d.d, &be, &bbits);
   144c8:	05810793          	addi	a5,sp,88
   144cc:	05c10713          	addi	a4,sp,92
   144d0:	00090613          	mv	a2,s2
   144d4:	00098693          	mv	a3,s3
   144d8:	00040513          	mv	a0,s0
   144dc:	0b9030ef          	jal	17d94 <__d2b>
#ifdef Sudden_Underflow
  i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1));
#else
  if ((i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1))) != 0)
   144e0:	014b5493          	srli	s1,s6,0x14
      if (rve)
	*rve = s + 1;
      return s;
    }

  b = d2b (ptr, d.d, &be, &bbits);
   144e4:	00a12e23          	sw	a0,28(sp)
#ifdef Sudden_Underflow
  i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1));
#else
  if ((i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1))) != 0)
   144e8:	50048a63          	beqz	s1,149fc <_dtoa_r+0x6a4>
    {
#endif
      d2.d = d.d;
      word0 (d2) &= Frac_mask1;
      word0 (d2) |= Exp_11;
   144ec:	001007b7          	lui	a5,0x100
   144f0:	fff78793          	addi	a5,a5,-1 # fffff <_gp+0xb781f>
   144f4:	05812c83          	lw	s9,88(sp)
   144f8:	00f9f7b3          	and	a5,s3,a5
   144fc:	3ff00737          	lui	a4,0x3ff00
  i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1));
#else
  if ((i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1))) != 0)
    {
#endif
      d2.d = d.d;
   14500:	00090513          	mv	a0,s2
      word0 (d2) &= Frac_mask1;
      word0 (d2) |= Exp_11;
   14504:	00e7e5b3          	or	a1,a5,a4
		 * Hence we adjust the constant term to 0.1760912590558.
		 * (We could get a more accurate k by invoking log10,
		 *  but this is probably not worthwhile.)
		 */

      i -= Bias;
   14508:	c0148493          	addi	s1,s1,-1023
#ifdef IBM
      i <<= 2;
      i += j;
#endif
#ifndef Sudden_Underflow
      denorm = 0;
   1450c:	04012423          	sw	zero,72(sp)
    }
#endif
#if defined (_DOUBLE_IS_32BITS)
  ds = (d2.d - 1.5) * 0.289529651 + 0.176091269 + i * 0.30103001;
#else
  ds = (d2.d - 1.5) * 0.289529654602168 + 0.1760912590558 + i * 0.301029995663981;
   14510:	8281a603          	lw	a2,-2008(gp) # 48008 <__wctomb+0x8>
   14514:	82c1a683          	lw	a3,-2004(gp) # 4800c <__wctomb+0xc>
   14518:	271060ef          	jal	1af88 <__subdf3>
   1451c:	8301a603          	lw	a2,-2000(gp) # 48010 <__wctomb+0x10>
   14520:	8341a683          	lw	a3,-1996(gp) # 48014 <__wctomb+0x14>
   14524:	2c1060ef          	jal	1afe4 <__muldf3>
   14528:	8381a603          	lw	a2,-1992(gp) # 48018 <__wctomb+0x18>
   1452c:	83c1a683          	lw	a3,-1988(gp) # 4801c <__wctomb+0x1c>
   14530:	209060ef          	jal	1af38 <__adddf3>
   14534:	00050a13          	mv	s4,a0
   14538:	00048513          	mv	a0,s1
   1453c:	00058a93          	mv	s5,a1
   14540:	0f8070ef          	jal	1b638 <__floatsidf>
   14544:	8401a603          	lw	a2,-1984(gp) # 48020 <__wctomb+0x20>
   14548:	8441a683          	lw	a3,-1980(gp) # 48024 <__wctomb+0x24>
   1454c:	299060ef          	jal	1afe4 <__muldf3>
   14550:	00050613          	mv	a2,a0
   14554:	00058693          	mv	a3,a1
   14558:	000a0513          	mv	a0,s4
   1455c:	000a8593          	mv	a1,s5
   14560:	1d9060ef          	jal	1af38 <__adddf3>
   14564:	00050a13          	mv	s4,a0
   14568:	00058a93          	mv	s5,a1
#endif
  k = (int) ds;
   1456c:	214070ef          	jal	1b780 <__fixdfsi>
   14570:	00a12823          	sw	a0,16(sp)
  if (ds < 0. && ds != k)
   14574:	00000613          	li	a2,0
   14578:	00000693          	li	a3,0
   1457c:	000a0513          	mv	a0,s4
   14580:	000a8593          	mv	a1,s5
   14584:	058070ef          	jal	1b5dc <__ltdf2>
   14588:	02054ae3          	bltz	a0,14dbc <_dtoa_r+0xa64>
    k--;			/* want k = floor(ds) */
  k_check = 1;
   1458c:	00100713          	li	a4,1
   14590:	02e12223          	sw	a4,36(sp)
  if (k >= 0 && k <= Ten_pmax)
   14594:	01012703          	lw	a4,16(sp)
   14598:	01600793          	li	a5,22
   1459c:	02e7ee63          	bltu	a5,a4,145d8 <_dtoa_r+0x280>
    {
      if (d.d < tens[k])
   145a0:	00371793          	slli	a5,a4,0x3
   145a4:	0001d737          	lui	a4,0x1d
   145a8:	a2870713          	addi	a4,a4,-1496 # 1ca28 <__mprec_tens>
   145ac:	00e787b3          	add	a5,a5,a4
   145b0:	0007a503          	lw	a0,0(a5)
   145b4:	0047a583          	lw	a1,4(a5)
   145b8:	00090613          	mv	a2,s2
   145bc:	00098693          	mv	a3,s3
   145c0:	7bd060ef          	jal	1b57c <__gtdf2>
   145c4:	04a058e3          	blez	a0,14e14 <_dtoa_r+0xabc>
	k--;
   145c8:	01012783          	lw	a5,16(sp)
      k_check = 0;
   145cc:	02012223          	sw	zero,36(sp)
    k--;			/* want k = floor(ds) */
  k_check = 1;
  if (k >= 0 && k <= Ten_pmax)
    {
      if (d.d < tens[k])
	k--;
   145d0:	fff78793          	addi	a5,a5,-1
   145d4:	00f12823          	sw	a5,16(sp)
      k_check = 0;
    }
  j = bbits - i - 1;
   145d8:	409c8cb3          	sub	s9,s9,s1
   145dc:	fffc8c93          	addi	s9,s9,-1
   145e0:	01912623          	sw	s9,12(sp)
  if (j >= 0)
    {
      b2 = 0;
   145e4:	00000a93          	li	s5,0
      if (d.d < tens[k])
	k--;
      k_check = 0;
    }
  j = bbits - i - 1;
  if (j >= 0)
   145e8:	000cc2e3          	bltz	s9,14dec <_dtoa_r+0xa94>
  else
    {
      b2 = -j;
      s2 = 0;
    }
  if (k >= 0)
   145ec:	01012703          	lw	a4,16(sp)
   145f0:	7a074c63          	bltz	a4,14da8 <_dtoa_r+0xa50>
    {
      b5 = 0;
      s5 = k;
      s2 += k;
   145f4:	00c12783          	lw	a5,12(sp)
   145f8:	02e12423          	sw	a4,40(sp)
      b2 = -j;
      s2 = 0;
    }
  if (k >= 0)
    {
      b5 = 0;
   145fc:	00000b13          	li	s6,0
      s5 = k;
      s2 += k;
   14600:	00e787b3          	add	a5,a5,a4
   14604:	00f12623          	sw	a5,12(sp)
    {
      b2 -= k;
      b5 = -k;
      s5 = 0;
    }
  if (mode < 0 || mode > 9)
   14608:	00900793          	li	a5,9
   1460c:	45b7e463          	bltu	a5,s11,14a54 <_dtoa_r+0x6fc>
    mode = 0;
  try_quick = 1;
  if (mode > 5)
   14610:	00500793          	li	a5,5
      b5 = -k;
      s5 = 0;
    }
  if (mode < 0 || mode > 9)
    mode = 0;
  try_quick = 1;
   14614:	00100a13          	li	s4,1
  if (mode > 5)
   14618:	01b7d663          	ble	s11,a5,14624 <_dtoa_r+0x2cc>
    {
      mode -= 4;
   1461c:	ffcd8d93          	addi	s11,s11,-4
      try_quick = 0;
   14620:	00000a13          	li	s4,0
    }
  leftright = 1;
  ilim = ilim1 = -1;
  switch (mode)
   14624:	00300793          	li	a5,3
   14628:	50fd8ae3          	beq	s11,a5,1533c <_dtoa_r+0xfe4>
   1462c:	47b7dce3          	ble	s11,a5,152a4 <_dtoa_r+0xf4c>
   14630:	00400793          	li	a5,4
   14634:	32fd84e3          	beq	s11,a5,1515c <_dtoa_r+0xe04>
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   14638:	00100713          	li	a4,1
  ilim = ilim1 = -1;
  switch (mode)
   1463c:	00500793          	li	a5,5
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   14640:	02e12023          	sw	a4,32(sp)
  ilim = ilim1 = -1;
  switch (mode)
   14644:	46fd96e3          	bne	s11,a5,152b0 <_dtoa_r+0xf58>
      break;
    case 3:
      leftright = 0;
      /* no break */
    case 5:
      i = ndigits + k + 1;
   14648:	01012703          	lw	a4,16(sp)
   1464c:	01770733          	add	a4,a4,s7
   14650:	00170793          	addi	a5,a4,1
   14654:	02e12623          	sw	a4,44(sp)
   14658:	00f12c23          	sw	a5,24(sp)
   1465c:	00078613          	mv	a2,a5
      ilim = i;
      ilim1 = i - 1;
      if (i <= 0)
   14660:	00078493          	mv	s1,a5
   14664:	42f05ae3          	blez	a5,15298 <_dtoa_r+0xf40>
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   14668:	01700793          	li	a5,23
   1466c:	04042223          	sw	zero,68(s0)
   14670:	00000593          	li	a1,0
   14674:	02c7f263          	bleu	a2,a5,14698 <_dtoa_r+0x340>
   14678:	00100713          	li	a4,1
   1467c:	00400793          	li	a5,4
       j <<= 1)
   14680:	00179793          	slli	a5,a5,0x1
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   14684:	01478693          	addi	a3,a5,20
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
   14688:	00070593          	mv	a1,a4
   1468c:	00170713          	addi	a4,a4,1
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   14690:	fed678e3          	bleu	a3,a2,14680 <_dtoa_r+0x328>
   14694:	04b42223          	sw	a1,68(s0)
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   14698:	00040513          	mv	a0,s0
   1469c:	249020ef          	jal	170e4 <_Balloc>
  s = s0 = (char *) _REENT_MP_RESULT(ptr);

  if (ilim >= 0 && ilim <= Quick_max && try_quick)
   146a0:	00e00793          	li	a5,14
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   146a4:	00050d13          	mv	s10,a0
   146a8:	04a42023          	sw	a0,64(s0)
  s = s0 = (char *) _REENT_MP_RESULT(ptr);

  if (ilim >= 0 && ilim <= Quick_max && try_quick)
   146ac:	3c97ee63          	bltu	a5,s1,14a88 <_dtoa_r+0x730>
   146b0:	3c0a0c63          	beqz	s4,14a88 <_dtoa_r+0x730>
      i = 0;
      d2.d = d.d;
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
      if (k > 0)
   146b4:	01012703          	lw	a4,16(sp)
  if (ilim >= 0 && ilim <= Quick_max && try_quick)
    {
      /* Try to get by with floating-point arithmetic. */

      i = 0;
      d2.d = d.d;
   146b8:	03212823          	sw	s2,48(sp)
   146bc:	03312a23          	sw	s3,52(sp)
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
      if (k > 0)
   146c0:	58e056e3          	blez	a4,1544c <_dtoa_r+0x10f4>
	{
	  ds = tens[k & 0xf];
   146c4:	00f77793          	andi	a5,a4,15
   146c8:	00379713          	slli	a4,a5,0x3
	  j = k >> 4;
   146cc:	01012783          	lw	a5,16(sp)

      i = 0;
      d2.d = d.d;
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
   146d0:	00200493          	li	s1,2
      if (k > 0)
	{
	  ds = tens[k & 0xf];
	  j = k >> 4;
   146d4:	4047da13          	srai	s4,a5,0x4
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
      if (k > 0)
	{
	  ds = tens[k & 0xf];
   146d8:	0001d7b7          	lui	a5,0x1d
   146dc:	a2878793          	addi	a5,a5,-1496 # 1ca28 <__mprec_tens>
   146e0:	00f707b3          	add	a5,a4,a5
	  j = k >> 4;
	  if (j & Bletch)
   146e4:	010a7693          	andi	a3,s4,16
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
      if (k > 0)
	{
	  ds = tens[k & 0xf];
   146e8:	0007a703          	lw	a4,0(a5)
   146ec:	0047a783          	lw	a5,4(a5)
	  j = k >> 4;
	  if (j & Bletch)
   146f0:	02068e63          	beqz	a3,1472c <_dtoa_r+0x3d4>
	    {
	      /* prevent overflows */
	      j &= Bletch - 1;
	      d.d /= bigtens[n_bigtens - 1];
   146f4:	0001d6b7          	lui	a3,0x1d
   146f8:	b386a603          	lw	a2,-1224(a3) # 1cb38 <__mprec_bigtens+0x20>
   146fc:	b3c6a683          	lw	a3,-1220(a3)
   14700:	00090513          	mv	a0,s2
   14704:	00098593          	mv	a1,s3
   14708:	00e12423          	sw	a4,8(sp)
   1470c:	00f12223          	sw	a5,4(sp)
   14710:	339060ef          	jal	1b248 <__divdf3>
	      ieps++;
   14714:	00412783          	lw	a5,4(sp)
   14718:	00812703          	lw	a4,8(sp)
	  ds = tens[k & 0xf];
	  j = k >> 4;
	  if (j & Bletch)
	    {
	      /* prevent overflows */
	      j &= Bletch - 1;
   1471c:	00fa7a13          	andi	s4,s4,15
	      d.d /= bigtens[n_bigtens - 1];
   14720:	00050913          	mv	s2,a0
   14724:	00058993          	mv	s3,a1
	      ieps++;
   14728:	00300493          	li	s1,3
	    }
	  for (; j; j >>= 1, i++)
   1472c:	040a0063          	beqz	s4,1476c <_dtoa_r+0x414>
   14730:	0001dc37          	lui	s8,0x1d
   14734:	b18c0c13          	addi	s8,s8,-1256 # 1cb18 <__mprec_bigtens>
	    if (j & 1)
   14738:	001a7693          	andi	a3,s4,1
	      {
		ieps++;
		ds *= bigtens[i];
   1473c:	00070513          	mv	a0,a4
	      /* prevent overflows */
	      j &= Bletch - 1;
	      d.d /= bigtens[n_bigtens - 1];
	      ieps++;
	    }
	  for (; j; j >>= 1, i++)
   14740:	401a5a13          	srai	s4,s4,0x1
	    if (j & 1)
	      {
		ieps++;
		ds *= bigtens[i];
   14744:	00078593          	mv	a1,a5
	      j &= Bletch - 1;
	      d.d /= bigtens[n_bigtens - 1];
	      ieps++;
	    }
	  for (; j; j >>= 1, i++)
	    if (j & 1)
   14748:	00068e63          	beqz	a3,14764 <_dtoa_r+0x40c>
	      {
		ieps++;
		ds *= bigtens[i];
   1474c:	000c2603          	lw	a2,0(s8)
   14750:	004c2683          	lw	a3,4(s8)
	      ieps++;
	    }
	  for (; j; j >>= 1, i++)
	    if (j & 1)
	      {
		ieps++;
   14754:	00148493          	addi	s1,s1,1
		ds *= bigtens[i];
   14758:	08d060ef          	jal	1afe4 <__muldf3>
   1475c:	00050713          	mv	a4,a0
   14760:	00058793          	mv	a5,a1
   14764:	008c0c13          	addi	s8,s8,8
	      /* prevent overflows */
	      j &= Bletch - 1;
	      d.d /= bigtens[n_bigtens - 1];
	      ieps++;
	    }
	  for (; j; j >>= 1, i++)
   14768:	fc0a18e3          	bnez	s4,14738 <_dtoa_r+0x3e0>
	    if (j & 1)
	      {
		ieps++;
		ds *= bigtens[i];
	      }
	  d.d /= ds;
   1476c:	00090513          	mv	a0,s2
   14770:	00098593          	mv	a1,s3
   14774:	00070613          	mv	a2,a4
   14778:	00078693          	mv	a3,a5
   1477c:	2cd060ef          	jal	1b248 <__divdf3>
   14780:	00050913          	mv	s2,a0
   14784:	00058993          	mv	s3,a1
	      {
		ieps++;
		d.d *= bigtens[i];
	      }
	}
      if (k_check && d.d < 1. && ilim > 0)
   14788:	02412783          	lw	a5,36(sp)
   1478c:	02078063          	beqz	a5,147ac <_dtoa_r+0x454>
   14790:	8481a603          	lw	a2,-1976(gp) # 48028 <__wctomb+0x28>
   14794:	84c1a683          	lw	a3,-1972(gp) # 4802c <__wctomb+0x2c>
   14798:	00090513          	mv	a0,s2
   1479c:	00098593          	mv	a1,s3
   147a0:	63d060ef          	jal	1b5dc <__ltdf2>
   147a4:	00055463          	bgez	a0,147ac <_dtoa_r+0x454>
   147a8:	7650006f          	j	1570c <_dtoa_r+0x13b4>
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   147ac:	00048513          	mv	a0,s1
   147b0:	689060ef          	jal	1b638 <__floatsidf>
   147b4:	00090613          	mv	a2,s2
   147b8:	00098693          	mv	a3,s3
   147bc:	029060ef          	jal	1afe4 <__muldf3>
   147c0:	85c1a683          	lw	a3,-1956(gp) # 4803c <__wctomb+0x3c>
   147c4:	8581a603          	lw	a2,-1960(gp) # 48038 <__wctomb+0x38>
   147c8:	770060ef          	jal	1af38 <__adddf3>
      word0 (eps) -= (P - 1) * Exp_msk1;
   147cc:	fcc006b7          	lui	a3,0xfcc00
   147d0:	00b687b3          	add	a5,a3,a1
      if (ilim == 0)
   147d4:	01812583          	lw	a1,24(sp)
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   147d8:	00050713          	mv	a4,a0
      word0 (eps) -= (P - 1) * Exp_msk1;
      if (ilim == 0)
   147dc:	3a0586e3          	beqz	a1,15388 <_dtoa_r+0x1030>
   147e0:	01012603          	lw	a2,16(sp)
   147e4:	01812483          	lw	s1,24(sp)
   147e8:	04c12623          	sw	a2,76(sp)
	  if (d.d < -eps.d)
	    goto no_digits;
	  goto fast_failed;
	}
#ifndef No_leftright
      if (leftright)
   147ec:	02012683          	lw	a3,32(sp)
   147f0:	54068ae3          	beqz	a3,15544 <_dtoa_r+0x11ec>
	{
	  /* Use Steele & White method of only
	   * generating digits needed.
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
   147f4:	fff48693          	addi	a3,s1,-1
   147f8:	00369613          	slli	a2,a3,0x3
   147fc:	0001d6b7          	lui	a3,0x1d
   14800:	a2868693          	addi	a3,a3,-1496 # 1ca28 <__mprec_tens>
   14804:	00d606b3          	add	a3,a2,a3
   14808:	0006a603          	lw	a2,0(a3)
   1480c:	8681a503          	lw	a0,-1944(gp) # 48048 <__wctomb+0x48>
   14810:	0046a683          	lw	a3,4(a3)
   14814:	86c1a583          	lw	a1,-1940(gp) # 4804c <__wctomb+0x4c>
   14818:	00e12423          	sw	a4,8(sp)
   1481c:	00f12223          	sw	a5,4(sp)
   14820:	229060ef          	jal	1b248 <__divdf3>
   14824:	00812703          	lw	a4,8(sp)
   14828:	00412783          	lw	a5,4(sp)
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
   1482c:	001d0c93          	addi	s9,s10,1
      if (leftright)
	{
	  /* Use Steele & White method of only
	   * generating digits needed.
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
   14830:	00070613          	mv	a2,a4
   14834:	00078693          	mv	a3,a5
   14838:	750060ef          	jal	1af88 <__subdf3>
   1483c:	02a12c23          	sw	a0,56(sp)
   14840:	02b12e23          	sw	a1,60(sp)
	  for (i = 0;;)
	    {
	      L = d.d;
   14844:	00090513          	mv	a0,s2
   14848:	00098593          	mv	a1,s3
   1484c:	735060ef          	jal	1b780 <__fixdfsi>
   14850:	00050a13          	mv	s4,a0
	      d.d -= L;
   14854:	5e5060ef          	jal	1b638 <__floatsidf>
   14858:	00050613          	mv	a2,a0
   1485c:	00058693          	mv	a3,a1
   14860:	00090513          	mv	a0,s2
   14864:	00098593          	mv	a1,s3
   14868:	720060ef          	jal	1af88 <__subdf3>
   1486c:	00050913          	mv	s2,a0
   14870:	00058993          	mv	s3,a1
	      *s++ = '0' + (int) L;
   14874:	030a0a13          	addi	s4,s4,48
	      if (d.d < eps.d)
   14878:	00050613          	mv	a2,a0
   1487c:	00058693          	mv	a3,a1
   14880:	03812503          	lw	a0,56(sp)
   14884:	03c12583          	lw	a1,60(sp)
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
   14888:	0ffa7a13          	andi	s4,s4,255
   1488c:	014d0023          	sb	s4,0(s10)
	      if (d.d < eps.d)
   14890:	4ed060ef          	jal	1b57c <__gtdf2>
   14894:	00a05463          	blez	a0,1489c <_dtoa_r+0x544>
   14898:	72d0006f          	j	157c4 <_dtoa_r+0x146c>
		goto ret1;
	      if (1. - d.d < eps.d)
   1489c:	8481a503          	lw	a0,-1976(gp) # 48028 <__wctomb+0x28>
   148a0:	84c1a583          	lw	a1,-1972(gp) # 4802c <__wctomb+0x2c>
   148a4:	00090613          	mv	a2,s2
   148a8:	00098693          	mv	a3,s3
   148ac:	00f12223          	sw	a5,4(sp)
   148b0:	6d8060ef          	jal	1af88 <__subdf3>
   148b4:	00050613          	mv	a2,a0
   148b8:	00058693          	mv	a3,a1
   148bc:	03812503          	lw	a0,56(sp)
   148c0:	03c12583          	lw	a1,60(sp)
   148c4:	4b9060ef          	jal	1b57c <__gtdf2>
   148c8:	00a05463          	blez	a0,148d0 <_dtoa_r+0x578>
   148cc:	7610006f          	j	1582c <_dtoa_r+0x14d4>
		goto bump_up;
	      if (++i >= ilim)
   148d0:	00100713          	li	a4,1
   148d4:	369756e3          	ble	s1,a4,15440 <_dtoa_r+0x10e8>
		break;
	      eps.d *= 10.;
	      d.d *= 10.;
   148d8:	05512023          	sw	s5,64(sp)
   148dc:	009d04b3          	add	s1,s10,s1
   148e0:	000c8a93          	mv	s5,s9
   148e4:	03812c03          	lw	s8,56(sp)
   148e8:	03c12c83          	lw	s9,60(sp)
   148ec:	02c0006f          	j	14918 <_dtoa_r+0x5c0>
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
	      if (d.d < eps.d)
		goto ret1;
	      if (1. - d.d < eps.d)
   148f0:	84818713          	addi	a4,gp,-1976 # 48028 <__wctomb+0x28>
   148f4:	00072503          	lw	a0,0(a4)
   148f8:	00472583          	lw	a1,4(a4)
   148fc:	68c060ef          	jal	1af88 <__subdf3>
   14900:	000c0613          	mv	a2,s8
   14904:	000c8693          	mv	a3,s9
   14908:	4d5060ef          	jal	1b5dc <__ltdf2>
   1490c:	00055463          	bgez	a0,14914 <_dtoa_r+0x5bc>
   14910:	6c10006f          	j	157d0 <_dtoa_r+0x1478>
		goto bump_up;
	      if (++i >= ilim)
   14914:	329a84e3          	beq	s5,s1,1543c <_dtoa_r+0x10e4>
		break;
	      eps.d *= 10.;
   14918:	85018793          	addi	a5,gp,-1968 # 48030 <__wctomb+0x30>
   1491c:	0007a603          	lw	a2,0(a5)
   14920:	0047a683          	lw	a3,4(a5)
   14924:	000c0513          	mv	a0,s8
   14928:	000c8593          	mv	a1,s9
   1492c:	6b8060ef          	jal	1afe4 <__muldf3>
   14930:	00058c93          	mv	s9,a1
	      d.d *= 10.;
   14934:	85018593          	addi	a1,gp,-1968 # 48030 <__wctomb+0x30>
   14938:	0005a603          	lw	a2,0(a1)
   1493c:	0045a683          	lw	a3,4(a1)
		goto ret1;
	      if (1. - d.d < eps.d)
		goto bump_up;
	      if (++i >= ilim)
		break;
	      eps.d *= 10.;
   14940:	00050c13          	mv	s8,a0
	      d.d *= 10.;
   14944:	00098593          	mv	a1,s3
   14948:	00090513          	mv	a0,s2
   1494c:	698060ef          	jal	1afe4 <__muldf3>
   14950:	00058993          	mv	s3,a1
   14954:	00050913          	mv	s2,a0
	   * generating digits needed.
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
	  for (i = 0;;)
	    {
	      L = d.d;
   14958:	629060ef          	jal	1b780 <__fixdfsi>
   1495c:	00050a13          	mv	s4,a0
	      d.d -= L;
   14960:	4d9060ef          	jal	1b638 <__floatsidf>
   14964:	00050613          	mv	a2,a0
   14968:	00058693          	mv	a3,a1
   1496c:	00090513          	mv	a0,s2
   14970:	00098593          	mv	a1,s3
   14974:	614060ef          	jal	1af88 <__subdf3>
	      *s++ = '0' + (int) L;
   14978:	030a0793          	addi	a5,s4,48
   1497c:	0ff7fa13          	andi	s4,a5,255
   14980:	001a8a93          	addi	s5,s5,1
	      if (d.d < eps.d)
   14984:	000c0613          	mv	a2,s8
   14988:	000c8693          	mv	a3,s9
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
   1498c:	ff4a8fa3          	sb	s4,-1(s5)
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
   14990:	00050913          	mv	s2,a0
   14994:	00058993          	mv	s3,a1
	      *s++ = '0' + (int) L;
	      if (d.d < eps.d)
   14998:	445060ef          	jal	1b5dc <__ltdf2>
		goto ret1;
	      if (1. - d.d < eps.d)
   1499c:	00090613          	mv	a2,s2
   149a0:	00098693          	mv	a3,s3
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
	      if (d.d < eps.d)
   149a4:	f40556e3          	bgez	a0,148f0 <_dtoa_r+0x598>
   149a8:	04c12703          	lw	a4,76(sp)
   149ac:	000a8c93          	mv	s9,s5
   149b0:	00e12823          	sw	a4,16(sp)
      if (mlo && mlo != mhi)
	Bfree (ptr, mlo);
      Bfree (ptr, mhi);
    }
ret1:
  Bfree (ptr, b);
   149b4:	01c12583          	lw	a1,28(sp)
   149b8:	00040513          	mv	a0,s0
   149bc:	7cc020ef          	jal	17188 <_Bfree>
  *s = 0;
  *decpt = k + 1;
   149c0:	01012703          	lw	a4,16(sp)
   149c4:	01412583          	lw	a1,20(sp)
  if (rve)
   149c8:	0a012603          	lw	a2,160(sp)
      Bfree (ptr, mhi);
    }
ret1:
  Bfree (ptr, b);
  *s = 0;
  *decpt = k + 1;
   149cc:	00170793          	addi	a5,a4,1
	Bfree (ptr, mlo);
      Bfree (ptr, mhi);
    }
ret1:
  Bfree (ptr, b);
  *s = 0;
   149d0:	000c8023          	sb	zero,0(s9)
  *decpt = k + 1;
   149d4:	00f5a023          	sw	a5,0(a1)
  if (rve)
   149d8:	22060ae3          	beqz	a2,1540c <_dtoa_r+0x10b4>
    *rve = s;
   149dc:	01962023          	sw	s9,0(a2)
   149e0:	000d0513          	mv	a0,s10
   149e4:	a4dff06f          	j	14430 <_dtoa_r+0xd8>
    {
      /* Infinity or NaN */
      *decpt = 9999;
      s =
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
   149e8:	00cb1613          	slli	a2,s6,0xc
   149ec:	a8061ae3          	bnez	a2,14480 <_dtoa_r+0x128>
   149f0:	0001d537          	lui	a0,0x1d
   149f4:	d3450513          	addi	a0,a0,-716 # 1cd34 <__thenan_sf+0x54>
   149f8:	a91ff06f          	j	14488 <_dtoa_r+0x130>
    }
  else
    {
      /* d is denormalized */

      i = bbits + be + (Bias + (P - 1) - 1);
   149fc:	05812c83          	lw	s9,88(sp)
   14a00:	05c12483          	lw	s1,92(sp)
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
       : (word1 (d) << (32 - i));
   14a04:	02000793          	li	a5,32
    }
  else
    {
      /* d is denormalized */

      i = bbits + be + (Bias + (P - 1) - 1);
   14a08:	009c84b3          	add	s1,s9,s1
   14a0c:	43248713          	addi	a4,s1,1074
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
       : (word1 (d) << (32 - i));
   14a10:	3ee7dc63          	ble	a4,a5,14e08 <_dtoa_r+0xab0>
   14a14:	04000793          	li	a5,64
   14a18:	41248513          	addi	a0,s1,1042
   14a1c:	40e78733          	sub	a4,a5,a4
   14a20:	00a95533          	srl	a0,s2,a0
   14a24:	00eb1b33          	sll	s6,s6,a4
   14a28:	01656533          	or	a0,a0,s6
#endif
      d2.d = x;
   14a2c:	4cd060ef          	jal	1b6f8 <__floatunsidf>
      word0 (d2) -= 31 * Exp_msk1;	/* adjust exponent */
   14a30:	fe1007b7          	lui	a5,0xfe100
      i -= (Bias + (P - 1) - 1) + 1;
      denorm = 1;
   14a34:	00100713          	li	a4,1
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
       : (word1 (d) << (32 - i));
#endif
      d2.d = x;
      word0 (d2) -= 31 * Exp_msk1;	/* adjust exponent */
   14a38:	00b785b3          	add	a1,a5,a1
      i -= (Bias + (P - 1) - 1) + 1;
   14a3c:	fff48493          	addi	s1,s1,-1
      denorm = 1;
   14a40:	04e12423          	sw	a4,72(sp)
   14a44:	acdff06f          	j	14510 <_dtoa_r+0x1b8>
    {
      *decpt = 1;
      s = "0";
      if (rve)
	*rve = s + 1;
      return s;
   14a48:	0001d537          	lui	a0,0x1d
   14a4c:	d3050513          	addi	a0,a0,-720 # 1cd30 <__thenan_sf+0x50>
   14a50:	9e1ff06f          	j	14430 <_dtoa_r+0xd8>
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   14a54:	04042223          	sw	zero,68(s0)
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   14a58:	00000593          	li	a1,0
   14a5c:	00040513          	mv	a0,s0
   14a60:	684020ef          	jal	170e4 <_Balloc>
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   14a64:	fff00713          	li	a4,-1
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   14a68:	00100793          	li	a5,1
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   14a6c:	00050d13          	mv	s10,a0
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   14a70:	00e12c23          	sw	a4,24(sp)
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   14a74:	04a42023          	sw	a0,64(s0)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   14a78:	02e12623          	sw	a4,44(sp)
  switch (mode)
    {
    case 0:
    case 1:
      i = 18;
      ndigits = 0;
   14a7c:	00000b93          	li	s7,0
      b2 -= k;
      b5 = -k;
      s5 = 0;
    }
  if (mode < 0 || mode > 9)
    mode = 0;
   14a80:	00000d93          	li	s11,0
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   14a84:	02f12023          	sw	a5,32(sp)
      ilim = ilim0;
    }

  /* Do we have a "small" integer? */

  if (be >= 0 && k <= Int_max)
   14a88:	05c12783          	lw	a5,92(sp)
   14a8c:	1c07c463          	bltz	a5,14c54 <_dtoa_r+0x8fc>
   14a90:	01012683          	lw	a3,16(sp)
   14a94:	00e00713          	li	a4,14
   14a98:	1ad74e63          	blt	a4,a3,14c54 <_dtoa_r+0x8fc>
    {
      /* Yes. */
      ds = tens[k];
   14a9c:	0001d737          	lui	a4,0x1d
   14aa0:	00369793          	slli	a5,a3,0x3
   14aa4:	a2870713          	addi	a4,a4,-1496 # 1ca28 <__mprec_tens>
   14aa8:	00e787b3          	add	a5,a5,a4
   14aac:	0007aa03          	lw	s4,0(a5) # fe100000 <_gp+0xfe0b7820>
   14ab0:	0047aa83          	lw	s5,4(a5)
      if (ndigits < 0 && ilim <= 0)
   14ab4:	6c0bc463          	bltz	s7,1517c <_dtoa_r+0xe24>
	    goto no_digits;
	  goto one_digit;
	}
      for (i = 1;; i++)
	{
	  L = d.d / ds;
   14ab8:	000a0613          	mv	a2,s4
   14abc:	000a8693          	mv	a3,s5
   14ac0:	00090513          	mv	a0,s2
   14ac4:	00098593          	mv	a1,s3
   14ac8:	780060ef          	jal	1b248 <__divdf3>
   14acc:	4b5060ef          	jal	1b780 <__fixdfsi>
   14ad0:	00050c13          	mv	s8,a0
	  d.d -= L * ds;
   14ad4:	365060ef          	jal	1b638 <__floatsidf>
   14ad8:	000a0613          	mv	a2,s4
   14adc:	000a8693          	mv	a3,s5
   14ae0:	504060ef          	jal	1afe4 <__muldf3>
   14ae4:	00050613          	mv	a2,a0
   14ae8:	00058693          	mv	a3,a1
   14aec:	00090513          	mv	a0,s2
   14af0:	00098593          	mv	a1,s3
   14af4:	494060ef          	jal	1af88 <__subdf3>
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
	  if (i == ilim)
   14af8:	01812603          	lw	a2,24(sp)
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
   14afc:	030c0693          	addi	a3,s8,48
   14b00:	00dd0023          	sb	a3,0(s10)
	  if (i == ilim)
   14b04:	00100693          	li	a3,1
	  goto one_digit;
	}
      for (i = 1;; i++)
	{
	  L = d.d / ds;
	  d.d -= L * ds;
   14b08:	00050713          	mv	a4,a0
   14b0c:	00058793          	mv	a5,a1
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
   14b10:	001d0c93          	addi	s9,s10,1
	  if (i == ilim)
   14b14:	0cd60063          	beq	a2,a3,14bd4 <_dtoa_r+0x87c>
		      }
		  ++*s++;
		}
	      break;
	    }
	  if (!(d.d *= 10.))
   14b18:	8501a603          	lw	a2,-1968(gp) # 48030 <__wctomb+0x30>
   14b1c:	8541a683          	lw	a3,-1964(gp) # 48034 <__wctomb+0x34>
   14b20:	4c4060ef          	jal	1afe4 <__muldf3>
   14b24:	00000613          	li	a2,0
   14b28:	00000693          	li	a3,0
   14b2c:	00050913          	mv	s2,a0
   14b30:	00058993          	mv	s3,a1
   14b34:	2b1060ef          	jal	1b5e4 <__eqdf2>
   14b38:	e6050ee3          	beqz	a0,149b4 <_dtoa_r+0x65c>
   14b3c:	01812783          	lw	a5,24(sp)
   14b40:	8501ab03          	lw	s6,-1968(gp) # 48030 <__wctomb+0x30>
   14b44:	8541ab83          	lw	s7,-1964(gp) # 48034 <__wctomb+0x34>
   14b48:	002d0493          	addi	s1,s10,2
   14b4c:	00fd0db3          	add	s11,s10,a5
   14b50:	0240006f          	j	14b74 <_dtoa_r+0x81c>
   14b54:	490060ef          	jal	1afe4 <__muldf3>
   14b58:	00000613          	li	a2,0
   14b5c:	00000693          	li	a3,0
   14b60:	00050913          	mv	s2,a0
   14b64:	00058993          	mv	s3,a1
   14b68:	00148493          	addi	s1,s1,1
   14b6c:	279060ef          	jal	1b5e4 <__eqdf2>
   14b70:	e40502e3          	beqz	a0,149b4 <_dtoa_r+0x65c>
	    goto no_digits;
	  goto one_digit;
	}
      for (i = 1;; i++)
	{
	  L = d.d / ds;
   14b74:	000a0613          	mv	a2,s4
   14b78:	000a8693          	mv	a3,s5
   14b7c:	00090513          	mv	a0,s2
   14b80:	00098593          	mv	a1,s3
   14b84:	6c4060ef          	jal	1b248 <__divdf3>
   14b88:	3f9060ef          	jal	1b780 <__fixdfsi>
   14b8c:	00050c13          	mv	s8,a0
	  d.d -= L * ds;
   14b90:	2a9060ef          	jal	1b638 <__floatsidf>
   14b94:	000a0613          	mv	a2,s4
   14b98:	000a8693          	mv	a3,s5
   14b9c:	448060ef          	jal	1afe4 <__muldf3>
   14ba0:	00050613          	mv	a2,a0
   14ba4:	00058693          	mv	a3,a1
   14ba8:	00090513          	mv	a0,s2
   14bac:	00098593          	mv	a1,s3
   14bb0:	3d8060ef          	jal	1af88 <__subdf3>
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
   14bb4:	030c0813          	addi	a6,s8,48
	  goto one_digit;
	}
      for (i = 1;; i++)
	{
	  L = d.d / ds;
	  d.d -= L * ds;
   14bb8:	00050713          	mv	a4,a0
   14bbc:	00058793          	mv	a5,a1
		      }
		  ++*s++;
		}
	      break;
	    }
	  if (!(d.d *= 10.))
   14bc0:	000b0613          	mv	a2,s6
   14bc4:	000b8693          	mv	a3,s7
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
   14bc8:	ff048fa3          	sb	a6,-1(s1)
   14bcc:	00048c93          	mv	s9,s1
	  if (i == ilim)
   14bd0:	f89d92e3          	bne	s11,s1,14b54 <_dtoa_r+0x7fc>
	    {
	      d.d += d.d;
   14bd4:	00070613          	mv	a2,a4
   14bd8:	00078693          	mv	a3,a5
   14bdc:	00070513          	mv	a0,a4
   14be0:	00078593          	mv	a1,a5
   14be4:	354060ef          	jal	1af38 <__adddf3>
   14be8:	00050913          	mv	s2,a0
   14bec:	00058993          	mv	s3,a1
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
   14bf0:	00050613          	mv	a2,a0
   14bf4:	00058693          	mv	a3,a1
   14bf8:	000a0513          	mv	a0,s4
   14bfc:	000a8593          	mv	a1,s5
   14c00:	1dd060ef          	jal	1b5dc <__ltdf2>
   14c04:	02054263          	bltz	a0,14c28 <_dtoa_r+0x8d0>
   14c08:	00090613          	mv	a2,s2
   14c0c:	00098693          	mv	a3,s3
   14c10:	000a0513          	mv	a0,s4
   14c14:	000a8593          	mv	a1,s5
   14c18:	1cd060ef          	jal	1b5e4 <__eqdf2>
   14c1c:	d8051ce3          	bnez	a0,149b4 <_dtoa_r+0x65c>
   14c20:	001c7c13          	andi	s8,s8,1
   14c24:	d80c08e3          	beqz	s8,149b4 <_dtoa_r+0x65c>
   14c28:	fffcca03          	lbu	s4,-1(s9)
		{
		bump_up:
		  while (*--s == '9')
   14c2c:	03900713          	li	a4,57
   14c30:	0100006f          	j	14c40 <_dtoa_r+0x8e8>
		    if (s == s0)
   14c34:	0ba784e3          	beq	a5,s10,154dc <_dtoa_r+0x1184>
   14c38:	fff7ca03          	lbu	s4,-1(a5)
   14c3c:	00078c93          	mv	s9,a5
	    {
	      d.d += d.d;
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
		{
		bump_up:
		  while (*--s == '9')
   14c40:	fffc8793          	addi	a5,s9,-1
   14c44:	feea08e3          	beq	s4,a4,14c34 <_dtoa_r+0x8dc>
		      {
			k++;
			*s = '0';
			break;
		      }
		  ++*s++;
   14c48:	001a0a13          	addi	s4,s4,1
   14c4c:	01478023          	sb	s4,0(a5)
   14c50:	d65ff06f          	j	149b4 <_dtoa_r+0x65c>
    }

  m2 = b2;
  m5 = b5;
  mhi = mlo = 0;
  if (leftright)
   14c54:	02012703          	lw	a4,32(sp)
   14c58:	1a070063          	beqz	a4,14df8 <_dtoa_r+0xaa0>
    {
      if (mode < 2)
   14c5c:	00100713          	li	a4,1
   14c60:	57b75a63          	ble	s11,a4,151d4 <_dtoa_r+0xe7c>
	    1 + P - bbits;
#endif
	}
      else
	{
	  j = ilim - 1;
   14c64:	01812703          	lw	a4,24(sp)
   14c68:	fff70793          	addi	a5,a4,-1
	  if (m5 >= j)
	    m5 -= j;
   14c6c:	40fb0cb3          	sub	s9,s6,a5
#endif
	}
      else
	{
	  j = ilim - 1;
	  if (m5 >= j)
   14c70:	00fb5e63          	ble	a5,s6,14c8c <_dtoa_r+0x934>
	    m5 -= j;
	  else
	    {
	      s5 += j -= m5;
   14c74:	02812583          	lw	a1,40(sp)
   14c78:	41678733          	sub	a4,a5,s6
	      b5 += j;
	      m5 = 0;
   14c7c:	00000c93          	li	s9,0
	  j = ilim - 1;
	  if (m5 >= j)
	    m5 -= j;
	  else
	    {
	      s5 += j -= m5;
   14c80:	00e585b3          	add	a1,a1,a4
   14c84:	02b12423          	sw	a1,40(sp)
   14c88:	00078b13          	mv	s6,a5
	      b5 += j;
	      m5 = 0;
	    }
	  if ((i = ilim) < 0)
   14c8c:	01812783          	lw	a5,24(sp)
	    break;
	}
      goto ret1;
    }

  m2 = b2;
   14c90:	000a8c13          	mv	s8,s5
	    {
	      s5 += j -= m5;
	      b5 += j;
	      m5 = 0;
	    }
	  if ((i = ilim) < 0)
   14c94:	2207c0e3          	bltz	a5,156b4 <_dtoa_r+0x135c>
	      m2 -= i;
	      i = 0;
	    }
	}
      b2 += i;
      s2 += i;
   14c98:	00c12703          	lw	a4,12(sp)
      mhi = i2b (ptr, 1);
   14c9c:	00100593          	li	a1,1
   14ca0:	00040513          	mv	a0,s0
	      m2 -= i;
	      i = 0;
	    }
	}
      b2 += i;
      s2 += i;
   14ca4:	00f70733          	add	a4,a4,a5
	    {
	      m2 -= i;
	      i = 0;
	    }
	}
      b2 += i;
   14ca8:	00fa8ab3          	add	s5,s5,a5
      s2 += i;
   14cac:	00e12623          	sw	a4,12(sp)
      mhi = i2b (ptr, 1);
   14cb0:	03d020ef          	jal	174ec <__i2b>
   14cb4:	00050a13          	mv	s4,a0
    }
  if (m2 > 0 && s2 > 0)
   14cb8:	020c0663          	beqz	s8,14ce4 <_dtoa_r+0x98c>
   14cbc:	00c12783          	lw	a5,12(sp)
   14cc0:	02f05263          	blez	a5,14ce4 <_dtoa_r+0x98c>
    {
      i = m2 < s2 ? m2 : s2;
   14cc4:	00c12703          	lw	a4,12(sp)
   14cc8:	000c0793          	mv	a5,s8
   14ccc:	45874463          	blt	a4,s8,15114 <_dtoa_r+0xdbc>
      b2 -= i;
      m2 -= i;
      s2 -= i;
   14cd0:	00c12703          	lw	a4,12(sp)
      mhi = i2b (ptr, 1);
    }
  if (m2 > 0 && s2 > 0)
    {
      i = m2 < s2 ? m2 : s2;
      b2 -= i;
   14cd4:	40fa8ab3          	sub	s5,s5,a5
      m2 -= i;
   14cd8:	40fc0c33          	sub	s8,s8,a5
      s2 -= i;
   14cdc:	40f70733          	sub	a4,a4,a5
   14ce0:	00e12623          	sw	a4,12(sp)
      if (rve)
	*rve = s + 1;
      return s;
    }

  b = d2b (ptr, d.d, &be, &bbits);
   14ce4:	01c12483          	lw	s1,28(sp)
      i = m2 < s2 ? m2 : s2;
      b2 -= i;
      m2 -= i;
      s2 -= i;
    }
  if (b5 > 0)
   14ce8:	07605263          	blez	s6,14d4c <_dtoa_r+0x9f4>
    {
      if (leftright)
   14cec:	02012783          	lw	a5,32(sp)
   14cf0:	70078263          	beqz	a5,153f4 <_dtoa_r+0x109c>
	{
	  if (m5 > 0)
   14cf4:	040c8263          	beqz	s9,14d38 <_dtoa_r+0x9e0>
	    {
	      mhi = pow5mult (ptr, mhi, m5);
   14cf8:	000a0593          	mv	a1,s4
   14cfc:	000c8613          	mv	a2,s9
   14d00:	00040513          	mv	a0,s0
   14d04:	20d020ef          	jal	17710 <__pow5mult>
	      b1 = mult (ptr, mhi, b);
   14d08:	01c12603          	lw	a2,28(sp)
   14d0c:	00050593          	mv	a1,a0
    {
      if (leftright)
	{
	  if (m5 > 0)
	    {
	      mhi = pow5mult (ptr, mhi, m5);
   14d10:	00050a13          	mv	s4,a0
	      b1 = mult (ptr, mhi, b);
   14d14:	00040513          	mv	a0,s0
   14d18:	009020ef          	jal	17520 <__multiply>
	      Bfree (ptr, b);
   14d1c:	01c12583          	lw	a1,28(sp)
      if (leftright)
	{
	  if (m5 > 0)
	    {
	      mhi = pow5mult (ptr, mhi, m5);
	      b1 = mult (ptr, mhi, b);
   14d20:	00050493          	mv	s1,a0
	      Bfree (ptr, b);
	      b = b1;
	    }
         if ((j = b5 - m5) != 0)
   14d24:	419b0b33          	sub	s6,s6,s9
	{
	  if (m5 > 0)
	    {
	      mhi = pow5mult (ptr, mhi, m5);
	      b1 = mult (ptr, mhi, b);
	      Bfree (ptr, b);
   14d28:	00040513          	mv	a0,s0
   14d2c:	45c020ef          	jal	17188 <_Bfree>
	      b = b1;
	    }
         if ((j = b5 - m5) != 0)
   14d30:	000b0e63          	beqz	s6,14d4c <_dtoa_r+0x9f4>
	  if (m5 > 0)
	    {
	      mhi = pow5mult (ptr, mhi, m5);
	      b1 = mult (ptr, mhi, b);
	      Bfree (ptr, b);
	      b = b1;
   14d34:	00912e23          	sw	s1,28(sp)
	    }
         if ((j = b5 - m5) != 0)
	    b = pow5mult (ptr, b, j);
   14d38:	01c12583          	lw	a1,28(sp)
   14d3c:	000b0613          	mv	a2,s6
   14d40:	00040513          	mv	a0,s0
   14d44:	1cd020ef          	jal	17710 <__pow5mult>
   14d48:	00050493          	mv	s1,a0
	}
      else
	b = pow5mult (ptr, b, b5);
    }
  S = i2b (ptr, 1);
   14d4c:	00100593          	li	a1,1
   14d50:	00040513          	mv	a0,s0
   14d54:	798020ef          	jal	174ec <__i2b>
  if (s5 > 0)
   14d58:	02812703          	lw	a4,40(sp)
	    b = pow5mult (ptr, b, j);
	}
      else
	b = pow5mult (ptr, b, b5);
    }
  S = i2b (ptr, 1);
   14d5c:	00050b13          	mv	s6,a0
  if (s5 > 0)
   14d60:	0a070e63          	beqz	a4,14e1c <_dtoa_r+0xac4>
    S = pow5mult (ptr, S, s5);
   14d64:	00050593          	mv	a1,a0
   14d68:	00070613          	mv	a2,a4
   14d6c:	00040513          	mv	a0,s0
   14d70:	1a1020ef          	jal	17710 <__pow5mult>

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
  if (mode < 2)
   14d74:	00100793          	li	a5,1
      else
	b = pow5mult (ptr, b, b5);
    }
  S = i2b (ptr, 1);
  if (s5 > 0)
    S = pow5mult (ptr, S, s5);
   14d78:	00050b13          	mv	s6,a0

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
  if (mode < 2)
   14d7c:	3bb7d063          	ble	s11,a5,1511c <_dtoa_r+0xdc4>
  if (s5 > 0)
    S = pow5mult (ptr, S, s5);

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
   14d80:	00000c93          	li	s9,0
   * and for all and pass them and a shift to quorem, so it
   * can do shifts and ors to compute the numerator for q.
   */

#ifdef Pack_32
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
   14d84:	010b2783          	lw	a5,16(s6) # 80000010 <_gp+0x7ffb7830>
   14d88:	00378793          	addi	a5,a5,3
   14d8c:	00279793          	slli	a5,a5,0x2
   14d90:	00fb07b3          	add	a5,s6,a5
   14d94:	0047a503          	lw	a0,4(a5)
   14d98:	628020ef          	jal	173c0 <__hi0bits>
   14d9c:	02000793          	li	a5,32
   14da0:	40a78533          	sub	a0,a5,a0
   14da4:	0840006f          	j	14e28 <_dtoa_r+0xad0>
      s5 = k;
      s2 += k;
    }
  else
    {
      b2 -= k;
   14da8:	01012703          	lw	a4,16(sp)
      b5 = -k;
      s5 = 0;
   14dac:	02012423          	sw	zero,40(sp)
      s5 = k;
      s2 += k;
    }
  else
    {
      b2 -= k;
   14db0:	40ea8ab3          	sub	s5,s5,a4
      b5 = -k;
   14db4:	40e00b33          	neg	s6,a4
   14db8:	851ff06f          	j	14608 <_dtoa_r+0x2b0>
  ds = (d2.d - 1.5) * 0.289529651 + 0.176091269 + i * 0.30103001;
#else
  ds = (d2.d - 1.5) * 0.289529654602168 + 0.1760912590558 + i * 0.301029995663981;
#endif
  k = (int) ds;
  if (ds < 0. && ds != k)
   14dbc:	01012503          	lw	a0,16(sp)
   14dc0:	079060ef          	jal	1b638 <__floatsidf>
   14dc4:	00050613          	mv	a2,a0
   14dc8:	00058693          	mv	a3,a1
   14dcc:	000a0513          	mv	a0,s4
   14dd0:	000a8593          	mv	a1,s5
   14dd4:	00d060ef          	jal	1b5e0 <__nedf2>
    k--;			/* want k = floor(ds) */
   14dd8:	01012783          	lw	a5,16(sp)
   14ddc:	00a03533          	snez	a0,a0
   14de0:	40a787b3          	sub	a5,a5,a0
   14de4:	00f12823          	sw	a5,16(sp)
   14de8:	fa4ff06f          	j	1458c <_dtoa_r+0x234>
      b2 = 0;
      s2 = j;
    }
  else
    {
      b2 = -j;
   14dec:	41900ab3          	neg	s5,s9
      s2 = 0;
   14df0:	00012623          	sw	zero,12(sp)
   14df4:	ff8ff06f          	j	145ec <_dtoa_r+0x294>
   14df8:	000b0c93          	mv	s9,s6
	    break;
	}
      goto ret1;
    }

  m2 = b2;
   14dfc:	000a8c13          	mv	s8,s5
  m5 = b5;
  mhi = mlo = 0;
   14e00:	00000a13          	li	s4,0
   14e04:	eb5ff06f          	j	14cb8 <_dtoa_r+0x960>
      i = bbits + be + (Bias + (P - 1) - 1);
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
       : (word1 (d) << (32 - i));
   14e08:	40e78b33          	sub	s6,a5,a4
   14e0c:	01691533          	sll	a0,s2,s6
   14e10:	c1dff06f          	j	14a2c <_dtoa_r+0x6d4>
  k_check = 1;
  if (k >= 0 && k <= Ten_pmax)
    {
      if (d.d < tens[k])
	k--;
      k_check = 0;
   14e14:	02012223          	sw	zero,36(sp)
   14e18:	fc0ff06f          	j	145d8 <_dtoa_r+0x280>
    S = pow5mult (ptr, S, s5);

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
  if (mode < 2)
   14e1c:	00100513          	li	a0,1
   14e20:	45b55663          	ble	s11,a0,1526c <_dtoa_r+0xf14>
  if (s5 > 0)
    S = pow5mult (ptr, S, s5);

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
   14e24:	00000c93          	li	s9,0
   * and for all and pass them and a shift to quorem, so it
   * can do shifts and ors to compute the numerator for q.
   */

#ifdef Pack_32
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
   14e28:	00c12703          	lw	a4,12(sp)
   14e2c:	00e50533          	add	a0,a0,a4
   14e30:	01f57513          	andi	a0,a0,31
   14e34:	1a050663          	beqz	a0,14fe0 <_dtoa_r+0xc88>
    i = 32 - i;
   14e38:	02000793          	li	a5,32
   14e3c:	40a787b3          	sub	a5,a5,a0
#else
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0xf) != 0)
    i = 16 - i;
#endif
  if (i > 4)
   14e40:	00400713          	li	a4,4
   14e44:	20f752e3          	ble	a5,a4,15848 <_dtoa_r+0x14f0>
    {
      i -= 4;
   14e48:	01c00793          	li	a5,28
   14e4c:	40a78533          	sub	a0,a5,a0
      b2 += i;
      m2 += i;
      s2 += i;
   14e50:	00c12783          	lw	a5,12(sp)
    i = 16 - i;
#endif
  if (i > 4)
    {
      i -= 4;
      b2 += i;
   14e54:	00aa8ab3          	add	s5,s5,a0
      m2 += i;
   14e58:	00ac0c33          	add	s8,s8,a0
      s2 += i;
   14e5c:	00a787b3          	add	a5,a5,a0
   14e60:	00f12623          	sw	a5,12(sp)
      i += 28;
      b2 += i;
      m2 += i;
      s2 += i;
    }
  if (b2 > 0)
   14e64:	01505c63          	blez	s5,14e7c <_dtoa_r+0xb24>
    b = lshift (ptr, b, b2);
   14e68:	00048593          	mv	a1,s1
   14e6c:	000a8613          	mv	a2,s5
   14e70:	00040513          	mv	a0,s0
   14e74:	1d5020ef          	jal	17848 <__lshift>
   14e78:	00050493          	mv	s1,a0
  if (s2 > 0)
   14e7c:	00c12783          	lw	a5,12(sp)
   14e80:	00f05c63          	blez	a5,14e98 <_dtoa_r+0xb40>
    S = lshift (ptr, S, s2);
   14e84:	000b0593          	mv	a1,s6
   14e88:	00078613          	mv	a2,a5
   14e8c:	00040513          	mv	a0,s0
   14e90:	1b9020ef          	jal	17848 <__lshift>
   14e94:	00050b13          	mv	s6,a0
  if (k_check)
   14e98:	02412703          	lw	a4,36(sp)
   14e9c:	16071063          	bnez	a4,14ffc <_dtoa_r+0xca4>
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   14ea0:	01812703          	lw	a4,24(sp)
   14ea4:	44e05063          	blez	a4,152e4 <_dtoa_r+0xf8c>
    one_digit:
      *s++ = '1';
      k++;
      goto ret;
    }
  if (leftright)
   14ea8:	02012783          	lw	a5,32(sp)
   14eac:	18078c63          	beqz	a5,15044 <_dtoa_r+0xcec>
    {
      if (m2 > 0)
   14eb0:	01805c63          	blez	s8,14ec8 <_dtoa_r+0xb70>
	mhi = lshift (ptr, mhi, m2);
   14eb4:	000a0593          	mv	a1,s4
   14eb8:	000c0613          	mv	a2,s8
   14ebc:	00040513          	mv	a0,s0
   14ec0:	189020ef          	jal	17848 <__lshift>
   14ec4:	00050a13          	mv	s4,a0
   14ec8:	000a0c13          	mv	s8,s4
      /* Compute mlo -- check for special case
       * that d is a normalized power of 2.
       */

      mlo = mhi;
      if (spec_case)
   14ecc:	620c9663          	bnez	s9,154f8 <_dtoa_r+0x11a0>
   14ed0:	01812703          	lw	a4,24(sp)
	  j = cmp (b, mlo);
	  delta = diff (ptr, S, mhi);
	  j1 = delta->_sign ? 1 : cmp (b, delta);
	  Bfree (ptr, delta);
#ifndef ROUND_BIASED
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
   14ed4:	00197793          	andi	a5,s2,1
   14ed8:	001d0993          	addi	s3,s10,1
   14edc:	00ed0733          	add	a4,s10,a4
   14ee0:	00e12e23          	sw	a4,28(sp)
   14ee4:	00f12c23          	sw	a5,24(sp)
   14ee8:	03a12023          	sw	s10,32(sp)
	  mhi = lshift (ptr, mhi, Log2P);
	}

      for (i = 1;; i++)
	{
	  dig = quorem (b, S) + '0';
   14eec:	000b0593          	mv	a1,s6
   14ef0:	00048513          	mv	a0,s1
   14ef4:	a7cff0ef          	jal	14170 <quorem>
   14ef8:	00050c93          	mv	s9,a0
	  /* Do we yet have the shortest decimal string
	   * that will round to d?
	   */
	  j = cmp (b, mlo);
   14efc:	000a0593          	mv	a1,s4
   14f00:	00048513          	mv	a0,s1
   14f04:	295020ef          	jal	17998 <__mcmp>
   14f08:	00050a93          	mv	s5,a0
	  delta = diff (ptr, S, mhi);
   14f0c:	000c0613          	mv	a2,s8
   14f10:	000b0593          	mv	a1,s6
   14f14:	00040513          	mv	a0,s0
   14f18:	2e1020ef          	jal	179f8 <__mdiff>
	  j1 = delta->_sign ? 1 : cmp (b, delta);
   14f1c:	00c52683          	lw	a3,12(a0)
   14f20:	fff98713          	addi	a4,s3,-1
	  dig = quorem (b, S) + '0';
	  /* Do we yet have the shortest decimal string
	   * that will round to d?
	   */
	  j = cmp (b, mlo);
	  delta = diff (ptr, S, mhi);
   14f24:	00050d13          	mv	s10,a0
   14f28:	00e12623          	sw	a4,12(sp)
	  mhi = lshift (ptr, mhi, Log2P);
	}

      for (i = 1;; i++)
	{
	  dig = quorem (b, S) + '0';
   14f2c:	030c8b93          	addi	s7,s9,48
	  /* Do we yet have the shortest decimal string
	   * that will round to d?
	   */
	  j = cmp (b, mlo);
	  delta = diff (ptr, S, mhi);
	  j1 = delta->_sign ? 1 : cmp (b, delta);
   14f30:	00100913          	li	s2,1
   14f34:	00069a63          	bnez	a3,14f48 <_dtoa_r+0xbf0>
   14f38:	00050593          	mv	a1,a0
   14f3c:	00048513          	mv	a0,s1
   14f40:	259020ef          	jal	17998 <__mcmp>
   14f44:	00050913          	mv	s2,a0
	  Bfree (ptr, delta);
   14f48:	000d0593          	mv	a1,s10
   14f4c:	00040513          	mv	a0,s0
   14f50:	238020ef          	jal	17188 <_Bfree>
#ifndef ROUND_BIASED
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
   14f54:	01b967b3          	or	a5,s2,s11
   14f58:	00079663          	bnez	a5,14f64 <_dtoa_r+0xc0c>
   14f5c:	01812783          	lw	a5,24(sp)
   14f60:	28078663          	beqz	a5,151ec <_dtoa_r+0xe94>
		dig++;
	      *s++ = dig;
	      goto ret;
	    }
#endif
         if ((j < 0) || ((j == 0) && !mode
   14f64:	2a0acc63          	bltz	s5,1521c <_dtoa_r+0xec4>
   14f68:	01baeab3          	or	s5,s5,s11
   14f6c:	000a9663          	bnez	s5,14f78 <_dtoa_r+0xc20>
#ifndef ROUND_BIASED
	      && !(word1 (d) & 1)
   14f70:	01812703          	lw	a4,24(sp)
   14f74:	2a070463          	beqz	a4,1521c <_dtoa_r+0xec4>
		    goto round_9_up;
		}
	      *s++ = dig;
	      goto ret;
	    }
	  if (j1 > 0)
   14f78:	71204063          	bgtz	s2,15678 <_dtoa_r+0x1320>
		}
	      *s++ = dig + 1;
	      goto ret;
	    }
	  *s++ = dig;
	  if (i == ilim)
   14f7c:	01c12783          	lw	a5,28(sp)
		  goto roundoff;
		}
	      *s++ = dig + 1;
	      goto ret;
	    }
	  *s++ = dig;
   14f80:	00098c93          	mv	s9,s3
   14f84:	ff798fa3          	sb	s7,-1(s3)
	  if (i == ilim)
   14f88:	71378e63          	beq	a5,s3,156a4 <_dtoa_r+0x134c>
	    break;
	  b = multadd (ptr, b, 10, 0);
   14f8c:	00048593          	mv	a1,s1
   14f90:	00000693          	li	a3,0
   14f94:	00a00613          	li	a2,10
   14f98:	00040513          	mv	a0,s0
   14f9c:	210020ef          	jal	171ac <__multadd>
   14fa0:	00050493          	mv	s1,a0
	  if (mlo == mhi)
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
   14fa4:	00000693          	li	a3,0
   14fa8:	00a00613          	li	a2,10
   14fac:	000a0593          	mv	a1,s4
   14fb0:	00040513          	mv	a0,s0
	    }
	  *s++ = dig;
	  if (i == ilim)
	    break;
	  b = multadd (ptr, b, 10, 0);
	  if (mlo == mhi)
   14fb4:	2d8a0063          	beq	s4,s8,15274 <_dtoa_r+0xf1c>
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
	  else
	    {
	      mlo = multadd (ptr, mlo, 10, 0);
   14fb8:	1f4020ef          	jal	171ac <__multadd>
   14fbc:	00050a13          	mv	s4,a0
	      mhi = multadd (ptr, mhi, 10, 0);
   14fc0:	000c0593          	mv	a1,s8
   14fc4:	00000693          	li	a3,0
   14fc8:	00a00613          	li	a2,10
   14fcc:	00040513          	mv	a0,s0
   14fd0:	1dc020ef          	jal	171ac <__multadd>
   14fd4:	00050c13          	mv	s8,a0
   14fd8:	00198993          	addi	s3,s3,1
	    }
	}
   14fdc:	f11ff06f          	j	14eec <_dtoa_r+0xb94>
   14fe0:	01c00513          	li	a0,28
  else if (i < 4)
    {
      i += 28;
      b2 += i;
      m2 += i;
      s2 += i;
   14fe4:	00c12703          	lw	a4,12(sp)
      s2 += i;
    }
  else if (i < 4)
    {
      i += 28;
      b2 += i;
   14fe8:	00aa8ab3          	add	s5,s5,a0
      m2 += i;
   14fec:	00ac0c33          	add	s8,s8,a0
      s2 += i;
   14ff0:	00a70733          	add	a4,a4,a0
   14ff4:	00e12623          	sw	a4,12(sp)
   14ff8:	e6dff06f          	j	14e64 <_dtoa_r+0xb0c>
    b = lshift (ptr, b, b2);
  if (s2 > 0)
    S = lshift (ptr, S, s2);
  if (k_check)
    {
      if (cmp (b, S) < 0)
   14ffc:	000b0593          	mv	a1,s6
   15000:	00048513          	mv	a0,s1
   15004:	195020ef          	jal	17998 <__mcmp>
   15008:	e8055ce3          	bgez	a0,14ea0 <_dtoa_r+0xb48>
	{
	  k--;
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
   1500c:	00048593          	mv	a1,s1
   15010:	00000693          	li	a3,0
   15014:	00a00613          	li	a2,10
   15018:	00040513          	mv	a0,s0
   1501c:	190020ef          	jal	171ac <__multadd>
    S = lshift (ptr, S, s2);
  if (k_check)
    {
      if (cmp (b, S) < 0)
	{
	  k--;
   15020:	01012783          	lw	a5,16(sp)
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
	  if (leftright)
   15024:	02012703          	lw	a4,32(sp)
  if (k_check)
    {
      if (cmp (b, S) < 0)
	{
	  k--;
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
   15028:	00050493          	mv	s1,a0
    S = lshift (ptr, S, s2);
  if (k_check)
    {
      if (cmp (b, S) < 0)
	{
	  k--;
   1502c:	fff78793          	addi	a5,a5,-1
   15030:	00f12823          	sw	a5,16(sp)
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
	  if (leftright)
   15034:	7a071e63          	bnez	a4,157f0 <_dtoa_r+0x1498>
	    mhi = multadd (ptr, mhi, 10, 0);
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   15038:	02c12783          	lw	a5,44(sp)
   1503c:	7cf05e63          	blez	a5,15818 <_dtoa_r+0x14c0>
   15040:	00f12c23          	sw	a5,24(sp)
	  *s++ = dig;
	  if (i == ilim)
	    break;
	  b = multadd (ptr, b, 10, 0);
	  if (mlo == mhi)
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
   15044:	000d0913          	mv	s2,s10
   15048:	01812983          	lw	s3,24(sp)
   1504c:	00c0006f          	j	15058 <_dtoa_r+0xd00>
    for (i = 1;; i++)
      {
	*s++ = dig = quorem (b, S) + '0';
	if (i >= ilim)
	  break;
	b = multadd (ptr, b, 10, 0);
   15050:	15c020ef          	jal	171ac <__multadd>
   15054:	00050493          	mv	s1,a0
	}
    }
  else
    for (i = 1;; i++)
      {
	*s++ = dig = quorem (b, S) + '0';
   15058:	000b0593          	mv	a1,s6
   1505c:	00048513          	mv	a0,s1
   15060:	910ff0ef          	jal	14170 <quorem>
   15064:	00190913          	addi	s2,s2,1
   15068:	03050b93          	addi	s7,a0,48
	if (i >= ilim)
   1506c:	41a907b3          	sub	a5,s2,s10
	  break;
	b = multadd (ptr, b, 10, 0);
   15070:	00000693          	li	a3,0
   15074:	00a00613          	li	a2,10
   15078:	00048593          	mv	a1,s1
   1507c:	00040513          	mv	a0,s0
	}
    }
  else
    for (i = 1;; i++)
      {
	*s++ = dig = quorem (b, S) + '0';
   15080:	ff790fa3          	sb	s7,-1(s2)
	if (i >= ilim)
   15084:	fd37c6e3          	blt	a5,s3,15050 <_dtoa_r+0xcf8>
   15088:	01812d83          	lw	s11,24(sp)
   1508c:	63b05a63          	blez	s11,156c0 <_dtoa_r+0x1368>
   15090:	01bd0cb3          	add	s9,s10,s11
      goto ret1;
    }

  m2 = b2;
  m5 = b5;
  mhi = mlo = 0;
   15094:	00000913          	li	s2,0
	b = multadd (ptr, b, 10, 0);
      }

  /* Round off last digit */

  b = lshift (ptr, b, 1);
   15098:	00048593          	mv	a1,s1
   1509c:	00100613          	li	a2,1
   150a0:	00040513          	mv	a0,s0
   150a4:	7a4020ef          	jal	17848 <__lshift>
  j = cmp (b, S);
   150a8:	000b0593          	mv	a1,s6
	b = multadd (ptr, b, 10, 0);
      }

  /* Round off last digit */

  b = lshift (ptr, b, 1);
   150ac:	00a12e23          	sw	a0,28(sp)
  j = cmp (b, S);
   150b0:	0e9020ef          	jal	17998 <__mcmp>
  if ((j > 0) || ((j == 0) && (dig & 1)))
   150b4:	36a05063          	blez	a0,15414 <_dtoa_r+0x10bc>
   150b8:	fffcc703          	lbu	a4,-1(s9)
    {
    roundoff:
      while (*--s == '9')
   150bc:	03900693          	li	a3,57
   150c0:	0100006f          	j	150d0 <_dtoa_r+0xd78>
	if (s == s0)
   150c4:	29a78063          	beq	a5,s10,15344 <_dtoa_r+0xfec>
   150c8:	fff7c703          	lbu	a4,-1(a5)
   150cc:	00078c93          	mv	s9,a5
  b = lshift (ptr, b, 1);
  j = cmp (b, S);
  if ((j > 0) || ((j == 0) && (dig & 1)))
    {
    roundoff:
      while (*--s == '9')
   150d0:	fffc8793          	addi	a5,s9,-1
   150d4:	fed708e3          	beq	a4,a3,150c4 <_dtoa_r+0xd6c>
	  {
	    k++;
	    *s++ = '1';
	    goto ret;
	  }
      ++*s++;
   150d8:	00170713          	addi	a4,a4,1
   150dc:	00e78023          	sb	a4,0(a5)
    {
      while (*--s == '0');
      s++;
    }
ret:
  Bfree (ptr, S);
   150e0:	000b0593          	mv	a1,s6
   150e4:	00040513          	mv	a0,s0
   150e8:	0a0020ef          	jal	17188 <_Bfree>
  if (mhi)
   150ec:	8c0a04e3          	beqz	s4,149b4 <_dtoa_r+0x65c>
    {
      if (mlo && mlo != mhi)
   150f0:	00090a63          	beqz	s2,15104 <_dtoa_r+0xdac>
   150f4:	01490863          	beq	s2,s4,15104 <_dtoa_r+0xdac>
	Bfree (ptr, mlo);
   150f8:	00090593          	mv	a1,s2
   150fc:	00040513          	mv	a0,s0
   15100:	088020ef          	jal	17188 <_Bfree>
      Bfree (ptr, mhi);
   15104:	000a0593          	mv	a1,s4
   15108:	00040513          	mv	a0,s0
   1510c:	07c020ef          	jal	17188 <_Bfree>
   15110:	8a5ff06f          	j	149b4 <_dtoa_r+0x65c>
      s2 += i;
      mhi = i2b (ptr, 1);
    }
  if (m2 > 0 && s2 > 0)
    {
      i = m2 < s2 ? m2 : s2;
   15114:	00070793          	mv	a5,a4
   15118:	bb9ff06f          	j	14cd0 <_dtoa_r+0x978>
  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
  if (mode < 2)
    {
      if (!word1 (d) && !(word0 (d) & Bndry_mask)
   1511c:	c60912e3          	bnez	s2,14d80 <_dtoa_r+0xa28>
   15120:	00c99793          	slli	a5,s3,0xc
  if (s5 > 0)
    S = pow5mult (ptr, S, s5);

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
   15124:	00000c93          	li	s9,0
  if (mode < 2)
    {
      if (!word1 (d) && !(word0 (d) & Bndry_mask)
   15128:	02079263          	bnez	a5,1514c <_dtoa_r+0xdf4>
#ifndef Sudden_Underflow
	  && word0 (d) & Exp_mask
   1512c:	7ff007b7          	lui	a5,0x7ff00
   15130:	0137f7b3          	and	a5,a5,s3
   15134:	00078c63          	beqz	a5,1514c <_dtoa_r+0xdf4>
#endif
	)
	{
	  /* The special case */
	  b2 += Log2P;
	  s2 += Log2P;
   15138:	00c12703          	lw	a4,12(sp)
	  && word0 (d) & Exp_mask
#endif
	)
	{
	  /* The special case */
	  b2 += Log2P;
   1513c:	001a8a93          	addi	s5,s5,1
	  s2 += Log2P;
	  spec_case = 1;
   15140:	00100c93          	li	s9,1
#endif
	)
	{
	  /* The special case */
	  b2 += Log2P;
	  s2 += Log2P;
   15144:	00170713          	addi	a4,a4,1
   15148:	00e12623          	sw	a4,12(sp)
   * and for all and pass them and a shift to quorem, so it
   * can do shifts and ors to compute the numerator for q.
   */

#ifdef Pack_32
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
   1514c:	02812783          	lw	a5,40(sp)
   15150:	00100513          	li	a0,1
   15154:	cc078ae3          	beqz	a5,14e28 <_dtoa_r+0xad0>
   15158:	c2dff06f          	j	14d84 <_dtoa_r+0xa2c>
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   1515c:	00100793          	li	a5,1
   15160:	02f12023          	sw	a5,32(sp)
      break;
    case 2:
      leftright = 0;
      /* no break */
    case 4:
      if (ndigits <= 0)
   15164:	13705263          	blez	s7,15288 <_dtoa_r+0xf30>
   15168:	000b8613          	mv	a2,s7
   1516c:	000b8493          	mv	s1,s7
   15170:	03712623          	sw	s7,44(sp)
   15174:	01712c23          	sw	s7,24(sp)
   15178:	cf0ff06f          	j	14668 <_dtoa_r+0x310>

  if (be >= 0 && k <= Int_max)
    {
      /* Yes. */
      ds = tens[k];
      if (ndigits < 0 && ilim <= 0)
   1517c:	01812703          	lw	a4,24(sp)
   15180:	92e04ce3          	bgtz	a4,14ab8 <_dtoa_r+0x760>
	{
	  S = mhi = 0;
	  if (ilim < 0 || d.d <= 5 * ds)
   15184:	26071263          	bnez	a4,153e8 <_dtoa_r+0x1090>
   15188:	8601a603          	lw	a2,-1952(gp) # 48040 <__wctomb+0x40>
   1518c:	8641a683          	lw	a3,-1948(gp) # 48044 <__wctomb+0x44>
   15190:	000a0513          	mv	a0,s4
   15194:	000a8593          	mv	a1,s5
   15198:	64d050ef          	jal	1afe4 <__muldf3>
   1519c:	00090613          	mv	a2,s2
   151a0:	00098693          	mv	a3,s3
   151a4:	378060ef          	jal	1b51c <__gedf2>
    {
      /* Yes. */
      ds = tens[k];
      if (ndigits < 0 && ilim <= 0)
	{
	  S = mhi = 0;
   151a8:	00000b13          	li	s6,0
   151ac:	00000a13          	li	s4,0
	  if (ilim < 0 || d.d <= 5 * ds)
   151b0:	16054863          	bltz	a0,15320 <_dtoa_r+0xfc8>
    {
      if (ilim < 0 || cmp (b, S = multadd (ptr, S, 5, 0)) <= 0)
	{
	  /* no digits, fcvt style */
	no_digits:
	  k = -1 - ndigits;
   151b4:	fffbcb93          	not	s7,s7
   151b8:	01712823          	sw	s7,16(sp)
	  goto ret;
   151bc:	000d0c93          	mv	s9,s10
    {
      while (*--s == '0');
      s++;
    }
ret:
  Bfree (ptr, S);
   151c0:	000b0593          	mv	a1,s6
   151c4:	00040513          	mv	a0,s0
   151c8:	7c1010ef          	jal	17188 <_Bfree>
  if (mhi)
   151cc:	fe0a0463          	beqz	s4,149b4 <_dtoa_r+0x65c>
   151d0:	f35ff06f          	j	15104 <_dtoa_r+0xdac>
    {
      if (mode < 2)
	{
	  i =
#ifndef Sudden_Underflow
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
   151d4:	04812703          	lw	a4,72(sp)
   151d8:	4e070863          	beqz	a4,156c8 <_dtoa_r+0x1370>
   151dc:	43378793          	addi	a5,a5,1075 # 7ff00433 <_gp+0x7feb7c53>
   151e0:	000b0c93          	mv	s9,s6
	    break;
	}
      goto ret1;
    }

  m2 = b2;
   151e4:	000a8c13          	mv	s8,s5
   151e8:	ab1ff06f          	j	14c98 <_dtoa_r+0x940>
	  j1 = delta->_sign ? 1 : cmp (b, delta);
	  Bfree (ptr, delta);
#ifndef ROUND_BIASED
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
	    {
	      if (dig == '9')
   151ec:	03900793          	li	a5,57
   151f0:	02012d03          	lw	s10,32(sp)
   151f4:	4efb8a63          	beq	s7,a5,156e8 <_dtoa_r+0x1390>
		goto round_9_up;
	      if (j > 0)
   151f8:	01505463          	blez	s5,15200 <_dtoa_r+0xea8>
		dig++;
   151fc:	031c8b93          	addi	s7,s9,49
	      *s++ = dig;
   15200:	00c12683          	lw	a3,12(sp)
	      goto ret;
   15204:	000a0913          	mv	s2,s4
   15208:	00912e23          	sw	s1,28(sp)
	    {
	      if (dig == '9')
		goto round_9_up;
	      if (j > 0)
		dig++;
	      *s++ = dig;
   1520c:	00168c93          	addi	s9,a3,1
   15210:	01768023          	sb	s7,0(a3)
	      goto ret;
   15214:	000c0a13          	mv	s4,s8
   15218:	ec9ff06f          	j	150e0 <_dtoa_r+0xd88>
   1521c:	02012d03          	lw	s10,32(sp)
#ifndef ROUND_BIASED
	      && !(word1 (d) & 1)
#endif
           ))
	    {
	      if (j1 > 0)
   15220:	03205863          	blez	s2,15250 <_dtoa_r+0xef8>
		{
		  b = lshift (ptr, b, 1);
   15224:	00048593          	mv	a1,s1
   15228:	00100613          	li	a2,1
   1522c:	00040513          	mv	a0,s0
   15230:	618020ef          	jal	17848 <__lshift>
		  j1 = cmp (b, S);
   15234:	000b0593          	mv	a1,s6
#endif
           ))
	    {
	      if (j1 > 0)
		{
		  b = lshift (ptr, b, 1);
   15238:	00050493          	mv	s1,a0
		  j1 = cmp (b, S);
   1523c:	75c020ef          	jal	17998 <__mcmp>
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
   15240:	5aa05063          	blez	a0,157e0 <_dtoa_r+0x1488>
		      && dig++ == '9')
   15244:	03900793          	li	a5,57
   15248:	4afb8063          	beq	s7,a5,156e8 <_dtoa_r+0x1390>
   1524c:	031c8b93          	addi	s7,s9,49
		    goto round_9_up;
		}
	      *s++ = dig;
   15250:	00c12783          	lw	a5,12(sp)
	      goto ret;
   15254:	000a0913          	mv	s2,s4
   15258:	00912e23          	sw	s1,28(sp)
		  j1 = cmp (b, S);
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
		      && dig++ == '9')
		    goto round_9_up;
		}
	      *s++ = dig;
   1525c:	00178c93          	addi	s9,a5,1
   15260:	01778023          	sb	s7,0(a5)
	      goto ret;
   15264:	000c0a13          	mv	s4,s8
   15268:	e79ff06f          	j	150e0 <_dtoa_r+0xd88>
  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
  if (mode < 2)
    {
      if (!word1 (d) && !(word0 (d) & Bndry_mask)
   1526c:	ba091ce3          	bnez	s2,14e24 <_dtoa_r+0xacc>
   15270:	eb1ff06f          	j	15120 <_dtoa_r+0xdc8>
	  *s++ = dig;
	  if (i == ilim)
	    break;
	  b = multadd (ptr, b, 10, 0);
	  if (mlo == mhi)
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
   15274:	739010ef          	jal	171ac <__multadd>
   15278:	00050a13          	mv	s4,a0
   1527c:	00050c13          	mv	s8,a0
   15280:	00198993          	addi	s3,s3,1
   15284:	c69ff06f          	j	14eec <_dtoa_r+0xb94>
   15288:	00100493          	li	s1,1
    case 2:
      leftright = 0;
      /* no break */
    case 4:
      if (ndigits <= 0)
	ndigits = 1;
   1528c:	02912623          	sw	s1,44(sp)
   15290:	00912c23          	sw	s1,24(sp)
   15294:	00048b93          	mv	s7,s1
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   15298:	04042223          	sw	zero,68(s0)
   1529c:	00000593          	li	a1,0
   152a0:	bf8ff06f          	j	14698 <_dtoa_r+0x340>
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
  switch (mode)
   152a4:	00200793          	li	a5,2
    case 1:
      i = 18;
      ndigits = 0;
      break;
    case 2:
      leftright = 0;
   152a8:	02012023          	sw	zero,32(sp)
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
  switch (mode)
   152ac:	eafd8ce3          	beq	s11,a5,15164 <_dtoa_r+0xe0c>
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   152b0:	04042223          	sw	zero,68(s0)
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   152b4:	00000593          	li	a1,0
   152b8:	00040513          	mv	a0,s0
   152bc:	629010ef          	jal	170e4 <_Balloc>
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   152c0:	fff00713          	li	a4,-1
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   152c4:	00100793          	li	a5,1
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   152c8:	00050d13          	mv	s10,a0
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   152cc:	00e12c23          	sw	a4,24(sp)
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   152d0:	04a42023          	sw	a0,64(s0)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
  ilim = ilim1 = -1;
   152d4:	02e12623          	sw	a4,44(sp)
  switch (mode)
    {
    case 0:
    case 1:
      i = 18;
      ndigits = 0;
   152d8:	00000b93          	li	s7,0
  if (mode > 5)
    {
      mode -= 4;
      try_quick = 0;
    }
  leftright = 1;
   152dc:	02f12023          	sw	a5,32(sp)
   152e0:	fa8ff06f          	j	14a88 <_dtoa_r+0x730>
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   152e4:	00200793          	li	a5,2
   152e8:	bdb7d0e3          	ble	s11,a5,14ea8 <_dtoa_r+0xb50>
    {
      if (ilim < 0 || cmp (b, S = multadd (ptr, S, 5, 0)) <= 0)
   152ec:	01812783          	lw	a5,24(sp)
   152f0:	3e079863          	bnez	a5,156e0 <_dtoa_r+0x1388>
   152f4:	000b0593          	mv	a1,s6
   152f8:	00000693          	li	a3,0
   152fc:	00500613          	li	a2,5
   15300:	00040513          	mv	a0,s0
   15304:	6a9010ef          	jal	171ac <__multadd>
   15308:	00050593          	mv	a1,a0
   1530c:	00050b13          	mv	s6,a0
   15310:	00048513          	mv	a0,s1
   15314:	684020ef          	jal	17998 <__mcmp>
   15318:	00912e23          	sw	s1,28(sp)
   1531c:	e8a05ce3          	blez	a0,151b4 <_dtoa_r+0xe5c>
	  k = -1 - ndigits;
	  goto ret;
	}
    one_digit:
      *s++ = '1';
      k++;
   15320:	01012703          	lw	a4,16(sp)
	no_digits:
	  k = -1 - ndigits;
	  goto ret;
	}
    one_digit:
      *s++ = '1';
   15324:	03100793          	li	a5,49
   15328:	001d0c93          	addi	s9,s10,1
      k++;
   1532c:	00170713          	addi	a4,a4,1
	no_digits:
	  k = -1 - ndigits;
	  goto ret;
	}
    one_digit:
      *s++ = '1';
   15330:	00fd0023          	sb	a5,0(s10)
      k++;
   15334:	00e12823          	sw	a4,16(sp)
      goto ret;
   15338:	e89ff06f          	j	151c0 <_dtoa_r+0xe68>
      if (ndigits <= 0)
	ndigits = 1;
      ilim = ilim1 = i = ndigits;
      break;
    case 3:
      leftright = 0;
   1533c:	02012023          	sw	zero,32(sp)
   15340:	b08ff06f          	j	14648 <_dtoa_r+0x2f0>
    {
    roundoff:
      while (*--s == '9')
	if (s == s0)
	  {
	    k++;
   15344:	01012703          	lw	a4,16(sp)
	    *s++ = '1';
   15348:	03100793          	li	a5,49
   1534c:	00fd0023          	sb	a5,0(s10)
    {
    roundoff:
      while (*--s == '9')
	if (s == s0)
	  {
	    k++;
   15350:	00170713          	addi	a4,a4,1
   15354:	00e12823          	sw	a4,16(sp)
	    *s++ = '1';
	    goto ret;
   15358:	d89ff06f          	j	150e0 <_dtoa_r+0xd88>
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   1535c:	00048513          	mv	a0,s1
   15360:	2d8060ef          	jal	1b638 <__floatsidf>
   15364:	00090613          	mv	a2,s2
   15368:	00098693          	mv	a3,s3
   1536c:	479050ef          	jal	1afe4 <__muldf3>
   15370:	85c1a683          	lw	a3,-1956(gp) # 4803c <__wctomb+0x3c>
   15374:	8581a603          	lw	a2,-1960(gp) # 48038 <__wctomb+0x38>
   15378:	3c1050ef          	jal	1af38 <__adddf3>
      word0 (eps) -= (P - 1) * Exp_msk1;
   1537c:	fcc006b7          	lui	a3,0xfcc00
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   15380:	00050713          	mv	a4,a0
      word0 (eps) -= (P - 1) * Exp_msk1;
   15384:	00b687b3          	add	a5,a3,a1
      if (ilim == 0)
	{
	  S = mhi = 0;
	  d.d -= 5.;
   15388:	8601a603          	lw	a2,-1952(gp) # 48040 <__wctomb+0x40>
   1538c:	8641a683          	lw	a3,-1948(gp) # 48044 <__wctomb+0x44>
   15390:	00090513          	mv	a0,s2
   15394:	00098593          	mv	a1,s3
   15398:	00e12423          	sw	a4,8(sp)
   1539c:	00f12223          	sw	a5,4(sp)
   153a0:	3e9050ef          	jal	1af88 <__subdf3>
	  if (d.d > eps.d)
   153a4:	00812703          	lw	a4,8(sp)
   153a8:	00412783          	lw	a5,4(sp)
      eps.d = ieps * d.d + 7.;
      word0 (eps) -= (P - 1) * Exp_msk1;
      if (ilim == 0)
	{
	  S = mhi = 0;
	  d.d -= 5.;
   153ac:	00050913          	mv	s2,a0
	  if (d.d > eps.d)
   153b0:	00070613          	mv	a2,a4
   153b4:	00078693          	mv	a3,a5
      eps.d = ieps * d.d + 7.;
      word0 (eps) -= (P - 1) * Exp_msk1;
      if (ilim == 0)
	{
	  S = mhi = 0;
	  d.d -= 5.;
   153b8:	00058993          	mv	s3,a1
	  if (d.d > eps.d)
   153bc:	1c0060ef          	jal	1b57c <__gtdf2>
   153c0:	00812703          	lw	a4,8(sp)
   153c4:	00412783          	lw	a5,4(sp)
   153c8:	16a04863          	bgtz	a0,15538 <_dtoa_r+0x11e0>
	    goto one_digit;
	  if (d.d < -eps.d)
   153cc:	00070613          	mv	a2,a4
   153d0:	80000737          	lui	a4,0x80000
   153d4:	00f746b3          	xor	a3,a4,a5
   153d8:	00090513          	mv	a0,s2
   153dc:	00098593          	mv	a1,s3
   153e0:	1fc060ef          	jal	1b5dc <__ltdf2>
   153e4:	04055e63          	bgez	a0,15440 <_dtoa_r+0x10e8>
    {
      /* Yes. */
      ds = tens[k];
      if (ndigits < 0 && ilim <= 0)
	{
	  S = mhi = 0;
   153e8:	00000b13          	li	s6,0
   153ec:	00000a13          	li	s4,0
   153f0:	dc5ff06f          	j	151b4 <_dtoa_r+0xe5c>
	    }
         if ((j = b5 - m5) != 0)
	    b = pow5mult (ptr, b, j);
	}
      else
	b = pow5mult (ptr, b, b5);
   153f4:	00048593          	mv	a1,s1
   153f8:	000b0613          	mv	a2,s6
   153fc:	00040513          	mv	a0,s0
   15400:	310020ef          	jal	17710 <__pow5mult>
   15404:	00050493          	mv	s1,a0
   15408:	945ff06f          	j	14d4c <_dtoa_r+0x9f4>
   1540c:	000d0513          	mv	a0,s10
   15410:	820ff06f          	j	14430 <_dtoa_r+0xd8>

  /* Round off last digit */

  b = lshift (ptr, b, 1);
  j = cmp (b, S);
  if ((j > 0) || ((j == 0) && (dig & 1)))
   15414:	00051663          	bnez	a0,15420 <_dtoa_r+0x10c8>
   15418:	001bfb93          	andi	s7,s7,1
   1541c:	c80b9ee3          	bnez	s7,150b8 <_dtoa_r+0xd60>
	  }
      ++*s++;
    }
  else
    {
      while (*--s == '0');
   15420:	03000693          	li	a3,48
   15424:	0080006f          	j	1542c <_dtoa_r+0x10d4>
   15428:	00070c93          	mv	s9,a4
   1542c:	fffcc783          	lbu	a5,-1(s9)
   15430:	fffc8713          	addi	a4,s9,-1
   15434:	fed78ae3          	beq	a5,a3,15428 <_dtoa_r+0x10d0>
   15438:	ca9ff06f          	j	150e0 <_dtoa_r+0xd88>
   1543c:	04012a83          	lw	s5,64(sp)
#ifndef No_leftright
	}
#endif
    fast_failed:
      s = s0;
      d.d = d2.d;
   15440:	03012903          	lw	s2,48(sp)
   15444:	03412983          	lw	s3,52(sp)
   15448:	e40ff06f          	j	14a88 <_dtoa_r+0x730>
		ieps++;
		ds *= bigtens[i];
	      }
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
   1544c:	01012703          	lw	a4,16(sp)
   15450:	03012903          	lw	s2,48(sp)
   15454:	03412983          	lw	s3,52(sp)
   15458:	40e00a33          	neg	s4,a4

      i = 0;
      d2.d = d.d;
      k0 = k;
      ilim0 = ilim;
      ieps = 2;			/* conservative */
   1545c:	00200493          	li	s1,2
		ieps++;
		ds *= bigtens[i];
	      }
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
   15460:	b20a0463          	beqz	s4,14788 <_dtoa_r+0x430>
	{
	  d.d *= tens[j1 & 0xf];
   15464:	00fa7793          	andi	a5,s4,15
   15468:	00379713          	slli	a4,a5,0x3
   1546c:	0001d7b7          	lui	a5,0x1d
   15470:	a2878793          	addi	a5,a5,-1496 # 1ca28 <__mprec_tens>
   15474:	00f707b3          	add	a5,a4,a5
   15478:	0007a603          	lw	a2,0(a5)
   1547c:	0047a683          	lw	a3,4(a5)
   15480:	00090513          	mv	a0,s2
   15484:	00098593          	mv	a1,s3
   15488:	35d050ef          	jal	1afe4 <__muldf3>
	  for (j = j1 >> 4; j; j >>= 1, i++)
   1548c:	404a5a13          	srai	s4,s4,0x4
	      }
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
	{
	  d.d *= tens[j1 & 0xf];
   15490:	00050913          	mv	s2,a0
   15494:	00058993          	mv	s3,a1
	  for (j = j1 >> 4; j; j >>= 1, i++)
   15498:	ae0a0863          	beqz	s4,14788 <_dtoa_r+0x430>
   1549c:	0001dc37          	lui	s8,0x1d
   154a0:	b18c0c13          	addi	s8,s8,-1256 # 1cb18 <__mprec_bigtens>
	    if (j & 1)
   154a4:	001a7793          	andi	a5,s4,1
	      {
		ieps++;
		d.d *= bigtens[i];
   154a8:	00090513          	mv	a0,s2
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
	{
	  d.d *= tens[j1 & 0xf];
	  for (j = j1 >> 4; j; j >>= 1, i++)
   154ac:	401a5a13          	srai	s4,s4,0x1
	    if (j & 1)
	      {
		ieps++;
		d.d *= bigtens[i];
   154b0:	00098593          	mv	a1,s3
	}
      else if ((j1 = -k) != 0)
	{
	  d.d *= tens[j1 & 0xf];
	  for (j = j1 >> 4; j; j >>= 1, i++)
	    if (j & 1)
   154b4:	00078e63          	beqz	a5,154d0 <_dtoa_r+0x1178>
	      {
		ieps++;
		d.d *= bigtens[i];
   154b8:	000c2603          	lw	a2,0(s8)
   154bc:	004c2683          	lw	a3,4(s8)
	{
	  d.d *= tens[j1 & 0xf];
	  for (j = j1 >> 4; j; j >>= 1, i++)
	    if (j & 1)
	      {
		ieps++;
   154c0:	00148493          	addi	s1,s1,1
		d.d *= bigtens[i];
   154c4:	321050ef          	jal	1afe4 <__muldf3>
   154c8:	00050913          	mv	s2,a0
   154cc:	00058993          	mv	s3,a1
   154d0:	008c0c13          	addi	s8,s8,8
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
	{
	  d.d *= tens[j1 & 0xf];
	  for (j = j1 >> 4; j; j >>= 1, i++)
   154d4:	fc0a18e3          	bnez	s4,154a4 <_dtoa_r+0x114c>
   154d8:	ab0ff06f          	j	14788 <_dtoa_r+0x430>
		bump_up:
		  while (*--s == '9')
		    if (s == s0)
		      {
			k++;
			*s = '0';
   154dc:	03000713          	li	a4,48
   154e0:	00ed0023          	sb	a4,0(s10)
		{
		bump_up:
		  while (*--s == '9')
		    if (s == s0)
		      {
			k++;
   154e4:	01012703          	lw	a4,16(sp)
   154e8:	fffcca03          	lbu	s4,-1(s9)
   154ec:	00170713          	addi	a4,a4,1 # 80000001 <_gp+0x7ffb7821>
   154f0:	00e12823          	sw	a4,16(sp)
			*s = '0';
			break;
   154f4:	f54ff06f          	j	14c48 <_dtoa_r+0x8f0>
       */

      mlo = mhi;
      if (spec_case)
	{
	  mhi = Balloc (ptr, mhi->_k);
   154f8:	004a2583          	lw	a1,4(s4)
   154fc:	00040513          	mv	a0,s0
   15500:	3e5010ef          	jal	170e4 <_Balloc>
	  Bcopy (mhi, mlo);
   15504:	010a2603          	lw	a2,16(s4)
       */

      mlo = mhi;
      if (spec_case)
	{
	  mhi = Balloc (ptr, mhi->_k);
   15508:	00050a93          	mv	s5,a0
	  Bcopy (mhi, mlo);
   1550c:	00ca0593          	addi	a1,s4,12
   15510:	00260613          	addi	a2,a2,2
   15514:	00261613          	slli	a2,a2,0x2
   15518:	00c50513          	addi	a0,a0,12
   1551c:	1c5010ef          	jal	16ee0 <memcpy>
	  mhi = lshift (ptr, mhi, Log2P);
   15520:	00100613          	li	a2,1
   15524:	000a8593          	mv	a1,s5
   15528:	00040513          	mv	a0,s0
   1552c:	31c020ef          	jal	17848 <__lshift>
   15530:	00050c13          	mv	s8,a0
   15534:	99dff06f          	j	14ed0 <_dtoa_r+0xb78>
	}
      eps.d = ieps * d.d + 7.;
      word0 (eps) -= (P - 1) * Exp_msk1;
      if (ilim == 0)
	{
	  S = mhi = 0;
   15538:	00000b13          	li	s6,0
   1553c:	00000a13          	li	s4,0
   15540:	de1ff06f          	j	15320 <_dtoa_r+0xfc8>
	}
      else
	{
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
   15544:	fff48613          	addi	a2,s1,-1
   15548:	0001d6b7          	lui	a3,0x1d
   1554c:	02c12c23          	sw	a2,56(sp)
   15550:	a2868693          	addi	a3,a3,-1496 # 1ca28 <__mprec_tens>
   15554:	00361613          	slli	a2,a2,0x3
   15558:	00d606b3          	add	a3,a2,a3
   1555c:	0006a503          	lw	a0,0(a3)
   15560:	0046a583          	lw	a1,4(a3)
   15564:	00070613          	mv	a2,a4
   15568:	00078693          	mv	a3,a5
   1556c:	279050ef          	jal	1afe4 <__muldf3>
   15570:	04a12023          	sw	a0,64(sp)
   15574:	04b12223          	sw	a1,68(sp)
	  for (i = 1;; i++, d.d *= 10.)
	    {
	      L = d.d;
   15578:	00090513          	mv	a0,s2
   1557c:	00098593          	mv	a1,s3
   15580:	200060ef          	jal	1b780 <__fixdfsi>
   15584:	00050c13          	mv	s8,a0
	      d.d -= L;
   15588:	0b0060ef          	jal	1b638 <__floatsidf>
   1558c:	00058693          	mv	a3,a1
   15590:	00050613          	mv	a2,a0
   15594:	00098593          	mv	a1,s3
   15598:	00090513          	mv	a0,s2
   1559c:	1ed050ef          	jal	1af88 <__subdf3>
	      *s++ = '0' + (int) L;
   155a0:	030c0c13          	addi	s8,s8,48
	      if (i == ilim)
   155a4:	00100693          	li	a3,1
	  eps.d *= tens[ilim - 1];
	  for (i = 1;; i++, d.d *= 10.)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
   155a8:	001d0c93          	addi	s9,s10,1
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
	  for (i = 1;; i++, d.d *= 10.)
	    {
	      L = d.d;
	      d.d -= L;
   155ac:	00050713          	mv	a4,a0
   155b0:	00058793          	mv	a5,a1
	      *s++ = '0' + (int) L;
   155b4:	018d0023          	sb	s8,0(s10)
	      if (i == ilim)
   155b8:	06d48a63          	beq	s1,a3,1562c <_dtoa_r+0x12d4>
   155bc:	009d04b3          	add	s1,s10,s1
   155c0:	000c8c13          	mv	s8,s9
   155c4:	000a8993          	mv	s3,s5
      else
	{
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
	  for (i = 1;; i++, d.d *= 10.)
   155c8:	85018593          	addi	a1,gp,-1968 # 48030 <__wctomb+0x30>
   155cc:	0005a603          	lw	a2,0(a1)
   155d0:	0045a683          	lw	a3,4(a1)
   155d4:	00070513          	mv	a0,a4
   155d8:	00078593          	mv	a1,a5
   155dc:	209050ef          	jal	1afe4 <__muldf3>
   155e0:	00058a93          	mv	s5,a1
   155e4:	00050a13          	mv	s4,a0
	    {
	      L = d.d;
   155e8:	198060ef          	jal	1b780 <__fixdfsi>
   155ec:	00050913          	mv	s2,a0
	      d.d -= L;
   155f0:	048060ef          	jal	1b638 <__floatsidf>
   155f4:	00050613          	mv	a2,a0
   155f8:	00058693          	mv	a3,a1
   155fc:	000a0513          	mv	a0,s4
   15600:	000a8593          	mv	a1,s5
   15604:	185050ef          	jal	1af88 <__subdf3>
	      *s++ = '0' + (int) L;
   15608:	001c0c13          	addi	s8,s8,1
   1560c:	03090913          	addi	s2,s2,48
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
	  for (i = 1;; i++, d.d *= 10.)
	    {
	      L = d.d;
	      d.d -= L;
   15610:	00050713          	mv	a4,a0
   15614:	00058793          	mv	a5,a1
	      *s++ = '0' + (int) L;
   15618:	ff2c0fa3          	sb	s2,-1(s8)
	      if (i == ilim)
   1561c:	fb8496e3          	bne	s1,s8,155c8 <_dtoa_r+0x1270>
   15620:	03812603          	lw	a2,56(sp)
   15624:	00098a93          	mv	s5,s3
   15628:	00cc8cb3          	add	s9,s9,a2
		{
		  if (d.d > 0.5 + eps.d)
   1562c:	8681a603          	lw	a2,-1944(gp) # 48048 <__wctomb+0x48>
   15630:	86c1a683          	lw	a3,-1940(gp) # 4804c <__wctomb+0x4c>
   15634:	04012503          	lw	a0,64(sp)
   15638:	04412583          	lw	a1,68(sp)
   1563c:	00e12423          	sw	a4,8(sp)
   15640:	00f12223          	sw	a5,4(sp)
   15644:	0f5050ef          	jal	1af38 <__adddf3>
   15648:	00812703          	lw	a4,8(sp)
   1564c:	00412783          	lw	a5,4(sp)
   15650:	00070613          	mv	a2,a4
   15654:	00078693          	mv	a3,a5
   15658:	785050ef          	jal	1b5dc <__ltdf2>
   1565c:	00812703          	lw	a4,8(sp)
   15660:	00412783          	lw	a5,4(sp)
   15664:	10055a63          	bgez	a0,15778 <_dtoa_r+0x1420>
   15668:	04c12703          	lw	a4,76(sp)
   1566c:	fffcca03          	lbu	s4,-1(s9)
   15670:	00e12823          	sw	a4,16(sp)
   15674:	db8ff06f          	j	14c2c <_dtoa_r+0x8d4>
	      *s++ = dig;
	      goto ret;
	    }
	  if (j1 > 0)
	    {
	      if (dig == '9')
   15678:	03900793          	li	a5,57
   1567c:	02012d03          	lw	s10,32(sp)
   15680:	06fb8463          	beq	s7,a5,156e8 <_dtoa_r+0x1390>
		{		/* possible if i == 1 */
		round_9_up:
		  *s++ = '9';
		  goto roundoff;
		}
	      *s++ = dig + 1;
   15684:	00c12703          	lw	a4,12(sp)
   15688:	001b8b93          	addi	s7,s7,1
	      goto ret;
   1568c:	000a0913          	mv	s2,s4
		{		/* possible if i == 1 */
		round_9_up:
		  *s++ = '9';
		  goto roundoff;
		}
	      *s++ = dig + 1;
   15690:	00170c93          	addi	s9,a4,1
   15694:	01770023          	sb	s7,0(a4)
	      goto ret;
   15698:	000c0a13          	mv	s4,s8
   1569c:	00912e23          	sw	s1,28(sp)
   156a0:	a41ff06f          	j	150e0 <_dtoa_r+0xd88>
   156a4:	000a0913          	mv	s2,s4
   156a8:	02012d03          	lw	s10,32(sp)
   156ac:	000c0a13          	mv	s4,s8
   156b0:	9e9ff06f          	j	15098 <_dtoa_r+0xd40>
	      b5 += j;
	      m5 = 0;
	    }
	  if ((i = ilim) < 0)
	    {
	      m2 -= i;
   156b4:	40fa8c33          	sub	s8,s5,a5
	      i = 0;
   156b8:	00000793          	li	a5,0
   156bc:	ddcff06f          	j	14c98 <_dtoa_r+0x940>
   156c0:	00100d93          	li	s11,1
   156c4:	9cdff06f          	j	15090 <_dtoa_r+0xd38>
    {
      if (mode < 2)
	{
	  i =
#ifndef Sudden_Underflow
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
   156c8:	05812703          	lw	a4,88(sp)
   156cc:	03600793          	li	a5,54
   156d0:	000b0c93          	mv	s9,s6
   156d4:	40e787b3          	sub	a5,a5,a4
	    break;
	}
      goto ret1;
    }

  m2 = b2;
   156d8:	000a8c13          	mv	s8,s5
   156dc:	dbcff06f          	j	14c98 <_dtoa_r+0x940>
   156e0:	00912e23          	sw	s1,28(sp)
   156e4:	ad1ff06f          	j	151b4 <_dtoa_r+0xe5c>
	  if (j1 > 0)
	    {
	      if (dig == '9')
		{		/* possible if i == 1 */
		round_9_up:
		  *s++ = '9';
   156e8:	00c12683          	lw	a3,12(sp)
   156ec:	03900793          	li	a5,57
		  goto roundoff;
   156f0:	000a0913          	mv	s2,s4
	  if (j1 > 0)
	    {
	      if (dig == '9')
		{		/* possible if i == 1 */
		round_9_up:
		  *s++ = '9';
   156f4:	00168c93          	addi	s9,a3,1
   156f8:	00f68023          	sb	a5,0(a3)
		  goto roundoff;
   156fc:	000c0a13          	mv	s4,s8
   15700:	00912e23          	sw	s1,28(sp)
   15704:	03900713          	li	a4,57
   15708:	9b5ff06f          	j	150bc <_dtoa_r+0xd64>
	      {
		ieps++;
		d.d *= bigtens[i];
	      }
	}
      if (k_check && d.d < 1. && ilim > 0)
   1570c:	01812703          	lw	a4,24(sp)
   15710:	c40706e3          	beqz	a4,1535c <_dtoa_r+0x1004>
	{
	  if (ilim1 <= 0)
   15714:	02c12783          	lw	a5,44(sp)
   15718:	d2f054e3          	blez	a5,15440 <_dtoa_r+0x10e8>
	    goto fast_failed;
	  ilim = ilim1;
	  k--;
   1571c:	01012703          	lw	a4,16(sp)
	  d.d *= 10.;
   15720:	8501a603          	lw	a2,-1968(gp) # 48030 <__wctomb+0x30>
   15724:	8541a683          	lw	a3,-1964(gp) # 48034 <__wctomb+0x34>
      if (k_check && d.d < 1. && ilim > 0)
	{
	  if (ilim1 <= 0)
	    goto fast_failed;
	  ilim = ilim1;
	  k--;
   15728:	fff70713          	addi	a4,a4,-1
	  d.d *= 10.;
   1572c:	00090513          	mv	a0,s2
   15730:	00098593          	mv	a1,s3
      if (k_check && d.d < 1. && ilim > 0)
	{
	  if (ilim1 <= 0)
	    goto fast_failed;
	  ilim = ilim1;
	  k--;
   15734:	04e12623          	sw	a4,76(sp)
	  d.d *= 10.;
   15738:	0ad050ef          	jal	1afe4 <__muldf3>
   1573c:	00050913          	mv	s2,a0
   15740:	00058993          	mv	s3,a1
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   15744:	00148513          	addi	a0,s1,1
   15748:	6f1050ef          	jal	1b638 <__floatsidf>
   1574c:	00090613          	mv	a2,s2
   15750:	00098693          	mv	a3,s3
   15754:	091050ef          	jal	1afe4 <__muldf3>
   15758:	85c1a683          	lw	a3,-1956(gp) # 4803c <__wctomb+0x3c>
   1575c:	8581a603          	lw	a2,-1960(gp) # 48038 <__wctomb+0x38>
      word0 (eps) -= (P - 1) * Exp_msk1;
   15760:	02c12483          	lw	s1,44(sp)
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   15764:	7d4050ef          	jal	1af38 <__adddf3>
      word0 (eps) -= (P - 1) * Exp_msk1;
   15768:	fcc006b7          	lui	a3,0xfcc00
	  ilim = ilim1;
	  k--;
	  d.d *= 10.;
	  ieps++;
	}
      eps.d = ieps * d.d + 7.;
   1576c:	00050713          	mv	a4,a0
      word0 (eps) -= (P - 1) * Exp_msk1;
   15770:	00b687b3          	add	a5,a3,a1
   15774:	878ff06f          	j	147ec <_dtoa_r+0x494>
	      *s++ = '0' + (int) L;
	      if (i == ilim)
		{
		  if (d.d > 0.5 + eps.d)
		    goto bump_up;
		  else if (d.d < 0.5 - eps.d)
   15778:	04012603          	lw	a2,64(sp)
   1577c:	04412683          	lw	a3,68(sp)
   15780:	8681a503          	lw	a0,-1944(gp) # 48048 <__wctomb+0x48>
   15784:	86c1a583          	lw	a1,-1940(gp) # 4804c <__wctomb+0x4c>
   15788:	00e12423          	sw	a4,8(sp)
   1578c:	00f12223          	sw	a5,4(sp)
   15790:	7f8050ef          	jal	1af88 <__subdf3>
   15794:	00812703          	lw	a4,8(sp)
   15798:	00412783          	lw	a5,4(sp)
   1579c:	00070613          	mv	a2,a4
   157a0:	00078693          	mv	a3,a5
   157a4:	5d9050ef          	jal	1b57c <__gtdf2>
		    {
		      while (*--s == '0');
   157a8:	03000693          	li	a3,48
	      *s++ = '0' + (int) L;
	      if (i == ilim)
		{
		  if (d.d > 0.5 + eps.d)
		    goto bump_up;
		  else if (d.d < 0.5 - eps.d)
   157ac:	00a04663          	bgtz	a0,157b8 <_dtoa_r+0x1460>
   157b0:	c91ff06f          	j	15440 <_dtoa_r+0x10e8>
   157b4:	00070c93          	mv	s9,a4
		    {
		      while (*--s == '0');
   157b8:	fffcc783          	lbu	a5,-1(s9)
   157bc:	fffc8713          	addi	a4,s9,-1
   157c0:	fed78ae3          	beq	a5,a3,157b4 <_dtoa_r+0x145c>
	  for (i = 0;;)
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
	      if (d.d < eps.d)
   157c4:	04c12783          	lw	a5,76(sp)
   157c8:	00f12823          	sw	a5,16(sp)
   157cc:	9e8ff06f          	j	149b4 <_dtoa_r+0x65c>
   157d0:	04c12703          	lw	a4,76(sp)
   157d4:	000a8c93          	mv	s9,s5
   157d8:	00e12823          	sw	a4,16(sp)
   157dc:	c50ff06f          	j	14c2c <_dtoa_r+0x8d4>
	    {
	      if (j1 > 0)
		{
		  b = lshift (ptr, b, 1);
		  j1 = cmp (b, S);
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
   157e0:	a60518e3          	bnez	a0,15250 <_dtoa_r+0xef8>
   157e4:	001bf793          	andi	a5,s7,1
   157e8:	a60784e3          	beqz	a5,15250 <_dtoa_r+0xef8>
   157ec:	a59ff06f          	j	15244 <_dtoa_r+0xeec>
      if (cmp (b, S) < 0)
	{
	  k--;
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
   157f0:	000a0593          	mv	a1,s4
   157f4:	00000693          	li	a3,0
   157f8:	00a00613          	li	a2,10
   157fc:	00040513          	mv	a0,s0
   15800:	1ad010ef          	jal	171ac <__multadd>
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   15804:	02c12783          	lw	a5,44(sp)
      if (cmp (b, S) < 0)
	{
	  k--;
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
   15808:	00050a13          	mv	s4,a0
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   1580c:	02f05663          	blez	a5,15838 <_dtoa_r+0x14e0>
   15810:	00f12c23          	sw	a5,24(sp)
   15814:	e9cff06f          	j	14eb0 <_dtoa_r+0xb58>
   15818:	00200793          	li	a5,2
   1581c:	03b7ce63          	blt	a5,s11,15858 <_dtoa_r+0x1500>
   15820:	02c12703          	lw	a4,44(sp)
   15824:	00e12c23          	sw	a4,24(sp)
   15828:	81dff06f          	j	15044 <_dtoa_r+0xcec>
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
	      if (d.d < eps.d)
		goto ret1;
	      if (1. - d.d < eps.d)
   1582c:	04c12783          	lw	a5,76(sp)
   15830:	00f12823          	sw	a5,16(sp)
   15834:	bf8ff06f          	j	14c2c <_dtoa_r+0x8d4>
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   15838:	00200793          	li	a5,2
   1583c:	03b7c463          	blt	a5,s11,15864 <_dtoa_r+0x150c>
   15840:	02c12783          	lw	a5,44(sp)
   15844:	fcdff06f          	j	15810 <_dtoa_r+0x14b8>
      i -= 4;
      b2 += i;
      m2 += i;
      s2 += i;
    }
  else if (i < 4)
   15848:	e0e78e63          	beq	a5,a4,14e64 <_dtoa_r+0xb0c>
   1584c:	03c00793          	li	a5,60
   15850:	40a78533          	sub	a0,a5,a0
   15854:	f90ff06f          	j	14fe4 <_dtoa_r+0xc8c>
	  if (leftright)
	    mhi = multadd (ptr, mhi, 10, 0);
	  ilim = ilim1;
	}
    }
  if (ilim <= 0 && mode > 2)
   15858:	02c12783          	lw	a5,44(sp)
   1585c:	00f12c23          	sw	a5,24(sp)
   15860:	a8dff06f          	j	152ec <_dtoa_r+0xf94>
   15864:	02c12703          	lw	a4,44(sp)
   15868:	00e12c23          	sw	a4,24(sp)
   1586c:	a81ff06f          	j	152ec <_dtoa_r+0xf94>

00015870 <__sflush_r>:
  register unsigned char *p;
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
   15870:	00c59683          	lh	a3,12(a1)
   directly from __srefill. */
int
_DEFUN(__sflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   15874:	fe010113          	addi	sp,sp,-32
   15878:	00812c23          	sw	s0,24(sp)
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
  if ((flags & __SWR) == 0)
   1587c:	01069713          	slli	a4,a3,0x10
   15880:	01075713          	srli	a4,a4,0x10
   15884:	00877793          	andi	a5,a4,8
   directly from __srefill. */
int
_DEFUN(__sflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   15888:	01312623          	sw	s3,12(sp)
   1588c:	00112e23          	sw	ra,28(sp)
   15890:	00912a23          	sw	s1,20(sp)
   15894:	01212823          	sw	s2,16(sp)
   15898:	00058413          	mv	s0,a1
   1589c:	00050993          	mv	s3,a0
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
  if ((flags & __SWR) == 0)
   158a0:	10079a63          	bnez	a5,159b4 <__sflush_r+0x144>
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
   158a4:	000017b7          	lui	a5,0x1
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   158a8:	0045a703          	lw	a4,4(a1)
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
   158ac:	80078793          	addi	a5,a5,-2048 # 800 <_reset+0x600>
   158b0:	00f6e7b3          	or	a5,a3,a5
   158b4:	00f59623          	sh	a5,12(a1)
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   158b8:	1ce05663          	blez	a4,15a84 <__sflush_r+0x214>
   158bc:	02842803          	lw	a6,40(s0)
   158c0:	0c080a63          	beqz	a6,15994 <__sflush_r+0x124>
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
	  ptr->_errno = 0;
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
   158c4:	01079793          	slli	a5,a5,0x10
   158c8:	0107d793          	srli	a5,a5,0x10
   158cc:	01379693          	slli	a3,a5,0x13
#endif

	  /* Save last errno and set errno to 0, so we can check if a device
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
   158d0:	0009a483          	lw	s1,0(s3)
	  ptr->_errno = 0;
   158d4:	0009a023          	sw	zero,0(s3)
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
   158d8:	1a06dc63          	bgez	a3,15a90 <__sflush_r+0x220>
	    curoff = fp->_offset;
   158dc:	05042603          	lw	a2,80(s0)
   158e0:	05442683          	lw	a3,84(s0)
		  else
		    fp->_flags |= __SERR;
		  return result;
		}
            }
          if (fp->_flags & __SRD)
   158e4:	0047f793          	andi	a5,a5,4
   158e8:	04078263          	beqz	a5,1592c <__sflush_r+0xbc>
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
   158ec:	00442503          	lw	a0,4(s0)
              if (HASUB (fp))
   158f0:	03042703          	lw	a4,48(s0)
            }
          if (fp->_flags & __SRD)
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
   158f4:	40a607b3          	sub	a5,a2,a0
   158f8:	41f55513          	srai	a0,a0,0x1f
   158fc:	00f635b3          	sltu	a1,a2,a5
   15900:	40a686b3          	sub	a3,a3,a0
   15904:	00078613          	mv	a2,a5
   15908:	40b686b3          	sub	a3,a3,a1
              if (HASUB (fp))
   1590c:	02070063          	beqz	a4,1592c <__sflush_r+0xbc>
                curoff -= fp->_ur;
   15910:	03c42503          	lw	a0,60(s0)
   15914:	40a787b3          	sub	a5,a5,a0
   15918:	41f55513          	srai	a0,a0,0x1f
   1591c:	00f63733          	sltu	a4,a2,a5
   15920:	40a686b3          	sub	a3,a3,a0
   15924:	00078613          	mv	a2,a5
   15928:	40e686b3          	sub	a3,a3,a4
#ifdef __LARGE64_FILES
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
   1592c:	01c42583          	lw	a1,28(s0)
   15930:	00000713          	li	a4,0
   15934:	00098513          	mv	a0,s3
   15938:	000800e7          	jalr	a6
	  if (curoff != -1 || ptr->_errno == 0
   1593c:	fff00793          	li	a5,-1
   15940:	0ef50063          	beq	a0,a5,15a20 <__sflush_r+0x1b0>
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   15944:	00c45683          	lhu	a3,12(s0)
   15948:	fffff7b7          	lui	a5,0xfffff
   1594c:	7ff78793          	addi	a5,a5,2047 # fffff7ff <_gp+0xfffb701f>
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   15950:	01042703          	lw	a4,16(s0)
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   15954:	00f6f7b3          	and	a5,a3,a5
   15958:	01079793          	slli	a5,a5,0x10
   1595c:	4107d793          	srai	a5,a5,0x10
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   15960:	00e42023          	sw	a4,0(s0)
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   15964:	01379713          	slli	a4,a5,0x13
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   15968:	00f41623          	sh	a5,12(s0)
#endif
	      fp->_r = 0;
   1596c:	00042223          	sw	zero,4(s0)
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   15970:	10074463          	bltz	a4,15a78 <__sflush_r+0x208>
		fp->_offset = curoff;
	      ptr->_errno = tmp_errno;
	      if (HASUB (fp))
   15974:	03042583          	lw	a1,48(s0)
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
		fp->_offset = curoff;
	      ptr->_errno = tmp_errno;
   15978:	0099a023          	sw	s1,0(s3)
	      if (HASUB (fp))
   1597c:	00058c63          	beqz	a1,15994 <__sflush_r+0x124>
		FREEUB (ptr, fp);
   15980:	04040793          	addi	a5,s0,64
   15984:	00f58663          	beq	a1,a5,15990 <__sflush_r+0x120>
   15988:	00098513          	mv	a0,s3
   1598c:	664000ef          	jal	15ff0 <_free_r>
   15990:	02042823          	sw	zero,48(s0)
	    {
	      fp->_flags |= __SERR;
	      return EOF;
	    }
	}
      return 0;
   15994:	00000513          	li	a0,0
	}
      p += t;
      n -= t;
    }
  return 0;
}
   15998:	01c12083          	lw	ra,28(sp)
   1599c:	01812403          	lw	s0,24(sp)
   159a0:	01412483          	lw	s1,20(sp)
   159a4:	01012903          	lw	s2,16(sp)
   159a8:	00c12983          	lw	s3,12(sp)
   159ac:	02010113          	addi	sp,sp,32
   159b0:	00008067          	ret
	      return EOF;
	    }
	}
      return 0;
    }
  if ((p = fp->_bf._base) == NULL)
   159b4:	0105a903          	lw	s2,16(a1)
   159b8:	fc090ee3          	beqz	s2,15994 <__sflush_r+0x124>
    {
      /* Nothing to flush.  */
      return 0;
    }
  n = fp->_p - p;		/* write this much */
   159bc:	0005a483          	lw	s1,0(a1)
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
   159c0:	00377713          	andi	a4,a4,3
  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
   159c4:	0125a023          	sw	s2,0(a1)
  if ((p = fp->_bf._base) == NULL)
    {
      /* Nothing to flush.  */
      return 0;
    }
  n = fp->_p - p;		/* write this much */
   159c8:	412484b3          	sub	s1,s1,s2
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
   159cc:	00000793          	li	a5,0
   159d0:	00071463          	bnez	a4,159d8 <__sflush_r+0x168>
   159d4:	0145a783          	lw	a5,20(a1)
   159d8:	00f42423          	sw	a5,8(s0)

  while (n > 0)
   159dc:	00904863          	bgtz	s1,159ec <__sflush_r+0x17c>
   159e0:	fb5ff06f          	j	15994 <__sflush_r+0x124>
      if (t <= 0)
	{
          fp->_flags |= __SERR;
          return EOF;
	}
      p += t;
   159e4:	00a90933          	add	s2,s2,a0
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
   159e8:	fa9056e3          	blez	s1,15994 <__sflush_r+0x124>
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
   159ec:	02442783          	lw	a5,36(s0)
   159f0:	01c42583          	lw	a1,28(s0)
   159f4:	00048693          	mv	a3,s1
   159f8:	00090613          	mv	a2,s2
   159fc:	00098513          	mv	a0,s3
   15a00:	000780e7          	jalr	a5
	{
          fp->_flags |= __SERR;
          return EOF;
	}
      p += t;
      n -= t;
   15a04:	40a484b3          	sub	s1,s1,a0
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
      if (t <= 0)
   15a08:	fca04ee3          	bgtz	a0,159e4 <__sflush_r+0x174>
	{
          fp->_flags |= __SERR;
   15a0c:	00c45783          	lhu	a5,12(s0)
          return EOF;
   15a10:	fff00513          	li	a0,-1
  while (n > 0)
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
      if (t <= 0)
	{
          fp->_flags |= __SERR;
   15a14:	0407e793          	ori	a5,a5,64
   15a18:	00f41623          	sh	a5,12(s0)
          return EOF;
   15a1c:	f7dff06f          	j	15998 <__sflush_r+0x128>
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
	  if (curoff != -1 || ptr->_errno == 0
   15a20:	f2a592e3          	bne	a1,a0,15944 <__sflush_r+0xd4>
   15a24:	0009a703          	lw	a4,0(s3)
   15a28:	01d00793          	li	a5,29
   15a2c:	fee7e0e3          	bltu	a5,a4,15a0c <__sflush_r+0x19c>
   15a30:	204007b7          	lui	a5,0x20400
   15a34:	00178793          	addi	a5,a5,1 # 20400001 <_gp+0x203b7821>
   15a38:	00e7d7b3          	srl	a5,a5,a4
   15a3c:	0017f793          	andi	a5,a5,1
   15a40:	fc0786e3          	beqz	a5,15a0c <__sflush_r+0x19c>
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   15a44:	00c45603          	lhu	a2,12(s0)
   15a48:	fffff7b7          	lui	a5,0xfffff
   15a4c:	7ff78793          	addi	a5,a5,2047 # fffff7ff <_gp+0xfffb701f>
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   15a50:	01042683          	lw	a3,16(s0)
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   15a54:	00f677b3          	and	a5,a2,a5
   15a58:	01079793          	slli	a5,a5,0x10
   15a5c:	4107d793          	srai	a5,a5,0x10
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   15a60:	00d42023          	sw	a3,0(s0)
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   15a64:	01379693          	slli	a3,a5,0x13
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   15a68:	00f41623          	sh	a5,12(s0)
#endif
	      fp->_r = 0;
   15a6c:	00042223          	sw	zero,4(s0)
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   15a70:	f006d2e3          	bgez	a3,15974 <__sflush_r+0x104>
   15a74:	f00710e3          	bnez	a4,15974 <__sflush_r+0x104>
		fp->_offset = curoff;
   15a78:	04a42823          	sw	a0,80(s0)
   15a7c:	04b42a23          	sw	a1,84(s0)
   15a80:	ef5ff06f          	j	15974 <__sflush_r+0x104>
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   15a84:	03c5a703          	lw	a4,60(a1)
   15a88:	e2e04ae3          	bgtz	a4,158bc <__sflush_r+0x4c>
   15a8c:	f09ff06f          	j	15994 <__sflush_r+0x124>
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
   15a90:	01c42583          	lw	a1,28(s0)
   15a94:	00000613          	li	a2,0
   15a98:	00000693          	li	a3,0
   15a9c:	00100713          	li	a4,1
   15aa0:	00098513          	mv	a0,s3
   15aa4:	000800e7          	jalr	a6
	      if (curoff == -1L && ptr->_errno != 0)
   15aa8:	fff00793          	li	a5,-1
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
   15aac:	00050613          	mv	a2,a0
   15ab0:	00058693          	mv	a3,a1
	      if (curoff == -1L && ptr->_errno != 0)
   15ab4:	00f50863          	beq	a0,a5,15ac4 <__sflush_r+0x254>
   15ab8:	00c45783          	lhu	a5,12(s0)
   15abc:	02842803          	lw	a6,40(s0)
   15ac0:	e25ff06f          	j	158e4 <__sflush_r+0x74>
   15ac4:	fea59ae3          	bne	a1,a0,15ab8 <__sflush_r+0x248>
   15ac8:	0009a783          	lw	a5,0(s3)
   15acc:	fe0786e3          	beqz	a5,15ab8 <__sflush_r+0x248>
		{
		  int result = EOF;
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
   15ad0:	01d00713          	li	a4,29
   15ad4:	00e78663          	beq	a5,a4,15ae0 <__sflush_r+0x270>
   15ad8:	01600713          	li	a4,22
   15adc:	00e79863          	bne	a5,a4,15aec <__sflush_r+0x27c>
		    {
		      result = 0;
		      ptr->_errno = tmp_errno;
   15ae0:	0099a023          	sw	s1,0(s3)
	      if (curoff == -1L && ptr->_errno != 0)
		{
		  int result = EOF;
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
		    {
		      result = 0;
   15ae4:	00000513          	li	a0,0
		      ptr->_errno = tmp_errno;
   15ae8:	eb1ff06f          	j	15998 <__sflush_r+0x128>
		    }
		  else
		    fp->_flags |= __SERR;
   15aec:	00c45783          	lhu	a5,12(s0)
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
	      if (curoff == -1L && ptr->_errno != 0)
		{
		  int result = EOF;
   15af0:	00058513          	mv	a0,a1
		    {
		      result = 0;
		      ptr->_errno = tmp_errno;
		    }
		  else
		    fp->_flags |= __SERR;
   15af4:	0407e793          	ori	a5,a5,64
   15af8:	00f41623          	sh	a5,12(s0)
   15afc:	e9dff06f          	j	15998 <__sflush_r+0x128>

00015b00 <_fflush_r>:

int
_DEFUN(_fflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   15b00:	fe010113          	addi	sp,sp,-32
   15b04:	00812c23          	sw	s0,24(sp)
   15b08:	00112e23          	sw	ra,28(sp)
   15b0c:	00050413          	mv	s0,a0
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
   15b10:	00050663          	beqz	a0,15b1c <_fflush_r+0x1c>
   15b14:	03852783          	lw	a5,56(a0)
   15b18:	02078a63          	beqz	a5,15b4c <_fflush_r+0x4c>

  if (!fp->_flags)
   15b1c:	00c59783          	lh	a5,12(a1)
   15b20:	00079c63          	bnez	a5,15b38 <_fflush_r+0x38>

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
  _newlib_flockfile_end (fp);
  return ret;
}
   15b24:	01c12083          	lw	ra,28(sp)
   15b28:	00000513          	li	a0,0
   15b2c:	01812403          	lw	s0,24(sp)
   15b30:	02010113          	addi	sp,sp,32
   15b34:	00008067          	ret

  if (!fp->_flags)
    return 0;

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
   15b38:	00040513          	mv	a0,s0
  _newlib_flockfile_end (fp);
  return ret;
}
   15b3c:	01c12083          	lw	ra,28(sp)
   15b40:	01812403          	lw	s0,24(sp)
   15b44:	02010113          	addi	sp,sp,32

  if (!fp->_flags)
    return 0;

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
   15b48:	d29ff06f          	j	15870 <__sflush_r>
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
   15b4c:	00b12623          	sw	a1,12(sp)
   15b50:	360000ef          	jal	15eb0 <__sinit>
   15b54:	00c12583          	lw	a1,12(sp)
   15b58:	fc5ff06f          	j	15b1c <_fflush_r+0x1c>

00015b5c <fflush>:
#ifndef _REENT_ONLY

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
   15b5c:	00050593          	mv	a1,a0
  if (fp == NULL)
   15b60:	00050663          	beqz	a0,15b6c <fflush+0x10>
    return _fwalk_reent (_GLOBAL_REENT, _fflush_r);

  return _fflush_r (_REENT, fp);
   15b64:	8101a503          	lw	a0,-2032(gp) # 47ff0 <_impure_ptr>
   15b68:	f99ff06f          	j	15b00 <_fflush_r>
int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
  if (fp == NULL)
    return _fwalk_reent (_GLOBAL_REENT, _fflush_r);
   15b6c:	80c1a503          	lw	a0,-2036(gp) # 47fec <_global_impure_ptr>
   15b70:	000165b7          	lui	a1,0x16
   15b74:	b0058593          	addi	a1,a1,-1280 # 15b00 <_fflush_r>
   15b78:	0050006f          	j	1637c <_fwalk_reent>

00015b7c <__fp_unlock>:
       FILE * ptr)
{
  _funlockfile (ptr);

  return 0;
}
   15b7c:	00000513          	li	a0,0
   15b80:	00008067          	ret

00015b84 <_cleanup_r>:
  cleanup_func = _fflush_r;
#else
  cleanup_func = _fclose_r;
#endif
#endif
  _CAST_VOID _fwalk_reent (ptr, cleanup_func);
   15b84:	000195b7          	lui	a1,0x19
   15b88:	70c58593          	addi	a1,a1,1804 # 1970c <_fclose_r>
   15b8c:	7f00006f          	j	1637c <_fwalk_reent>

00015b90 <__sinit.part.1>:
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   15b90:	fe010113          	addi	sp,sp,-32
      __sinit_lock_release ();
      return;
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
   15b94:	000167b7          	lui	a5,0x16
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   15b98:	00812c23          	sw	s0,24(sp)
      __sinit_lock_release ();
      return;
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
   15b9c:	b8478793          	addi	a5,a5,-1148 # 15b84 <_cleanup_r>
  s->_stdin = __sfp(s);
  s->_stdout = __sfp(s);
  s->_stderr = __sfp(s);
#endif

  std (s->_stdin,  __SRD, 0, s);
   15ba0:	00452403          	lw	s0,4(a0)
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   15ba4:	00112e23          	sw	ra,28(sp)
   15ba8:	00912a23          	sw	s1,20(sp)
   15bac:	01212823          	sw	s2,16(sp)
   15bb0:	01312623          	sw	s3,12(sp)
   15bb4:	01412423          	sw	s4,8(sp)
   15bb8:	01512223          	sw	s5,4(sp)
   15bbc:	01612023          	sw	s6,0(sp)
      __sinit_lock_release ();
      return;
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
   15bc0:	02f52e23          	sw	a5,60(a0)

  s->__sglue._next = NULL;
#ifndef _REENT_SMALL
  s->__sglue._niobs = 3;
   15bc4:	00300793          	li	a5,3
   15bc8:	2ef52223          	sw	a5,740(a0)
  s->__sglue._iobs = &s->__sf[0];
   15bcc:	2f050713          	addi	a4,a0,752
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   15bd0:	00400793          	li	a5,4
  s->__cleanup = _cleanup_r;	/* conservative */

  s->__sglue._next = NULL;
#ifndef _REENT_SMALL
  s->__sglue._niobs = 3;
  s->__sglue._iobs = &s->__sf[0];
   15bd4:	2ee52423          	sw	a4,744(a0)
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */

  s->__sglue._next = NULL;
   15bd8:	2e052023          	sw	zero,736(a0)
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   15bdc:	00050913          	mv	s2,a0
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   15be0:	00f41623          	sh	a5,12(s0)
  ptr->_flags2 = 0;
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   15be4:	00800613          	li	a2,8
   15be8:	00000593          	li	a1,0
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
  ptr->_p = 0;
   15bec:	00042023          	sw	zero,0(s0)
  ptr->_r = 0;
   15bf0:	00042223          	sw	zero,4(s0)
  ptr->_w = 0;
   15bf4:	00042423          	sw	zero,8(s0)
  ptr->_flags = flags;
  ptr->_flags2 = 0;
   15bf8:	06042423          	sw	zero,104(s0)
  ptr->_file = file;
   15bfc:	00041723          	sh	zero,14(s0)
  ptr->_bf._base = 0;
   15c00:	00042823          	sw	zero,16(s0)
  ptr->_bf._size = 0;
   15c04:	00042a23          	sw	zero,20(s0)
  ptr->_lbfsize = 0;
   15c08:	00042c23          	sw	zero,24(s0)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   15c0c:	06040513          	addi	a0,s0,96
   15c10:	3f0010ef          	jal	17000 <memset>
     requires both stdin and stdout to be line-buffered, but tradition
     leaves stdin alone on systems without fcntl.  */
#ifdef HAVE_FCNTL
  std (s->_stdout, __SWR, 1, s);
#else
  std (s->_stdout, __SWR | __SLBF, 1, s);
   15c14:	00892483          	lw	s1,8(s2)
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   15c18:	00018b37          	lui	s6,0x18
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   15c1c:	00018ab7          	lui	s5,0x18
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   15c20:	00018a37          	lui	s4,0x18
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   15c24:	000189b7          	lui	s3,0x18
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   15c28:	15cb0b13          	addi	s6,s6,348 # 1815c <__sread>
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   15c2c:	1e0a8a93          	addi	s5,s5,480 # 181e0 <__swrite>
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   15c30:	258a0a13          	addi	s4,s4,600 # 18258 <__sseek>
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   15c34:	2c498993          	addi	s3,s3,708 # 182c4 <__sclose>
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   15c38:	00900793          	li	a5,9
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   15c3c:	03642023          	sw	s6,32(s0)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   15c40:	03542223          	sw	s5,36(s0)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   15c44:	03442423          	sw	s4,40(s0)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   15c48:	03342623          	sw	s3,44(s0)
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
   15c4c:	00842e23          	sw	s0,28(s0)
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   15c50:	00f49623          	sh	a5,12(s1)
  ptr->_flags2 = 0;
  ptr->_file = file;
   15c54:	00100793          	li	a5,1
   15c58:	00f49723          	sh	a5,14(s1)
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   15c5c:	00800613          	li	a2,8
   15c60:	00000593          	li	a1,0
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
  ptr->_p = 0;
   15c64:	0004a023          	sw	zero,0(s1)
  ptr->_r = 0;
   15c68:	0004a223          	sw	zero,4(s1)
  ptr->_w = 0;
   15c6c:	0004a423          	sw	zero,8(s1)
  ptr->_flags = flags;
  ptr->_flags2 = 0;
   15c70:	0604a423          	sw	zero,104(s1)
  ptr->_file = file;
  ptr->_bf._base = 0;
   15c74:	0004a823          	sw	zero,16(s1)
  ptr->_bf._size = 0;
   15c78:	0004aa23          	sw	zero,20(s1)
  ptr->_lbfsize = 0;
   15c7c:	0004ac23          	sw	zero,24(s1)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   15c80:	06048513          	addi	a0,s1,96
   15c84:	37c010ef          	jal	17000 <memset>
  std (s->_stdout, __SWR | __SLBF, 1, s);
#endif

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);
   15c88:	00c92403          	lw	s0,12(s2)
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   15c8c:	01200793          	li	a5,18
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   15c90:	0364a023          	sw	s6,32(s1)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   15c94:	0354a223          	sw	s5,36(s1)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   15c98:	0344a423          	sw	s4,40(s1)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   15c9c:	0334a623          	sw	s3,44(s1)
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
   15ca0:	0094ae23          	sw	s1,28(s1)
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   15ca4:	00f41623          	sh	a5,12(s0)
  ptr->_flags2 = 0;
  ptr->_file = file;
   15ca8:	00200793          	li	a5,2
   15cac:	00f41723          	sh	a5,14(s0)
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
  ptr->_p = 0;
   15cb0:	00042023          	sw	zero,0(s0)
  ptr->_r = 0;
   15cb4:	00042223          	sw	zero,4(s0)
  ptr->_w = 0;
   15cb8:	00042423          	sw	zero,8(s0)
  ptr->_flags = flags;
  ptr->_flags2 = 0;
   15cbc:	06042423          	sw	zero,104(s0)
  ptr->_file = file;
  ptr->_bf._base = 0;
   15cc0:	00042823          	sw	zero,16(s0)
  ptr->_bf._size = 0;
   15cc4:	00042a23          	sw	zero,20(s0)
  ptr->_lbfsize = 0;
   15cc8:	00042c23          	sw	zero,24(s0)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   15ccc:	06040513          	addi	a0,s0,96
   15cd0:	00800613          	li	a2,8
   15cd4:	00000593          	li	a1,0
   15cd8:	328010ef          	jal	17000 <memset>
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;

  __sinit_lock_release ();
}
   15cdc:	01c12083          	lw	ra,28(sp)

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;
   15ce0:	00100793          	li	a5,1
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   15ce4:	03642023          	sw	s6,32(s0)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   15ce8:	03542223          	sw	s5,36(s0)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   15cec:	03442423          	sw	s4,40(s0)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   15cf0:	03342623          	sw	s3,44(s0)
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
   15cf4:	00842e23          	sw	s0,28(s0)
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;

  __sinit_lock_release ();
}
   15cf8:	01412483          	lw	s1,20(sp)

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;
   15cfc:	02f92c23          	sw	a5,56(s2)

  __sinit_lock_release ();
}
   15d00:	01812403          	lw	s0,24(sp)
   15d04:	01012903          	lw	s2,16(sp)
   15d08:	00c12983          	lw	s3,12(sp)
   15d0c:	00812a03          	lw	s4,8(sp)
   15d10:	00412a83          	lw	s5,4(sp)
   15d14:	00012b03          	lw	s6,0(sp)
   15d18:	02010113          	addi	sp,sp,32
   15d1c:	00008067          	ret

00015d20 <__fp_lock>:
   15d20:	00000513          	li	a0,0
   15d24:	00008067          	ret

00015d28 <__sfmoreglue>:

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   15d28:	ff010113          	addi	sp,sp,-16
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
   15d2c:	fff58793          	addi	a5,a1,-1

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   15d30:	00812423          	sw	s0,8(sp)
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
   15d34:	00479413          	slli	s0,a5,0x4
   15d38:	00779793          	slli	a5,a5,0x7
   15d3c:	40878433          	sub	s0,a5,s0

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   15d40:	01212023          	sw	s2,0(sp)
   15d44:	00058913          	mv	s2,a1
  struct glue_with_file *g;

  g = (struct glue_with_file *)
   15d48:	08040593          	addi	a1,s0,128

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   15d4c:	00912223          	sw	s1,4(sp)
   15d50:	00112623          	sw	ra,12(sp)
  struct glue_with_file *g;

  g = (struct glue_with_file *)
   15d54:	141000ef          	jal	16694 <_malloc_r>
   15d58:	00050493          	mv	s1,a0
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  if (g == NULL)
   15d5c:	02050063          	beqz	a0,15d7c <__sfmoreglue+0x54>
    return NULL;
  g->glue._next = NULL;
  g->glue._niobs = n;
  g->glue._iobs = &g->file;
   15d60:	01050513          	addi	a0,a0,16

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  if (g == NULL)
    return NULL;
  g->glue._next = NULL;
   15d64:	0004a023          	sw	zero,0(s1)
  g->glue._niobs = n;
   15d68:	0124a223          	sw	s2,4(s1)
  g->glue._iobs = &g->file;
   15d6c:	00a4a423          	sw	a0,8(s1)
  memset (&g->file, 0, n * sizeof (FILE));
   15d70:	07040613          	addi	a2,s0,112
   15d74:	00000593          	li	a1,0
   15d78:	288010ef          	jal	17000 <memset>
  return &g->glue;
}
   15d7c:	00c12083          	lw	ra,12(sp)
   15d80:	00048513          	mv	a0,s1
   15d84:	00812403          	lw	s0,8(sp)
   15d88:	00412483          	lw	s1,4(sp)
   15d8c:	00012903          	lw	s2,0(sp)
   15d90:	01010113          	addi	sp,sp,16
   15d94:	00008067          	ret

00015d98 <__sfp>:
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
   15d98:	fe010113          	addi	sp,sp,-32
   15d9c:	01212823          	sw	s2,16(sp)
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
   15da0:	80c1a903          	lw	s2,-2036(gp) # 47fec <_global_impure_ptr>
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
   15da4:	01312623          	sw	s3,12(sp)
   15da8:	00112e23          	sw	ra,28(sp)
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
   15dac:	03892783          	lw	a5,56(s2)
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
   15db0:	00812c23          	sw	s0,24(sp)
   15db4:	00912a23          	sw	s1,20(sp)
   15db8:	00050993          	mv	s3,a0
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
   15dbc:	00079663          	bnez	a5,15dc8 <__sfp+0x30>
   15dc0:	00090513          	mv	a0,s2
   15dc4:	dcdff0ef          	jal	15b90 <__sinit.part.1>
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
   15dc8:	2e090913          	addi	s2,s2,736
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   15dcc:	fff00493          	li	s1,-1
   15dd0:	00492783          	lw	a5,4(s2)
   15dd4:	00892403          	lw	s0,8(s2)
   15dd8:	fff78793          	addi	a5,a5,-1
   15ddc:	0007da63          	bgez	a5,15df0 <__sfp+0x58>
   15de0:	0840006f          	j	15e64 <__sfp+0xcc>
   15de4:	fff78793          	addi	a5,a5,-1
   15de8:	07040413          	addi	s0,s0,112
   15dec:	06978c63          	beq	a5,s1,15e64 <__sfp+0xcc>
	if (fp->_flags == 0)
   15df0:	00c41703          	lh	a4,12(s0)
   15df4:	fe0718e3          	bnez	a4,15de4 <__sfp+0x4c>
  _newlib_sfp_lock_exit ();
  d->_errno = ENOMEM;
  return NULL;

found:
  fp->_file = -1;		/* no file */
   15df8:	fff00793          	li	a5,-1
   15dfc:	00f41723          	sh	a5,14(s0)
  fp->_flags = 1;		/* reserve this slot; caller sets real flags */
   15e00:	00100793          	li	a5,1
   15e04:	00f41623          	sh	a5,12(s0)
  fp->_flags2 = 0;
   15e08:	06042423          	sw	zero,104(s0)
#ifndef __SINGLE_THREAD__
  __lock_init_recursive (fp->_lock);
#endif
  _newlib_sfp_lock_end ();

  fp->_p = NULL;		/* no current pointer */
   15e0c:	00042023          	sw	zero,0(s0)
  fp->_w = 0;			/* nothing to read or write */
   15e10:	00042423          	sw	zero,8(s0)
  fp->_r = 0;
   15e14:	00042223          	sw	zero,4(s0)
  fp->_bf._base = NULL;		/* no buffer */
   15e18:	00042823          	sw	zero,16(s0)
  fp->_bf._size = 0;
   15e1c:	00042a23          	sw	zero,20(s0)
  fp->_lbfsize = 0;		/* not line buffered */
   15e20:	00042c23          	sw	zero,24(s0)
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
   15e24:	00800613          	li	a2,8
   15e28:	00000593          	li	a1,0
   15e2c:	06040513          	addi	a0,s0,96
   15e30:	1d0010ef          	jal	17000 <memset>
  /* fp->_cookie = <any>; */	/* caller sets cookie, _read/_write etc */
  fp->_ub._base = NULL;		/* no ungetc buffer */
   15e34:	02042823          	sw	zero,48(s0)
  fp->_ub._size = 0;
   15e38:	02042a23          	sw	zero,52(s0)
  fp->_lb._base = NULL;		/* no line buffer */
   15e3c:	04042223          	sw	zero,68(s0)
  fp->_lb._size = 0;
   15e40:	04042423          	sw	zero,72(s0)

  return fp;
   15e44:	00040513          	mv	a0,s0
}
   15e48:	01c12083          	lw	ra,28(sp)
   15e4c:	01812403          	lw	s0,24(sp)
   15e50:	01412483          	lw	s1,20(sp)
   15e54:	01012903          	lw	s2,16(sp)
   15e58:	00c12983          	lw	s3,12(sp)
   15e5c:	02010113          	addi	sp,sp,32
   15e60:	00008067          	ret
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
   15e64:	00092783          	lw	a5,0(s2)
   15e68:	00078663          	beqz	a5,15e74 <__sfp+0xdc>
   15e6c:	00078913          	mv	s2,a5
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
    }
   15e70:	f61ff06f          	j	15dd0 <__sfp+0x38>
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
   15e74:	00400593          	li	a1,4
   15e78:	00098513          	mv	a0,s3
   15e7c:	eadff0ef          	jal	15d28 <__sfmoreglue>
   15e80:	00a92023          	sw	a0,0(s2)
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
   15e84:	00050663          	beqz	a0,15e90 <__sfp+0xf8>
   15e88:	00050913          	mv	s2,a0
   15e8c:	f45ff06f          	j	15dd0 <__sfp+0x38>
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
    }
  _newlib_sfp_lock_exit ();
  d->_errno = ENOMEM;
   15e90:	00c00793          	li	a5,12
   15e94:	00f9a023          	sw	a5,0(s3)
  return NULL;
   15e98:	00000513          	li	a0,0
   15e9c:	fadff06f          	j	15e48 <__sfp+0xb0>

00015ea0 <_cleanup>:
  cleanup_func = _fflush_r;
#else
  cleanup_func = _fclose_r;
#endif
#endif
  _CAST_VOID _fwalk_reent (ptr, cleanup_func);
   15ea0:	80c1a503          	lw	a0,-2036(gp) # 47fec <_global_impure_ptr>
   15ea4:	000195b7          	lui	a1,0x19
   15ea8:	70c58593          	addi	a1,a1,1804 # 1970c <_fclose_r>
   15eac:	4d00006f          	j	1637c <_fwalk_reent>

00015eb0 <__sinit>:
_DEFUN(__sinit, (s),
       struct _reent *s)
{
  __sinit_lock_acquire ();

  if (s->__sdidinit)
   15eb0:	03852783          	lw	a5,56(a0)
   15eb4:	00078463          	beqz	a5,15ebc <__sinit+0xc>
   15eb8:	00008067          	ret
   15ebc:	cd5ff06f          	j	15b90 <__sinit.part.1>

00015ec0 <__sfp_lock_acquire>:
   15ec0:	00008067          	ret

00015ec4 <__sfp_lock_release>:
   15ec4:	00008067          	ret

00015ec8 <__sinit_lock_acquire>:
   15ec8:	00008067          	ret

00015ecc <__sinit_lock_release>:
  __lock_acquire_recursive (__sinit_lock);
}

_VOID
_DEFUN_VOID(__sinit_lock_release)
{
   15ecc:	00008067          	ret

00015ed0 <__fp_lock_all>:
_VOID
_DEFUN_VOID(__fp_lock_all)
{
  __sfp_lock_acquire ();

  _CAST_VOID _fwalk (_REENT, __fp_lock);
   15ed0:	8101a503          	lw	a0,-2032(gp) # 47ff0 <_impure_ptr>
   15ed4:	000165b7          	lui	a1,0x16
   15ed8:	d2058593          	addi	a1,a1,-736 # 15d20 <__fp_lock>
   15edc:	3f00006f          	j	162cc <_fwalk>

00015ee0 <__fp_unlock_all>:
}

_VOID
_DEFUN_VOID(__fp_unlock_all)
{
  _CAST_VOID _fwalk (_REENT, __fp_unlock);
   15ee0:	8101a503          	lw	a0,-2032(gp) # 47ff0 <_impure_ptr>
   15ee4:	000165b7          	lui	a1,0x16
   15ee8:	b7c58593          	addi	a1,a1,-1156 # 15b7c <__fp_unlock>
   15eec:	3e00006f          	j	162cc <_fwalk>

00015ef0 <_malloc_trim_r>:
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
   15ef0:	fe010113          	addi	sp,sp,-32
   15ef4:	01212823          	sw	s2,16(sp)

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;

  top_size = chunksize(top);
   15ef8:	00048937          	lui	s2,0x48
   15efc:	bd890913          	addi	s2,s2,-1064 # 47bd8 <__malloc_av_>
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
   15f00:	00812c23          	sw	s0,24(sp)
   15f04:	00912a23          	sw	s1,20(sp)
   15f08:	00058413          	mv	s0,a1
   15f0c:	01312623          	sw	s3,12(sp)
   15f10:	00112e23          	sw	ra,28(sp)
   15f14:	00050993          	mv	s3,a0
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;
   15f18:	1c4010ef          	jal	170dc <__malloc_lock>

  top_size = chunksize(top);
   15f1c:	00892703          	lw	a4,8(s2)
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
   15f20:	000017b7          	lui	a5,0x1
   15f24:	fef78593          	addi	a1,a5,-17 # fef <_reset+0xdef>

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;

  top_size = chunksize(top);
   15f28:	00472483          	lw	s1,4(a4)
   15f2c:	ffc4f493          	andi	s1,s1,-4
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
   15f30:	40848433          	sub	s0,s1,s0
   15f34:	00b40433          	add	s0,s0,a1
   15f38:	00c45413          	srli	s0,s0,0xc
   15f3c:	fff40413          	addi	s0,s0,-1
   15f40:	00c41413          	slli	s0,s0,0xc

  if (extra < (long)pagesz)  /* Not enough memory to release */
   15f44:	00f44c63          	blt	s0,a5,15f5c <_malloc_trim_r+0x6c>
  }

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
   15f48:	00000513          	li	a0,0
   15f4c:	c74fa0ef          	jal	103c0 <sbrk>
    if (current_brk != (char*)(top) + top_size)
   15f50:	00892783          	lw	a5,8(s2)
   15f54:	009787b3          	add	a5,a5,s1
   15f58:	02f50663          	beq	a0,a5,15f84 <_malloc_trim_r+0x94>
  top_size = chunksize(top);
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;

  if (extra < (long)pagesz)  /* Not enough memory to release */
  {
    MALLOC_UNLOCK;
   15f5c:	00098513          	mv	a0,s3
   15f60:	180010ef          	jal	170e0 <__malloc_unlock>
    return 0;
   15f64:	00000513          	li	a0,0
	MALLOC_UNLOCK;
        return 1;
      }
    }
  }
}
   15f68:	01c12083          	lw	ra,28(sp)
   15f6c:	01812403          	lw	s0,24(sp)
   15f70:	01412483          	lw	s1,20(sp)
   15f74:	01012903          	lw	s2,16(sp)
   15f78:	00c12983          	lw	s3,12(sp)
   15f7c:	02010113          	addi	sp,sp,32
   15f80:	00008067          	ret
      return 0;     /* Apparently we don't own memory; must fail */
    }

    else
    {
      new_brk = (char*)(MORECORE (-extra));
   15f84:	40800533          	neg	a0,s0
   15f88:	c38fa0ef          	jal	103c0 <sbrk>
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
   15f8c:	fff00793          	li	a5,-1
   15f90:	02f50863          	beq	a0,a5,15fc0 <_malloc_trim_r+0xd0>

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
        sbrked_mem -= extra;
   15f94:	8bc1a783          	lw	a5,-1860(gp) # 4809c <__malloc_current_mallinfo>
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
   15f98:	00892683          	lw	a3,8(s2)
   15f9c:	408484b3          	sub	s1,s1,s0
   15fa0:	0014e493          	ori	s1,s1,1
        sbrked_mem -= extra;
   15fa4:	40878433          	sub	s0,a5,s0
        check_chunk(top);
	MALLOC_UNLOCK;
   15fa8:	00098513          	mv	a0,s3
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
   15fac:	0096a223          	sw	s1,4(a3) # fcc00004 <_gp+0xfcbb7824>
        sbrked_mem -= extra;
   15fb0:	8a81ae23          	sw	s0,-1860(gp) # 4809c <__malloc_current_mallinfo>
        check_chunk(top);
	MALLOC_UNLOCK;
   15fb4:	12c010ef          	jal	170e0 <__malloc_unlock>
        return 1;
   15fb8:	00100513          	li	a0,1
   15fbc:	fadff06f          	j	15f68 <_malloc_trim_r+0x78>
      new_brk = (char*)(MORECORE (-extra));
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
   15fc0:	00000513          	li	a0,0
   15fc4:	bfcfa0ef          	jal	103c0 <sbrk>
        top_size = current_brk - (char*)top;
   15fc8:	00892703          	lw	a4,8(s2)
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
   15fcc:	00f00693          	li	a3,15
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
        top_size = current_brk - (char*)top;
   15fd0:	40e507b3          	sub	a5,a0,a4
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
   15fd4:	f8f6d4e3          	ble	a5,a3,15f5c <_malloc_trim_r+0x6c>
        {
          sbrked_mem = current_brk - sbrk_base;
   15fd8:	8181a683          	lw	a3,-2024(gp) # 47ff8 <__malloc_sbrk_base>
          set_head(top, top_size | PREV_INUSE);
   15fdc:	0017e793          	ori	a5,a5,1
   15fe0:	00f72223          	sw	a5,4(a4)
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
        top_size = current_brk - (char*)top;
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
        {
          sbrked_mem = current_brk - sbrk_base;
   15fe4:	40d50533          	sub	a0,a0,a3
   15fe8:	8aa1ae23          	sw	a0,-1860(gp) # 4809c <__malloc_current_mallinfo>
   15fec:	f71ff06f          	j	15f5c <_malloc_trim_r+0x6c>

00015ff0 <_free_r>:
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
   15ff0:	0e058e63          	beqz	a1,160ec <_free_r+0xfc>
#if __STD_C
void fREe(RARG Void_t* mem)
#else
void fREe(RARG mem) RDECL Void_t* mem;
#endif
{
   15ff4:	ff010113          	addi	sp,sp,-16
   15ff8:	00812423          	sw	s0,8(sp)
   15ffc:	00058413          	mv	s0,a1
   16000:	00912223          	sw	s1,4(sp)
   16004:	00112623          	sw	ra,12(sp)
   16008:	00050493          	mv	s1,a0
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
    return;

  MALLOC_LOCK;
   1600c:	0d0010ef          	jal	170dc <__malloc_lock>

  p = mem2chunk(mem);
  hd = p->size;
   16010:	ffc42503          	lw	a0,-4(s0)
  if (mem == 0)                              /* free(0) has no effect */
    return;

  MALLOC_LOCK;

  p = mem2chunk(mem);
   16014:	ff840613          	addi	a2,s0,-8
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
   16018:	000485b7          	lui	a1,0x48
  }
#endif
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
   1601c:	ffe57793          	andi	a5,a0,-2
  next = chunk_at_offset(p, sz);
   16020:	00f606b3          	add	a3,a2,a5
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
   16024:	bd858593          	addi	a1,a1,-1064 # 47bd8 <__malloc_av_>
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
   16028:	0046a703          	lw	a4,4(a3)
  
  if (next == top)                            /* merge with top */
   1602c:	0085a803          	lw	a6,8(a1)
  {
    sz += nextsz;

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
   16030:	00157513          	andi	a0,a0,1
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
   16034:	ffc77713          	andi	a4,a4,-4
  
  if (next == top)                            /* merge with top */
   16038:	15068463          	beq	a3,a6,16180 <_free_r+0x190>
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
    return;
  }

  set_head(next, nextsz);                    /* clear inuse bit */
   1603c:	00e6a223          	sw	a4,4(a3)

  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
   16040:	02051663          	bnez	a0,1606c <_free_r+0x7c>
  {
    prevsz = p->prev_size;
   16044:	ff842503          	lw	a0,-8(s0)
    p = chunk_at_offset(p, -prevsz);
   16048:	40a60633          	sub	a2,a2,a0
    sz += prevsz;
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
   1604c:	00862803          	lw	a6,8(a2)

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
  {
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -prevsz);
    sz += prevsz;
   16050:	00a787b3          	add	a5,a5,a0
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
   16054:	00048537          	lui	a0,0x48
   16058:	be050513          	addi	a0,a0,-1056 # 47be0 <__malloc_av_+0x8>
   1605c:	16a80663          	beq	a6,a0,161c8 <_free_r+0x1d8>
      islr = 1;
    else
      unlink(p, bck, fwd);
   16060:	00c62503          	lw	a0,12(a2)
   16064:	00a82623          	sw	a0,12(a6)
   16068:	01052423          	sw	a6,8(a0)
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
   1606c:	00e68533          	add	a0,a3,a4
   16070:	00452503          	lw	a0,4(a0)
   16074:	00157513          	andi	a0,a0,1
   16078:	0c050a63          	beqz	a0,1614c <_free_r+0x15c>
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   1607c:	0017e693          	ori	a3,a5,1
  set_foot(p, sz);
   16080:	00f60733          	add	a4,a2,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   16084:	00d62223          	sw	a3,4(a2)
  set_foot(p, sz);
   16088:	00f72023          	sw	a5,0(a4)
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   1608c:	1ff00713          	li	a4,511
   16090:	06f76063          	bltu	a4,a5,160f0 <_free_r+0x100>
   16094:	0037d793          	srli	a5,a5,0x3
   16098:	00178713          	addi	a4,a5,1
   1609c:	00371713          	slli	a4,a4,0x3
   160a0:	0045a683          	lw	a3,4(a1)
   160a4:	00e58733          	add	a4,a1,a4
   160a8:	00072803          	lw	a6,0(a4)
   160ac:	4027d793          	srai	a5,a5,0x2
   160b0:	00100513          	li	a0,1
   160b4:	00f517b3          	sll	a5,a0,a5
   160b8:	00d7e7b3          	or	a5,a5,a3
   160bc:	ff870693          	addi	a3,a4,-8
   160c0:	00d62623          	sw	a3,12(a2)
   160c4:	01062423          	sw	a6,8(a2)
   160c8:	00f5a223          	sw	a5,4(a1)
   160cc:	00c72023          	sw	a2,0(a4)
   160d0:	00c82623          	sw	a2,12(a6)

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
   160d4:	00048513          	mv	a0,s1
    frontlink(p, sz, idx, bck, fwd);  

  MALLOC_UNLOCK;

#endif /* MALLOC_PROVIDED */
}
   160d8:	00c12083          	lw	ra,12(sp)
   160dc:	00812403          	lw	s0,8(sp)
   160e0:	00412483          	lw	s1,4(sp)
   160e4:	01010113          	addi	sp,sp,16

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
   160e8:	7f90006f          	j	170e0 <__malloc_unlock>
   160ec:	00008067          	ret


  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   160f0:	0097d713          	srli	a4,a5,0x9
   160f4:	00400693          	li	a3,4
   160f8:	10e6e463          	bltu	a3,a4,16200 <_free_r+0x210>
   160fc:	0067d713          	srli	a4,a5,0x6
   16100:	03970513          	addi	a0,a4,57
   16104:	03870693          	addi	a3,a4,56
   16108:	00151513          	slli	a0,a0,0x1
   1610c:	00251513          	slli	a0,a0,0x2
   16110:	00a58533          	add	a0,a1,a0
   16114:	00052703          	lw	a4,0(a0)
   16118:	ff850513          	addi	a0,a0,-8
   1611c:	0ee50e63          	beq	a0,a4,16218 <_free_r+0x228>
   16120:	00472683          	lw	a3,4(a4)
   16124:	ffc6f693          	andi	a3,a3,-4
   16128:	00d7f663          	bleu	a3,a5,16134 <_free_r+0x144>
   1612c:	00872703          	lw	a4,8(a4)
   16130:	fee518e3          	bne	a0,a4,16120 <_free_r+0x130>
   16134:	00c72503          	lw	a0,12(a4)
   16138:	00a62623          	sw	a0,12(a2)
   1613c:	00e62423          	sw	a4,8(a2)
   16140:	00c52423          	sw	a2,8(a0)
   16144:	00c72623          	sw	a2,12(a4)
   16148:	f8dff06f          	j	160d4 <_free_r+0xe4>
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
   1614c:	0086a503          	lw	a0,8(a3)
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
   16150:	00e787b3          	add	a5,a5,a4
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
   16154:	00048737          	lui	a4,0x48
   16158:	be070713          	addi	a4,a4,-1056 # 47be0 <__malloc_av_+0x8>
   1615c:	0ce50e63          	beq	a0,a4,16238 <_free_r+0x248>
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   16160:	00c6a803          	lw	a6,12(a3)
  }


  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
   16164:	00f60733          	add	a4,a2,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   16168:	0017e693          	ori	a3,a5,1
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   1616c:	01052623          	sw	a6,12(a0)
   16170:	00a82423          	sw	a0,8(a6)
  }


  set_head(p, sz | PREV_INUSE);
   16174:	00d62223          	sw	a3,4(a2)
  set_foot(p, sz);
   16178:	00f72023          	sw	a5,0(a4)
   1617c:	f11ff06f          	j	1608c <_free_r+0x9c>
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
  {
    sz += nextsz;
   16180:	00e787b3          	add	a5,a5,a4

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
   16184:	02051063          	bnez	a0,161a4 <_free_r+0x1b4>
    {
      prevsz = p->prev_size;
   16188:	ff842503          	lw	a0,-8(s0)
      p = chunk_at_offset(p, -prevsz);
   1618c:	40a60633          	sub	a2,a2,a0
      sz += prevsz;
      unlink(p, bck, fwd);
   16190:	00c62703          	lw	a4,12(a2)
   16194:	00862683          	lw	a3,8(a2)

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
    {
      prevsz = p->prev_size;
      p = chunk_at_offset(p, -prevsz);
      sz += prevsz;
   16198:	00a787b3          	add	a5,a5,a0
      unlink(p, bck, fwd);
   1619c:	00e6a623          	sw	a4,12(a3)
   161a0:	00d72423          	sw	a3,8(a4)
    }

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
   161a4:	81c1a703          	lw	a4,-2020(gp) # 47ffc <__malloc_trim_threshold>
      p = chunk_at_offset(p, -prevsz);
      sz += prevsz;
      unlink(p, bck, fwd);
    }

    set_head(p, sz | PREV_INUSE);
   161a8:	0017e693          	ori	a3,a5,1
   161ac:	00d62223          	sw	a3,4(a2)
    top = p;
   161b0:	00c5a423          	sw	a2,8(a1)
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
   161b4:	f2e7e0e3          	bltu	a5,a4,160d4 <_free_r+0xe4>
      malloc_trim(RCALL top_pad); 
   161b8:	8981a583          	lw	a1,-1896(gp) # 48078 <__malloc_top_pad>
   161bc:	00048513          	mv	a0,s1
   161c0:	d31ff0ef          	jal	15ef0 <_malloc_trim_r>
   161c4:	f11ff06f          	j	160d4 <_free_r+0xe4>
      islr = 1;
    else
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
   161c8:	00e685b3          	add	a1,a3,a4
   161cc:	0045a583          	lw	a1,4(a1)
   161d0:	0015f593          	andi	a1,a1,1
   161d4:	0e059263          	bnez	a1,162b8 <_free_r+0x2c8>
   161d8:	0086a583          	lw	a1,8(a3)
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   161dc:	00c6a683          	lw	a3,12(a3)
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
   161e0:	00f707b3          	add	a5,a4,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   161e4:	0017e513          	ori	a0,a5,1
  set_foot(p, sz);
   161e8:	00f60733          	add	a4,a2,a5
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   161ec:	00d5a623          	sw	a3,12(a1)
   161f0:	00b6a423          	sw	a1,8(a3)
  }


  set_head(p, sz | PREV_INUSE);
   161f4:	00a62223          	sw	a0,4(a2)
  set_foot(p, sz);
   161f8:	00f72023          	sw	a5,0(a4)
   161fc:	ed9ff06f          	j	160d4 <_free_r+0xe4>
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   16200:	01400693          	li	a3,20
   16204:	04e6ec63          	bltu	a3,a4,1625c <_free_r+0x26c>
   16208:	05c70513          	addi	a0,a4,92
   1620c:	05b70693          	addi	a3,a4,91
   16210:	00151513          	slli	a0,a0,0x1
   16214:	ef9ff06f          	j	1610c <_free_r+0x11c>
   16218:	0045a783          	lw	a5,4(a1)
   1621c:	4026d713          	srai	a4,a3,0x2
   16220:	00100693          	li	a3,1
   16224:	00e69733          	sll	a4,a3,a4
   16228:	00f76733          	or	a4,a4,a5
   1622c:	00e5a223          	sw	a4,4(a1)
   16230:	00050713          	mv	a4,a0
   16234:	f05ff06f          	j	16138 <_free_r+0x148>
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   16238:	0017e693          	ori	a3,a5,1
  set_foot(p, sz);
   1623c:	00f60733          	add	a4,a2,a5
    sz += nextsz;
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
    {
      islr = 1;
      link_last_remainder(p);   
   16240:	00c5aa23          	sw	a2,20(a1)
   16244:	00c5a823          	sw	a2,16(a1)
   16248:	00a62623          	sw	a0,12(a2)
   1624c:	00a62423          	sw	a0,8(a2)
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   16250:	00d62223          	sw	a3,4(a2)
  set_foot(p, sz);
   16254:	00f72023          	sw	a5,0(a4)
   16258:	e7dff06f          	j	160d4 <_free_r+0xe4>
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   1625c:	05400693          	li	a3,84
   16260:	00e6ec63          	bltu	a3,a4,16278 <_free_r+0x288>
   16264:	00c7d713          	srli	a4,a5,0xc
   16268:	06f70513          	addi	a0,a4,111
   1626c:	06e70693          	addi	a3,a4,110
   16270:	00151513          	slli	a0,a0,0x1
   16274:	e99ff06f          	j	1610c <_free_r+0x11c>
   16278:	15400693          	li	a3,340
   1627c:	00e6ec63          	bltu	a3,a4,16294 <_free_r+0x2a4>
   16280:	00f7d713          	srli	a4,a5,0xf
   16284:	07870513          	addi	a0,a4,120
   16288:	07770693          	addi	a3,a4,119
   1628c:	00151513          	slli	a0,a0,0x1
   16290:	e7dff06f          	j	1610c <_free_r+0x11c>
   16294:	55400813          	li	a6,1364
   16298:	0fe00513          	li	a0,254
   1629c:	07e00693          	li	a3,126
   162a0:	e6e866e3          	bltu	a6,a4,1610c <_free_r+0x11c>
   162a4:	0127d713          	srli	a4,a5,0x12
   162a8:	07d70513          	addi	a0,a4,125
   162ac:	07c70693          	addi	a3,a4,124
   162b0:	00151513          	slli	a0,a0,0x1
   162b4:	e59ff06f          	j	1610c <_free_r+0x11c>
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   162b8:	0017e693          	ori	a3,a5,1
  set_foot(p, sz);
   162bc:	00f60733          	add	a4,a2,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   162c0:	00d62223          	sw	a3,4(a2)
  set_foot(p, sz);
   162c4:	00f72023          	sw	a5,0(a4)
   162c8:	e0dff06f          	j	160d4 <_free_r+0xe4>

000162cc <_fwalk>:

int
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
   162cc:	fe010113          	addi	sp,sp,-32
   162d0:	01512223          	sw	s5,4(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   162d4:	2e050a93          	addi	s5,a0,736

int
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
   162d8:	00112e23          	sw	ra,28(sp)
   162dc:	00812c23          	sw	s0,24(sp)
   162e0:	00912a23          	sw	s1,20(sp)
   162e4:	01212823          	sw	s2,16(sp)
   162e8:	01312623          	sw	s3,12(sp)
   162ec:	01412423          	sw	s4,8(sp)
   162f0:	01612023          	sw	s6,0(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   162f4:	080a8063          	beqz	s5,16374 <_fwalk+0xa8>
   162f8:	00058b13          	mv	s6,a1
   162fc:	00000a13          	li	s4,0
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   16300:	00100993          	li	s3,1
   16304:	fff00913          	li	s2,-1
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   16308:	004aa483          	lw	s1,4(s5)
   1630c:	008aa403          	lw	s0,8(s5)
   16310:	fff48493          	addi	s1,s1,-1
   16314:	0204c663          	bltz	s1,16340 <_fwalk+0x74>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   16318:	00c45783          	lhu	a5,12(s0)
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   1631c:	fff48493          	addi	s1,s1,-1
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   16320:	00f9fc63          	bleu	a5,s3,16338 <_fwalk+0x6c>
   16324:	00e41783          	lh	a5,14(s0)
	ret |= (*function) (fp);
   16328:	00040513          	mv	a0,s0
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   1632c:	01278663          	beq	a5,s2,16338 <_fwalk+0x6c>
	ret |= (*function) (fp);
   16330:	000b00e7          	jalr	s6
   16334:	00aa6a33          	or	s4,s4,a0
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   16338:	07040413          	addi	s0,s0,112
   1633c:	fd249ee3          	bne	s1,s2,16318 <_fwalk+0x4c>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   16340:	000aaa83          	lw	s5,0(s5)
   16344:	fc0a92e3          	bnez	s5,16308 <_fwalk+0x3c>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*function) (fp);

  return ret;
}
   16348:	01c12083          	lw	ra,28(sp)
   1634c:	000a0513          	mv	a0,s4
   16350:	01812403          	lw	s0,24(sp)
   16354:	01412483          	lw	s1,20(sp)
   16358:	01012903          	lw	s2,16(sp)
   1635c:	00c12983          	lw	s3,12(sp)
   16360:	00812a03          	lw	s4,8(sp)
   16364:	00412a83          	lw	s5,4(sp)
   16368:	00012b03          	lw	s6,0(sp)
   1636c:	02010113          	addi	sp,sp,32
   16370:	00008067          	ret
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
  register FILE *fp;
  register int n, ret = 0;
   16374:	00000a13          	li	s4,0
   16378:	fd1ff06f          	j	16348 <_fwalk+0x7c>

0001637c <_fwalk_reent>:
   I/O function (e.g. _fclose_r).  */
int
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
   1637c:	fd010113          	addi	sp,sp,-48
   16380:	01612823          	sw	s6,16(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   16384:	2e050b13          	addi	s6,a0,736
   I/O function (e.g. _fclose_r).  */
int
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
   16388:	02112623          	sw	ra,44(sp)
   1638c:	02812423          	sw	s0,40(sp)
   16390:	02912223          	sw	s1,36(sp)
   16394:	03212023          	sw	s2,32(sp)
   16398:	01312e23          	sw	s3,28(sp)
   1639c:	01412c23          	sw	s4,24(sp)
   163a0:	01512a23          	sw	s5,20(sp)
   163a4:	01712623          	sw	s7,12(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   163a8:	080b0663          	beqz	s6,16434 <_fwalk_reent+0xb8>
   163ac:	00058b93          	mv	s7,a1
   163b0:	00050a93          	mv	s5,a0
   163b4:	00000a13          	li	s4,0
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   163b8:	00100993          	li	s3,1
   163bc:	fff00913          	li	s2,-1
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   163c0:	004b2483          	lw	s1,4(s6)
   163c4:	008b2403          	lw	s0,8(s6)
   163c8:	fff48493          	addi	s1,s1,-1
   163cc:	0204c863          	bltz	s1,163fc <_fwalk_reent+0x80>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   163d0:	00c45783          	lhu	a5,12(s0)
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   163d4:	fff48493          	addi	s1,s1,-1
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   163d8:	00f9fe63          	bleu	a5,s3,163f4 <_fwalk_reent+0x78>
   163dc:	00e41783          	lh	a5,14(s0)
	ret |= (*reent_function) (ptr, fp);
   163e0:	00040593          	mv	a1,s0
   163e4:	000a8513          	mv	a0,s5
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   163e8:	01278663          	beq	a5,s2,163f4 <_fwalk_reent+0x78>
	ret |= (*reent_function) (ptr, fp);
   163ec:	000b80e7          	jalr	s7
   163f0:	00aa6a33          	or	s4,s4,a0
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   163f4:	07040413          	addi	s0,s0,112
   163f8:	fd249ce3          	bne	s1,s2,163d0 <_fwalk_reent+0x54>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   163fc:	000b2b03          	lw	s6,0(s6)
   16400:	fc0b10e3          	bnez	s6,163c0 <_fwalk_reent+0x44>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*reent_function) (ptr, fp);

  return ret;
}
   16404:	02c12083          	lw	ra,44(sp)
   16408:	000a0513          	mv	a0,s4
   1640c:	02812403          	lw	s0,40(sp)
   16410:	02412483          	lw	s1,36(sp)
   16414:	02012903          	lw	s2,32(sp)
   16418:	01c12983          	lw	s3,28(sp)
   1641c:	01812a03          	lw	s4,24(sp)
   16420:	01412a83          	lw	s5,20(sp)
   16424:	01012b03          	lw	s6,16(sp)
   16428:	00c12b83          	lw	s7,12(sp)
   1642c:	03010113          	addi	sp,sp,48
   16430:	00008067          	ret
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
  register FILE *fp;
  register int n, ret = 0;
   16434:	00000a13          	li	s4,0
   16438:	fcdff06f          	j	16404 <_fwalk_reent+0x88>

0001643c <_setlocale_r>:
char *
_DEFUN(_setlocale_r, (p, category, locale),
       struct _reent *p _AND
       int category _AND
       _CONST char *locale)
{
   1643c:	ff010113          	addi	sp,sp,-16
   16440:	00912223          	sw	s1,4(sp)
   16444:	00112623          	sw	ra,12(sp)
   16448:	00812423          	sw	s0,8(sp)
   1644c:	0001d4b7          	lui	s1,0x1d
#ifndef _MB_CAPABLE
  if (locale)
   16450:	02060063          	beqz	a2,16470 <_setlocale_r+0x34>
    { 
      if (strcmp (locale, "POSIX") && strcmp (locale, "C")
   16454:	0001d5b7          	lui	a1,0x1d
   16458:	d4858593          	addi	a1,a1,-696 # 1cd48 <__thenan_sf+0x68>
   1645c:	00060513          	mv	a0,a2
   16460:	00060413          	mv	s0,a2
   16464:	669010ef          	jal	182cc <strcmp>
   16468:	0001d4b7          	lui	s1,0x1d
   1646c:	00051e63          	bnez	a0,16488 <_setlocale_r+0x4c>
	  && strcmp (locale, ""))
        return NULL;
    }
  return "C";
   16470:	d4448513          	addi	a0,s1,-700 # 1cd44 <__thenan_sf+0x64>
	  return NULL;
	}
    }
  return currentlocale ();
#endif /* !_MB_CAPABLE */
}
   16474:	00c12083          	lw	ra,12(sp)
   16478:	00812403          	lw	s0,8(sp)
   1647c:	00412483          	lw	s1,4(sp)
   16480:	01010113          	addi	sp,sp,16
   16484:	00008067          	ret
       _CONST char *locale)
{
#ifndef _MB_CAPABLE
  if (locale)
    { 
      if (strcmp (locale, "POSIX") && strcmp (locale, "C")
   16488:	d4448593          	addi	a1,s1,-700
   1648c:	00040513          	mv	a0,s0
   16490:	63d010ef          	jal	182cc <strcmp>
   16494:	fc050ee3          	beqz	a0,16470 <_setlocale_r+0x34>
	  && strcmp (locale, ""))
   16498:	0001d5b7          	lui	a1,0x1d
   1649c:	d1058593          	addi	a1,a1,-752 # 1cd10 <__thenan_sf+0x30>
   164a0:	00040513          	mv	a0,s0
   164a4:	629010ef          	jal	182cc <strcmp>
   164a8:	fc0504e3          	beqz	a0,16470 <_setlocale_r+0x34>
        return NULL;
   164ac:	00000513          	li	a0,0
   164b0:	fc5ff06f          	j	16474 <_setlocale_r+0x38>

000164b4 <__locale_charset>:
_DEFUN_VOID(__locale_charset)
{
#if 0//def __HAVE_LOCALE_INFO__
  return __get_current_ctype_locale ()->codeset;
#else
  return lc_ctype_charset;
   164b4:	00048537          	lui	a0,0x48
#endif
}
   164b8:	b6050513          	addi	a0,a0,-1184 # 47b60 <lc_ctype_charset>
   164bc:	00008067          	ret

000164c0 <__locale_mb_cur_max>:
#if 0//def __HAVE_LOCALE_INFO__
  return __get_current_ctype_locale ()->mb_cur_max[0];
#else
  return __mb_cur_max;
#endif
}
   164c0:	8141a503          	lw	a0,-2028(gp) # 47ff4 <__mb_cur_max>
   164c4:	00008067          	ret

000164c8 <__locale_msgcharset>:
_DEFUN_VOID(__locale_msgcharset)
{
#ifdef __HAVE_LOCALE_INFO__
  return (char *) __get_current_messages_locale ()->codeset;
#else
  return lc_message_charset;
   164c8:	00048537          	lui	a0,0x48
#endif
}
   164cc:	b8050513          	addi	a0,a0,-1152 # 47b80 <lc_message_charset>
   164d0:	00008067          	ret

000164d4 <__locale_cjk_lang>:

int
_DEFUN_VOID(__locale_cjk_lang)
{
  return lc_ctype_cjk_lang;
}
   164d4:	00000513          	li	a0,0
   164d8:	00008067          	ret

000164dc <_localeconv_r>:
      lconv.int_p_sign_posn = m->p_sign_posn[0];
#endif /* !__HAVE_LOCALE_INFO_EXTENDED__ */
      __mlocale_changed = 0;
    }
#endif /* __HAVE_LOCALE_INFO__ */
  return (struct lconv *) &lconv;
   164dc:	00048537          	lui	a0,0x48
}
   164e0:	ba050513          	addi	a0,a0,-1120 # 47ba0 <lconv>
   164e4:	00008067          	ret

000164e8 <setlocale>:
char *
_DEFUN(setlocale, (category, locale),
       int category _AND
       _CONST char *locale)
{
  return _setlocale_r (_REENT, category, locale);
   164e8:	00058613          	mv	a2,a1
   164ec:	00050593          	mv	a1,a0
   164f0:	8101a503          	lw	a0,-2032(gp) # 47ff0 <_impure_ptr>
   164f4:	f49ff06f          	j	1643c <_setlocale_r>

000164f8 <localeconv>:
#endif /* __CYGWIN__ */

struct lconv *
_DEFUN_VOID(localeconv)
{
  return _localeconv_r (_REENT);
   164f8:	00048537          	lui	a0,0x48
}
   164fc:	ba050513          	addi	a0,a0,-1120 # 47ba0 <lconv>
   16500:	00008067          	ret

00016504 <__smakebuf_r>:
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
   16504:	00c59783          	lh	a5,12(a1)

_VOID
_DEFUN(__smakebuf_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE *fp)
{
   16508:	f7010113          	addi	sp,sp,-144
   1650c:	08912223          	sw	s1,132(sp)
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
   16510:	01079493          	slli	s1,a5,0x10
   16514:	0104d493          	srli	s1,s1,0x10
   16518:	0024f713          	andi	a4,s1,2

_VOID
_DEFUN(__smakebuf_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE *fp)
{
   1651c:	08112623          	sw	ra,140(sp)
   16520:	08812423          	sw	s0,136(sp)
   16524:	09212023          	sw	s2,128(sp)
   16528:	07312e23          	sw	s3,124(sp)
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
   1652c:	0e071063          	bnez	a4,1660c <__smakebuf_r+0x108>
   16530:	00050913          	mv	s2,a0
      return;
    }
#ifdef __USE_INTERNAL_STAT64
  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
   16534:	00e59503          	lh	a0,14(a1)
   16538:	00058413          	mv	s0,a1
   1653c:	04054c63          	bltz	a0,16594 <__smakebuf_r+0x90>
   16540:	00010593          	mv	a1,sp
   16544:	c91f90ef          	jal	101d4 <fstat>
   16548:	04054063          	bltz	a0,16588 <__smakebuf_r+0x84>
      fp->_flags |= __SNPT;
#endif
    }
  else
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
   1654c:	01012703          	lw	a4,16(sp)
   16550:	0000f7b7          	lui	a5,0xf
   16554:	ffffe9b7          	lui	s3,0xffffe
   16558:	00f777b3          	and	a5,a4,a5
   1655c:	013789b3          	add	s3,a5,s3
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
   16560:	00008737          	lui	a4,0x8
      fp->_flags |= __SNPT;
#endif
    }
  else
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
   16564:	0019b993          	seqz	s3,s3
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
   16568:	0ae78e63          	beq	a5,a4,16624 <__smakebuf_r+0x120>
#else
	  fp->_blksize = 1024;
#endif
	}
      else
	fp->_flags |= __SNPT;
   1656c:	00c45703          	lhu	a4,12(s0)
   16570:	000017b7          	lui	a5,0x1
   16574:	80078793          	addi	a5,a5,-2048 # 800 <_reset+0x600>
   16578:	00f767b3          	or	a5,a4,a5
   1657c:	00f41623          	sh	a5,12(s0)
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
#ifdef HAVE_BLKSIZE
      size = st.st_blksize <= 0 ? BUFSIZ : st.st_blksize;
#else
      size = BUFSIZ;
   16580:	40000493          	li	s1,1024
   16584:	0340006f          	j	165b8 <__smakebuf_r+0xb4>
   16588:	00c41783          	lh	a5,12(s0)
   1658c:	01079493          	slli	s1,a5,0x10
   16590:	0104d493          	srli	s1,s1,0x10
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   16594:	01849493          	slli	s1,s1,0x18
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   16598:	00001737          	lui	a4,0x1
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   1659c:	41f4d493          	srai	s1,s1,0x1f
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   165a0:	80070713          	addi	a4,a4,-2048 # 800 <_reset+0x600>
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   165a4:	c404f493          	andi	s1,s1,-960
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   165a8:	00e7e7b3          	or	a5,a5,a4
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   165ac:	40048493          	addi	s1,s1,1024
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   165b0:	00f41623          	sh	a5,12(s0)
  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
#endif
    {
      couldbetty = 0;
   165b4:	00000993          	li	s3,0
	}
      else
	fp->_flags |= __SNPT;
#endif
    }
  if ((p = _malloc_r (ptr, size)) == NULL)
   165b8:	00048593          	mv	a1,s1
   165bc:	00090513          	mv	a0,s2
   165c0:	0d4000ef          	jal	16694 <_malloc_r>
   165c4:	0a050263          	beqz	a0,16668 <__smakebuf_r+0x164>
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
      fp->_flags |= __SMBF;
   165c8:	00c45783          	lhu	a5,12(s0)
	  fp->_bf._size = 1;
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
   165cc:	00016737          	lui	a4,0x16
   165d0:	b8470713          	addi	a4,a4,-1148 # 15b84 <_cleanup_r>
      fp->_flags |= __SMBF;
   165d4:	0807e793          	ori	a5,a5,128
	  fp->_bf._size = 1;
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
   165d8:	02e92e23          	sw	a4,60(s2)
      fp->_flags |= __SMBF;
   165dc:	00f41623          	sh	a5,12(s0)
      fp->_bf._base = fp->_p = (unsigned char *) p;
   165e0:	00a42023          	sw	a0,0(s0)
   165e4:	00a42823          	sw	a0,16(s0)
      fp->_bf._size = size;
   165e8:	00942a23          	sw	s1,20(s0)
      if (couldbetty && _isatty_r (ptr, fp->_file))
   165ec:	06099063          	bnez	s3,1664c <__smakebuf_r+0x148>
	fp->_flags |= __SLBF;
    }
}
   165f0:	08c12083          	lw	ra,140(sp)
   165f4:	08812403          	lw	s0,136(sp)
   165f8:	08412483          	lw	s1,132(sp)
   165fc:	08012903          	lw	s2,128(sp)
   16600:	07c12983          	lw	s3,124(sp)
   16604:	09010113          	addi	sp,sp,144
   16608:	00008067          	ret
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
    {
      fp->_bf._base = fp->_p = fp->_nbuf;
   1660c:	04358793          	addi	a5,a1,67
   16610:	00f5a023          	sw	a5,0(a1)
   16614:	00f5a823          	sw	a5,16(a1)
      fp->_bf._size = 1;
   16618:	00100793          	li	a5,1
   1661c:	00f5aa23          	sw	a5,20(a1)
   16620:	fd1ff06f          	j	165f0 <__smakebuf_r+0xec>
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
   16624:	02842703          	lw	a4,40(s0)
   16628:	000187b7          	lui	a5,0x18
   1662c:	25878793          	addi	a5,a5,600 # 18258 <__sseek>
   16630:	f2f71ee3          	bne	a4,a5,1656c <__smakebuf_r+0x68>
	{
	  fp->_flags |= __SOPT;
   16634:	00c45783          	lhu	a5,12(s0)
#ifdef HAVE_BLKSIZE
	  fp->_blksize = st.st_blksize;
#else
	  fp->_blksize = 1024;
   16638:	40000493          	li	s1,1024
   1663c:	04942623          	sw	s1,76(s0)
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
	{
	  fp->_flags |= __SOPT;
   16640:	0097e7b3          	or	a5,a5,s1
   16644:	00f41623          	sh	a5,12(s0)
#ifdef HAVE_BLKSIZE
	  fp->_blksize = st.st_blksize;
#else
	  fp->_blksize = 1024;
   16648:	f71ff06f          	j	165b8 <__smakebuf_r+0xb4>
    {
      ptr->__cleanup = _cleanup_r;
      fp->_flags |= __SMBF;
      fp->_bf._base = fp->_p = (unsigned char *) p;
      fp->_bf._size = size;
      if (couldbetty && _isatty_r (ptr, fp->_file))
   1664c:	00e41503          	lh	a0,14(s0)
   16650:	bd9f90ef          	jal	10228 <isatty>
   16654:	f8050ee3          	beqz	a0,165f0 <__smakebuf_r+0xec>
	fp->_flags |= __SLBF;
   16658:	00c45783          	lhu	a5,12(s0)
   1665c:	0017e793          	ori	a5,a5,1
   16660:	00f41623          	sh	a5,12(s0)
   16664:	f8dff06f          	j	165f0 <__smakebuf_r+0xec>
	fp->_flags |= __SNPT;
#endif
    }
  if ((p = _malloc_r (ptr, size)) == NULL)
    {
      if (!(fp->_flags & __SSTR))
   16668:	00c41783          	lh	a5,12(s0)
   1666c:	2007f713          	andi	a4,a5,512
   16670:	f80710e3          	bnez	a4,165f0 <__smakebuf_r+0xec>
	{
	  fp->_flags |= __SNBF;
   16674:	0027e793          	ori	a5,a5,2
	  fp->_bf._base = fp->_p = fp->_nbuf;
   16678:	04340713          	addi	a4,s0,67
    }
  if ((p = _malloc_r (ptr, size)) == NULL)
    {
      if (!(fp->_flags & __SSTR))
	{
	  fp->_flags |= __SNBF;
   1667c:	00f41623          	sh	a5,12(s0)
	  fp->_bf._base = fp->_p = fp->_nbuf;
	  fp->_bf._size = 1;
   16680:	00100793          	li	a5,1
  if ((p = _malloc_r (ptr, size)) == NULL)
    {
      if (!(fp->_flags & __SSTR))
	{
	  fp->_flags |= __SNBF;
	  fp->_bf._base = fp->_p = fp->_nbuf;
   16684:	00e42023          	sw	a4,0(s0)
   16688:	00e42823          	sw	a4,16(s0)
	  fp->_bf._size = 1;
   1668c:	00f42a23          	sw	a5,20(s0)
   16690:	f61ff06f          	j	165f0 <__smakebuf_r+0xec>

00016694 <_malloc_r>:
#if __STD_C
Void_t* mALLOc(RARG size_t bytes)
#else
Void_t* mALLOc(RARG bytes) RDECL size_t bytes;
#endif
{
   16694:	fd010113          	addi	sp,sp,-48
   16698:	02912223          	sw	s1,36(sp)
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
   1669c:	01600793          	li	a5,22
   166a0:	00b58493          	addi	s1,a1,11
#if __STD_C
Void_t* mALLOc(RARG size_t bytes)
#else
Void_t* mALLOc(RARG bytes) RDECL size_t bytes;
#endif
{
   166a4:	01312e23          	sw	s3,28(sp)
   166a8:	02112623          	sw	ra,44(sp)
   166ac:	02812423          	sw	s0,40(sp)
   166b0:	03212023          	sw	s2,32(sp)
   166b4:	01412c23          	sw	s4,24(sp)
   166b8:	01512a23          	sw	s5,20(sp)
   166bc:	01612823          	sw	s6,16(sp)
   166c0:	01712623          	sw	s7,12(sp)
   166c4:	01812423          	sw	s8,8(sp)
   166c8:	01912223          	sw	s9,4(sp)
   166cc:	00050993          	mv	s3,a0
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
   166d0:	1a97fc63          	bleu	s1,a5,16888 <_malloc_r+0x1f4>
   166d4:	ff84f493          	andi	s1,s1,-8

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   166d8:	2404c463          	bltz	s1,16920 <_malloc_r+0x28c>
   166dc:	24b4e263          	bltu	s1,a1,16920 <_malloc_r+0x28c>
  {
    RERRNO = ENOMEM;
    return 0;
  }

  MALLOC_LOCK;
   166e0:	1fd000ef          	jal	170dc <__malloc_lock>

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
   166e4:	1f700793          	li	a5,503
   166e8:	7097fa63          	bleu	s1,a5,16dfc <_malloc_r+0x768>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   166ec:	0094d793          	srli	a5,s1,0x9
   166f0:	08000693          	li	a3,128
   166f4:	04000513          	li	a0,64
   166f8:	03f00593          	li	a1,63
   166fc:	22079a63          	bnez	a5,16930 <_malloc_r+0x29c>
    bin = bin_at(idx);
   16700:	00048937          	lui	s2,0x48
   16704:	bd890913          	addi	s2,s2,-1064 # 47bd8 <__malloc_av_>
   16708:	00269693          	slli	a3,a3,0x2
   1670c:	00d906b3          	add	a3,s2,a3

    for (victim = last(bin); victim != bin; victim = victim->bk)
   16710:	0046a403          	lw	s0,4(a3)

  }
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);
   16714:	ff868693          	addi	a3,a3,-8

    for (victim = last(bin); victim != bin; victim = victim->bk)
   16718:	22868a63          	beq	a3,s0,1694c <_malloc_r+0x2b8>
    {
      victim_size = chunksize(victim);
   1671c:	00442783          	lw	a5,4(s0)
      remainder_size = long_sub_size_t(victim_size, nb);
      
      if (remainder_size >= (long)MINSIZE) /* too big */
   16720:	00f00613          	li	a2,15
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
    {
      victim_size = chunksize(victim);
   16724:	ffc7f793          	andi	a5,a5,-4
      remainder_size = long_sub_size_t(victim_size, nb);
   16728:	40978733          	sub	a4,a5,s1
      
      if (remainder_size >= (long)MINSIZE) /* too big */
   1672c:	02e64063          	blt	a2,a4,1674c <_malloc_r+0xb8>
      {
        --idx; /* adjust to rescan below after checking last remainder */
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
   16730:	22075263          	bgez	a4,16954 <_malloc_r+0x2c0>
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
   16734:	00c42403          	lw	s0,12(s0)
   16738:	20868a63          	beq	a3,s0,1694c <_malloc_r+0x2b8>
    {
      victim_size = chunksize(victim);
   1673c:	00442783          	lw	a5,4(s0)
   16740:	ffc7f793          	andi	a5,a5,-4
      remainder_size = long_sub_size_t(victim_size, nb);
   16744:	40978733          	sub	a4,a5,s1
      
      if (remainder_size >= (long)MINSIZE) /* too big */
   16748:	fee654e3          	ble	a4,a2,16730 <_malloc_r+0x9c>
      {
        --idx; /* adjust to rescan below after checking last remainder */
        break;   
   1674c:	00058693          	mv	a3,a1

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
   16750:	01092403          	lw	s0,16(s2)
   16754:	00890813          	addi	a6,s2,8
   16758:	4b040263          	beq	s0,a6,16bfc <_malloc_r+0x568>
  {
    victim_size = chunksize(victim);
   1675c:	00442783          	lw	a5,4(s0)
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
   16760:	00f00613          	li	a2,15

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
  {
    victim_size = chunksize(victim);
   16764:	ffc7f793          	andi	a5,a5,-4
    remainder_size = long_sub_size_t(victim_size, nb);
   16768:	40978733          	sub	a4,a5,s1

    if (remainder_size >= (long)MINSIZE) /* re-split */
   1676c:	44e64a63          	blt	a2,a4,16bc0 <_malloc_r+0x52c>
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
      return chunk2mem(victim);
    }

    clear_last_remainder;
   16770:	01092a23          	sw	a6,20(s2)
   16774:	01092823          	sw	a6,16(s2)

    if (remainder_size >= 0)  /* exhaust */
   16778:	20075663          	bgez	a4,16984 <_malloc_r+0x2f0>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   1677c:	1ff00713          	li	a4,511
   16780:	3cf76e63          	bltu	a4,a5,16b5c <_malloc_r+0x4c8>
   16784:	0037d793          	srli	a5,a5,0x3
   16788:	00178613          	addi	a2,a5,1
   1678c:	00361613          	slli	a2,a2,0x3
   16790:	00492703          	lw	a4,4(s2)
   16794:	00c90633          	add	a2,s2,a2
   16798:	00062503          	lw	a0,0(a2)
   1679c:	4027d793          	srai	a5,a5,0x2
   167a0:	00100593          	li	a1,1
   167a4:	00f597b3          	sll	a5,a1,a5
   167a8:	00e7e7b3          	or	a5,a5,a4
   167ac:	ff860713          	addi	a4,a2,-8
   167b0:	00e42623          	sw	a4,12(s0)
   167b4:	00a42423          	sw	a0,8(s0)
   167b8:	00f92223          	sw	a5,4(s2)
   167bc:	00862023          	sw	s0,0(a2)
   167c0:	00852623          	sw	s0,12(a0)
  /* 
     If there are any possibly nonempty big-enough blocks, 
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks)  
   167c4:	4026d713          	srai	a4,a3,0x2
   167c8:	00100613          	li	a2,1
   167cc:	00e61633          	sll	a2,a2,a4
   167d0:	1cc7ea63          	bltu	a5,a2,169a4 <_malloc_r+0x310>
  {

    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
   167d4:	00f67733          	and	a4,a2,a5
   167d8:	02071463          	bnez	a4,16800 <_malloc_r+0x16c>
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
   167dc:	00161613          	slli	a2,a2,0x1
    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
   167e0:	ffc6f693          	andi	a3,a3,-4
      block <<= 1;
      while ((block & binblocks) == 0)
   167e4:	00f67733          	and	a4,a2,a5
    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
   167e8:	00468693          	addi	a3,a3,4
      block <<= 1;
      while ((block & binblocks) == 0)
   167ec:	00071a63          	bnez	a4,16800 <_malloc_r+0x16c>
      {
        idx += BINBLOCKWIDTH;
        block <<= 1;
   167f0:	00161613          	slli	a2,a2,0x1
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
   167f4:	00f67733          	and	a4,a2,a5
      {
        idx += BINBLOCKWIDTH;
   167f8:	00468693          	addi	a3,a3,4
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
   167fc:	fe070ae3          	beqz	a4,167f0 <_malloc_r+0x15c>
        for (victim = last(bin); victim != bin; victim = victim->bk)
        {
          victim_size = chunksize(victim);
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
   16800:	00f00513          	li	a0,15
      
    /* For each possibly nonempty block ... */
    for (;;)  
    {
      startidx = idx;          /* (track incomplete blocks) */
      q = bin = bin_at(idx);
   16804:	00369893          	slli	a7,a3,0x3
   16808:	012888b3          	add	a7,a7,s2
   1680c:	00088593          	mv	a1,a7
   16810:	00068293          	mv	t0,a3
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
   16814:	00c5a403          	lw	s0,12(a1)
   16818:	00859a63          	bne	a1,s0,1682c <_malloc_r+0x198>
   1681c:	3e80006f          	j	16c04 <_malloc_r+0x570>
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
   16820:	40075463          	bgez	a4,16c28 <_malloc_r+0x594>
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
   16824:	00c42403          	lw	s0,12(s0)
   16828:	3c858e63          	beq	a1,s0,16c04 <_malloc_r+0x570>
        {
          victim_size = chunksize(victim);
   1682c:	00442783          	lw	a5,4(s0)
   16830:	ffc7f793          	andi	a5,a5,-4
          remainder_size = long_sub_size_t(victim_size, nb);
   16834:	40978733          	sub	a4,a5,s1

          if (remainder_size >= (long)MINSIZE) /* split */
   16838:	fee554e3          	ble	a4,a0,16820 <_malloc_r+0x18c>
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
   1683c:	00c42683          	lw	a3,12(s0)
   16840:	00842603          	lw	a2,8(s0)
          victim_size = chunksize(victim);
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
   16844:	009407b3          	add	a5,s0,s1
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
            link_last_remainder(remainder);
            set_head(remainder, remainder_size | PREV_INUSE);
   16848:	00176893          	ori	a7,a4,1
            set_foot(remainder, remainder_size);
   1684c:	00e785b3          	add	a1,a5,a4
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
   16850:	0014e493          	ori	s1,s1,1
   16854:	00942223          	sw	s1,4(s0)
            unlink(victim, bck, fwd);
            link_last_remainder(remainder);
            set_head(remainder, remainder_size | PREV_INUSE);
            set_foot(remainder, remainder_size);
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   16858:	00098513          	mv	a0,s3

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
   1685c:	00d62623          	sw	a3,12(a2)
   16860:	00c6a423          	sw	a2,8(a3)
            link_last_remainder(remainder);
   16864:	00f92a23          	sw	a5,20(s2)
   16868:	00f92823          	sw	a5,16(s2)
   1686c:	0107a623          	sw	a6,12(a5)
   16870:	0107a423          	sw	a6,8(a5)
            set_head(remainder, remainder_size | PREV_INUSE);
   16874:	0117a223          	sw	a7,4(a5)
            set_foot(remainder, remainder_size);
   16878:	00e5a023          	sw	a4,0(a1)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   1687c:	065000ef          	jal	170e0 <__malloc_unlock>
            return chunk2mem(victim);
   16880:	00840513          	addi	a0,s0,8
   16884:	0680006f          	j	168ec <_malloc_r+0x258>
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   16888:	01000493          	li	s1,16
   1688c:	08b4ea63          	bltu	s1,a1,16920 <_malloc_r+0x28c>
  {
    RERRNO = ENOMEM;
    return 0;
  }

  MALLOC_LOCK;
   16890:	04d000ef          	jal	170dc <__malloc_lock>
   16894:	00600793          	li	a5,6
   16898:	00200693          	li	a3,2
  {
    idx = smallbin_index(nb); 

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
   1689c:	00048937          	lui	s2,0x48
   168a0:	bd890913          	addi	s2,s2,-1064 # 47bd8 <__malloc_av_>
   168a4:	00279793          	slli	a5,a5,0x2
   168a8:	00f907b3          	add	a5,s2,a5
    victim = last(q);
   168ac:	0047a403          	lw	s0,4(a5)

#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
   168b0:	ff878713          	addi	a4,a5,-8
   168b4:	36e40263          	beq	s0,a4,16c18 <_malloc_r+0x584>
      victim = last(q);
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
   168b8:	00442783          	lw	a5,4(s0)
      unlink(victim, bck, fwd);
   168bc:	00c42683          	lw	a3,12(s0)
   168c0:	00842603          	lw	a2,8(s0)
      victim = last(q);
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
   168c4:	ffc7f793          	andi	a5,a5,-4
      unlink(victim, bck, fwd);
      set_inuse_bit_at_offset(victim, victim_size);
   168c8:	00f407b3          	add	a5,s0,a5
   168cc:	0047a703          	lw	a4,4(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   168d0:	00098513          	mv	a0,s3
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
      unlink(victim, bck, fwd);
   168d4:	00d62623          	sw	a3,12(a2)
      set_inuse_bit_at_offset(victim, victim_size);
   168d8:	00176713          	ori	a4,a4,1
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
      unlink(victim, bck, fwd);
   168dc:	00c6a423          	sw	a2,8(a3)
      set_inuse_bit_at_offset(victim, victim_size);
   168e0:	00e7a223          	sw	a4,4(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   168e4:	7fc000ef          	jal	170e0 <__malloc_unlock>
      return chunk2mem(victim);
   168e8:	00840513          	addi	a0,s0,8
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
  return chunk2mem(victim);

#endif /* MALLOC_PROVIDED */
}
   168ec:	02c12083          	lw	ra,44(sp)
   168f0:	02812403          	lw	s0,40(sp)
   168f4:	02412483          	lw	s1,36(sp)
   168f8:	02012903          	lw	s2,32(sp)
   168fc:	01c12983          	lw	s3,28(sp)
   16900:	01812a03          	lw	s4,24(sp)
   16904:	01412a83          	lw	s5,20(sp)
   16908:	01012b03          	lw	s6,16(sp)
   1690c:	00c12b83          	lw	s7,12(sp)
   16910:	00812c03          	lw	s8,8(sp)
   16914:	00412c83          	lw	s9,4(sp)
   16918:	03010113          	addi	sp,sp,48
   1691c:	00008067          	ret
  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
  {
    RERRNO = ENOMEM;
   16920:	00c00793          	li	a5,12
   16924:	00f9a023          	sw	a5,0(s3) # ffffe000 <_gp+0xfffb5820>
    return 0;
   16928:	00000513          	li	a0,0
   1692c:	fc1ff06f          	j	168ec <_malloc_r+0x258>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   16930:	00400713          	li	a4,4
   16934:	20f76263          	bltu	a4,a5,16b38 <_malloc_r+0x4a4>
   16938:	0064d593          	srli	a1,s1,0x6
   1693c:	03958513          	addi	a0,a1,57
   16940:	00151693          	slli	a3,a0,0x1
   16944:	03858593          	addi	a1,a1,56
   16948:	db9ff06f          	j	16700 <_malloc_r+0x6c>
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
   1694c:	00050693          	mv	a3,a0
   16950:	e01ff06f          	j	16750 <_malloc_r+0xbc>
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
        set_inuse_bit_at_offset(victim, victim_size);
   16954:	00f407b3          	add	a5,s0,a5
   16958:	0047a703          	lw	a4,4(a5)
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
   1695c:	00c42683          	lw	a3,12(s0)
   16960:	00842603          	lw	a2,8(s0)
        set_inuse_bit_at_offset(victim, victim_size);
   16964:	00176713          	ori	a4,a4,1
        check_malloced_chunk(victim, nb);
	MALLOC_UNLOCK;
   16968:	00098513          	mv	a0,s3
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
   1696c:	00d62623          	sw	a3,12(a2)
   16970:	00c6a423          	sw	a2,8(a3)
        set_inuse_bit_at_offset(victim, victim_size);
   16974:	00e7a223          	sw	a4,4(a5)
        check_malloced_chunk(victim, nb);
	MALLOC_UNLOCK;
   16978:	768000ef          	jal	170e0 <__malloc_unlock>
        return chunk2mem(victim);
   1697c:	00840513          	addi	a0,s0,8
   16980:	f6dff06f          	j	168ec <_malloc_r+0x258>

    clear_last_remainder;

    if (remainder_size >= 0)  /* exhaust */
    {
      set_inuse_bit_at_offset(victim, victim_size);
   16984:	00f407b3          	add	a5,s0,a5
   16988:	0047a703          	lw	a4,4(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   1698c:	00098513          	mv	a0,s3

    clear_last_remainder;

    if (remainder_size >= 0)  /* exhaust */
    {
      set_inuse_bit_at_offset(victim, victim_size);
   16990:	00176713          	ori	a4,a4,1
   16994:	00e7a223          	sw	a4,4(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   16998:	748000ef          	jal	170e0 <__malloc_unlock>
      return chunk2mem(victim);
   1699c:	00840513          	addi	a0,s0,8
   169a0:	f4dff06f          	j	168ec <_malloc_r+0x258>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  remainder_size = long_sub_size_t(chunksize(top), nb);
   169a4:	00892403          	lw	s0,8(s2)
   169a8:	00442a03          	lw	s4,4(s0)
   169ac:	ffca7a93          	andi	s5,s4,-4
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   169b0:	009ae863          	bltu	s5,s1,169c0 <_malloc_r+0x32c>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  remainder_size = long_sub_size_t(chunksize(top), nb);
   169b4:	409a87b3          	sub	a5,s5,s1
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   169b8:	00f00713          	li	a4,15
   169bc:	14f74a63          	blt	a4,a5,16b10 <_malloc_r+0x47c>
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
   169c0:	8981a703          	lw	a4,-1896(gp) # 48078 <__malloc_top_pad>

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
   169c4:	8181a683          	lw	a3,-2024(gp) # 47ff8 <__malloc_sbrk_base>
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
   169c8:	00e48733          	add	a4,s1,a4

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
   169cc:	fff00793          	li	a5,-1
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
   169d0:	01540b33          	add	s6,s0,s5

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
   169d4:	01070a13          	addi	s4,a4,16

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
   169d8:	00f68c63          	beq	a3,a5,169f0 <_malloc_r+0x35c>
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
   169dc:	000016b7          	lui	a3,0x1
   169e0:	00f68a13          	addi	s4,a3,15 # 100f <_reset+0xe0f>
   169e4:	014706b3          	add	a3,a4,s4
   169e8:	fffff737          	lui	a4,0xfffff
   169ec:	00e6fa33          	and	s4,a3,a4

  brk = (char*)(MORECORE (sbrk_size));
   169f0:	000a0513          	mv	a0,s4
   169f4:	9cdf90ef          	jal	103c0 <sbrk>

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
   169f8:	fff00793          	li	a5,-1
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));
   169fc:	00050b93          	mv	s7,a0

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
   16a00:	28f50063          	beq	a0,a5,16c80 <_malloc_r+0x5ec>
   16a04:	27656c63          	bltu	a0,s6,16c7c <_malloc_r+0x5e8>
      (brk < old_end && old_top != initial_top))
    return;

  sbrked_mem += sbrk_size;
   16a08:	8bc18c13          	addi	s8,gp,-1860 # 4809c <__malloc_current_mallinfo>
   16a0c:	000c2703          	lw	a4,0(s8)
   16a10:	00ea0733          	add	a4,s4,a4
   16a14:	00ec2023          	sw	a4,0(s8)

  if (brk == old_end /* can just add bytes to current top, unless
   16a18:	357b0c63          	beq	s6,s7,16d70 <_malloc_r+0x6dc>
    top_size = sbrk_size + old_top_size;
    set_head(top, top_size | PREV_INUSE);
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
   16a1c:	8181a683          	lw	a3,-2024(gp) # 47ff8 <__malloc_sbrk_base>
   16a20:	fff00793          	li	a5,-1
   16a24:	36f68a63          	beq	a3,a5,16d98 <_malloc_r+0x704>
      sbrk_base = brk;
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
   16a28:	416b8b33          	sub	s6,s7,s6
   16a2c:	00eb0733          	add	a4,s6,a4
   16a30:	00ec2023          	sw	a4,0(s8)

    /* Guarantee alignment of first new chunk made from this space */
    front_misalign = (POINTER_UINT)chunk2mem(brk) & MALLOC_ALIGN_MASK;
   16a34:	007bf713          	andi	a4,s7,7
    if (front_misalign > 0) 
   16a38:	000017b7          	lui	a5,0x1
   16a3c:	00070a63          	beqz	a4,16a50 <_malloc_r+0x3bc>
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
      brk += correction;
   16a40:	40eb8bb3          	sub	s7,s7,a4
   16a44:	00878793          	addi	a5,a5,8 # 1008 <_reset+0xe08>
   16a48:	008b8b93          	addi	s7,s7,8
   16a4c:	40e787b3          	sub	a5,a5,a4
    }
    else
      correction = 0;

    /* Guarantee the next brk will be at a page boundary */
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));
   16a50:	00001737          	lui	a4,0x1
   16a54:	fff70713          	addi	a4,a4,-1 # fff <_reset+0xdff>
   16a58:	014b8a33          	add	s4,s7,s4
   16a5c:	00ea7a33          	and	s4,s4,a4
   16a60:	41478a33          	sub	s4,a5,s4

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
   16a64:	000a0513          	mv	a0,s4
   16a68:	959f90ef          	jal	103c0 <sbrk>
    if (new_brk == (char*)(MORECORE_FAILURE))
   16a6c:	fff00793          	li	a5,-1
   16a70:	30f50e63          	beq	a0,a5,16d8c <_malloc_r+0x6f8>
   16a74:	417507b3          	sub	a5,a0,s7
   16a78:	014787b3          	add	a5,a5,s4
   16a7c:	0017e793          	ori	a5,a5,1
	correction = 0;
	correction_failed = 1;
	new_brk = brk;
      }

    sbrked_mem += correction;
   16a80:	000c2703          	lw	a4,0(s8)

    top = (mchunkptr)brk;
   16a84:	01792423          	sw	s7,8(s2)
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);
   16a88:	00fba223          	sw	a5,4(s7)
	correction = 0;
	correction_failed = 1;
	new_brk = brk;
      }

    sbrked_mem += correction;
   16a8c:	00ea0733          	add	a4,s4,a4
   16a90:	00ec2023          	sw	a4,0(s8)

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);

    if (old_top != initial_top)
   16a94:	03240c63          	beq	s0,s2,16acc <_malloc_r+0x438>

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE) 
   16a98:	00f00613          	li	a2,15
   16a9c:	29567263          	bleu	s5,a2,16d20 <_malloc_r+0x68c>
        return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
   16aa0:	00442683          	lw	a3,4(s0)
        set_head(top, PREV_INUSE); /* will force null return from malloc */
        return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
   16aa4:	ff4a8793          	addi	a5,s5,-12
   16aa8:	ff87f793          	andi	a5,a5,-8
      set_head_size(old_top, old_top_size);
   16aac:	0016f693          	andi	a3,a3,1
      chunk_at_offset(old_top, old_top_size          )->size =
   16ab0:	00f405b3          	add	a1,s0,a5
   16ab4:	00500513          	li	a0,5
        return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
   16ab8:	00f6e6b3          	or	a3,a3,a5
   16abc:	00d42223          	sw	a3,4(s0)
      chunk_at_offset(old_top, old_top_size          )->size =
   16ac0:	00a5a223          	sw	a0,4(a1)
        SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
   16ac4:	00a5a423          	sw	a0,8(a1)
        SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE) 
   16ac8:	2cf66c63          	bltu	a2,a5,16da0 <_malloc_r+0x70c>
        fREe(RCALL chunk2mem(old_top));
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem) 
   16acc:	8941a683          	lw	a3,-1900(gp) # 48074 <__malloc_max_sbrked_mem>
   16ad0:	00e6f463          	bleu	a4,a3,16ad8 <_malloc_r+0x444>
    max_sbrked_mem = sbrked_mem;
   16ad4:	88e1aa23          	sw	a4,-1900(gp) # 48074 <__malloc_max_sbrked_mem>
#if HAVE_MMAP
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem) 
    max_total_mem = mmapped_mem + sbrked_mem;
#else
  if ((unsigned long)(sbrked_mem) > (unsigned long)max_total_mem) 
   16ad8:	8901a683          	lw	a3,-1904(gp) # 48070 <__malloc_max_total_mem>
   16adc:	00892403          	lw	s0,8(s2)
   16ae0:	00e6f463          	bleu	a4,a3,16ae8 <_malloc_r+0x454>
    max_total_mem = sbrked_mem;
   16ae4:	88e1a823          	sw	a4,-1904(gp) # 48070 <__malloc_max_total_mem>
   16ae8:	00442703          	lw	a4,4(s0)
   16aec:	ffc77713          	andi	a4,a4,-4
    }
#endif

    /* Try to extend */
    malloc_extend_top(RCALL nb);
    remainder_size = long_sub_size_t(chunksize(top), nb);
   16af0:	409707b3          	sub	a5,a4,s1
    if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   16af4:	00976663          	bltu	a4,s1,16b00 <_malloc_r+0x46c>
   16af8:	00f00713          	li	a4,15
   16afc:	00f74a63          	blt	a4,a5,16b10 <_malloc_r+0x47c>
    {
      MALLOC_UNLOCK;
   16b00:	00098513          	mv	a0,s3
   16b04:	5dc000ef          	jal	170e0 <__malloc_unlock>
      return 0; /* propagate failure */
   16b08:	00000513          	li	a0,0
   16b0c:	de1ff06f          	j	168ec <_malloc_r+0x258>
    }
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
   16b10:	00940733          	add	a4,s0,s1
  set_head(top, remainder_size | PREV_INUSE);
   16b14:	0017e793          	ori	a5,a5,1
      return 0; /* propagate failure */
    }
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
   16b18:	0014e493          	ori	s1,s1,1
   16b1c:	00942223          	sw	s1,4(s0)
  top = chunk_at_offset(victim, nb);
  set_head(top, remainder_size | PREV_INUSE);
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
   16b20:	00098513          	mv	a0,s3
    }
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
   16b24:	00e92423          	sw	a4,8(s2)
  set_head(top, remainder_size | PREV_INUSE);
   16b28:	00f72223          	sw	a5,4(a4)
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
   16b2c:	5b4000ef          	jal	170e0 <__malloc_unlock>
  return chunk2mem(victim);
   16b30:	00840513          	addi	a0,s0,8
   16b34:	db9ff06f          	j	168ec <_malloc_r+0x258>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   16b38:	01400713          	li	a4,20
   16b3c:	10f77e63          	bleu	a5,a4,16c58 <_malloc_r+0x5c4>
   16b40:	05400713          	li	a4,84
   16b44:	1af76063          	bltu	a4,a5,16ce4 <_malloc_r+0x650>
   16b48:	00c4d593          	srli	a1,s1,0xc
   16b4c:	06f58513          	addi	a0,a1,111
   16b50:	00151693          	slli	a3,a0,0x1
   16b54:	06e58593          	addi	a1,a1,110
   16b58:	ba9ff06f          	j	16700 <_malloc_r+0x6c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   16b5c:	0097d713          	srli	a4,a5,0x9
   16b60:	00400613          	li	a2,4
   16b64:	10e67263          	bleu	a4,a2,16c68 <_malloc_r+0x5d4>
   16b68:	01400613          	li	a2,20
   16b6c:	1ee66463          	bltu	a2,a4,16d54 <_malloc_r+0x6c0>
   16b70:	05c70593          	addi	a1,a4,92
   16b74:	05b70613          	addi	a2,a4,91
   16b78:	00159593          	slli	a1,a1,0x1
   16b7c:	00259593          	slli	a1,a1,0x2
   16b80:	00b905b3          	add	a1,s2,a1
   16b84:	0005a703          	lw	a4,0(a1)
   16b88:	ff858593          	addi	a1,a1,-8
   16b8c:	16e58a63          	beq	a1,a4,16d00 <_malloc_r+0x66c>
   16b90:	00472603          	lw	a2,4(a4)
   16b94:	ffc67613          	andi	a2,a2,-4
   16b98:	00c7f663          	bleu	a2,a5,16ba4 <_malloc_r+0x510>
   16b9c:	00872703          	lw	a4,8(a4)
   16ba0:	fee598e3          	bne	a1,a4,16b90 <_malloc_r+0x4fc>
   16ba4:	00c72583          	lw	a1,12(a4)
   16ba8:	00492783          	lw	a5,4(s2)
   16bac:	00b42623          	sw	a1,12(s0)
   16bb0:	00e42423          	sw	a4,8(s0)
   16bb4:	0085a423          	sw	s0,8(a1)
   16bb8:	00872623          	sw	s0,12(a4)
   16bbc:	c09ff06f          	j	167c4 <_malloc_r+0x130>
    victim_size = chunksize(victim);
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
   16bc0:	009407b3          	add	a5,s0,s1
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
   16bc4:	00176613          	ori	a2,a4,1
      set_foot(remainder, remainder_size);
   16bc8:	00e786b3          	add	a3,a5,a4
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
   16bcc:	0014e493          	ori	s1,s1,1
   16bd0:	00942223          	sw	s1,4(s0)
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
      set_foot(remainder, remainder_size);
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   16bd4:	00098513          	mv	a0,s3

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
   16bd8:	00f92a23          	sw	a5,20(s2)
   16bdc:	00f92823          	sw	a5,16(s2)
   16be0:	0107a623          	sw	a6,12(a5)
   16be4:	0107a423          	sw	a6,8(a5)
      set_head(remainder, remainder_size | PREV_INUSE);
   16be8:	00c7a223          	sw	a2,4(a5)
      set_foot(remainder, remainder_size);
   16bec:	00e6a023          	sw	a4,0(a3)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   16bf0:	4f0000ef          	jal	170e0 <__malloc_unlock>
      return chunk2mem(victim);
   16bf4:	00840513          	addi	a0,s0,8
   16bf8:	cf5ff06f          	j	168ec <_malloc_r+0x258>
   16bfc:	00492783          	lw	a5,4(s2)
   16c00:	bc5ff06f          	j	167c4 <_malloc_r+0x130>
         {
           bin = next_bin(bin);
           ++idx;
         }
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
   16c04:	00128293          	addi	t0,t0,1
   16c08:	0032f793          	andi	a5,t0,3
            return chunk2mem(victim);
          }

        }

       bin = next_bin(bin);
   16c0c:	00858593          	addi	a1,a1,8
         {
           bin = next_bin(bin);
           ++idx;
         }
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
   16c10:	c00792e3          	bnez	a5,16814 <_malloc_r+0x180>
   16c14:	0880006f          	j	16c9c <_malloc_r+0x608>
#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
    {
      q = next_bin(q);
      victim = last(q);
   16c18:	00c7a403          	lw	s0,12(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
      return chunk2mem(victim);
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
   16c1c:	00268693          	addi	a3,a3,2
    {
      q = next_bin(q);
      victim = last(q);
    }
#endif
    if (victim != q)
   16c20:	b28788e3          	beq	a5,s0,16750 <_malloc_r+0xbc>
   16c24:	c95ff06f          	j	168b8 <_malloc_r+0x224>
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
   16c28:	00f407b3          	add	a5,s0,a5
   16c2c:	0047a703          	lw	a4,4(a5)
            unlink(victim, bck, fwd);
   16c30:	00c42683          	lw	a3,12(s0)
   16c34:	00842603          	lw	a2,8(s0)
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
   16c38:	00176713          	ori	a4,a4,1
   16c3c:	00e7a223          	sw	a4,4(a5)
            unlink(victim, bck, fwd);
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   16c40:	00098513          	mv	a0,s3
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
            unlink(victim, bck, fwd);
   16c44:	00d62623          	sw	a3,12(a2)
   16c48:	00c6a423          	sw	a2,8(a3)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   16c4c:	494000ef          	jal	170e0 <__malloc_unlock>
            return chunk2mem(victim);
   16c50:	00840513          	addi	a0,s0,8
   16c54:	c99ff06f          	j	168ec <_malloc_r+0x258>
   16c58:	05c78513          	addi	a0,a5,92
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   16c5c:	05b78593          	addi	a1,a5,91
   16c60:	00151693          	slli	a3,a0,0x1
   16c64:	a9dff06f          	j	16700 <_malloc_r+0x6c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   16c68:	0067d613          	srli	a2,a5,0x6
   16c6c:	03960593          	addi	a1,a2,57
   16c70:	00159593          	slli	a1,a1,0x1
   16c74:	03860613          	addi	a2,a2,56
   16c78:	f05ff06f          	j	16b7c <_malloc_r+0x4e8>

  brk = (char*)(MORECORE (sbrk_size));

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
      (brk < old_end && old_top != initial_top))
   16c7c:	d92406e3          	beq	s0,s2,16a08 <_malloc_r+0x374>
   16c80:	00892403          	lw	s0,8(s2)
   16c84:	00442703          	lw	a4,4(s0)
   16c88:	ffc77713          	andi	a4,a4,-4
   16c8c:	e65ff06f          	j	16af0 <_malloc_r+0x45c>
          binblocks &= ~block;
          break;
        }
        --startidx;
       q = prev_bin(q);
      } while (first(q) == q);
   16c90:	0088a783          	lw	a5,8(a7)
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
        {
          binblocks &= ~block;
          break;
        }
        --startidx;
   16c94:	fff68693          	addi	a3,a3,-1
       q = prev_bin(q);
      } while (first(q) == q);
   16c98:	14f89e63          	bne	a7,a5,16df4 <_malloc_r+0x760>

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
   16c9c:	0036f793          	andi	a5,a3,3
        {
          binblocks &= ~block;
          break;
        }
        --startidx;
       q = prev_bin(q);
   16ca0:	ff888893          	addi	a7,a7,-8

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
   16ca4:	fe0796e3          	bnez	a5,16c90 <_malloc_r+0x5fc>
        {
          binblocks &= ~block;
   16ca8:	00492783          	lw	a5,4(s2)
   16cac:	fff64713          	not	a4,a2
   16cb0:	00f777b3          	and	a5,a4,a5
   16cb4:	00f92223          	sw	a5,4(s2)
       q = prev_bin(q);
      } while (first(q) == q);

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
   16cb8:	00161613          	slli	a2,a2,0x1
   16cbc:	cec7e4e3          	bltu	a5,a2,169a4 <_malloc_r+0x310>
   16cc0:	ce0602e3          	beqz	a2,169a4 <_malloc_r+0x310>
      {
        while ((block & binblocks) == 0)
   16cc4:	00f67733          	and	a4,a2,a5
   16cc8:	00028693          	mv	a3,t0
   16ccc:	b2071ce3          	bnez	a4,16804 <_malloc_r+0x170>
        {
          idx += BINBLOCKWIDTH;
          block <<= 1;
   16cd0:	00161613          	slli	a2,a2,0x1

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
   16cd4:	00f67733          	and	a4,a2,a5
        {
          idx += BINBLOCKWIDTH;
   16cd8:	00468693          	addi	a3,a3,4

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
   16cdc:	fe070ae3          	beqz	a4,16cd0 <_malloc_r+0x63c>
   16ce0:	b25ff06f          	j	16804 <_malloc_r+0x170>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   16ce4:	15400713          	li	a4,340
   16ce8:	04f76263          	bltu	a4,a5,16d2c <_malloc_r+0x698>
   16cec:	00f4d593          	srli	a1,s1,0xf
   16cf0:	07858513          	addi	a0,a1,120
   16cf4:	00151693          	slli	a3,a0,0x1
   16cf8:	07758593          	addi	a1,a1,119
   16cfc:	a05ff06f          	j	16700 <_malloc_r+0x6c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   16d00:	00492703          	lw	a4,4(s2)
   16d04:	40265613          	srai	a2,a2,0x2
   16d08:	00100793          	li	a5,1
   16d0c:	00c797b3          	sll	a5,a5,a2
   16d10:	00e7e7b3          	or	a5,a5,a4
   16d14:	00f92223          	sw	a5,4(s2)
   16d18:	00058713          	mv	a4,a1
   16d1c:	e91ff06f          	j	16bac <_malloc_r+0x518>
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE) 
      {
        set_head(top, PREV_INUSE); /* will force null return from malloc */
   16d20:	00100793          	li	a5,1
   16d24:	00fba223          	sw	a5,4(s7)
   16d28:	dd9ff06f          	j	16b00 <_malloc_r+0x46c>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   16d2c:	55400713          	li	a4,1364
   16d30:	0fe00693          	li	a3,254
   16d34:	07f00513          	li	a0,127
   16d38:	07e00593          	li	a1,126
   16d3c:	9cf762e3          	bltu	a4,a5,16700 <_malloc_r+0x6c>
   16d40:	0124d593          	srli	a1,s1,0x12
   16d44:	07d58513          	addi	a0,a1,125
   16d48:	00151693          	slli	a3,a0,0x1
   16d4c:	07c58593          	addi	a1,a1,124
   16d50:	9b1ff06f          	j	16700 <_malloc_r+0x6c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   16d54:	05400613          	li	a2,84
   16d58:	04e66e63          	bltu	a2,a4,16db4 <_malloc_r+0x720>
   16d5c:	00c7d613          	srli	a2,a5,0xc
   16d60:	06f60593          	addi	a1,a2,111
   16d64:	00159593          	slli	a1,a1,0x1
   16d68:	06e60613          	addi	a2,a2,110
   16d6c:	e11ff06f          	j	16b7c <_malloc_r+0x4e8>

  sbrked_mem += sbrk_size;

  if (brk == old_end /* can just add bytes to current top, unless
			previous correction failed */
      && ((POINTER_UINT)old_end & (pagesz - 1)) == 0)
   16d70:	014b1793          	slli	a5,s6,0x14
   16d74:	ca0794e3          	bnez	a5,16a1c <_malloc_r+0x388>
  {
    top_size = sbrk_size + old_top_size;
    set_head(top, top_size | PREV_INUSE);
   16d78:	00892783          	lw	a5,8(s2)
   16d7c:	014a8a33          	add	s4,s5,s4
   16d80:	001a6a13          	ori	s4,s4,1
   16d84:	0147a223          	sw	s4,4(a5)
   16d88:	d45ff06f          	j	16acc <_malloc_r+0x438>
    /* Guarantee the next brk will be at a page boundary */
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE))
   16d8c:	00100793          	li	a5,1
      {
	correction = 0;
   16d90:	00000a13          	li	s4,0
   16d94:	cedff06f          	j	16a80 <_malloc_r+0x3ec>
    set_head(top, top_size | PREV_INUSE);
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
      sbrk_base = brk;
   16d98:	8171ac23          	sw	s7,-2024(gp) # 47ff8 <__malloc_sbrk_base>
   16d9c:	c99ff06f          	j	16a34 <_malloc_r+0x3a0>
        SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
        SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE) 
        fREe(RCALL chunk2mem(old_top));
   16da0:	00840593          	addi	a1,s0,8
   16da4:	00098513          	mv	a0,s3
   16da8:	a48ff0ef          	jal	15ff0 <_free_r>
   16dac:	000c2703          	lw	a4,0(s8)
   16db0:	d1dff06f          	j	16acc <_malloc_r+0x438>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   16db4:	15400613          	li	a2,340
   16db8:	00e66c63          	bltu	a2,a4,16dd0 <_malloc_r+0x73c>
   16dbc:	00f7d613          	srli	a2,a5,0xf
   16dc0:	07860593          	addi	a1,a2,120
   16dc4:	00159593          	slli	a1,a1,0x1
   16dc8:	07760613          	addi	a2,a2,119
   16dcc:	db1ff06f          	j	16b7c <_malloc_r+0x4e8>
   16dd0:	55400513          	li	a0,1364
   16dd4:	0fe00593          	li	a1,254
   16dd8:	07e00613          	li	a2,126
   16ddc:	dae560e3          	bltu	a0,a4,16b7c <_malloc_r+0x4e8>
   16de0:	0127d613          	srli	a2,a5,0x12
   16de4:	07d60593          	addi	a1,a2,125
   16de8:	00159593          	slli	a1,a1,0x1
   16dec:	07c60613          	addi	a2,a2,124
   16df0:	d8dff06f          	j	16b7c <_malloc_r+0x4e8>
   16df4:	00492783          	lw	a5,4(s2)
   16df8:	ec1ff06f          	j	16cb8 <_malloc_r+0x624>
   16dfc:	0034d693          	srli	a3,s1,0x3
   16e00:	00168793          	addi	a5,a3,1
   16e04:	00179793          	slli	a5,a5,0x1
   16e08:	a95ff06f          	j	1689c <_malloc_r+0x208>

00016e0c <memchr>:
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   16e0c:	00357793          	andi	a5,a0,3
	_CONST _PTR src_void _AND
	int c _AND
	size_t length)
{
  _CONST unsigned char *src = (_CONST unsigned char *) src_void;
  unsigned char d = c;
   16e10:	0ff5f693          	andi	a3,a1,255
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   16e14:	0c078063          	beqz	a5,16ed4 <memchr+0xc8>
    {
      if (!length--)
   16e18:	fff60793          	addi	a5,a2,-1
   16e1c:	06060063          	beqz	a2,16e7c <memchr+0x70>
        return NULL;
      if (*src == d)
   16e20:	00054703          	lbu	a4,0(a0)
   16e24:	00d71c63          	bne	a4,a3,16e3c <memchr+0x30>
   16e28:	0b40006f          	j	16edc <memchr+0xd0>
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
    {
      if (!length--)
   16e2c:	04078863          	beqz	a5,16e7c <memchr+0x70>
        return NULL;
      if (*src == d)
   16e30:	00054703          	lbu	a4,0(a0)
   16e34:	fff78793          	addi	a5,a5,-1
   16e38:	04d70463          	beq	a4,a3,16e80 <memchr+0x74>
        return (void *) src;
      src++;
   16e3c:	00150513          	addi	a0,a0,1
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   16e40:	00357713          	andi	a4,a0,3
   16e44:	fe0714e3          	bnez	a4,16e2c <memchr+0x20>
      if (*src == d)
        return (void *) src;
      src++;
    }

  if (!TOO_SMALL (length))
   16e48:	00300813          	li	a6,3
   16e4c:	02f86c63          	bltu	a6,a5,16e84 <memchr+0x78>
      src = (unsigned char *) asrc;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
   16e50:	02078663          	beqz	a5,16e7c <memchr+0x70>
    {
      if (*src == d)
   16e54:	00054703          	lbu	a4,0(a0)
   16e58:	02d70463          	beq	a4,a3,16e80 <memchr+0x74>
   16e5c:	00150713          	addi	a4,a0,1
   16e60:	00f507b3          	add	a5,a0,a5
   16e64:	0100006f          	j	16e74 <memchr+0x68>
   16e68:	00170713          	addi	a4,a4,1
   16e6c:	fff74603          	lbu	a2,-1(a4)
   16e70:	00d60863          	beq	a2,a3,16e80 <memchr+0x74>
        return (void *) src;
      src++;
   16e74:	00070513          	mv	a0,a4
      src = (unsigned char *) asrc;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
   16e78:	fee798e3          	bne	a5,a4,16e68 <memchr+0x5c>
  unsigned int i;

  while (UNALIGNED (src))
    {
      if (!length--)
        return NULL;
   16e7c:	00000513          	li	a0,0
        return (void *) src;
      src++;
    }

  return NULL;
}
   16e80:	00008067          	ret
   16e84:	0ff5f593          	andi	a1,a1,255
         contain the search character, which is detected by XORing
         the word-sized segment with a word-sized block of the search
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
      mask = d << 8 | d;
   16e88:	00859713          	slli	a4,a1,0x8
   16e8c:	00b765b3          	or	a1,a4,a1
      mask = mask << 16 | mask;
   16e90:	01059713          	slli	a4,a1,0x10
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
        {
          if (DETECTCHAR (*asrc, mask))
   16e94:	feff02b7          	lui	t0,0xfeff0
   16e98:	808088b7          	lui	a7,0x80808
         the word-sized segment with a word-sized block of the search
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
      mask = d << 8 | d;
      mask = mask << 16 | mask;
   16e9c:	00e5e5b3          	or	a1,a1,a4
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
        {
          if (DETECTCHAR (*asrc, mask))
   16ea0:	eff28293          	addi	t0,t0,-257 # fefefeff <_gp+0xfefa771f>
   16ea4:	08088893          	addi	a7,a7,128 # 80808080 <_gp+0x807bf8a0>
   16ea8:	00052703          	lw	a4,0(a0)
   16eac:	00e5c733          	xor	a4,a1,a4
   16eb0:	00570633          	add	a2,a4,t0
   16eb4:	fff74713          	not	a4,a4
   16eb8:	00e67733          	and	a4,a2,a4
   16ebc:	01177733          	and	a4,a4,a7
   16ec0:	f8071ae3          	bnez	a4,16e54 <memchr+0x48>
            break;
          length -= LBLOCKSIZE;
   16ec4:	ffc78793          	addi	a5,a5,-4
          asrc++;
   16ec8:	00450513          	addi	a0,a0,4
      mask = d << 8 | d;
      mask = mask << 16 | mask;
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
   16ecc:	fcf86ee3          	bltu	a6,a5,16ea8 <memchr+0x9c>
   16ed0:	f81ff06f          	j	16e50 <memchr+0x44>
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   16ed4:	00060793          	mv	a5,a2
   16ed8:	f71ff06f          	j	16e48 <memchr+0x3c>
   16edc:	00008067          	ret

00016ee0 <memcpy>:

  char* a = (char*)aa;
  const char* b = (const char*)bb;
  char* end = a+n;
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
   16ee0:	00a5c7b3          	xor	a5,a1,a0
   16ee4:	0037f793          	andi	a5,a5,3
    *(a-1) = tt; \
  }

  char* a = (char*)aa;
  const char* b = (const char*)bb;
  char* end = a+n;
   16ee8:	00c508b3          	add	a7,a0,a2
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
   16eec:	0e079263          	bnez	a5,16fd0 <memcpy+0xf0>
   16ef0:	00300793          	li	a5,3
   16ef4:	0ec7fe63          	bleu	a2,a5,16ff0 <memcpy+0x110>
      while (a < end)
        BODY(a, b, char);
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
   16ef8:	00357793          	andi	a5,a0,3
   16efc:	04079a63          	bnez	a5,16f50 <memcpy+0x70>
    while ((uintptr_t)a & msk)
      BODY(a, b, char);

  long* la = (long*)a;
  const long* lb = (const long*)b;
  long* lend = (long*)((uintptr_t)end & ~msk);
   16f00:	ffc8f813          	andi	a6,a7,-4

  if (__builtin_expect(la < lend-8, 0))
   16f04:	fe080793          	addi	a5,a6,-32
   16f08:	00050713          	mv	a4,a0
   16f0c:	06f56663          	bltu	a0,a5,16f78 <memcpy+0x98>
      *la++ = b7;
      *la++ = b8;
    }
  }

  while (la < lend)
   16f10:	00058693          	mv	a3,a1
   16f14:	00070793          	mv	a5,a4
   16f18:	03077863          	bleu	a6,a4,16f48 <memcpy+0x68>
    BODY(la, lb, long);
   16f1c:	0006a603          	lw	a2,0(a3)
   16f20:	00478793          	addi	a5,a5,4
   16f24:	00468693          	addi	a3,a3,4
   16f28:	fec7ae23          	sw	a2,-4(a5)
      *la++ = b7;
      *la++ = b8;
    }
  }

  while (la < lend)
   16f2c:	ff07e8e3          	bltu	a5,a6,16f1c <memcpy+0x3c>
   16f30:	fff74793          	not	a5,a4
   16f34:	01078833          	add	a6,a5,a6
   16f38:	ffc87813          	andi	a6,a6,-4
   16f3c:	00480813          	addi	a6,a6,4
   16f40:	01070733          	add	a4,a4,a6
   16f44:	010585b3          	add	a1,a1,a6
    BODY(la, lb, long);

  a = (char*)la;
  b = (const char*)lb;
  if (__builtin_expect(a < end, 0))
   16f48:	09176863          	bltu	a4,a7,16fd8 <memcpy+0xf8>
    goto small;
  return aa;
}
   16f4c:	00008067          	ret
   16f50:	00050713          	mv	a4,a0
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
    while ((uintptr_t)a & msk)
      BODY(a, b, char);
   16f54:	0005c683          	lbu	a3,0(a1)
   16f58:	00170713          	addi	a4,a4,1
        BODY(a, b, char);
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
    while ((uintptr_t)a & msk)
   16f5c:	00377793          	andi	a5,a4,3
      BODY(a, b, char);
   16f60:	00158593          	addi	a1,a1,1
   16f64:	fed70fa3          	sb	a3,-1(a4)
        BODY(a, b, char);
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
    while ((uintptr_t)a & msk)
   16f68:	fe0796e3          	bnez	a5,16f54 <memcpy+0x74>
      BODY(a, b, char);

  long* la = (long*)a;
  const long* lb = (const long*)b;
  long* lend = (long*)((uintptr_t)end & ~msk);
   16f6c:	ffc8f813          	andi	a6,a7,-4

  if (__builtin_expect(la < lend-8, 0))
   16f70:	fe080793          	addi	a5,a6,-32
   16f74:	f8f77ee3          	bleu	a5,a4,16f10 <memcpy+0x30>
  {
    while (la < lend-8)
    {
      long b0 = *lb++;
   16f78:	0005af83          	lw	t6,0(a1)
      long b1 = *lb++;
   16f7c:	0045af03          	lw	t5,4(a1)
      long b2 = *lb++;
   16f80:	0085ae83          	lw	t4,8(a1)
      long b3 = *lb++;
   16f84:	00c5ae03          	lw	t3,12(a1)
      long b4 = *lb++;
   16f88:	0105a383          	lw	t2,16(a1)
      long b5 = *lb++;
   16f8c:	0145a303          	lw	t1,20(a1)
      long b6 = *lb++;
   16f90:	0185a283          	lw	t0,24(a1)
      long b7 = *lb++;
   16f94:	01c5a603          	lw	a2,28(a1)
   16f98:	02458593          	addi	a1,a1,36
   16f9c:	02470713          	addi	a4,a4,36
      long b8 = *lb++;
   16fa0:	ffc5a683          	lw	a3,-4(a1)
      *la++ = b0;
   16fa4:	fdf72e23          	sw	t6,-36(a4)
      *la++ = b1;
   16fa8:	ffe72023          	sw	t5,-32(a4)
      *la++ = b2;
   16fac:	ffd72223          	sw	t4,-28(a4)
      *la++ = b3;
   16fb0:	ffc72423          	sw	t3,-24(a4)
      *la++ = b4;
   16fb4:	fe772623          	sw	t2,-20(a4)
      *la++ = b5;
   16fb8:	fe672823          	sw	t1,-16(a4)
      *la++ = b6;
   16fbc:	fe572a23          	sw	t0,-12(a4)
      *la++ = b7;
   16fc0:	fec72c23          	sw	a2,-8(a4)
      *la++ = b8;
   16fc4:	fed72e23          	sw	a3,-4(a4)
  const long* lb = (const long*)b;
  long* lend = (long*)((uintptr_t)end & ~msk);

  if (__builtin_expect(la < lend-8, 0))
  {
    while (la < lend-8)
   16fc8:	faf768e3          	bltu	a4,a5,16f78 <memcpy+0x98>
   16fcc:	f45ff06f          	j	16f10 <memcpy+0x30>
  char* end = a+n;
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
  {
small:
    if (__builtin_expect(a < end, 1))
   16fd0:	00050713          	mv	a4,a0
   16fd4:	03157463          	bleu	a7,a0,16ffc <memcpy+0x11c>
      while (a < end)
        BODY(a, b, char);
   16fd8:	0005c783          	lbu	a5,0(a1)
   16fdc:	00170713          	addi	a4,a4,1
   16fe0:	00158593          	addi	a1,a1,1
   16fe4:	fef70fa3          	sb	a5,-1(a4)
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
  {
small:
    if (__builtin_expect(a < end, 1))
      while (a < end)
   16fe8:	ff1768e3          	bltu	a4,a7,16fd8 <memcpy+0xf8>
   16fec:	00008067          	ret
   16ff0:	00050713          	mv	a4,a0
  char* end = a+n;
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
  {
small:
    if (__builtin_expect(a < end, 1))
   16ff4:	ff1562e3          	bltu	a0,a7,16fd8 <memcpy+0xf8>
   16ff8:	f55ff06f          	j	16f4c <memcpy+0x6c>
   16ffc:	00008067          	ret

00017000 <memset>:
   17000:	00f00813          	li	a6,15
   17004:	00050713          	mv	a4,a0
   17008:	02c87e63          	bleu	a2,a6,17044 <memset+0x44>
   1700c:	00f77793          	andi	a5,a4,15
   17010:	0a079063          	bnez	a5,170b0 <memset+0xb0>
   17014:	08059263          	bnez	a1,17098 <memset+0x98>
   17018:	ff067693          	andi	a3,a2,-16
   1701c:	00f67613          	andi	a2,a2,15
   17020:	00e686b3          	add	a3,a3,a4
   17024:	00b72023          	sw	a1,0(a4)
   17028:	00b72223          	sw	a1,4(a4)
   1702c:	00b72423          	sw	a1,8(a4)
   17030:	00b72623          	sw	a1,12(a4)
   17034:	01070713          	addi	a4,a4,16
   17038:	fed766e3          	bltu	a4,a3,17024 <memset+0x24>
   1703c:	00061463          	bnez	a2,17044 <memset+0x44>
   17040:	00008067          	ret
   17044:	40c806b3          	sub	a3,a6,a2
   17048:	00269693          	slli	a3,a3,0x2
   1704c:	00000297          	auipc	t0,0x0
   17050:	005686b3          	add	a3,a3,t0
   17054:	00c68067          	jr	a3,12
   17058:	00b70723          	sb	a1,14(a4)
   1705c:	00b706a3          	sb	a1,13(a4)
   17060:	00b70623          	sb	a1,12(a4)
   17064:	00b705a3          	sb	a1,11(a4)
   17068:	00b70523          	sb	a1,10(a4)
   1706c:	00b704a3          	sb	a1,9(a4)
   17070:	00b70423          	sb	a1,8(a4)
   17074:	00b703a3          	sb	a1,7(a4)
   17078:	00b70323          	sb	a1,6(a4)
   1707c:	00b702a3          	sb	a1,5(a4)
   17080:	00b70223          	sb	a1,4(a4)
   17084:	00b701a3          	sb	a1,3(a4)
   17088:	00b70123          	sb	a1,2(a4)
   1708c:	00b700a3          	sb	a1,1(a4)
   17090:	00b70023          	sb	a1,0(a4)
   17094:	00008067          	ret
   17098:	0ff5f593          	andi	a1,a1,255
   1709c:	00859693          	slli	a3,a1,0x8
   170a0:	00d5e5b3          	or	a1,a1,a3
   170a4:	01059693          	slli	a3,a1,0x10
   170a8:	00d5e5b3          	or	a1,a1,a3
   170ac:	f6dff06f          	j	17018 <memset+0x18>
   170b0:	00279693          	slli	a3,a5,0x2
   170b4:	00000297          	auipc	t0,0x0
   170b8:	005686b3          	add	a3,a3,t0
   170bc:	00008293          	mv	t0,ra
   170c0:	fa0680e7          	jalr	a3,-96
   170c4:	00028093          	mv	ra,t0
   170c8:	ff078793          	addi	a5,a5,-16
   170cc:	40f70733          	sub	a4,a4,a5
   170d0:	00f60633          	add	a2,a2,a5
   170d4:	f6c878e3          	bleu	a2,a6,17044 <memset+0x44>
   170d8:	f3dff06f          	j	17014 <memset+0x14>

000170dc <__malloc_lock>:
   170dc:	00008067          	ret

000170e0 <__malloc_unlock>:
}

void
__malloc_unlock (ptr)
     struct _reent *ptr;
{
   170e0:	00008067          	ret

000170e4 <_Balloc>:
{
  int x;
  _Bigint *rv ;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_FREELIST(ptr) == NULL)
   170e4:	04c52783          	lw	a5,76(a0)
#define _Kmax 15
*/

_Bigint *
_DEFUN (Balloc, (ptr, k), struct _reent *ptr _AND int k)
{
   170e8:	ff010113          	addi	sp,sp,-16
   170ec:	00812423          	sw	s0,8(sp)
   170f0:	00912223          	sw	s1,4(sp)
   170f4:	00112623          	sw	ra,12(sp)
   170f8:	01212023          	sw	s2,0(sp)
   170fc:	00050413          	mv	s0,a0
   17100:	00058493          	mv	s1,a1
  int x;
  _Bigint *rv ;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_FREELIST(ptr) == NULL)
   17104:	02078e63          	beqz	a5,17140 <_Balloc+0x5c>
	{
	  return NULL;
	}
    }

  if ((rv = _REENT_MP_FREELIST(ptr)[k]) != 0)
   17108:	00249713          	slli	a4,s1,0x2
   1710c:	00e787b3          	add	a5,a5,a4
   17110:	0007a503          	lw	a0,0(a5)
   17114:	04050663          	beqz	a0,17160 <_Balloc+0x7c>
    {
      _REENT_MP_FREELIST(ptr)[k] = rv->_next;
   17118:	00052703          	lw	a4,0(a0)
   1711c:	00e7a023          	sw	a4,0(a5)
				  (x-1) * sizeof(rv->_x));
      if (rv == NULL) return NULL;
      rv->_k = k;
      rv->_maxwds = x;
    }
  rv->_sign = rv->_wds = 0;
   17120:	00052823          	sw	zero,16(a0)
   17124:	00052623          	sw	zero,12(a0)
  return rv;
}
   17128:	00c12083          	lw	ra,12(sp)
   1712c:	00812403          	lw	s0,8(sp)
   17130:	00412483          	lw	s1,4(sp)
   17134:	00012903          	lw	s2,0(sp)
   17138:	01010113          	addi	sp,sp,16
   1713c:	00008067          	ret

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_FREELIST(ptr) == NULL)
    {
      /* Allocate a list of pointers to the mprec objects */
      _REENT_MP_FREELIST(ptr) = (struct _Bigint **) _calloc_r (ptr, 
   17140:	02100613          	li	a2,33
   17144:	00400593          	li	a1,4
   17148:	510020ef          	jal	19658 <_calloc_r>
   1714c:	00050793          	mv	a5,a0
   17150:	04a42623          	sw	a0,76(s0)
						      sizeof (struct _Bigint *),
						      _Kmax + 1);
      if (_REENT_MP_FREELIST(ptr) == NULL)
   17154:	fa051ae3          	bnez	a0,17108 <_Balloc+0x24>
	{
	  return NULL;
   17158:	00000513          	li	a0,0
   1715c:	fcdff06f          	j	17128 <_Balloc+0x44>
    {
      _REENT_MP_FREELIST(ptr)[k] = rv->_next;
    }
  else
    {
      x = 1 << k;
   17160:	00100593          	li	a1,1
   17164:	00959933          	sll	s2,a1,s1
      /* Allocate an mprec Bigint and stick in in the freelist */
      rv = (_Bigint *) _calloc_r (ptr,
   17168:	00590613          	addi	a2,s2,5
   1716c:	00261613          	slli	a2,a2,0x2
   17170:	00040513          	mv	a0,s0
   17174:	4e4020ef          	jal	19658 <_calloc_r>
				  1,
				  sizeof (_Bigint) +
				  (x-1) * sizeof(rv->_x));
      if (rv == NULL) return NULL;
   17178:	fe0500e3          	beqz	a0,17158 <_Balloc+0x74>
      rv->_k = k;
   1717c:	00952223          	sw	s1,4(a0)
      rv->_maxwds = x;
   17180:	01252423          	sw	s2,8(a0)
   17184:	f9dff06f          	j	17120 <_Balloc+0x3c>

00017188 <_Bfree>:

void
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
   17188:	02058063          	beqz	a1,171a8 <_Bfree+0x20>
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   1718c:	0045a783          	lw	a5,4(a1)
   17190:	04c52703          	lw	a4,76(a0)
   17194:	00279793          	slli	a5,a5,0x2
   17198:	00f707b3          	add	a5,a4,a5
   1719c:	0007a703          	lw	a4,0(a5)
   171a0:	00e5a023          	sw	a4,0(a1)
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   171a4:	00b7a023          	sw	a1,0(a5)
   171a8:	00008067          	ret

000171ac <__multadd>:
_DEFUN (multadd, (ptr, b, m, a),
	struct _reent *ptr _AND
	_Bigint * b _AND
	int m _AND
	int a)
{
   171ac:	fd010113          	addi	sp,sp,-48
  i = 0;
  do
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
   171b0:	00010837          	lui	a6,0x10
_DEFUN (multadd, (ptr, b, m, a),
	struct _reent *ptr _AND
	_Bigint * b _AND
	int m _AND
	int a)
{
   171b4:	02812423          	sw	s0,40(sp)
   171b8:	02912223          	sw	s1,36(sp)
   171bc:	03212023          	sw	s2,32(sp)
   171c0:	00058493          	mv	s1,a1
#ifdef Pack_32
  __ULong xi, z;
#endif
  _Bigint *b1;

  wds = b->_wds;
   171c4:	0105a403          	lw	s0,16(a1)
_DEFUN (multadd, (ptr, b, m, a),
	struct _reent *ptr _AND
	_Bigint * b _AND
	int m _AND
	int a)
{
   171c8:	00050913          	mv	s2,a0
   171cc:	02112623          	sw	ra,44(sp)
   171d0:	01312e23          	sw	s3,28(sp)
  __ULong xi, z;
#endif
  _Bigint *b1;

  wds = b->_wds;
  x = b->_x;
   171d4:	01458593          	addi	a1,a1,20
  i = 0;
   171d8:	00000513          	li	a0,0
  do
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
   171dc:	fff80813          	addi	a6,a6,-1 # ffff <_reset+0xfdff>
  x = b->_x;
  i = 0;
  do
    {
#ifdef Pack_32
      xi = *x;
   171e0:	0005a783          	lw	a5,0(a1)
      y = *x * m + a;
      a = (int) (y >> 16);
      *x++ = y & 0xffff;
#endif
    }
  while (++i < wds);
   171e4:	00150513          	addi	a0,a0,1
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
      z = (xi >> 16) * m + (y >> 16);
      a = (int) (z >> 16);
      *x++ = (z << 16) + (y & 0xffff);
   171e8:	00458593          	addi	a1,a1,4
  i = 0;
  do
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
   171ec:	0107f733          	and	a4,a5,a6
   171f0:	02c70733          	mul	a4,a4,a2
      z = (xi >> 16) * m + (y >> 16);
   171f4:	0107d793          	srli	a5,a5,0x10
   171f8:	02c787b3          	mul	a5,a5,a2
  i = 0;
  do
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
   171fc:	00d70733          	add	a4,a4,a3
      z = (xi >> 16) * m + (y >> 16);
   17200:	01075693          	srli	a3,a4,0x10
      a = (int) (z >> 16);
      *x++ = (z << 16) + (y & 0xffff);
   17204:	01077733          	and	a4,a4,a6
  do
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
      z = (xi >> 16) * m + (y >> 16);
   17208:	00d786b3          	add	a3,a5,a3
      a = (int) (z >> 16);
      *x++ = (z << 16) + (y & 0xffff);
   1720c:	01069793          	slli	a5,a3,0x10
   17210:	00e78733          	add	a4,a5,a4
    {
#ifdef Pack_32
      xi = *x;
      y = (xi & 0xffff) * m + a;
      z = (xi >> 16) * m + (y >> 16);
      a = (int) (z >> 16);
   17214:	0106d693          	srli	a3,a3,0x10
      *x++ = (z << 16) + (y & 0xffff);
   17218:	fee5ae23          	sw	a4,-4(a1)
      y = *x * m + a;
      a = (int) (y >> 16);
      *x++ = y & 0xffff;
#endif
    }
  while (++i < wds);
   1721c:	fc8542e3          	blt	a0,s0,171e0 <__multadd+0x34>
  if (a)
   17220:	02068263          	beqz	a3,17244 <__multadd+0x98>
    {
      if (wds >= b->_maxwds)
   17224:	0084a783          	lw	a5,8(s1)
   17228:	02f45e63          	ble	a5,s0,17264 <__multadd+0xb8>
	  b1 = Balloc (ptr, b->_k + 1);
	  Bcopy (b1, b);
	  Bfree (ptr, b);
	  b = b1;
	}
      b->_x[wds++] = a;
   1722c:	00440793          	addi	a5,s0,4
   17230:	00279793          	slli	a5,a5,0x2
   17234:	00f487b3          	add	a5,s1,a5
      b->_wds = wds;
   17238:	00140413          	addi	s0,s0,1
	  b1 = Balloc (ptr, b->_k + 1);
	  Bcopy (b1, b);
	  Bfree (ptr, b);
	  b = b1;
	}
      b->_x[wds++] = a;
   1723c:	00d7a223          	sw	a3,4(a5)
      b->_wds = wds;
   17240:	0084a823          	sw	s0,16(s1)
    }
  return b;
}
   17244:	02c12083          	lw	ra,44(sp)
   17248:	00048513          	mv	a0,s1
   1724c:	02812403          	lw	s0,40(sp)
   17250:	02412483          	lw	s1,36(sp)
   17254:	02012903          	lw	s2,32(sp)
   17258:	01c12983          	lw	s3,28(sp)
   1725c:	03010113          	addi	sp,sp,48
   17260:	00008067          	ret
  while (++i < wds);
  if (a)
    {
      if (wds >= b->_maxwds)
	{
	  b1 = Balloc (ptr, b->_k + 1);
   17264:	0044a583          	lw	a1,4(s1)
   17268:	00090513          	mv	a0,s2
   1726c:	00d12623          	sw	a3,12(sp)
   17270:	00158593          	addi	a1,a1,1
   17274:	e71ff0ef          	jal	170e4 <_Balloc>
	  Bcopy (b1, b);
   17278:	0104a603          	lw	a2,16(s1)
  while (++i < wds);
  if (a)
    {
      if (wds >= b->_maxwds)
	{
	  b1 = Balloc (ptr, b->_k + 1);
   1727c:	00050993          	mv	s3,a0
	  Bcopy (b1, b);
   17280:	00c48593          	addi	a1,s1,12
   17284:	00260613          	addi	a2,a2,2
   17288:	00c50513          	addi	a0,a0,12
   1728c:	00261613          	slli	a2,a2,0x2
   17290:	c51ff0ef          	jal	16ee0 <memcpy>
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   17294:	0044a783          	lw	a5,4(s1)
   17298:	04c92703          	lw	a4,76(s2)
      if (wds >= b->_maxwds)
	{
	  b1 = Balloc (ptr, b->_k + 1);
	  Bcopy (b1, b);
	  Bfree (ptr, b);
	  b = b1;
   1729c:	00c12683          	lw	a3,12(sp)
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   172a0:	00279793          	slli	a5,a5,0x2
   172a4:	00f707b3          	add	a5,a4,a5
   172a8:	0007a703          	lw	a4,0(a5)
   172ac:	00e4a023          	sw	a4,0(s1)
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   172b0:	0097a023          	sw	s1,0(a5)
      if (wds >= b->_maxwds)
	{
	  b1 = Balloc (ptr, b->_k + 1);
	  Bcopy (b1, b);
	  Bfree (ptr, b);
	  b = b1;
   172b4:	00098493          	mv	s1,s3
   172b8:	f75ff06f          	j	1722c <__multadd+0x80>

000172bc <__s2b>:
	struct _reent * ptr _AND
	_CONST char *s _AND
	int nd0 _AND
	int nd _AND
	__ULong y9)
{
   172bc:	fe010113          	addi	sp,sp,-32
  _Bigint *b;
  int i, k;
  __Long x, y;

  x = (nd + 8) / 9;
   172c0:	00868793          	addi	a5,a3,8
	struct _reent * ptr _AND
	_CONST char *s _AND
	int nd0 _AND
	int nd _AND
	__ULong y9)
{
   172c4:	01312623          	sw	s3,12(sp)
   172c8:	00068993          	mv	s3,a3
  _Bigint *b;
  int i, k;
  __Long x, y;

  x = (nd + 8) / 9;
   172cc:	00900693          	li	a3,9
   172d0:	02d7c6b3          	div	a3,a5,a3
  for (k = 0, y = 1; x > y; y <<= 1, k++);
   172d4:	00100793          	li	a5,1
	struct _reent * ptr _AND
	_CONST char *s _AND
	int nd0 _AND
	int nd _AND
	__ULong y9)
{
   172d8:	00812c23          	sw	s0,24(sp)
   172dc:	00912a23          	sw	s1,20(sp)
   172e0:	01212823          	sw	s2,16(sp)
   172e4:	01412423          	sw	s4,8(sp)
   172e8:	00058413          	mv	s0,a1
   172ec:	00112e23          	sw	ra,28(sp)
   172f0:	01512223          	sw	s5,4(sp)
   172f4:	00050913          	mv	s2,a0
   172f8:	00060a13          	mv	s4,a2
   172fc:	00070493          	mv	s1,a4
  _Bigint *b;
  int i, k;
  __Long x, y;

  x = (nd + 8) / 9;
  for (k = 0, y = 1; x > y; y <<= 1, k++);
   17300:	00000593          	li	a1,0
   17304:	00d7d863          	ble	a3,a5,17314 <__s2b+0x58>
   17308:	00179793          	slli	a5,a5,0x1
   1730c:	00158593          	addi	a1,a1,1
   17310:	fed7cce3          	blt	a5,a3,17308 <__s2b+0x4c>
#ifdef Pack_32
  b = Balloc (ptr, k);
   17314:	00090513          	mv	a0,s2
   17318:	dcdff0ef          	jal	170e4 <_Balloc>
  b->_x[0] = y9;
  b->_wds = 1;
   1731c:	00100713          	li	a4,1
  b->_x[0] = y9 & 0xffff;
  b->_wds = (b->_x[1] = y9 >> 16) ? 2 : 1;
#endif

  i = 9;
  if (9 < nd0)
   17320:	00900793          	li	a5,9

  x = (nd + 8) / 9;
  for (k = 0, y = 1; x > y; y <<= 1, k++);
#ifdef Pack_32
  b = Balloc (ptr, k);
  b->_x[0] = y9;
   17324:	00952a23          	sw	s1,20(a0)
  b->_wds = 1;
   17328:	00e52823          	sw	a4,16(a0)
  b->_x[0] = y9 & 0xffff;
  b->_wds = (b->_x[1] = y9 >> 16) ? 2 : 1;
#endif

  i = 9;
  if (9 < nd0)
   1732c:	0947d463          	ble	s4,a5,173b4 <__s2b+0xf8>
    {
      s += 9;
   17330:	00f40ab3          	add	s5,s0,a5
   17334:	000a8493          	mv	s1,s5
   17338:	01440433          	add	s0,s0,s4
      do
	b = multadd (ptr, b, 10, *s++ - '0');
   1733c:	00148493          	addi	s1,s1,1
   17340:	fff4c683          	lbu	a3,-1(s1)
   17344:	00050593          	mv	a1,a0
   17348:	00a00613          	li	a2,10
   1734c:	fd068693          	addi	a3,a3,-48
   17350:	00090513          	mv	a0,s2
   17354:	e59ff0ef          	jal	171ac <__multadd>
      while (++i < nd0);
   17358:	fe8492e3          	bne	s1,s0,1733c <__s2b+0x80>
   1735c:	014a8433          	add	s0,s5,s4
      s++;
   17360:	ff840413          	addi	s0,s0,-8
    }
  else
    s += 10;
  for (; i < nd; i++)
   17364:	033a5663          	ble	s3,s4,17390 <__s2b+0xd4>
   17368:	414984b3          	sub	s1,s3,s4
   1736c:	009404b3          	add	s1,s0,s1
    b = multadd (ptr, b, 10, *s++ - '0');
   17370:	00140413          	addi	s0,s0,1
   17374:	fff44683          	lbu	a3,-1(s0)
   17378:	00050593          	mv	a1,a0
   1737c:	00a00613          	li	a2,10
   17380:	fd068693          	addi	a3,a3,-48
   17384:	00090513          	mv	a0,s2
   17388:	e25ff0ef          	jal	171ac <__multadd>
      while (++i < nd0);
      s++;
    }
  else
    s += 10;
  for (; i < nd; i++)
   1738c:	fe8492e3          	bne	s1,s0,17370 <__s2b+0xb4>
    b = multadd (ptr, b, 10, *s++ - '0');
  return b;
}
   17390:	01c12083          	lw	ra,28(sp)
   17394:	01812403          	lw	s0,24(sp)
   17398:	01412483          	lw	s1,20(sp)
   1739c:	01012903          	lw	s2,16(sp)
   173a0:	00c12983          	lw	s3,12(sp)
   173a4:	00812a03          	lw	s4,8(sp)
   173a8:	00412a83          	lw	s5,4(sp)
   173ac:	02010113          	addi	sp,sp,32
   173b0:	00008067          	ret
	b = multadd (ptr, b, 10, *s++ - '0');
      while (++i < nd0);
      s++;
    }
  else
    s += 10;
   173b4:	00a40413          	addi	s0,s0,10
  b = Balloc (ptr, k + 1);
  b->_x[0] = y9 & 0xffff;
  b->_wds = (b->_x[1] = y9 >> 16) ? 2 : 1;
#endif

  i = 9;
   173b8:	00078a13          	mv	s4,a5
   173bc:	fa9ff06f          	j	17364 <__s2b+0xa8>

000173c0 <__hi0bits>:
_DEFUN (hi0bits,
	(x), register __ULong x)
{
  register int k = 0;

  if (!(x & 0xffff0000))
   173c0:	ffff06b7          	lui	a3,0xffff0
   173c4:	00d576b3          	and	a3,a0,a3
}

int
_DEFUN (hi0bits,
	(x), register __ULong x)
{
   173c8:	00050793          	mv	a5,a0
  register int k = 0;
   173cc:	00000713          	li	a4,0

  if (!(x & 0xffff0000))
   173d0:	00069663          	bnez	a3,173dc <__hi0bits+0x1c>
    {
      k = 16;
      x <<= 16;
   173d4:	01051793          	slli	a5,a0,0x10
{
  register int k = 0;

  if (!(x & 0xffff0000))
    {
      k = 16;
   173d8:	01000713          	li	a4,16
      x <<= 16;
    }
  if (!(x & 0xff000000))
   173dc:	ff0006b7          	lui	a3,0xff000
   173e0:	00d7f6b3          	and	a3,a5,a3
   173e4:	00069663          	bnez	a3,173f0 <__hi0bits+0x30>
    {
      k += 8;
   173e8:	00870713          	addi	a4,a4,8
      x <<= 8;
   173ec:	00879793          	slli	a5,a5,0x8
    }
  if (!(x & 0xf0000000))
   173f0:	f00006b7          	lui	a3,0xf0000
   173f4:	00d7f6b3          	and	a3,a5,a3
   173f8:	00069663          	bnez	a3,17404 <__hi0bits+0x44>
    {
      k += 4;
   173fc:	00470713          	addi	a4,a4,4
      x <<= 4;
   17400:	00479793          	slli	a5,a5,0x4
    }
  if (!(x & 0xc0000000))
   17404:	c00006b7          	lui	a3,0xc0000
   17408:	00d7f6b3          	and	a3,a5,a3
   1740c:	00069663          	bnez	a3,17418 <__hi0bits+0x58>
    {
      k += 2;
   17410:	00270713          	addi	a4,a4,2
      x <<= 2;
   17414:	00279793          	slli	a5,a5,0x2
    }
  if (!(x & 0x80000000))
   17418:	0007ce63          	bltz	a5,17434 <__hi0bits+0x74>
    {
      k++;
      if (!(x & 0x40000000))
   1741c:	00179693          	slli	a3,a5,0x1
	return 32;
   17420:	02000513          	li	a0,32
      x <<= 2;
    }
  if (!(x & 0x80000000))
    {
      k++;
      if (!(x & 0x40000000))
   17424:	0006c463          	bltz	a3,1742c <__hi0bits+0x6c>
	return 32;
    }
  return k;
}
   17428:	00008067          	ret
      k += 2;
      x <<= 2;
    }
  if (!(x & 0x80000000))
    {
      k++;
   1742c:	00170513          	addi	a0,a4,1
   17430:	00008067          	ret
   17434:	00070513          	mv	a0,a4
      if (!(x & 0x40000000))
	return 32;
    }
  return k;
}
   17438:	00008067          	ret

0001743c <__lo0bits>:

int
_DEFUN (lo0bits, (y), __ULong *y)
{
  register int k;
  register __ULong x = *y;
   1743c:	00052783          	lw	a5,0(a0)
  return k;
}

int
_DEFUN (lo0bits, (y), __ULong *y)
{
   17440:	00050693          	mv	a3,a0
  register int k;
  register __ULong x = *y;

  if (x & 7)
   17444:	0077f713          	andi	a4,a5,7
   17448:	02070463          	beqz	a4,17470 <__lo0bits+0x34>
    {
      if (x & 1)
   1744c:	0017f713          	andi	a4,a5,1
	return 0;
   17450:	00000513          	li	a0,0
  register int k;
  register __ULong x = *y;

  if (x & 7)
    {
      if (x & 1)
   17454:	08071263          	bnez	a4,174d8 <__lo0bits+0x9c>
	return 0;
      if (x & 2)
   17458:	0027f713          	andi	a4,a5,2
   1745c:	08071063          	bnez	a4,174dc <__lo0bits+0xa0>
	{
	  *y = x >> 1;
	  return 1;
	}
      *y = x >> 2;
   17460:	0027d793          	srli	a5,a5,0x2
   17464:	00f6a023          	sw	a5,0(a3) # c0000000 <_gp+0xbffb7820>
      return 2;
   17468:	00200513          	li	a0,2
   1746c:	00008067          	ret
    }
  k = 0;
  if (!(x & 0xffff))
   17470:	01079613          	slli	a2,a5,0x10
   17474:	01065613          	srli	a2,a2,0x10
	  return 1;
	}
      *y = x >> 2;
      return 2;
    }
  k = 0;
   17478:	00000713          	li	a4,0
  if (!(x & 0xffff))
   1747c:	00061663          	bnez	a2,17488 <__lo0bits+0x4c>
    {
      k = 16;
      x >>= 16;
   17480:	0107d793          	srli	a5,a5,0x10
      return 2;
    }
  k = 0;
  if (!(x & 0xffff))
    {
      k = 16;
   17484:	01000713          	li	a4,16
      x >>= 16;
    }
  if (!(x & 0xff))
   17488:	0ff7f613          	andi	a2,a5,255
   1748c:	00061663          	bnez	a2,17498 <__lo0bits+0x5c>
    {
      k += 8;
   17490:	00870713          	addi	a4,a4,8
      x >>= 8;
   17494:	0087d793          	srli	a5,a5,0x8
    }
  if (!(x & 0xf))
   17498:	00f7f613          	andi	a2,a5,15
   1749c:	00061663          	bnez	a2,174a8 <__lo0bits+0x6c>
    {
      k += 4;
   174a0:	00470713          	addi	a4,a4,4
      x >>= 4;
   174a4:	0047d793          	srli	a5,a5,0x4
    }
  if (!(x & 0x3))
   174a8:	0037f613          	andi	a2,a5,3
   174ac:	00061663          	bnez	a2,174b8 <__lo0bits+0x7c>
    {
      k += 2;
   174b0:	00270713          	addi	a4,a4,2
      x >>= 2;
   174b4:	0027d793          	srli	a5,a5,0x2
    }
  if (!(x & 1))
   174b8:	0017f613          	andi	a2,a5,1
   174bc:	00061a63          	bnez	a2,174d0 <__lo0bits+0x94>
    {
      k++;
      x >>= 1;
   174c0:	0017d793          	srli	a5,a5,0x1
      if (!x & 1)
	return 32;
   174c4:	02000513          	li	a0,32
    }
  if (!(x & 1))
    {
      k++;
      x >>= 1;
      if (!x & 1)
   174c8:	00078863          	beqz	a5,174d8 <__lo0bits+0x9c>
      k += 2;
      x >>= 2;
    }
  if (!(x & 1))
    {
      k++;
   174cc:	00170713          	addi	a4,a4,1
      x >>= 1;
      if (!x & 1)
	return 32;
    }
  *y = x;
   174d0:	00f6a023          	sw	a5,0(a3)
  return k;
   174d4:	00070513          	mv	a0,a4
}
   174d8:	00008067          	ret
    {
      if (x & 1)
	return 0;
      if (x & 2)
	{
	  *y = x >> 1;
   174dc:	0017d793          	srli	a5,a5,0x1
   174e0:	00f6a023          	sw	a5,0(a3)
	  return 1;
   174e4:	00100513          	li	a0,1
   174e8:	00008067          	ret

000174ec <__i2b>:
  return k;
}

_Bigint *
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
   174ec:	ff010113          	addi	sp,sp,-16
   174f0:	00812423          	sw	s0,8(sp)
   174f4:	00058413          	mv	s0,a1
  _Bigint *b;

  b = Balloc (ptr, 1);
   174f8:	00100593          	li	a1,1
  return k;
}

_Bigint *
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
   174fc:	00112623          	sw	ra,12(sp)
  _Bigint *b;

  b = Balloc (ptr, 1);
   17500:	be5ff0ef          	jal	170e4 <_Balloc>
  b->_x[0] = i;
  b->_wds = 1;
  return b;
}
   17504:	00c12083          	lw	ra,12(sp)
{
  _Bigint *b;

  b = Balloc (ptr, 1);
  b->_x[0] = i;
  b->_wds = 1;
   17508:	00100713          	li	a4,1
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
  _Bigint *b;

  b = Balloc (ptr, 1);
  b->_x[0] = i;
   1750c:	00852a23          	sw	s0,20(a0)
  b->_wds = 1;
   17510:	00e52823          	sw	a4,16(a0)
  return b;
}
   17514:	00812403          	lw	s0,8(sp)
   17518:	01010113          	addi	sp,sp,16
   1751c:	00008067          	ret

00017520 <__multiply>:

_Bigint *
_DEFUN (mult, (ptr, a, b), struct _reent * ptr _AND _Bigint * a _AND _Bigint * b)
{
   17520:	fe010113          	addi	sp,sp,-32
   17524:	01312623          	sw	s3,12(sp)
   17528:	01412423          	sw	s4,8(sp)
  __ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;
#ifdef Pack_32
  __ULong z2;
#endif

  if (a->_wds < b->_wds)
   1752c:	0105a983          	lw	s3,16(a1)
   17530:	01062a03          	lw	s4,16(a2)
  return b;
}

_Bigint *
_DEFUN (mult, (ptr, a, b), struct _reent * ptr _AND _Bigint * a _AND _Bigint * b)
{
   17534:	00912a23          	sw	s1,20(sp)
   17538:	01212823          	sw	s2,16(sp)
   1753c:	00112e23          	sw	ra,28(sp)
   17540:	00812c23          	sw	s0,24(sp)
   17544:	00058913          	mv	s2,a1
   17548:	00060493          	mv	s1,a2
  __ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;
#ifdef Pack_32
  __ULong z2;
#endif

  if (a->_wds < b->_wds)
   1754c:	0149dc63          	ble	s4,s3,17564 <__multiply+0x44>
   17550:	00098713          	mv	a4,s3
   17554:	00060913          	mv	s2,a2
   17558:	000a0993          	mv	s3,s4
   1755c:	00058493          	mv	s1,a1
   17560:	00070a13          	mv	s4,a4
    }
  k = a->_k;
  wa = a->_wds;
  wb = b->_wds;
  wc = wa + wb;
  if (wc > a->_maxwds)
   17564:	00892783          	lw	a5,8(s2)
    {
      c = a;
      a = b;
      b = c;
    }
  k = a->_k;
   17568:	00492583          	lw	a1,4(s2)
  wa = a->_wds;
  wb = b->_wds;
  wc = wa + wb;
   1756c:	01498433          	add	s0,s3,s4
  if (wc > a->_maxwds)
    k++;
   17570:	0087a7b3          	slt	a5,a5,s0
  c = Balloc (ptr, k);
   17574:	00f585b3          	add	a1,a1,a5
   17578:	b6dff0ef          	jal	170e4 <_Balloc>
  for (x = c->_x, xa = x + wc; x < xa; x++)
   1757c:	01450293          	addi	t0,a0,20
   17580:	00241893          	slli	a7,s0,0x2
   17584:	011288b3          	add	a7,t0,a7
   17588:	00028793          	mv	a5,t0
   1758c:	0112f863          	bleu	a7,t0,1759c <__multiply+0x7c>
    *x = 0;
   17590:	0007a023          	sw	zero,0(a5)
  wb = b->_wds;
  wc = wa + wb;
  if (wc > a->_maxwds)
    k++;
  c = Balloc (ptr, k);
  for (x = c->_x, xa = x + wc; x < xa; x++)
   17594:	00478793          	addi	a5,a5,4
   17598:	ff17ece3          	bltu	a5,a7,17590 <__multiply+0x70>
    *x = 0;
  xa = a->_x;
  xae = xa + wa;
  xb = b->_x;
   1759c:	01448613          	addi	a2,s1,20
  xbe = xb + wb;
   175a0:	002a1313          	slli	t1,s4,0x2
  if (wc > a->_maxwds)
    k++;
  c = Balloc (ptr, k);
  for (x = c->_x, xa = x + wc; x < xa; x++)
    *x = 0;
  xa = a->_x;
   175a4:	01490393          	addi	t2,s2,20
  xae = xa + wa;
   175a8:	00299813          	slli	a6,s3,0x2
  xbe = xb + wb;
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
    {
      if ((y = *xb & 0xffff) != 0)
   175ac:	000105b7          	lui	a1,0x10
  for (x = c->_x, xa = x + wc; x < xa; x++)
    *x = 0;
  xa = a->_x;
  xae = xa + wa;
  xb = b->_x;
  xbe = xb + wb;
   175b0:	00660333          	add	t1,a2,t1
    k++;
  c = Balloc (ptr, k);
  for (x = c->_x, xa = x + wc; x < xa; x++)
    *x = 0;
  xa = a->_x;
  xae = xa + wa;
   175b4:	01038833          	add	a6,t2,a6
  xbe = xb + wb;
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
    {
      if ((y = *xb & 0xffff) != 0)
   175b8:	fff58593          	addi	a1,a1,-1 # ffff <_reset+0xfdff>
  xae = xa + wa;
  xb = b->_x;
  xbe = xb + wb;
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
   175bc:	10667463          	bleu	t1,a2,176c4 <__multiply+0x1a4>
    {
      if ((y = *xb & 0xffff) != 0)
   175c0:	00062f83          	lw	t6,0(a2)
   175c4:	00bff933          	and	s2,t6,a1
   175c8:	06090a63          	beqz	s2,1763c <__multiply+0x11c>
   175cc:	00028f93          	mv	t6,t0
   175d0:	00038f13          	mv	t5,t2
   175d4:	00000693          	li	a3,0
   175d8:	0080006f          	j	175e0 <__multiply+0xc0>
   175dc:	00048f93          	mv	t6,s1
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   175e0:	000f2e03          	lw	t3,0(t5)
   175e4:	000fae83          	lw	t4,0(t6)
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
	      carry = z2 >> 16;
	      Storeinc (xc, z2, z);
   175e8:	004f8493          	addi	s1,t6,4
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   175ec:	00be7733          	and	a4,t3,a1
   175f0:	03270733          	mul	a4,a4,s2
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   175f4:	010e5e13          	srli	t3,t3,0x10
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   175f8:	00bef7b3          	and	a5,t4,a1
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   175fc:	010ede93          	srli	t4,t4,0x10
   17600:	004f0f13          	addi	t5,t5,4
   17604:	032e0e33          	mul	t3,t3,s2
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   17608:	00f70733          	add	a4,a4,a5
   1760c:	00d707b3          	add	a5,a4,a3
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   17610:	0107d693          	srli	a3,a5,0x10
	      carry = z2 >> 16;
	      Storeinc (xc, z2, z);
   17614:	00b7f7b3          	and	a5,a5,a1
	  carry = 0;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   17618:	01de0e33          	add	t3,t3,t4
   1761c:	00de06b3          	add	a3,t3,a3
	      carry = z2 >> 16;
	      Storeinc (xc, z2, z);
   17620:	01069713          	slli	a4,a3,0x10
   17624:	00f76733          	or	a4,a4,a5
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
	      carry = z >> 16;
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
	      carry = z2 >> 16;
   17628:	0106d693          	srli	a3,a3,0x10
	      Storeinc (xc, z2, z);
   1762c:	fee4ae23          	sw	a4,-4(s1)
	    }
	  while (x < xae);
   17630:	fb0f66e3          	bltu	t5,a6,175dc <__multiply+0xbc>
	  *xc = carry;
   17634:	00dfa223          	sw	a3,4(t6)
   17638:	00062f83          	lw	t6,0(a2)
	}
      if ((y = *xb >> 16) != 0)
   1763c:	010fdf93          	srli	t6,t6,0x10
   17640:	060f8c63          	beqz	t6,176b8 <__multiply+0x198>
	{
	  x = xa;
	  xc = xc0;
	  carry = 0;
	  z2 = *xc;
   17644:	0002a783          	lw	a5,0(t0) # 170b4 <memset+0xb4>
   17648:	00028f13          	mv	t5,t0
	  while (x < xae);
	  *xc = carry;
	}
      if ((y = *xb >> 16) != 0)
	{
	  x = xa;
   1764c:	00038e93          	mv	t4,t2
	  xc = xc0;
	  carry = 0;
	  z2 = *xc;
   17650:	00078e13          	mv	t3,a5
	}
      if ((y = *xb >> 16) != 0)
	{
	  x = xa;
	  xc = xc0;
	  carry = 0;
   17654:	00000913          	li	s2,0
   17658:	0080006f          	j	17660 <__multiply+0x140>
   1765c:	00048f13          	mv	t5,s1
	  z2 = *xc;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
   17660:	000ea703          	lw	a4,0(t4)
   17664:	010e5693          	srli	a3,t3,0x10
	      carry = z >> 16;
	      Storeinc (xc, z, z2);
   17668:	00b7f7b3          	and	a5,a5,a1
	  xc = xc0;
	  carry = 0;
	  z2 = *xc;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
   1766c:	00b77733          	and	a4,a4,a1
   17670:	03f70733          	mul	a4,a4,t6
	      carry = z >> 16;
	      Storeinc (xc, z, z2);
   17674:	004f0493          	addi	s1,t5,4
	      z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
   17678:	004e8e93          	addi	t4,t4,4
	  xc = xc0;
	  carry = 0;
	  z2 = *xc;
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
   1767c:	00d706b3          	add	a3,a4,a3
   17680:	012686b3          	add	a3,a3,s2
	      carry = z >> 16;
	      Storeinc (xc, z, z2);
   17684:	01069713          	slli	a4,a3,0x10
   17688:	00f767b3          	or	a5,a4,a5
   1768c:	fef4ae23          	sw	a5,-4(s1)
	      z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
   17690:	ffeed703          	lhu	a4,-2(t4)
   17694:	004f2e03          	lw	t3,4(t5)
   17698:	0106d693          	srli	a3,a3,0x10
   1769c:	03f70733          	mul	a4,a4,t6
   176a0:	00be77b3          	and	a5,t3,a1
   176a4:	00f707b3          	add	a5,a4,a5
   176a8:	00d787b3          	add	a5,a5,a3
	      carry = z2 >> 16;
   176ac:	0107d913          	srli	s2,a5,0x10
	    }
	  while (x < xae);
   176b0:	fb0ee6e3          	bltu	t4,a6,1765c <__multiply+0x13c>
	  *xc = z2;
   176b4:	00ff2223          	sw	a5,4(t5)
  xae = xa + wa;
  xb = b->_x;
  xbe = xb + wb;
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
   176b8:	00460613          	addi	a2,a2,4
   176bc:	00428293          	addi	t0,t0,4
   176c0:	f06660e3          	bltu	a2,t1,175c0 <__multiply+0xa0>
	  while (x < xae);
	  *xc = carry;
	}
    }
#endif
  for (xc0 = c->_x, xc = xc0 + wc; wc > 0 && !*--xc; --wc);
   176c4:	02805463          	blez	s0,176ec <__multiply+0x1cc>
   176c8:	ffc8a783          	lw	a5,-4(a7)
   176cc:	ffc88893          	addi	a7,a7,-4
   176d0:	00078863          	beqz	a5,176e0 <__multiply+0x1c0>
   176d4:	0180006f          	j	176ec <__multiply+0x1cc>
   176d8:	0008a783          	lw	a5,0(a7)
   176dc:	00079863          	bnez	a5,176ec <__multiply+0x1cc>
   176e0:	fff40413          	addi	s0,s0,-1
   176e4:	ffc88893          	addi	a7,a7,-4
   176e8:	fe0418e3          	bnez	s0,176d8 <__multiply+0x1b8>
  c->_wds = wc;
  return c;
}
   176ec:	01c12083          	lw	ra,28(sp)
	  *xc = carry;
	}
    }
#endif
  for (xc0 = c->_x, xc = xc0 + wc; wc > 0 && !*--xc; --wc);
  c->_wds = wc;
   176f0:	00852823          	sw	s0,16(a0)
  return c;
}
   176f4:	01412483          	lw	s1,20(sp)
   176f8:	01812403          	lw	s0,24(sp)
   176fc:	01012903          	lw	s2,16(sp)
   17700:	00c12983          	lw	s3,12(sp)
   17704:	00812a03          	lw	s4,8(sp)
   17708:	02010113          	addi	sp,sp,32
   1770c:	00008067          	ret

00017710 <__pow5mult>:

_Bigint *
_DEFUN (pow5mult,
	(ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   17710:	fe010113          	addi	sp,sp,-32
  _Bigint *b1, *p5, *p51;
  int i;
  static _CONST int p05[3] = {5, 25, 125};

  if ((i = k & 3) != 0)
   17714:	00367793          	andi	a5,a2,3
}

_Bigint *
_DEFUN (pow5mult,
	(ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   17718:	00812c23          	sw	s0,24(sp)
   1771c:	01212823          	sw	s2,16(sp)
   17720:	01312623          	sw	s3,12(sp)
   17724:	00112e23          	sw	ra,28(sp)
   17728:	00912a23          	sw	s1,20(sp)
   1772c:	00060413          	mv	s0,a2
   17730:	00050993          	mv	s3,a0
   17734:	00058913          	mv	s2,a1
  _Bigint *b1, *p5, *p51;
  int i;
  static _CONST int p05[3] = {5, 25, 125};

  if ((i = k & 3) != 0)
   17738:	0a079e63          	bnez	a5,177f4 <__pow5mult+0xe4>
    b = multadd (ptr, b, p05[i - 1], 0);

  if (!(k >>= 2))
   1773c:	40245413          	srai	s0,s0,0x2
   17740:	06040663          	beqz	s0,177ac <__pow5mult+0x9c>
    return b;
  _REENT_CHECK_MP(ptr);
  if (!(p5 = _REENT_MP_P5S(ptr)))
   17744:	0489a483          	lw	s1,72(s3)
   17748:	0c048a63          	beqz	s1,1781c <__pow5mult+0x10c>
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
      p5->_next = 0;
    }
  for (;;)
    {
      if (k & 1)
   1774c:	00147793          	andi	a5,s0,1
   17750:	02079063          	bnez	a5,17770 <__pow5mult+0x60>
	{
	  b1 = mult (ptr, b, p5);
	  Bfree (ptr, b);
	  b = b1;
	}
      if (!(k >>= 1))
   17754:	40145413          	srai	s0,s0,0x1
   17758:	04040a63          	beqz	s0,177ac <__pow5mult+0x9c>
	break;
      if (!(p51 = p5->_next))
   1775c:	0004a503          	lw	a0,0(s1)
   17760:	06050663          	beqz	a0,177cc <__pow5mult+0xbc>
}

_Bigint *
_DEFUN (pow5mult,
	(ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   17764:	00050493          	mv	s1,a0
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
      p5->_next = 0;
    }
  for (;;)
    {
      if (k & 1)
   17768:	00147793          	andi	a5,s0,1
   1776c:	fe0784e3          	beqz	a5,17754 <__pow5mult+0x44>
	{
	  b1 = mult (ptr, b, p5);
   17770:	00048613          	mv	a2,s1
   17774:	00090593          	mv	a1,s2
   17778:	00098513          	mv	a0,s3
   1777c:	da5ff0ef          	jal	17520 <__multiply>

void
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
   17780:	06090663          	beqz	s2,177ec <__pow5mult+0xdc>
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   17784:	00492783          	lw	a5,4(s2)
   17788:	04c9a703          	lw	a4,76(s3)
	{
	  b1 = mult (ptr, b, p5);
	  Bfree (ptr, b);
	  b = b1;
	}
      if (!(k >>= 1))
   1778c:	40145413          	srai	s0,s0,0x1
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   17790:	00279793          	slli	a5,a5,0x2
   17794:	00f707b3          	add	a5,a4,a5
   17798:	0007a703          	lw	a4,0(a5)
   1779c:	00e92023          	sw	a4,0(s2)
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   177a0:	0127a023          	sw	s2,0(a5)
    {
      if (k & 1)
	{
	  b1 = mult (ptr, b, p5);
	  Bfree (ptr, b);
	  b = b1;
   177a4:	00050913          	mv	s2,a0
	}
      if (!(k >>= 1))
   177a8:	fa041ae3          	bnez	s0,1775c <__pow5mult+0x4c>
	  p51->_next = 0;
	}
      p5 = p51;
    }
  return b;
}
   177ac:	01c12083          	lw	ra,28(sp)
   177b0:	00090513          	mv	a0,s2
   177b4:	01812403          	lw	s0,24(sp)
   177b8:	01412483          	lw	s1,20(sp)
   177bc:	01012903          	lw	s2,16(sp)
   177c0:	00c12983          	lw	s3,12(sp)
   177c4:	02010113          	addi	sp,sp,32
   177c8:	00008067          	ret
	}
      if (!(k >>= 1))
	break;
      if (!(p51 = p5->_next))
	{
	  p51 = p5->_next = mult (ptr, p5, p5);
   177cc:	00048613          	mv	a2,s1
   177d0:	00048593          	mv	a1,s1
   177d4:	00098513          	mv	a0,s3
   177d8:	d49ff0ef          	jal	17520 <__multiply>
   177dc:	00a4a023          	sw	a0,0(s1)
	  p51->_next = 0;
   177e0:	00052023          	sw	zero,0(a0)
}

_Bigint *
_DEFUN (pow5mult,
	(ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   177e4:	00050493          	mv	s1,a0
   177e8:	f81ff06f          	j	17768 <__pow5mult+0x58>
    {
      if (k & 1)
	{
	  b1 = mult (ptr, b, p5);
	  Bfree (ptr, b);
	  b = b1;
   177ec:	00050913          	mv	s2,a0
   177f0:	f65ff06f          	j	17754 <__pow5mult+0x44>
  _Bigint *b1, *p5, *p51;
  int i;
  static _CONST int p05[3] = {5, 25, 125};

  if ((i = k & 3) != 0)
    b = multadd (ptr, b, p05[i - 1], 0);
   177f4:	fff78793          	addi	a5,a5,-1
   177f8:	0001d737          	lui	a4,0x1d
   177fc:	a1870713          	addi	a4,a4,-1512 # 1ca18 <p05.2565>
   17800:	00279793          	slli	a5,a5,0x2
   17804:	00f707b3          	add	a5,a4,a5
   17808:	0007a603          	lw	a2,0(a5)
   1780c:	00000693          	li	a3,0
   17810:	99dff0ef          	jal	171ac <__multadd>
   17814:	00050913          	mv	s2,a0
   17818:	f25ff06f          	j	1773c <__pow5mult+0x2c>
_Bigint *
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
  _Bigint *b;

  b = Balloc (ptr, 1);
   1781c:	00100593          	li	a1,1
   17820:	00098513          	mv	a0,s3
   17824:	8c1ff0ef          	jal	170e4 <_Balloc>
  b->_x[0] = i;
   17828:	27100793          	li	a5,625
   1782c:	00f52a23          	sw	a5,20(a0)
  b->_wds = 1;
   17830:	00100793          	li	a5,1
   17834:	00f52823          	sw	a5,16(a0)
_Bigint *
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
  _Bigint *b;

  b = Balloc (ptr, 1);
   17838:	00050493          	mv	s1,a0
    return b;
  _REENT_CHECK_MP(ptr);
  if (!(p5 = _REENT_MP_P5S(ptr)))
    {
      /* first time */
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
   1783c:	04a9a423          	sw	a0,72(s3)
      p5->_next = 0;
   17840:	00052023          	sw	zero,0(a0)
   17844:	f09ff06f          	j	1774c <__pow5mult+0x3c>

00017848 <__lshift>:
  return b;
}

_Bigint *
_DEFUN (lshift, (ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   17848:	fe010113          	addi	sp,sp,-32
   1784c:	01412423          	sw	s4,8(sp)
  n = k >> 5;
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
   17850:	0105aa03          	lw	s4,16(a1)
  return b;
}

_Bigint *
_DEFUN (lshift, (ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   17854:	00812c23          	sw	s0,24(sp)
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
   17858:	0085a783          	lw	a5,8(a1)
  int i, k1, n, n1;
  _Bigint *b1;
  __ULong *x, *x1, *xe, z;

#ifdef Pack_32
  n = k >> 5;
   1785c:	40565413          	srai	s0,a2,0x5
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
   17860:	01440a33          	add	s4,s0,s4
  return b;
}

_Bigint *
_DEFUN (lshift, (ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   17864:	00912a23          	sw	s1,20(sp)
  n = k >> 5;
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
   17868:	001a0493          	addi	s1,s4,1
  return b;
}

_Bigint *
_DEFUN (lshift, (ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   1786c:	01212823          	sw	s2,16(sp)
   17870:	01312623          	sw	s3,12(sp)
   17874:	01512223          	sw	s5,4(sp)
   17878:	00058993          	mv	s3,a1
   1787c:	00112e23          	sw	ra,28(sp)
   17880:	00060913          	mv	s2,a2
   17884:	00050a93          	mv	s5,a0
#ifdef Pack_32
  n = k >> 5;
#else
  n = k >> 4;
#endif
  k1 = b->_k;
   17888:	0045a583          	lw	a1,4(a1)
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
   1788c:	0097d863          	ble	s1,a5,1789c <__lshift+0x54>
   17890:	00179793          	slli	a5,a5,0x1
    k1++;
   17894:	00158593          	addi	a1,a1,1
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
   17898:	fe97cce3          	blt	a5,s1,17890 <__lshift+0x48>
    k1++;
  b1 = Balloc (ptr, k1);
   1789c:	000a8513          	mv	a0,s5
   178a0:	845ff0ef          	jal	170e4 <_Balloc>
  x1 = b1->_x;
   178a4:	01450793          	addi	a5,a0,20
  for (i = 0; i < n; i++)
   178a8:	0e805463          	blez	s0,17990 <__lshift+0x148>
   178ac:	00241713          	slli	a4,s0,0x2
   178b0:	00e78733          	add	a4,a5,a4
    *x1++ = 0;
   178b4:	00478793          	addi	a5,a5,4
   178b8:	fe07ae23          	sw	zero,-4(a5)
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
    k1++;
  b1 = Balloc (ptr, k1);
  x1 = b1->_x;
  for (i = 0; i < n; i++)
   178bc:	fee79ce3          	bne	a5,a4,178b4 <__lshift+0x6c>
    *x1++ = 0;
  x = b->_x;
  xe = x + b->_wds;
   178c0:	0109a883          	lw	a7,16(s3)
    k1++;
  b1 = Balloc (ptr, k1);
  x1 = b1->_x;
  for (i = 0; i < n; i++)
    *x1++ = 0;
  x = b->_x;
   178c4:	01498793          	addi	a5,s3,20
  xe = x + b->_wds;
#ifdef Pack_32
  if (k &= 0x1f)
   178c8:	01f97613          	andi	a2,s2,31
  b1 = Balloc (ptr, k1);
  x1 = b1->_x;
  for (i = 0; i < n; i++)
    *x1++ = 0;
  x = b->_x;
  xe = x + b->_wds;
   178cc:	00289893          	slli	a7,a7,0x2
   178d0:	011788b3          	add	a7,a5,a7
#ifdef Pack_32
  if (k &= 0x1f)
   178d4:	08060863          	beqz	a2,17964 <__lshift+0x11c>
    {
      k1 = 32 - k;
   178d8:	02000293          	li	t0,32
   178dc:	40c282b3          	sub	t0,t0,a2
      z = 0;
   178e0:	00000693          	li	a3,0
   178e4:	0080006f          	j	178ec <__lshift+0xa4>
   178e8:	00080713          	mv	a4,a6
      do
	{
	  *x1++ = *x << k | z;
   178ec:	0007a583          	lw	a1,0(a5)
   178f0:	00470813          	addi	a6,a4,4
	  z = *x++ >> k1;
   178f4:	00478793          	addi	a5,a5,4
    {
      k1 = 32 - k;
      z = 0;
      do
	{
	  *x1++ = *x << k | z;
   178f8:	00c595b3          	sll	a1,a1,a2
   178fc:	00d5e6b3          	or	a3,a1,a3
   17900:	fed82e23          	sw	a3,-4(a6)
	  z = *x++ >> k1;
   17904:	ffc7a683          	lw	a3,-4(a5)
   17908:	0056d6b3          	srl	a3,a3,t0
	}
      while (x < xe);
   1790c:	fd17eee3          	bltu	a5,a7,178e8 <__lshift+0xa0>
      if ((*x1 = z) != 0)
   17910:	00d72223          	sw	a3,4(a4)
   17914:	00068463          	beqz	a3,1791c <__lshift+0xd4>
	++n1;
   17918:	002a0493          	addi	s1,s4,2
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   1791c:	0049a783          	lw	a5,4(s3)
   17920:	04caa703          	lw	a4,76(s5)
      *x1++ = *x++;
    while (x < xe);
  b1->_wds = n1 - 1;
  Bfree (ptr, b);
  return b1;
}
   17924:	01c12083          	lw	ra,28(sp)
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   17928:	00279793          	slli	a5,a5,0x2
   1792c:	00f707b3          	add	a5,a4,a5
   17930:	0007a703          	lw	a4,0(a5)
#endif
  else
    do
      *x1++ = *x++;
    while (x < xe);
  b1->_wds = n1 - 1;
   17934:	fff48493          	addi	s1,s1,-1
   17938:	00952823          	sw	s1,16(a0)
  Bfree (ptr, b);
  return b1;
}
   1793c:	01812403          	lw	s0,24(sp)
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   17940:	00e9a023          	sw	a4,0(s3)
      *x1++ = *x++;
    while (x < xe);
  b1->_wds = n1 - 1;
  Bfree (ptr, b);
  return b1;
}
   17944:	01412483          	lw	s1,20(sp)
{
  _REENT_CHECK_MP(ptr);
  if (v)
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   17948:	0137a023          	sw	s3,0(a5)
      *x1++ = *x++;
    while (x < xe);
  b1->_wds = n1 - 1;
  Bfree (ptr, b);
  return b1;
}
   1794c:	01012903          	lw	s2,16(sp)
   17950:	00c12983          	lw	s3,12(sp)
   17954:	00812a03          	lw	s4,8(sp)
   17958:	00412a83          	lw	s5,4(sp)
   1795c:	02010113          	addi	sp,sp,32
   17960:	00008067          	ret
	++n1;
    }
#endif
  else
    do
      *x1++ = *x++;
   17964:	00478793          	addi	a5,a5,4
   17968:	ffc7a683          	lw	a3,-4(a5)
   1796c:	00470713          	addi	a4,a4,4
   17970:	fed72e23          	sw	a3,-4(a4)
    while (x < xe);
   17974:	fb17f4e3          	bleu	a7,a5,1791c <__lshift+0xd4>
	++n1;
    }
#endif
  else
    do
      *x1++ = *x++;
   17978:	00478793          	addi	a5,a5,4
   1797c:	ffc7a683          	lw	a3,-4(a5)
   17980:	00470713          	addi	a4,a4,4
   17984:	fed72e23          	sw	a3,-4(a4)
    while (x < xe);
   17988:	fd17eee3          	bltu	a5,a7,17964 <__lshift+0x11c>
   1798c:	f91ff06f          	j	1791c <__lshift+0xd4>
  k1 = b->_k;
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
    k1++;
  b1 = Balloc (ptr, k1);
  x1 = b1->_x;
   17990:	00078713          	mv	a4,a5
   17994:	f2dff06f          	j	178c0 <__lshift+0x78>

00017998 <__mcmp>:
_DEFUN (cmp, (a, b), _Bigint * a _AND _Bigint * b)
{
  __ULong *xa, *xa0, *xb, *xb0;
  int i, j;

  i = a->_wds;
   17998:	01052703          	lw	a4,16(a0)
  j = b->_wds;
   1799c:	0105a783          	lw	a5,16(a1)
  if (i > 1 && !a->_x[i - 1])
    Bug ("cmp called with a->_x[a->_wds-1] == 0");
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
   179a0:	40f70733          	sub	a4,a4,a5
   179a4:	04071263          	bnez	a4,179e8 <__mcmp+0x50>
    return i;
  xa0 = a->_x;
  xa = xa0 + j;
   179a8:	00279713          	slli	a4,a5,0x2
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
    return i;
  xa0 = a->_x;
   179ac:	01450513          	addi	a0,a0,20
  xa = xa0 + j;
  xb0 = b->_x;
   179b0:	01458593          	addi	a1,a1,20
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
    return i;
  xa0 = a->_x;
  xa = xa0 + j;
   179b4:	00e507b3          	add	a5,a0,a4
  xb0 = b->_x;
  xb = xb0 + j;
   179b8:	00e585b3          	add	a1,a1,a4
   179bc:	0080006f          	j	179c4 <__mcmp+0x2c>
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
      if (xa <= xa0)
   179c0:	02f57863          	bleu	a5,a0,179f0 <__mcmp+0x58>
  xa = xa0 + j;
  xb0 = b->_x;
  xb = xb0 + j;
  for (;;)
    {
      if (*--xa != *--xb)
   179c4:	ffc78793          	addi	a5,a5,-4
   179c8:	ffc58593          	addi	a1,a1,-4
   179cc:	0007a703          	lw	a4,0(a5)
   179d0:	0005a683          	lw	a3,0(a1)
   179d4:	fed706e3          	beq	a4,a3,179c0 <__mcmp+0x28>
	return *xa < *xb ? -1 : 1;
   179d8:	00d73733          	sltu	a4,a4,a3
   179dc:	40e00733          	neg	a4,a4
   179e0:	00176513          	ori	a0,a4,1
   179e4:	00008067          	ret
   179e8:	00070513          	mv	a0,a4
      if (xa <= xa0)
	break;
    }
  return 0;
}
   179ec:	00008067          	ret
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
      if (xa <= xa0)
	break;
    }
  return 0;
   179f0:	00000513          	li	a0,0
   179f4:	00008067          	ret

000179f8 <__mdiff>:
_DEFUN (cmp, (a, b), _Bigint * a _AND _Bigint * b)
{
  __ULong *xa, *xa0, *xb, *xb0;
  int i, j;

  i = a->_wds;
   179f8:	0105a783          	lw	a5,16(a1)
  j = b->_wds;
   179fc:	01062703          	lw	a4,16(a2)
}

_Bigint *
_DEFUN (diff, (ptr, a, b), struct _reent * ptr _AND
	_Bigint * a _AND _Bigint * b)
{
   17a00:	fd010113          	addi	sp,sp,-48
   17a04:	03212023          	sw	s2,32(sp)
  if (i > 1 && !a->_x[i - 1])
    Bug ("cmp called with a->_x[a->_wds-1] == 0");
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
   17a08:	40e787b3          	sub	a5,a5,a4
}

_Bigint *
_DEFUN (diff, (ptr, a, b), struct _reent * ptr _AND
	_Bigint * a _AND _Bigint * b)
{
   17a0c:	02112623          	sw	ra,44(sp)
   17a10:	02812423          	sw	s0,40(sp)
   17a14:	02912223          	sw	s1,36(sp)
   17a18:	01312e23          	sw	s3,28(sp)
   17a1c:	00058913          	mv	s2,a1
  if (i > 1 && !a->_x[i - 1])
    Bug ("cmp called with a->_x[a->_wds-1] == 0");
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
   17a20:	04079863          	bnez	a5,17a70 <__mdiff+0x78>
    return i;
  xa0 = a->_x;
  xa = xa0 + j;
   17a24:	00271713          	slli	a4,a4,0x2
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
    return i;
  xa0 = a->_x;
   17a28:	01458813          	addi	a6,a1,20
  xa = xa0 + j;
  xb0 = b->_x;
   17a2c:	01460413          	addi	s0,a2,20
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
    return i;
  xa0 = a->_x;
  xa = xa0 + j;
   17a30:	00e807b3          	add	a5,a6,a4
  xb0 = b->_x;
  xb = xb0 + j;
   17a34:	00e40733          	add	a4,s0,a4
   17a38:	0080006f          	j	17a40 <__mdiff+0x48>
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
      if (xa <= xa0)
   17a3c:	16f87463          	bleu	a5,a6,17ba4 <__mdiff+0x1ac>
  xa = xa0 + j;
  xb0 = b->_x;
  xb = xb0 + j;
  for (;;)
    {
      if (*--xa != *--xb)
   17a40:	ffc78793          	addi	a5,a5,-4
   17a44:	ffc70713          	addi	a4,a4,-4
   17a48:	0007a583          	lw	a1,0(a5)
   17a4c:	00072683          	lw	a3,0(a4)
   17a50:	fed586e3          	beq	a1,a3,17a3c <__mdiff+0x44>
	return *xa < *xb ? -1 : 1;
   17a54:	16d5f463          	bleu	a3,a1,17bbc <__mdiff+0x1c4>
   17a58:	00090793          	mv	a5,s2
   17a5c:	00080493          	mv	s1,a6
   17a60:	00060913          	mv	s2,a2
  if (i < 0)
    {
      c = a;
      a = b;
      b = c;
      i = 1;
   17a64:	00100993          	li	s3,1
  xb0 = b->_x;
  xb = xb0 + j;
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
   17a68:	00078613          	mv	a2,a5
   17a6c:	0140006f          	j	17a80 <__mdiff+0x88>
      c = Balloc (ptr, 0);
      c->_wds = 1;
      c->_x[0] = 0;
      return c;
    }
  if (i < 0)
   17a70:	1407ce63          	bltz	a5,17bcc <__mdiff+0x1d4>
   17a74:	01460493          	addi	s1,a2,20
   17a78:	01458413          	addi	s0,a1,20
      a = b;
      b = c;
      i = 1;
    }
  else
    i = 0;
   17a7c:	00000993          	li	s3,0
  c = Balloc (ptr, a->_k);
   17a80:	00492583          	lw	a1,4(s2)
   17a84:	00c12623          	sw	a2,12(sp)
   17a88:	e5cff0ef          	jal	170e4 <_Balloc>
  wa = a->_wds;
  xa = a->_x;
  xae = xa + wa;
  wb = b->_wds;
  xb = b->_x;
  xbe = xb + wb;
   17a8c:	00c12603          	lw	a2,12(sp)
    }
  else
    i = 0;
  c = Balloc (ptr, a->_k);
  c->_sign = i;
  wa = a->_wds;
   17a90:	01092303          	lw	t1,16(s2)
  xc = c->_x;
  borrow = 0;
#ifdef Pack_32
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
   17a94:	000102b7          	lui	t0,0x10
  wa = a->_wds;
  xa = a->_x;
  xae = xa + wa;
  wb = b->_wds;
  xb = b->_x;
  xbe = xb + wb;
   17a98:	01062e03          	lw	t3,16(a2)
    i = 0;
  c = Balloc (ptr, a->_k);
  c->_sign = i;
  wa = a->_wds;
  xa = a->_x;
  xae = xa + wa;
   17a9c:	00231393          	slli	t2,t1,0x2
      i = 1;
    }
  else
    i = 0;
  c = Balloc (ptr, a->_k);
  c->_sign = i;
   17aa0:	01352623          	sw	s3,12(a0)
  wa = a->_wds;
  xa = a->_x;
  xae = xa + wa;
  wb = b->_wds;
  xb = b->_x;
  xbe = xb + wb;
   17aa4:	002e1e13          	slli	t3,t3,0x2
    i = 0;
  c = Balloc (ptr, a->_k);
  c->_sign = i;
  wa = a->_wds;
  xa = a->_x;
  xae = xa + wa;
   17aa8:	007403b3          	add	t2,s0,t2
  wb = b->_wds;
  xb = b->_x;
  xbe = xb + wb;
   17aac:	01c48e33          	add	t3,s1,t3
  xc = c->_x;
   17ab0:	01450813          	addi	a6,a0,20
  borrow = 0;
   17ab4:	00000693          	li	a3,0
#ifdef Pack_32
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
   17ab8:	fff28293          	addi	t0,t0,-1 # ffff <_reset+0xfdff>
   17abc:	00042583          	lw	a1,0(s0)
   17ac0:	0004a883          	lw	a7,0(s1)
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   17ac4:	00480813          	addi	a6,a6,4
  xc = c->_x;
  borrow = 0;
#ifdef Pack_32
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
   17ac8:	0055f633          	and	a2,a1,t0
   17acc:	00d606b3          	add	a3,a2,a3
   17ad0:	0058f733          	and	a4,a7,t0
   17ad4:	40e68733          	sub	a4,a3,a4
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
   17ad8:	0105d593          	srli	a1,a1,0x10
   17adc:	0108d693          	srli	a3,a7,0x10
   17ae0:	40d585b3          	sub	a1,a1,a3
   17ae4:	41075693          	srai	a3,a4,0x10
   17ae8:	00d586b3          	add	a3,a1,a3
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   17aec:	01069793          	slli	a5,a3,0x10
   17af0:	00577733          	and	a4,a4,t0
   17af4:	00e7e7b3          	or	a5,a5,a4
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
   17af8:	00448493          	addi	s1,s1,4
   17afc:	00440413          	addi	s0,s0,4
      borrow = z >> 16;
   17b00:	4106d693          	srai	a3,a3,0x10
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   17b04:	fef82e23          	sw	a5,-4(a6)
    }
  while (xb < xbe);
   17b08:	fbc4eae3          	bltu	s1,t3,17abc <__mdiff+0xc4>
  while (xa < xae)
   17b0c:	06747063          	bleu	t2,s0,17b6c <__mdiff+0x174>
    {
      y = (*xa & 0xffff) + borrow;
   17b10:	00010e37          	lui	t3,0x10
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   17b14:	00080293          	mv	t0,a6
    }
  while (xb < xbe);
  while (xa < xae)
   17b18:	00040893          	mv	a7,s0
    {
      y = (*xa & 0xffff) + borrow;
   17b1c:	fffe0e13          	addi	t3,t3,-1 # ffff <_reset+0xfdff>
   17b20:	0008a583          	lw	a1,0(a7)
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   17b24:	00428293          	addi	t0,t0,4
  while (xa < xae)
    {
      y = (*xa & 0xffff) + borrow;
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
   17b28:	00488893          	addi	a7,a7,4
      Storeinc (xc, z, y);
    }
  while (xb < xbe);
  while (xa < xae)
    {
      y = (*xa & 0xffff) + borrow;
   17b2c:	01c5f633          	and	a2,a1,t3
   17b30:	00d606b3          	add	a3,a2,a3
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
   17b34:	4106d713          	srai	a4,a3,0x10
   17b38:	0105d593          	srli	a1,a1,0x10
   17b3c:	00e58733          	add	a4,a1,a4
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   17b40:	01c6f6b3          	and	a3,a3,t3
   17b44:	01071793          	slli	a5,a4,0x10
   17b48:	00d7e7b3          	or	a5,a5,a3
   17b4c:	fef2ae23          	sw	a5,-4(t0)
    {
      y = (*xa & 0xffff) + borrow;
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
      borrow = z >> 16;
   17b50:	41075693          	srai	a3,a4,0x10
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
    }
  while (xb < xbe);
  while (xa < xae)
   17b54:	fc78e6e3          	bltu	a7,t2,17b20 <__mdiff+0x128>
   17b58:	fff44413          	not	s0,s0
   17b5c:	007403b3          	add	t2,s0,t2
   17b60:	ffc3f393          	andi	t2,t2,-4
   17b64:	00438393          	addi	t2,t2,4
   17b68:	00780833          	add	a6,a6,t2
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      *xc++ = y & 0xffff;
    }
#endif
  while (!*--xc)
   17b6c:	ffc80813          	addi	a6,a6,-4
   17b70:	00079a63          	bnez	a5,17b84 <__mdiff+0x18c>
   17b74:	ffc80813          	addi	a6,a6,-4
   17b78:	00082783          	lw	a5,0(a6)
    wa--;
   17b7c:	fff30313          	addi	t1,t1,-1
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      *xc++ = y & 0xffff;
    }
#endif
  while (!*--xc)
   17b80:	fe078ae3          	beqz	a5,17b74 <__mdiff+0x17c>
    wa--;
  c->_wds = wa;
   17b84:	00652823          	sw	t1,16(a0)
  return c;
}
   17b88:	02c12083          	lw	ra,44(sp)
   17b8c:	02812403          	lw	s0,40(sp)
   17b90:	02412483          	lw	s1,36(sp)
   17b94:	02012903          	lw	s2,32(sp)
   17b98:	01c12983          	lw	s3,28(sp)
   17b9c:	03010113          	addi	sp,sp,48
   17ba0:	00008067          	ret
#endif

  i = cmp (a, b);
  if (!i)
    {
      c = Balloc (ptr, 0);
   17ba4:	00000593          	li	a1,0
   17ba8:	d3cff0ef          	jal	170e4 <_Balloc>
      c->_wds = 1;
   17bac:	00100793          	li	a5,1
   17bb0:	00f52823          	sw	a5,16(a0)
      c->_x[0] = 0;
   17bb4:	00052a23          	sw	zero,20(a0)
      return c;
   17bb8:	fd1ff06f          	j	17b88 <__mdiff+0x190>
  xb0 = b->_x;
  xb = xb0 + j;
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
   17bbc:	00040493          	mv	s1,s0
      a = b;
      b = c;
      i = 1;
    }
  else
    i = 0;
   17bc0:	00000993          	li	s3,0
  xb0 = b->_x;
  xb = xb0 + j;
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
   17bc4:	00080413          	mv	s0,a6
   17bc8:	eb9ff06f          	j	17a80 <__mdiff+0x88>
   17bcc:	00090793          	mv	a5,s2
   17bd0:	01490493          	addi	s1,s2,20
   17bd4:	01460413          	addi	s0,a2,20
   17bd8:	00060913          	mv	s2,a2
  if (i < 0)
    {
      c = a;
      a = b;
      b = c;
      i = 1;
   17bdc:	00100993          	li	s3,1
   17be0:	00078613          	mv	a2,a5
   17be4:	e9dff06f          	j	17a80 <__mdiff+0x88>

00017be8 <__ulp>:
  union double_union x, a;
  register __Long L;

  x.d = _x;

  L = (word0 (x) & Exp_mask) - (P - 1) * Exp_msk1;
   17be8:	7ff007b7          	lui	a5,0x7ff00
   17bec:	00f5f5b3          	and	a1,a1,a5
   17bf0:	fcc007b7          	lui	a5,0xfcc00
   17bf4:	00f585b3          	add	a1,a1,a5
#ifndef Sudden_Underflow
  if (L > 0)
   17bf8:	00b05c63          	blez	a1,17c10 <__ulp+0x28>
    {
#endif
#ifdef IBM
      L |= Exp_msk1 >> 4;
#endif
      word0 (a) = L;
   17bfc:	00000713          	li	a4,0
   17c00:	00058793          	mv	a5,a1
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
#endif
	}
    }
#endif
  return a.d;
   17c04:	00070513          	mv	a0,a4
   17c08:	00078593          	mv	a1,a5
}
   17c0c:	00008067          	ret

#ifndef Sudden_Underflow
    }
  else
    {
      L = -L >> Exp_shift;
   17c10:	40b005b3          	neg	a1,a1
   17c14:	4145d593          	srai	a1,a1,0x14
      if (L < Exp_shift)
   17c18:	01300793          	li	a5,19
   17c1c:	02b7d863          	ble	a1,a5,17c4c <__ulp+0x64>
#endif
	}
      else
	{
	  word0 (a) = 0;
	  L -= Exp_shift;
   17c20:	fec58593          	addi	a1,a1,-20
#ifndef _DOUBLE_IS_32BITS
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
   17c24:	01e00613          	li	a2,30
	  word1 (a) = 0;
#endif
	}
      else
	{
	  word0 (a) = 0;
   17c28:	00000793          	li	a5,0
	  L -= Exp_shift;
#ifndef _DOUBLE_IS_32BITS
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
   17c2c:	00100693          	li	a3,1
   17c30:	00b64663          	blt	a2,a1,17c3c <__ulp+0x54>
   17c34:	fff5c593          	not	a1,a1
   17c38:	00b696b3          	sll	a3,a3,a1
   17c3c:	00068713          	mv	a4,a3
#endif
	}
    }
#endif
  return a.d;
   17c40:	00070513          	mv	a0,a4
   17c44:	00078593          	mv	a1,a5
}
   17c48:	00008067          	ret
  else
    {
      L = -L >> Exp_shift;
      if (L < Exp_shift)
	{
	  word0 (a) = 0x80000 >> L;
   17c4c:	000806b7          	lui	a3,0x80
   17c50:	00000713          	li	a4,0
   17c54:	40b6d7b3          	sra	a5,a3,a1
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
#endif
	}
    }
#endif
  return a.d;
   17c58:	00070513          	mv	a0,a4
   17c5c:	00078593          	mv	a1,a5
}
   17c60:	00008067          	ret

00017c64 <__b2d>:

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   17c64:	fe010113          	addi	sp,sp,-32
   17c68:	00812c23          	sw	s0,24(sp)
#define d0 word0(d)
#define d1 word1(d)
#endif

  xa0 = a->_x;
  xa = xa0 + a->_wds;
   17c6c:	01052403          	lw	s0,16(a0)
}

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   17c70:	00912a23          	sw	s1,20(sp)
#else
#define d0 word0(d)
#define d1 word1(d)
#endif

  xa0 = a->_x;
   17c74:	01450493          	addi	s1,a0,20
  xa = xa0 + a->_wds;
   17c78:	00241413          	slli	s0,s0,0x2
   17c7c:	00848433          	add	s0,s1,s0
}

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   17c80:	01212823          	sw	s2,16(sp)
#define d1 word1(d)
#endif

  xa0 = a->_x;
  xa = xa0 + a->_wds;
  y = *--xa;
   17c84:	ffc42903          	lw	s2,-4(s0)
}

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   17c88:	01312623          	sw	s3,12(sp)
   17c8c:	01412423          	sw	s4,8(sp)
  y = *--xa;
#ifdef DEBUG
  if (!y)
    Bug ("zero y in b2d");
#endif
  k = hi0bits (y);
   17c90:	00090513          	mv	a0,s2
}

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   17c94:	00058a13          	mv	s4,a1
   17c98:	00112e23          	sw	ra,28(sp)
  y = *--xa;
#ifdef DEBUG
  if (!y)
    Bug ("zero y in b2d");
#endif
  k = hi0bits (y);
   17c9c:	f24ff0ef          	jal	173c0 <__hi0bits>
  *e = 32 - k;
   17ca0:	02000793          	li	a5,32
   17ca4:	40a78733          	sub	a4,a5,a0
   17ca8:	00ea2023          	sw	a4,0(s4)
#ifdef Pack_32
  if (k < Ebits)
   17cac:	00a00713          	li	a4,10
#define d1 word1(d)
#endif

  xa0 = a->_x;
  xa = xa0 + a->_wds;
  y = *--xa;
   17cb0:	ffc40993          	addi	s3,s0,-4
    Bug ("zero y in b2d");
#endif
  k = hi0bits (y);
  *e = 32 - k;
#ifdef Pack_32
  if (k < Ebits)
   17cb4:	04a74e63          	blt	a4,a0,17d10 <__b2d+0xac>
    {
      d0 = Exp_1 | y >> (Ebits - k);
   17cb8:	00b00793          	li	a5,11
   17cbc:	40a787b3          	sub	a5,a5,a0
   17cc0:	3ff00737          	lui	a4,0x3ff00
   17cc4:	00f955b3          	srl	a1,s2,a5
   17cc8:	00e5e6b3          	or	a3,a1,a4
   17ccc:	00000713          	li	a4,0
      w = xa > xa0 ? *--xa : 0;
   17cd0:	0134f663          	bleu	s3,s1,17cdc <__b2d+0x78>
   17cd4:	ff842703          	lw	a4,-8(s0)
   17cd8:	00f75733          	srl	a4,a4,a5
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
   17cdc:	01550793          	addi	a5,a0,21
   17ce0:	00f917b3          	sll	a5,s2,a5
   17ce4:	00e7e633          	or	a2,a5,a4
#else
#undef d0
#undef d1
#endif
  return d.d;
}
   17ce8:	01c12083          	lw	ra,28(sp)
  word1 (d) = d1 >> 16 | d1 << 16;
#else
#undef d0
#undef d1
#endif
  return d.d;
   17cec:	00060513          	mv	a0,a2
   17cf0:	00068593          	mv	a1,a3
}
   17cf4:	01812403          	lw	s0,24(sp)
   17cf8:	01412483          	lw	s1,20(sp)
   17cfc:	01012903          	lw	s2,16(sp)
   17d00:	00c12983          	lw	s3,12(sp)
   17d04:	00812a03          	lw	s4,8(sp)
   17d08:	02010113          	addi	sp,sp,32
   17d0c:	00008067          	ret
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
#endif
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
   17d10:	0534f463          	bleu	s3,s1,17d58 <__b2d+0xf4>
  if (k -= Ebits)
   17d14:	ff550713          	addi	a4,a0,-11
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
#endif
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
   17d18:	ff842503          	lw	a0,-8(s0)
  if (k -= Ebits)
   17d1c:	04070263          	beqz	a4,17d60 <__b2d+0xfc>
    {
      d0 = Exp_1 | y << k | z >> (32 - k);
   17d20:	3ff006b7          	lui	a3,0x3ff00
   17d24:	40e787b3          	sub	a5,a5,a4
   17d28:	00e91933          	sll	s2,s2,a4
   17d2c:	00d96933          	or	s2,s2,a3
   17d30:	00f55833          	srl	a6,a0,a5
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
#endif
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
   17d34:	ff840593          	addi	a1,s0,-8
  if (k -= Ebits)
    {
      d0 = Exp_1 | y << k | z >> (32 - k);
   17d38:	010966b3          	or	a3,s2,a6
      y = xa > xa0 ? *--xa : 0;
   17d3c:	04b4f663          	bleu	a1,s1,17d88 <__b2d+0x124>
   17d40:	ff442583          	lw	a1,-12(s0)
   17d44:	00e51533          	sll	a0,a0,a4
   17d48:	00f5d7b3          	srl	a5,a1,a5
   17d4c:	00a7e533          	or	a0,a5,a0
    }
  else
    {
      d0 = Exp_1 | y;
#ifndef _DOUBLE_IS_32BITS
      d1 = z;
   17d50:	00050613          	mv	a2,a0
   17d54:	f95ff06f          	j	17ce8 <__b2d+0x84>
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
#endif
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
  if (k -= Ebits)
   17d58:	ff550513          	addi	a0,a0,-11
   17d5c:	00051a63          	bnez	a0,17d70 <__b2d+0x10c>
      d1 = z << k | y >> (32 - k);
#endif
    }
  else
    {
      d0 = Exp_1 | y;
   17d60:	3ff007b7          	lui	a5,0x3ff00
   17d64:	00f966b3          	or	a3,s2,a5
#ifndef _DOUBLE_IS_32BITS
      d1 = z;
   17d68:	00050613          	mv	a2,a0
   17d6c:	f7dff06f          	j	17ce8 <__b2d+0x84>
      goto ret_d;
    }
  z = xa > xa0 ? *--xa : 0;
  if (k -= Ebits)
    {
      d0 = Exp_1 | y << k | z >> (32 - k);
   17d70:	00a91933          	sll	s2,s2,a0
   17d74:	3ff007b7          	lui	a5,0x3ff00
   17d78:	00000513          	li	a0,0
   17d7c:	00f966b3          	or	a3,s2,a5
    }
  else
    {
      d0 = Exp_1 | y;
#ifndef _DOUBLE_IS_32BITS
      d1 = z;
   17d80:	00050613          	mv	a2,a0
   17d84:	f65ff06f          	j	17ce8 <__b2d+0x84>
   17d88:	00e51533          	sll	a0,a0,a4
   17d8c:	00050613          	mv	a2,a0
   17d90:	f59ff06f          	j	17ce8 <__b2d+0x84>

00017d94 <__d2b>:
	struct _reent * ptr _AND
	double _d _AND
	int *e _AND
	int *bits)

{
   17d94:	fd010113          	addi	sp,sp,-48
   17d98:	02812423          	sw	s0,40(sp)
#define d1 word1(d)
  d.d = _d;
#endif

#ifdef Pack_32
  b = Balloc (ptr, 1);
   17d9c:	00100593          	li	a1,1
  int de, i, k;
  __ULong *x, y, z;
#ifdef VAX
  __ULong d0, d1;
#endif
  d.d = _d;
   17da0:	00068413          	mv	s0,a3
	struct _reent * ptr _AND
	double _d _AND
	int *e _AND
	int *bits)

{
   17da4:	02912223          	sw	s1,36(sp)
   17da8:	03212023          	sw	s2,32(sp)
   17dac:	01312e23          	sw	s3,28(sp)
   17db0:	01412c23          	sw	s4,24(sp)
   17db4:	01512a23          	sw	s5,20(sp)
   17db8:	00078993          	mv	s3,a5
  de = (int) (d0 >> Exp_shift);
#ifndef IBM
  z |= Exp_msk11;
#endif
#else
  if ((de = (int) (d0 >> Exp_shift)) != 0)
   17dbc:	00141493          	slli	s1,s0,0x1
	struct _reent * ptr _AND
	double _d _AND
	int *e _AND
	int *bits)

{
   17dc0:	02112623          	sw	ra,44(sp)
   17dc4:	00070a13          	mv	s4,a4
  int de, i, k;
  __ULong *x, y, z;
#ifdef VAX
  __ULong d0, d1;
#endif
  d.d = _d;
   17dc8:	00060a93          	mv	s5,a2
#define d1 word1(d)
  d.d = _d;
#endif

#ifdef Pack_32
  b = Balloc (ptr, 1);
   17dcc:	b18ff0ef          	jal	170e4 <_Balloc>
#else
  b = Balloc (ptr, 2);
#endif
  x = b->_x;

  z = d0 & Frac_mask;
   17dd0:	001007b7          	lui	a5,0x100
   17dd4:	fff78693          	addi	a3,a5,-1 # fffff <_gp+0xb781f>
  de = (int) (d0 >> Exp_shift);
#ifndef IBM
  z |= Exp_msk11;
#endif
#else
  if ((de = (int) (d0 >> Exp_shift)) != 0)
   17dd8:	0154d493          	srli	s1,s1,0x15
#define d1 word1(d)
  d.d = _d;
#endif

#ifdef Pack_32
  b = Balloc (ptr, 1);
   17ddc:	00050913          	mv	s2,a0
#else
  b = Balloc (ptr, 2);
#endif
  x = b->_x;

  z = d0 & Frac_mask;
   17de0:	00d47433          	and	s0,s0,a3
  de = (int) (d0 >> Exp_shift);
#ifndef IBM
  z |= Exp_msk11;
#endif
#else
  if ((de = (int) (d0 >> Exp_shift)) != 0)
   17de4:	00048463          	beqz	s1,17dec <__d2b+0x58>
    z |= Exp_msk1;
   17de8:	00f46433          	or	s0,s0,a5
   17dec:	00812623          	sw	s0,12(sp)
#endif
#ifdef Pack_32
#ifndef _DOUBLE_IS_32BITS
  if (d1)
   17df0:	080a8463          	beqz	s5,17e78 <__d2b+0xe4>
    {
      y = d1;
      k = lo0bits (&y);
   17df4:	00810513          	addi	a0,sp,8
#endif
#ifdef Pack_32
#ifndef _DOUBLE_IS_32BITS
  if (d1)
    {
      y = d1;
   17df8:	01512423          	sw	s5,8(sp)
      k = lo0bits (&y);
   17dfc:	e40ff0ef          	jal	1743c <__lo0bits>
   17e00:	00050793          	mv	a5,a0
      if (k)
	{
         x[0] = y | z << (32 - k);
   17e04:	00c12703          	lw	a4,12(sp)
#ifndef _DOUBLE_IS_32BITS
  if (d1)
    {
      y = d1;
      k = lo0bits (&y);
      if (k)
   17e08:	0a051663          	bnez	a0,17eb4 <__d2b+0x120>
	{
         x[0] = y | z << (32 - k);
	  z >>= k;
	}
      else
	x[0] = y;
   17e0c:	00812683          	lw	a3,8(sp)
   17e10:	00d92a23          	sw	a3,20(s2)
      i = b->_wds = (x[1] = z) ? 2 : 1;
   17e14:	00173413          	seqz	s0,a4
   17e18:	00200693          	li	a3,2
   17e1c:	40868433          	sub	s0,a3,s0
   17e20:	00e92c23          	sw	a4,24(s2)
   17e24:	00892823          	sw	s0,16(s2)
  while (!x[i])
    --i;
  b->_wds = i + 1;
#endif
#ifndef Sudden_Underflow
  if (de)
   17e28:	06049863          	bnez	s1,17e98 <__d2b+0x104>
    }
  else
    {
      *e = de - Bias - (P - 1) + 1 + k;
#ifdef Pack_32
      *bits = 32 * i - hi0bits (x[i - 1]);
   17e2c:	00241713          	slli	a4,s0,0x2
   17e30:	00e90733          	add	a4,s2,a4
   17e34:	01072503          	lw	a0,16(a4) # 3ff00010 <_gp+0x3feb7830>
#endif
#ifndef Sudden_Underflow
    }
  else
    {
      *e = de - Bias - (P - 1) + 1 + k;
   17e38:	bce78793          	addi	a5,a5,-1074
   17e3c:	00fa2023          	sw	a5,0(s4)
#ifdef Pack_32
      *bits = 32 * i - hi0bits (x[i - 1]);
   17e40:	d80ff0ef          	jal	173c0 <__hi0bits>
   17e44:	00541413          	slli	s0,s0,0x5
   17e48:	40a40533          	sub	a0,s0,a0
   17e4c:	00a9a023          	sw	a0,0(s3)
      *bits = (i + 2) * 16 - hi0bits (x[i]);
#endif
    }
#endif
  return b;
}
   17e50:	02c12083          	lw	ra,44(sp)
   17e54:	00090513          	mv	a0,s2
   17e58:	02812403          	lw	s0,40(sp)
   17e5c:	02412483          	lw	s1,36(sp)
   17e60:	02012903          	lw	s2,32(sp)
   17e64:	01c12983          	lw	s3,28(sp)
   17e68:	01812a03          	lw	s4,24(sp)
   17e6c:	01412a83          	lw	s5,20(sp)
   17e70:	03010113          	addi	sp,sp,48
   17e74:	00008067          	ret
    {
#ifdef DEBUG
      if (!z)
	Bug ("Zero passed to d2b");
#endif
      k = lo0bits (&z);
   17e78:	00c10513          	addi	a0,sp,12
   17e7c:	dc0ff0ef          	jal	1743c <__lo0bits>
      x[0] = z;
   17e80:	00c12783          	lw	a5,12(sp)
      i = b->_wds = 1;
   17e84:	00100413          	li	s0,1
   17e88:	00892823          	sw	s0,16(s2)
#ifdef DEBUG
      if (!z)
	Bug ("Zero passed to d2b");
#endif
      k = lo0bits (&z);
      x[0] = z;
   17e8c:	00f92a23          	sw	a5,20(s2)
      i = b->_wds = 1;
#ifndef _DOUBLE_IS_32BITS
      k += 32;
   17e90:	02050793          	addi	a5,a0,32
  while (!x[i])
    --i;
  b->_wds = i + 1;
#endif
#ifndef Sudden_Underflow
  if (de)
   17e94:	f8048ce3          	beqz	s1,17e2c <__d2b+0x98>
#endif
#ifdef IBM
      *e = (de - Bias - (P - 1) << 2) + k;
      *bits = 4 * P + 8 - k - hi0bits (word0 (d) & Frac_mask);
#else
      *e = de - Bias - (P - 1) + k;
   17e98:	bcd48493          	addi	s1,s1,-1075
      *bits = P - k;
   17e9c:	03500713          	li	a4,53
#endif
#ifdef IBM
      *e = (de - Bias - (P - 1) << 2) + k;
      *bits = 4 * P + 8 - k - hi0bits (word0 (d) & Frac_mask);
#else
      *e = de - Bias - (P - 1) + k;
   17ea0:	00f484b3          	add	s1,s1,a5
      *bits = P - k;
   17ea4:	40f707b3          	sub	a5,a4,a5
#endif
#ifdef IBM
      *e = (de - Bias - (P - 1) << 2) + k;
      *bits = 4 * P + 8 - k - hi0bits (word0 (d) & Frac_mask);
#else
      *e = de - Bias - (P - 1) + k;
   17ea8:	009a2023          	sw	s1,0(s4)
      *bits = P - k;
   17eac:	00f9a023          	sw	a5,0(s3)
   17eb0:	fa1ff06f          	j	17e50 <__d2b+0xbc>
    {
      y = d1;
      k = lo0bits (&y);
      if (k)
	{
         x[0] = y | z << (32 - k);
   17eb4:	02000693          	li	a3,32
   17eb8:	00812603          	lw	a2,8(sp)
   17ebc:	40a686b3          	sub	a3,a3,a0
   17ec0:	00d716b3          	sll	a3,a4,a3
   17ec4:	00c6e6b3          	or	a3,a3,a2
	  z >>= k;
   17ec8:	00a75733          	srl	a4,a4,a0
    {
      y = d1;
      k = lo0bits (&y);
      if (k)
	{
         x[0] = y | z << (32 - k);
   17ecc:	00d92a23          	sw	a3,20(s2)
	  z >>= k;
   17ed0:	00e12623          	sw	a4,12(sp)
   17ed4:	f41ff06f          	j	17e14 <__d2b+0x80>

00017ed8 <__ratio>:
#undef d1

double
_DEFUN (ratio, (a, b), _Bigint * a _AND _Bigint * b)

{
   17ed8:	fd010113          	addi	sp,sp,-48
   17edc:	03212023          	sw	s2,32(sp)
   17ee0:	00058913          	mv	s2,a1
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
   17ee4:	00810593          	addi	a1,sp,8
#undef d1

double
_DEFUN (ratio, (a, b), _Bigint * a _AND _Bigint * b)

{
   17ee8:	02112623          	sw	ra,44(sp)
   17eec:	02812423          	sw	s0,40(sp)
   17ef0:	02912223          	sw	s1,36(sp)
   17ef4:	01312e23          	sw	s3,28(sp)
   17ef8:	00050993          	mv	s3,a0
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
   17efc:	d69ff0ef          	jal	17c64 <__b2d>
   17f00:	00050413          	mv	s0,a0
   17f04:	00058493          	mv	s1,a1
  db.d = b2d (b, &kb);
   17f08:	00090513          	mv	a0,s2
   17f0c:	00c10593          	addi	a1,sp,12
   17f10:	d55ff0ef          	jal	17c64 <__b2d>
#ifdef Pack_32
  k = ka - kb + 32 * (a->_wds - b->_wds);
   17f14:	01092703          	lw	a4,16(s2)
   17f18:	0109a783          	lw	a5,16(s3)
{
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
  db.d = b2d (b, &kb);
   17f1c:	00058693          	mv	a3,a1
#ifdef Pack_32
  k = ka - kb + 32 * (a->_wds - b->_wds);
   17f20:	00c12583          	lw	a1,12(sp)
   17f24:	40e787b3          	sub	a5,a5,a4
   17f28:	00579713          	slli	a4,a5,0x5
   17f2c:	00812783          	lw	a5,8(sp)
{
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
  db.d = b2d (b, &kb);
   17f30:	00050613          	mv	a2,a0
#ifdef Pack_32
  k = ka - kb + 32 * (a->_wds - b->_wds);
   17f34:	40b787b3          	sub	a5,a5,a1
   17f38:	00f707b3          	add	a5,a4,a5
      word0 (db) += (k >> 2) * Exp_msk1;
      if (k &= 3)
	db.d *= 1 << k;
    }
#else
  if (k > 0)
   17f3c:	02f05c63          	blez	a5,17f74 <__ratio+0x9c>
    word0 (da) += k * Exp_msk1;
   17f40:	01479793          	slli	a5,a5,0x14
   17f44:	009785b3          	add	a1,a5,s1
   17f48:	00058493          	mv	s1,a1
    {
      k = -k;
      word0 (db) += k * Exp_msk1;
    }
#endif
  return da.d / db.d;
   17f4c:	00040513          	mv	a0,s0
   17f50:	00048593          	mv	a1,s1
   17f54:	2f4030ef          	jal	1b248 <__divdf3>
}
   17f58:	02c12083          	lw	ra,44(sp)
   17f5c:	02812403          	lw	s0,40(sp)
   17f60:	02412483          	lw	s1,36(sp)
   17f64:	02012903          	lw	s2,32(sp)
   17f68:	01c12983          	lw	s3,28(sp)
   17f6c:	03010113          	addi	sp,sp,48
   17f70:	00008067          	ret
  if (k > 0)
    word0 (da) += k * Exp_msk1;
  else
    {
      k = -k;
      word0 (db) += k * Exp_msk1;
   17f74:	01479793          	slli	a5,a5,0x14
   17f78:	40f688b3          	sub	a7,a3,a5
   17f7c:	00088693          	mv	a3,a7
   17f80:	fcdff06f          	j	17f4c <__ratio+0x74>

00017f84 <_mprec_log10>:


double
_DEFUN (_mprec_log10, (dig),
	int dig)
{
   17f84:	ff010113          	addi	sp,sp,-16
  double v = 1.0;
  if (dig < 24)
   17f88:	01700793          	li	a5,23


double
_DEFUN (_mprec_log10, (dig),
	int dig)
{
   17f8c:	00812423          	sw	s0,8(sp)
   17f90:	00112623          	sw	ra,12(sp)
   17f94:	01212223          	sw	s2,4(sp)
   17f98:	01312023          	sw	s3,0(sp)
   17f9c:	00050413          	mv	s0,a0
  double v = 1.0;
  if (dig < 24)
   17fa0:	04a7d063          	ble	a0,a5,17fe0 <_mprec_log10+0x5c>
   17fa4:	8481a503          	lw	a0,-1976(gp) # 48028 <__wctomb+0x28>
   17fa8:	84c1a583          	lw	a1,-1972(gp) # 4802c <__wctomb+0x2c>
    return tens[dig];
  while (dig > 0)
    {
      v *= 10;
   17fac:	8501a903          	lw	s2,-1968(gp) # 48030 <__wctomb+0x30>
   17fb0:	8541a983          	lw	s3,-1964(gp) # 48034 <__wctomb+0x34>
      dig--;
   17fb4:	fff40413          	addi	s0,s0,-1
  double v = 1.0;
  if (dig < 24)
    return tens[dig];
  while (dig > 0)
    {
      v *= 10;
   17fb8:	00090613          	mv	a2,s2
   17fbc:	00098693          	mv	a3,s3
   17fc0:	024030ef          	jal	1afe4 <__muldf3>
	int dig)
{
  double v = 1.0;
  if (dig < 24)
    return tens[dig];
  while (dig > 0)
   17fc4:	fe0418e3          	bnez	s0,17fb4 <_mprec_log10+0x30>
    {
      v *= 10;
      dig--;
    }
  return v;
}
   17fc8:	00c12083          	lw	ra,12(sp)
   17fcc:	00812403          	lw	s0,8(sp)
   17fd0:	00412903          	lw	s2,4(sp)
   17fd4:	00012983          	lw	s3,0(sp)
   17fd8:	01010113          	addi	sp,sp,16
   17fdc:	00008067          	ret
_DEFUN (_mprec_log10, (dig),
	int dig)
{
  double v = 1.0;
  if (dig < 24)
    return tens[dig];
   17fe0:	0001d7b7          	lui	a5,0x1d
   17fe4:	00351413          	slli	s0,a0,0x3
   17fe8:	a1878793          	addi	a5,a5,-1512 # 1ca18 <p05.2565>
   17fec:	00878433          	add	s0,a5,s0
   17ff0:	01042503          	lw	a0,16(s0)
   17ff4:	01442583          	lw	a1,20(s0)
   17ff8:	fd1ff06f          	j	17fc8 <_mprec_log10+0x44>

00017ffc <__copybits>:
#endif

	ce = c + ((n-1) >> kshift) + 1;
	x = b->_x;
#ifdef Pack_32
	xe = x + b->_wds;
   17ffc:	01062683          	lw	a3,16(a2)
	__ULong *ce, *x, *xe;
#ifdef Pack_16
	int nw, nw1;
#endif

	ce = c + ((n-1) >> kshift) + 1;
   18000:	fff58593          	addi	a1,a1,-1
   18004:	4055d813          	srai	a6,a1,0x5
   18008:	00180813          	addi	a6,a6,1
	x = b->_x;
   1800c:	01460793          	addi	a5,a2,20
#ifdef Pack_32
	xe = x + b->_wds;
   18010:	00269693          	slli	a3,a3,0x2
	__ULong *ce, *x, *xe;
#ifdef Pack_16
	int nw, nw1;
#endif

	ce = c + ((n-1) >> kshift) + 1;
   18014:	00281813          	slli	a6,a6,0x2
	x = b->_x;
#ifdef Pack_32
	xe = x + b->_wds;
   18018:	00d786b3          	add	a3,a5,a3
	__ULong *ce, *x, *xe;
#ifdef Pack_16
	int nw, nw1;
#endif

	ce = c + ((n-1) >> kshift) + 1;
   1801c:	01050833          	add	a6,a0,a6
	x = b->_x;
#ifdef Pack_32
	xe = x + b->_wds;
	while(x < xe)
   18020:	02d7f863          	bleu	a3,a5,18050 <__copybits+0x54>
   18024:	00050713          	mv	a4,a0
		*c++ = *x++;
   18028:	00478793          	addi	a5,a5,4
   1802c:	ffc7a583          	lw	a1,-4(a5)
   18030:	00470713          	addi	a4,a4,4
   18034:	feb72e23          	sw	a1,-4(a4)

	ce = c + ((n-1) >> kshift) + 1;
	x = b->_x;
#ifdef Pack_32
	xe = x + b->_wds;
	while(x < xe)
   18038:	fed7e8e3          	bltu	a5,a3,18028 <__copybits+0x2c>
   1803c:	40c687b3          	sub	a5,a3,a2
   18040:	feb78793          	addi	a5,a5,-21
   18044:	ffc7f793          	andi	a5,a5,-4
   18048:	00478793          	addi	a5,a5,4
   1804c:	00f50533          	add	a0,a0,a5
	for(xe = x + (nw - nw1); x < xe; x += 2)
		Storeinc(c, x[1], x[0]);
	if (nw1)
		*c++ = *x;
#endif
	while(c < ce)
   18050:	01057863          	bleu	a6,a0,18060 <__copybits+0x64>
		*c++ = 0;
   18054:	00450513          	addi	a0,a0,4
   18058:	fe052e23          	sw	zero,-4(a0)
	for(xe = x + (nw - nw1); x < xe; x += 2)
		Storeinc(c, x[1], x[0]);
	if (nw1)
		*c++ = *x;
#endif
	while(c < ce)
   1805c:	ff056ce3          	bltu	a0,a6,18054 <__copybits+0x58>
   18060:	00008067          	ret

00018064 <__any_on>:
{
	int n, nwds;
	__ULong *x, *x0, x1, x2;

	x = b->_x;
	nwds = b->_wds;
   18064:	01052783          	lw	a5,16(a0)
	n = k >> kshift;
   18068:	4055d713          	srai	a4,a1,0x5
	int k)
{
	int n, nwds;
	__ULong *x, *x0, x1, x2;

	x = b->_x;
   1806c:	01450693          	addi	a3,a0,20
	nwds = b->_wds;
	n = k >> kshift;
	if (n > nwds)
   18070:	02e7da63          	ble	a4,a5,180a4 <__any_on+0x40>
   18074:	00279793          	slli	a5,a5,0x2
   18078:	00f687b3          	add	a5,a3,a5
		if (x1 != x2)
			return 1;
		}
	x0 = x;
	x += n;
	while(x > x0)
   1807c:	06f6f263          	bleu	a5,a3,180e0 <__any_on+0x7c>
		if (*--x)
   18080:	ffc7a503          	lw	a0,-4(a5)
   18084:	ffc78793          	addi	a5,a5,-4
   18088:	00051a63          	bnez	a0,1809c <__any_on+0x38>
		if (x1 != x2)
			return 1;
		}
	x0 = x;
	x += n;
	while(x > x0)
   1808c:	04f6f863          	bleu	a5,a3,180dc <__any_on+0x78>
		if (*--x)
   18090:	ffc78793          	addi	a5,a5,-4
   18094:	0007a703          	lw	a4,0(a5)
   18098:	fe070ae3          	beqz	a4,1808c <__any_on+0x28>
	else if (n < nwds && (k &= kmask)) {
		x1 = x2 = x[n];
		x1 >>= k;
		x1 <<= k;
		if (x1 != x2)
			return 1;
   1809c:	00100513          	li	a0,1
	x += n;
	while(x > x0)
		if (*--x)
			return 1;
	return 0;
}
   180a0:	00008067          	ret
	x = b->_x;
	nwds = b->_wds;
	n = k >> kshift;
	if (n > nwds)
		n = nwds;
	else if (n < nwds && (k &= kmask)) {
   180a4:	02f75663          	ble	a5,a4,180d0 <__any_on+0x6c>
		x1 = x2 = x[n];
   180a8:	00271793          	slli	a5,a4,0x2
	x = b->_x;
	nwds = b->_wds;
	n = k >> kshift;
	if (n > nwds)
		n = nwds;
	else if (n < nwds && (k &= kmask)) {
   180ac:	01f5f593          	andi	a1,a1,31
		x1 = x2 = x[n];
   180b0:	00f687b3          	add	a5,a3,a5
	x = b->_x;
	nwds = b->_wds;
	n = k >> kshift;
	if (n > nwds)
		n = nwds;
	else if (n < nwds && (k &= kmask)) {
   180b4:	fc0584e3          	beqz	a1,1807c <__any_on+0x18>
		x1 = x2 = x[n];
   180b8:	0007a603          	lw	a2,0(a5)
		x1 >>= k;
		x1 <<= k;
		if (x1 != x2)
			return 1;
   180bc:	00100513          	li	a0,1
	n = k >> kshift;
	if (n > nwds)
		n = nwds;
	else if (n < nwds && (k &= kmask)) {
		x1 = x2 = x[n];
		x1 >>= k;
   180c0:	00b65733          	srl	a4,a2,a1
		x1 <<= k;
		if (x1 != x2)
   180c4:	00b715b3          	sll	a1,a4,a1
   180c8:	fab60ae3          	beq	a2,a1,1807c <__any_on+0x18>
	x += n;
	while(x > x0)
		if (*--x)
			return 1;
	return 0;
}
   180cc:	00008067          	ret
   180d0:	00271793          	slli	a5,a4,0x2
   180d4:	00f687b3          	add	a5,a3,a5
   180d8:	fa5ff06f          	j	1807c <__any_on+0x18>
   180dc:	00008067          	ret
	x0 = x;
	x += n;
	while(x > x0)
		if (*--x)
			return 1;
	return 0;
   180e0:	00000513          	li	a0,0
   180e4:	00008067          	ret

000180e8 <__fpclassifyd>:
{
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
   180e8:	00a5e733          	or	a4,a1,a0
int
__fpclassifyd (double x)
{
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);
   180ec:	00050793          	mv	a5,a0

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
   180f0:	00200513          	li	a0,2
{
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
   180f4:	00071463          	bnez	a4,180fc <__fpclassifyd+0x14>
  else if ((msw == 0x7ff00000 && lsw == 0x00000000) ||
           (msw == 0xfff00000 && lsw == 0x00000000))
    return FP_INFINITE;
  else
    return FP_NAN;
}
   180f8:	00008067          	ret
{
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
   180fc:	80000737          	lui	a4,0x80000
   18100:	04e58863          	beq	a1,a4,18150 <__fpclassifyd+0x68>
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
   18104:	fff00737          	lui	a4,0xfff00
   18108:	00e58733          	add	a4,a1,a4
   1810c:	7fe006b7          	lui	a3,0x7fe00
           (msw >= 0x80100000 && msw <= 0xffefffff))
    return FP_NORMAL;
   18110:	00400513          	li	a0,4
  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
   18114:	fed762e3          	bltu	a4,a3,180f8 <__fpclassifyd+0x10>
   18118:	7ff00737          	lui	a4,0x7ff00
   1811c:	00e58733          	add	a4,a1,a4
   18120:	fcd76ce3          	bltu	a4,a3,180f8 <__fpclassifyd+0x10>
           (msw >= 0x80100000 && msw <= 0xffefffff))
    return FP_NORMAL;
  else if ((msw >= 0x00000000 && msw <= 0x000fffff) ||
   18124:	80000737          	lui	a4,0x80000
   18128:	fff74713          	not	a4,a4
   1812c:	00e5f5b3          	and	a1,a1,a4
   18130:	00100737          	lui	a4,0x100
           (msw >= 0x80000000 && msw <= 0x800fffff))
    /* zero is already handled above */
    return FP_SUBNORMAL;
   18134:	00300513          	li	a0,3
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
           (msw >= 0x80100000 && msw <= 0xffefffff))
    return FP_NORMAL;
  else if ((msw >= 0x00000000 && msw <= 0x000fffff) ||
   18138:	fce5e0e3          	bltu	a1,a4,180f8 <__fpclassifyd+0x10>
           (msw >= 0x80000000 && msw <= 0x800fffff))
    /* zero is already handled above */
    return FP_SUBNORMAL;
  else if ((msw == 0x7ff00000 && lsw == 0x00000000) ||
   1813c:	7ff00737          	lui	a4,0x7ff00
           (msw == 0xfff00000 && lsw == 0x00000000))
    return FP_INFINITE;
  else
    return FP_NAN;
   18140:	00000513          	li	a0,0
    return FP_NORMAL;
  else if ((msw >= 0x00000000 && msw <= 0x000fffff) ||
           (msw >= 0x80000000 && msw <= 0x800fffff))
    /* zero is already handled above */
    return FP_SUBNORMAL;
  else if ((msw == 0x7ff00000 && lsw == 0x00000000) ||
   18144:	fae59ae3          	bne	a1,a4,180f8 <__fpclassifyd+0x10>
  if ((msw == 0x00000000 && lsw == 0x00000000) ||
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
           (msw >= 0x80100000 && msw <= 0xffefffff))
    return FP_NORMAL;
   18148:	0017b513          	seqz	a0,a5
   1814c:	00008067          	ret

  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
   18150:	00200513          	li	a0,2
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
      (msw == 0x80000000 && lsw == 0x00000000))
   18154:	fc0798e3          	bnez	a5,18124 <__fpclassifyd+0x3c>
  else if ((msw == 0x7ff00000 && lsw == 0x00000000) ||
           (msw == 0xfff00000 && lsw == 0x00000000))
    return FP_INFINITE;
  else
    return FP_NAN;
}
   18158:	00008067          	ret

0001815c <__sread>:
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   1815c:	00e59503          	lh	a0,14(a1)
_DEFUN(__sread, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   18160:	ff010113          	addi	sp,sp,-16
   18164:	00812423          	sw	s0,8(sp)
   18168:	00058413          	mv	s0,a1
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   1816c:	00060593          	mv	a1,a2
   18170:	00068613          	mv	a2,a3
_DEFUN(__sread, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   18174:	00112623          	sw	ra,12(sp)
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   18178:	98cf80ef          	jal	10304 <read>
    setmode (fp->_file, oldmode);
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
   1817c:	02054c63          	bltz	a0,181b4 <__sread+0x58>
    fp->_offset += ret;
   18180:	05042783          	lw	a5,80(s0)
   18184:	05442683          	lw	a3,84(s0)
   18188:	41f55613          	srai	a2,a0,0x1f
   1818c:	00a785b3          	add	a1,a5,a0
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
  return ret;
}
   18190:	00c12083          	lw	ra,12(sp)
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
    fp->_offset += ret;
   18194:	00f5b733          	sltu	a4,a1,a5
   18198:	00c687b3          	add	a5,a3,a2
   1819c:	00f707b3          	add	a5,a4,a5
   181a0:	04b42823          	sw	a1,80(s0)
   181a4:	04f42a23          	sw	a5,84(s0)
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
  return ret;
}
   181a8:	00812403          	lw	s0,8(sp)
   181ac:	01010113          	addi	sp,sp,16
   181b0:	00008067          	ret
  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
    fp->_offset += ret;
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
   181b4:	00c45703          	lhu	a4,12(s0)
   181b8:	fffff7b7          	lui	a5,0xfffff
  return ret;
}
   181bc:	00c12083          	lw	ra,12(sp)
  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
    fp->_offset += ret;
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
   181c0:	fff78793          	addi	a5,a5,-1 # ffffefff <_gp+0xfffb681f>
   181c4:	00f777b3          	and	a5,a4,a5
   181c8:	00f41623          	sh	a5,12(s0)
  return ret;
}
   181cc:	00812403          	lw	s0,8(sp)
   181d0:	01010113          	addi	sp,sp,16
   181d4:	00008067          	ret

000181d8 <__seofread>:
       _PTR cookie _AND
       char *buf   _AND
       _READ_WRITE_BUFSIZE_TYPE len)
{
  return 0;
}
   181d8:	00000513          	li	a0,0
   181dc:	00008067          	ret

000181e0 <__swrite>:
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   181e0:	00c59703          	lh	a4,12(a1)
_DEFUN(__swrite, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char const *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   181e4:	ff010113          	addi	sp,sp,-16
   181e8:	00812423          	sw	s0,8(sp)
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   181ec:	10077793          	andi	a5,a4,256
_DEFUN(__swrite, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char const *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   181f0:	00912223          	sw	s1,4(sp)
   181f4:	01212023          	sw	s2,0(sp)
   181f8:	00112623          	sw	ra,12(sp)
   181fc:	00058413          	mv	s0,a1
   18200:	00060493          	mv	s1,a2
   18204:	00068913          	mv	s2,a3
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   18208:	00078e63          	beqz	a5,18224 <__swrite+0x44>
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
   1820c:	00e59503          	lh	a0,14(a1)
   18210:	00200713          	li	a4,2
   18214:	00000613          	li	a2,0
   18218:	00000693          	li	a3,0
   1821c:	890f80ef          	jal	102ac <lseek>
   18220:	00c41703          	lh	a4,12(s0)
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
   18224:	fffff7b7          	lui	a5,0xfffff
   18228:	fff78793          	addi	a5,a5,-1 # ffffefff <_gp+0xfffb681f>
   1822c:	00f777b3          	and	a5,a4,a5
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   18230:	00e41503          	lh	a0,14(s0)
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
   18234:	00f41623          	sh	a5,12(s0)
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   18238:	00090613          	mv	a2,s2
   1823c:	00048593          	mv	a1,s1
  if (oldmode)
    setmode (fp->_file, oldmode);
#endif

  return w;
}
   18240:	00c12083          	lw	ra,12(sp)
   18244:	00812403          	lw	s0,8(sp)
   18248:	00412483          	lw	s1,4(sp)
   1824c:	00012903          	lw	s2,0(sp)
   18250:	01010113          	addi	sp,sp,16
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   18254:	a8cf806f          	j	104e0 <write>

00018258 <__sseek>:
       int whence)
{
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
   18258:	00e59503          	lh	a0,14(a1)
_DEFUN(__sseek, (ptr, cookie, offset, whence),
       struct _reent *ptr _AND
       void *cookie _AND
       _fpos_t offset _AND
       int whence)
{
   1825c:	ff010113          	addi	sp,sp,-16
   18260:	00812423          	sw	s0,8(sp)
   18264:	00112623          	sw	ra,12(sp)
   18268:	00058413          	mv	s0,a1
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
   1826c:	840f80ef          	jal	102ac <lseek>
  if (ret == -1L)
   18270:	fff00793          	li	a5,-1
    fp->_flags &= ~__SOFF;
   18274:	00c45703          	lhu	a4,12(s0)
{
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
   18278:	02f50463          	beq	a0,a5,182a0 <__sseek+0x48>
    {
      fp->_flags |= __SOFF;
      fp->_offset = ret;
    }
  return ret;
}
   1827c:	00c12083          	lw	ra,12(sp)
  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
    fp->_flags &= ~__SOFF;
  else
    {
      fp->_flags |= __SOFF;
   18280:	000017b7          	lui	a5,0x1
   18284:	00f767b3          	or	a5,a4,a5
      fp->_offset = ret;
   18288:	04a42823          	sw	a0,80(s0)
  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
    fp->_flags &= ~__SOFF;
  else
    {
      fp->_flags |= __SOFF;
   1828c:	00f41623          	sh	a5,12(s0)
      fp->_offset = ret;
   18290:	04b42a23          	sw	a1,84(s0)
    }
  return ret;
}
   18294:	00812403          	lw	s0,8(sp)
   18298:	01010113          	addi	sp,sp,16
   1829c:	00008067          	ret
{
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
   182a0:	fca59ee3          	bne	a1,a0,1827c <__sseek+0x24>
    fp->_flags &= ~__SOFF;
   182a4:	fffff7b7          	lui	a5,0xfffff
    {
      fp->_flags |= __SOFF;
      fp->_offset = ret;
    }
  return ret;
}
   182a8:	00c12083          	lw	ra,12(sp)
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
    fp->_flags &= ~__SOFF;
   182ac:	fff78793          	addi	a5,a5,-1 # ffffefff <_gp+0xfffb681f>
   182b0:	00f777b3          	and	a5,a4,a5
   182b4:	00f41623          	sh	a5,12(s0)
    {
      fp->_flags |= __SOFF;
      fp->_offset = ret;
    }
  return ret;
}
   182b8:	00812403          	lw	s0,8(sp)
   182bc:	01010113          	addi	sp,sp,16
   182c0:	00008067          	ret

000182c4 <__sclose>:
       struct _reent *ptr _AND
       void *cookie)
{
  FILE *fp = (FILE *) cookie;

  return _close_r (ptr, fp->_file);
   182c4:	00e59503          	lh	a0,14(a1)
   182c8:	e8df706f          	j	10154 <close>

000182cc <strcmp>:
   182cc:	00b56733          	or	a4,a0,a1
   182d0:	fff00393          	li	t2,-1
   182d4:	00377713          	andi	a4,a4,3
   182d8:	0c071063          	bnez	a4,18398 <strcmp+0xcc>
   182dc:	7f7f8e37          	lui	t3,0x7f7f8
   182e0:	f7fe0e13          	addi	t3,t3,-129 # 7f7f7f7f <_gp+0x7f7af79f>
   182e4:	00052603          	lw	a2,0(a0)
   182e8:	0005a683          	lw	a3,0(a1)
   182ec:	01c672b3          	and	t0,a2,t3
   182f0:	01c66333          	or	t1,a2,t3
   182f4:	01c282b3          	add	t0,t0,t3
   182f8:	0062e2b3          	or	t0,t0,t1
   182fc:	0c729263          	bne	t0,t2,183c0 <strcmp+0xf4>
   18300:	04d61663          	bne	a2,a3,1834c <strcmp+0x80>
   18304:	00452603          	lw	a2,4(a0)
   18308:	0045a683          	lw	a3,4(a1)
   1830c:	01c672b3          	and	t0,a2,t3
   18310:	01c66333          	or	t1,a2,t3
   18314:	01c282b3          	add	t0,t0,t3
   18318:	0062e2b3          	or	t0,t0,t1
   1831c:	08729e63          	bne	t0,t2,183b8 <strcmp+0xec>
   18320:	02d61663          	bne	a2,a3,1834c <strcmp+0x80>
   18324:	00852603          	lw	a2,8(a0)
   18328:	0085a683          	lw	a3,8(a1)
   1832c:	01c672b3          	and	t0,a2,t3
   18330:	01c66333          	or	t1,a2,t3
   18334:	01c282b3          	add	t0,t0,t3
   18338:	0062e2b3          	or	t0,t0,t1
   1833c:	08729863          	bne	t0,t2,183cc <strcmp+0x100>
   18340:	00c50513          	addi	a0,a0,12
   18344:	00c58593          	addi	a1,a1,12
   18348:	f8d60ee3          	beq	a2,a3,182e4 <strcmp+0x18>
   1834c:	01061713          	slli	a4,a2,0x10
   18350:	01069793          	slli	a5,a3,0x10
   18354:	00f71e63          	bne	a4,a5,18370 <strcmp+0xa4>
   18358:	01065713          	srli	a4,a2,0x10
   1835c:	0106d793          	srli	a5,a3,0x10
   18360:	40f70533          	sub	a0,a4,a5
   18364:	0ff57593          	andi	a1,a0,255
   18368:	02059063          	bnez	a1,18388 <strcmp+0xbc>
   1836c:	00008067          	ret
   18370:	01075713          	srli	a4,a4,0x10
   18374:	0107d793          	srli	a5,a5,0x10
   18378:	40f70533          	sub	a0,a4,a5
   1837c:	0ff57593          	andi	a1,a0,255
   18380:	00059463          	bnez	a1,18388 <strcmp+0xbc>
   18384:	00008067          	ret
   18388:	0ff77713          	andi	a4,a4,255
   1838c:	0ff7f793          	andi	a5,a5,255
   18390:	40f70533          	sub	a0,a4,a5
   18394:	00008067          	ret
   18398:	00054603          	lbu	a2,0(a0)
   1839c:	0005c683          	lbu	a3,0(a1)
   183a0:	00150513          	addi	a0,a0,1
   183a4:	00158593          	addi	a1,a1,1
   183a8:	00d61463          	bne	a2,a3,183b0 <strcmp+0xe4>
   183ac:	fe0616e3          	bnez	a2,18398 <strcmp+0xcc>
   183b0:	40d60533          	sub	a0,a2,a3
   183b4:	00008067          	ret
   183b8:	00450513          	addi	a0,a0,4
   183bc:	00458593          	addi	a1,a1,4
   183c0:	fcd61ce3          	bne	a2,a3,18398 <strcmp+0xcc>
   183c4:	00000513          	li	a0,0
   183c8:	00008067          	ret
   183cc:	00850513          	addi	a0,a0,8
   183d0:	00858593          	addi	a1,a1,8
   183d4:	fcd612e3          	bne	a2,a3,18398 <strcmp+0xcc>
   183d8:	00000513          	li	a0,0
   183dc:	00008067          	ret

000183e0 <strlen>:
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  while (*str++)
    ;
  return str - start - 1;
#else
  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
   183e0:	00357793          	andi	a5,a0,3
   183e4:	00050593          	mv	a1,a0
   183e8:	04079a63          	bnez	a5,1843c <strlen+0x5c>
    if (!ch)
      return str - start - 1;
  } while ((uintptr_t)str & (sizeof(long)-1));

  unsigned long* ls = (unsigned long*)str;
  while (!__libc_detect_null(*ls++))
   183ec:	7f7f86b7          	lui	a3,0x7f7f8
   183f0:	f7f68693          	addi	a3,a3,-129 # 7f7f7f7f <_gp+0x7f7af79f>
   183f4:	fff00613          	li	a2,-1
   183f8:	00450513          	addi	a0,a0,4
   183fc:	ffc52783          	lw	a5,-4(a0)
   18400:	00d7f733          	and	a4,a5,a3
   18404:	00d70733          	add	a4,a4,a3
   18408:	00d7e7b3          	or	a5,a5,a3
   1840c:	00f767b3          	or	a5,a4,a5
   18410:	fec784e3          	beq	a5,a2,183f8 <strlen+0x18>

  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
   18414:	ffc54703          	lbu	a4,-4(a0)
  while (!__libc_detect_null(*ls++))
    ;
  asm volatile ("" : "+r"(ls)); /* prevent "optimization" */

  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);
   18418:	40b507b3          	sub	a5,a0,a1

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
   1841c:	ffd54683          	lbu	a3,-3(a0)
   18420:	ffe54603          	lbu	a2,-2(a0)
  if (c0 == 0)            return ret + 0 - sl;
   18424:	02070e63          	beqz	a4,18460 <strlen+0x80>
  if (c1 == 0)            return ret + 1 - sl;
   18428:	02068863          	beqz	a3,18458 <strlen+0x78>
  if (c2 == 0)            return ret + 2 - sl;
  if (sl == 4 || c3 == 0) return ret + 3 - sl;
   1842c:	fff78513          	addi	a0,a5,-1
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
  if (c1 == 0)            return ret + 1 - sl;
  if (c2 == 0)            return ret + 2 - sl;
   18430:	02060c63          	beqz	a2,18468 <strlen+0x88>
  if (c0 == 0)            return ret + 4 - sl;
  if (c1 == 0)            return ret + 5 - sl;
  if (c2 == 0)            return ret + 6 - sl;
                          return ret + 7 - sl;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   18434:	00008067          	ret
  {
    char ch = *str;
    str++;
    if (!ch)
      return str - start - 1;
  } while ((uintptr_t)str & (sizeof(long)-1));
   18438:	fa070ae3          	beqz	a4,183ec <strlen+0xc>
    ;
  return str - start - 1;
#else
  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
  {
    char ch = *str;
   1843c:	00054783          	lbu	a5,0(a0)
    str++;
   18440:	00150513          	addi	a0,a0,1
    if (!ch)
      return str - start - 1;
  } while ((uintptr_t)str & (sizeof(long)-1));
   18444:	00357713          	andi	a4,a0,3
#else
  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
  {
    char ch = *str;
    str++;
    if (!ch)
   18448:	fe0798e3          	bnez	a5,18438 <strlen+0x58>
      return str - start - 1;
   1844c:	40b50533          	sub	a0,a0,a1
   18450:	fff50513          	addi	a0,a0,-1
   18454:	00008067          	ret
  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
  if (c1 == 0)            return ret + 1 - sl;
   18458:	ffd78513          	addi	a0,a5,-3
   1845c:	00008067          	ret

  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
   18460:	ffc78513          	addi	a0,a5,-4
   18464:	00008067          	ret
  if (c1 == 0)            return ret + 1 - sl;
  if (c2 == 0)            return ret + 2 - sl;
   18468:	ffe78513          	addi	a0,a5,-2
  if (c0 == 0)            return ret + 4 - sl;
  if (c1 == 0)            return ret + 5 - sl;
  if (c2 == 0)            return ret + 6 - sl;
                          return ret + 7 - sl;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   1846c:	00008067          	ret

00018470 <__sprint_r.part.0>:
	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
		return (0);
	}
#ifdef _WIDE_ORIENT
	if (fp->_flags2 & __SWID) {
   18470:	0685a783          	lw	a5,104(a1)
/*
 * Flush out all the vectors defined by the given uio,
 * then reset it so that it can be reused.
 */
int
_DEFUN(__sprint_r, (ptr, fp, uio),
   18474:	fd010113          	addi	sp,sp,-48
   18478:	01612823          	sw	s6,16(sp)
	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
		return (0);
	}
#ifdef _WIDE_ORIENT
	if (fp->_flags2 & __SWID) {
   1847c:	01279713          	slli	a4,a5,0x12
/*
 * Flush out all the vectors defined by the given uio,
 * then reset it so that it can be reused.
 */
int
_DEFUN(__sprint_r, (ptr, fp, uio),
   18480:	02112623          	sw	ra,44(sp)
   18484:	02812423          	sw	s0,40(sp)
   18488:	02912223          	sw	s1,36(sp)
   1848c:	03212023          	sw	s2,32(sp)
   18490:	01312e23          	sw	s3,28(sp)
   18494:	01412c23          	sw	s4,24(sp)
   18498:	01512a23          	sw	s5,20(sp)
   1849c:	01712623          	sw	s7,12(sp)
   184a0:	00060b13          	mv	s6,a2
	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
		return (0);
	}
#ifdef _WIDE_ORIENT
	if (fp->_flags2 & __SWID) {
   184a4:	0a075663          	bgez	a4,18550 <__sprint_r.part.0+0xe0>
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
   184a8:	00862783          	lw	a5,8(a2)
   184ac:	00058a13          	mv	s4,a1
   184b0:	00050a93          	mv	s5,a0
	if (fp->_flags2 & __SWID) {
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
   184b4:	00062b83          	lw	s7,0(a2)
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
			len = iov->iov_len / sizeof (wchar_t);
			for (i = 0; i < len; i++) {
				if (_fputwc_r (ptr, p[i], fp) == WEOF) {
   184b8:	fff00993          	li	s3,-1
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
   184bc:	08078663          	beqz	a5,18548 <__sprint_r.part.0+0xd8>
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
			len = iov->iov_len / sizeof (wchar_t);
   184c0:	004ba903          	lw	s2,4(s7)
   184c4:	000ba483          	lw	s1,0(s7)
			for (i = 0; i < len; i++) {
   184c8:	00000413          	li	s0,0

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
			len = iov->iov_len / sizeof (wchar_t);
   184cc:	00295913          	srli	s2,s2,0x2
			for (i = 0; i < len; i++) {
   184d0:	00091863          	bnez	s2,184e0 <__sprint_r.part.0+0x70>
   184d4:	0600006f          	j	18534 <__sprint_r.part.0+0xc4>
   184d8:	00448493          	addi	s1,s1,4
   184dc:	04890a63          	beq	s2,s0,18530 <__sprint_r.part.0+0xc0>
				if (_fputwc_r (ptr, p[i], fp) == WEOF) {
   184e0:	0004a583          	lw	a1,0(s1)
   184e4:	000a0613          	mv	a2,s4
   184e8:	000a8513          	mv	a0,s5
   184ec:	47c010ef          	jal	19968 <_fputwc_r>
		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
			len = iov->iov_len / sizeof (wchar_t);
			for (i = 0; i < len; i++) {
   184f0:	00140413          	addi	s0,s0,1
				if (_fputwc_r (ptr, p[i], fp) == WEOF) {
   184f4:	ff3512e3          	bne	a0,s3,184d8 <__sprint_r.part.0+0x68>
					err = -1;
   184f8:	00098513          	mv	a0,s3
		err = __sfvwrite_r(ptr, fp, uio);
out:
	uio->uio_resid = 0;
	uio->uio_iovcnt = 0;
	return (err);
}
   184fc:	02c12083          	lw	ra,44(sp)
		}
	} else
#endif
		err = __sfvwrite_r(ptr, fp, uio);
out:
	uio->uio_resid = 0;
   18500:	000b2423          	sw	zero,8(s6)
	uio->uio_iovcnt = 0;
   18504:	000b2223          	sw	zero,4(s6)
	return (err);
}
   18508:	02812403          	lw	s0,40(sp)
   1850c:	02412483          	lw	s1,36(sp)
   18510:	02012903          	lw	s2,32(sp)
   18514:	01c12983          	lw	s3,28(sp)
   18518:	01812a03          	lw	s4,24(sp)
   1851c:	01412a83          	lw	s5,20(sp)
   18520:	01012b03          	lw	s6,16(sp)
   18524:	00c12b83          	lw	s7,12(sp)
   18528:	03010113          	addi	sp,sp,48
   1852c:	00008067          	ret
   18530:	008b2783          	lw	a5,8(s6)
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
   18534:	00291913          	slli	s2,s2,0x2
   18538:	412787b3          	sub	a5,a5,s2
   1853c:	00fb2423          	sw	a5,8(s6)
   18540:	008b8b93          	addi	s7,s7,8
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
   18544:	f6079ee3          	bnez	a5,184c0 <__sprint_r.part.0+0x50>
_DEFUN(__sprint_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;
   18548:	00000513          	li	a0,0
   1854c:	fb1ff06f          	j	184fc <__sprint_r.part.0+0x8c>
				}
			}
		}
	} else
#endif
		err = __sfvwrite_r(ptr, fp, uio);
   18550:	4bc010ef          	jal	19a0c <__sfvwrite_r>
   18554:	fa9ff06f          	j	184fc <__sprint_r.part.0+0x8c>

00018558 <__sprint_r>:
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   18558:	00862703          	lw	a4,8(a2)
   1855c:	00070463          	beqz	a4,18564 <__sprint_r+0xc>
   18560:	f11ff06f          	j	18470 <__sprint_r.part.0>
		uio->uio_iovcnt = 0;
   18564:	00062223          	sw	zero,4(a2)
		err = __sfvwrite_r(ptr, fp, uio);
out:
	uio->uio_resid = 0;
	uio->uio_iovcnt = 0;
	return (err);
}
   18568:	00000513          	li	a0,0
   1856c:	00008067          	ret

00018570 <_vfiprintf_r>:
_DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
       struct _reent *data _AND
       FILE * fp           _AND
       _CONST char *fmt0   _AND
       va_list ap)
{
   18570:	f1010113          	addi	sp,sp,-240
   18574:	0e912223          	sw	s1,228(sp)
   18578:	0d512a23          	sw	s5,212(sp)
   1857c:	0da12023          	sw	s10,192(sp)
   18580:	0e112623          	sw	ra,236(sp)
   18584:	0e812423          	sw	s0,232(sp)
   18588:	0f212023          	sw	s2,224(sp)
   1858c:	0d312e23          	sw	s3,220(sp)
   18590:	0d412c23          	sw	s4,216(sp)
   18594:	0d612823          	sw	s6,208(sp)
   18598:	0d712623          	sw	s7,204(sp)
   1859c:	0d812423          	sw	s8,200(sp)
   185a0:	0d912223          	sw	s9,196(sp)
   185a4:	0bb12e23          	sw	s11,188(sp)
   185a8:	00050a93          	mv	s5,a0
   185ac:	00058d13          	mv	s10,a1
   185b0:	00060493          	mv	s1,a2
   185b4:	00d12823          	sw	a3,16(sp)
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
   185b8:	00050663          	beqz	a0,185c4 <_vfiprintf_r+0x54>
   185bc:	03852783          	lw	a5,56(a0)
   185c0:	1e078863          	beqz	a5,187b0 <_vfiprintf_r+0x240>
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);
   185c4:	00cd1683          	lh	a3,12(s10)
   185c8:	01069793          	slli	a5,a3,0x10
   185cc:	0107d793          	srli	a5,a5,0x10
   185d0:	01279593          	slli	a1,a5,0x12
   185d4:	0205c663          	bltz	a1,18600 <_vfiprintf_r+0x90>
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
	_newlib_flockfile_start (fp);
   185d8:	068d2603          	lw	a2,104(s10)

	ORIENT(fp, -1);
   185dc:	000027b7          	lui	a5,0x2
   185e0:	ffffe737          	lui	a4,0xffffe
   185e4:	00f6e7b3          	or	a5,a3,a5
   185e8:	fff70713          	addi	a4,a4,-1 # ffffdfff <_gp+0xfffb581f>
   185ec:	00e67733          	and	a4,a2,a4
   185f0:	00fd1623          	sh	a5,12(s10)
   185f4:	01079793          	slli	a5,a5,0x10
   185f8:	06ed2423          	sw	a4,104(s10)
   185fc:	0107d793          	srli	a5,a5,0x10

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   18600:	0087f713          	andi	a4,a5,8
   18604:	12070a63          	beqz	a4,18738 <_vfiprintf_r+0x1c8>
   18608:	010d2703          	lw	a4,16(s10)
   1860c:	12070663          	beqz	a4,18738 <_vfiprintf_r+0x1c8>
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   18610:	01a7f793          	andi	a5,a5,26
   18614:	00a00713          	li	a4,10
   18618:	14e78063          	beq	a5,a4,18758 <_vfiprintf_r+0x1e8>
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   1861c:	07010c93          	addi	s9,sp,112
   18620:	06f10713          	addi	a4,sp,111
   18624:	0001d337          	lui	t1,0x1d
   18628:	0001d8b7          	lui	a7,0x1d
   1862c:	40ec87b3          	sub	a5,s9,a4
   18630:	00e12623          	sw	a4,12(sp)
   18634:	03912e23          	sw	s9,60(sp)
	uio.uio_resid = 0;
   18638:	04012223          	sw	zero,68(sp)
	uio.uio_iovcnt = 0;
   1863c:	04012023          	sw	zero,64(sp)
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
   18640:	00012e23          	sw	zero,28(sp)
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
	uio.uio_resid = 0;
	uio.uio_iovcnt = 0;
#endif
	ret = 0;
   18644:	00012a23          	sw	zero,20(sp)
   18648:	ca430b13          	addi	s6,t1,-860 # 1cca4 <blanks.4133>
   1864c:	cb488c13          	addi	s8,a7,-844 # 1ccb4 <zeroes.4134>
   18650:	02f12223          	sw	a5,36(sp)
   18654:	000c8693          	mv	a3,s9
   18658:	00048d93          	mv	s11,s1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   1865c:	000dc783          	lbu	a5,0(s11)
   18660:	4a078ce3          	beqz	a5,19318 <_vfiprintf_r+0xda8>
   18664:	02500713          	li	a4,37
   18668:	000d8913          	mv	s2,s11
   1866c:	00e79663          	bne	a5,a4,18678 <_vfiprintf_r+0x108>
   18670:	0540006f          	j	186c4 <_vfiprintf_r+0x154>
   18674:	00e78863          	beq	a5,a4,18684 <_vfiprintf_r+0x114>
                    fmt += 1;
   18678:	00190913          	addi	s2,s2,1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   1867c:	00094783          	lbu	a5,0(s2)
   18680:	fe079ae3          	bnez	a5,18674 <_vfiprintf_r+0x104>
   18684:	41b90433          	sub	s0,s2,s11
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
   18688:	02040e63          	beqz	s0,186c4 <_vfiprintf_r+0x154>
			PRINT (cp, m);
   1868c:	04412703          	lw	a4,68(sp)
   18690:	04012783          	lw	a5,64(sp)
   18694:	00700613          	li	a2,7
   18698:	00e40733          	add	a4,s0,a4
   1869c:	00178793          	addi	a5,a5,1 # 2001 <_reset+0x1e01>
   186a0:	01b6a023          	sw	s11,0(a3)
   186a4:	0086a223          	sw	s0,4(a3)
   186a8:	04e12223          	sw	a4,68(sp)
   186ac:	04f12023          	sw	a5,64(sp)
   186b0:	00868693          	addi	a3,a3,8
   186b4:	06f64463          	blt	a2,a5,1871c <_vfiprintf_r+0x1ac>
			ret += m;
   186b8:	01412883          	lw	a7,20(sp)
   186bc:	008888b3          	add	a7,a7,s0
   186c0:	01112a23          	sw	a7,20(sp)
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
   186c4:	00094783          	lbu	a5,0(s2)
   186c8:	060788e3          	beqz	a5,18f38 <_vfiprintf_r+0x9c8>
                    goto done;
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */
   186cc:	00190493          	addi	s1,s2,1

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
   186d0:	02010ba3          	sb	zero,55(sp)
   186d4:	00000813          	li	a6,0
   186d8:	00000313          	li	t1,0
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
   186dc:	fff00713          	li	a4,-1
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
   186e0:	00000913          	li	s2,0
                    goto done;
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
   186e4:	00000b93          	li	s7,0
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   186e8:	05800593          	li	a1,88
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			} while (is_digit (ch));
   186ec:	00900513          	li	a0,9
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
   186f0:	02a00393          	li	t2,42
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
   186f4:	0004c603          	lbu	a2,0(s1)
   186f8:	00148d93          	addi	s11,s1,1
reswitch:	switch (ch) {
   186fc:	fe060793          	addi	a5,a2,-32
   18700:	6af5e263          	bltu	a1,a5,18da4 <_vfiprintf_r+0x834>
   18704:	0001d8b7          	lui	a7,0x1d
   18708:	00279793          	slli	a5,a5,0x2
   1870c:	b4088893          	addi	a7,a7,-1216 # 1cb40 <__mprec_bigtens+0x28>
   18710:	011787b3          	add	a5,a5,a7
   18714:	0007a783          	lw	a5,0(a5)
   18718:	00078067          	jr	a5
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   1871c:	300710e3          	bnez	a4,1921c <_vfiprintf_r+0xcac>
		uio->uio_iovcnt = 0;
   18720:	04012023          	sw	zero,64(sp)
#else
                while (*fmt != '\0' && *fmt != '%')
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
			PRINT (cp, m);
   18724:	000c8693          	mv	a3,s9
   18728:	f91ff06f          	j	186b8 <_vfiprintf_r+0x148>
			} else
#endif
				flags |= LONGINT;
			goto rflag;
		case 'q': /* extension */
			flags |= QUADINT;
   1872c:	010beb93          	ori	s7,s7,16
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   18730:	000d8493          	mv	s1,s11
   18734:	fc1ff06f          	j	186f4 <_vfiprintf_r+0x184>
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   18738:	000d0593          	mv	a1,s10
   1873c:	000a8513          	mv	a0,s5
   18740:	fe8fb0ef          	jal	13f28 <__swsetup_r>
   18744:	48051ae3          	bnez	a0,193d8 <_vfiprintf_r+0xe68>
   18748:	00cd5783          	lhu	a5,12(s10)
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   1874c:	00a00713          	li	a4,10
   18750:	01a7f793          	andi	a5,a5,26
   18754:	ece794e3          	bne	a5,a4,1861c <_vfiprintf_r+0xac>
   18758:	00ed1783          	lh	a5,14(s10)
   1875c:	ec07c0e3          	bltz	a5,1861c <_vfiprintf_r+0xac>
	    fp->_file >= 0) {
		_newlib_flockfile_exit (fp);
		return (__sbprintf (data, fp, fmt0, ap));
   18760:	01012683          	lw	a3,16(sp)
   18764:	00048613          	mv	a2,s1
   18768:	000d0593          	mv	a1,s10
   1876c:	000a8513          	mv	a0,s5
   18770:	629000ef          	jal	19598 <__sbprintf>
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
	/* NOTREACHED */
}
   18774:	0ec12083          	lw	ra,236(sp)
   18778:	0e812403          	lw	s0,232(sp)
   1877c:	0e412483          	lw	s1,228(sp)
   18780:	0e012903          	lw	s2,224(sp)
   18784:	0dc12983          	lw	s3,220(sp)
   18788:	0d812a03          	lw	s4,216(sp)
   1878c:	0d412a83          	lw	s5,212(sp)
   18790:	0d012b03          	lw	s6,208(sp)
   18794:	0cc12b83          	lw	s7,204(sp)
   18798:	0c812c03          	lw	s8,200(sp)
   1879c:	0c412c83          	lw	s9,196(sp)
   187a0:	0c012d03          	lw	s10,192(sp)
   187a4:	0bc12d83          	lw	s11,188(sp)
   187a8:	0f010113          	addi	sp,sp,240
   187ac:	00008067          	ret
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
   187b0:	f00fd0ef          	jal	15eb0 <__sinit>
   187b4:	e11ff06f          	j	185c4 <_vfiprintf_r+0x54>
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   187b8:	01012783          	lw	a5,16(sp)
   187bc:	0007a903          	lw	s2,0(a5)
   187c0:	00478793          	addi	a5,a5,4
   187c4:	00f12823          	sw	a5,16(sp)
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
   187c8:	f60954e3          	bgez	s2,18730 <_vfiprintf_r+0x1c0>
				goto rflag;
			width = -width;
   187cc:	41200933          	neg	s2,s2
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
   187d0:	004beb93          	ori	s7,s7,4
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   187d4:	000d8493          	mv	s1,s11
   187d8:	f1dff06f          	j	186f4 <_vfiprintf_r+0x184>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   187dc:	01012883          	lw	a7,16(sp)
			base = HEX;
			xdigs = "0123456789abcdef";
			flags |= HEXPREFIX;
			ox[0] = '0';
   187e0:	03000593          	li	a1,48
   187e4:	02b10c23          	sb	a1,56(sp)
			ox[1] = ch = 'x';
   187e8:	07800593          	li	a1,120
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   187ec:	00488613          	addi	a2,a7,4
   187f0:	0008a783          	lw	a5,0(a7)
			base = HEX;
			xdigs = "0123456789abcdef";
			flags |= HEXPREFIX;
   187f4:	002be513          	ori	a0,s7,2
			ox[0] = '0';
			ox[1] = ch = 'x';
   187f8:	02b10ca3          	sb	a1,57(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   187fc:	02010ba3          	sb	zero,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   18800:	2e074ae3          	bltz	a4,192f4 <_vfiprintf_r+0xd84>
   18804:	f7fbf293          	andi	t0,s7,-129
				flags &= ~ZEROPAD;
   18808:	0022eb93          	ori	s7,t0,2
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   1880c:	00c12823          	sw	a2,16(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   18810:	300798e3          	bnez	a5,19320 <_vfiprintf_r+0xdb0>
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   18814:	0001d7b7          	lui	a5,0x1d
   18818:	d1478793          	addi	a5,a5,-748 # 1cd14 <__thenan_sf+0x34>
   1881c:	00f12e23          	sw	a5,28(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   18820:	00000593          	li	a1,0
   18824:	20071ae3          	bnez	a4,19238 <_vfiprintf_r+0xcc8>
   18828:	00000713          	li	a4,0
   1882c:	00000a13          	li	s4,0
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   18830:	000c8413          	mv	s0,s9
		 * If flags&FPT, ch must be in [aAeEfg].
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
   18834:	00070993          	mv	s3,a4
   18838:	01475463          	ble	s4,a4,18840 <_vfiprintf_r+0x2d0>
   1883c:	000a0993          	mv	s3,s4
		if (sign)
			realsz++;
   18840:	00b035b3          	snez	a1,a1
   18844:	00b989b3          	add	s3,s3,a1
		if (flags & HEXPREFIX)
   18848:	002bfe13          	andi	t3,s7,2
   1884c:	000e0463          	beqz	t3,18854 <_vfiprintf_r+0x2e4>
			realsz+= 2;
   18850:	00298993          	addi	s3,s3,2

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   18854:	084bf393          	andi	t2,s7,132
   18858:	5c039263          	bnez	t2,18e1c <_vfiprintf_r+0x8ac>
			PAD (width - realsz, blanks);
   1885c:	413904b3          	sub	s1,s2,s3
   18860:	5a905e63          	blez	s1,18e1c <_vfiprintf_r+0x8ac>
   18864:	01000813          	li	a6,16
   18868:	04412783          	lw	a5,68(sp)
   1886c:	3e9850e3          	ble	s1,a6,1944c <_vfiprintf_r+0xedc>
   18870:	02812023          	sw	s0,32(sp)
   18874:	04012503          	lw	a0,64(sp)
   18878:	00048413          	mv	s0,s1
   1887c:	01612c23          	sw	s6,24(sp)
   18880:	00700e93          	li	t4,7
   18884:	02e12423          	sw	a4,40(sp)
   18888:	03c12623          	sw	t3,44(sp)
   1888c:	00038493          	mv	s1,t2
   18890:	0180006f          	j	188a8 <_vfiprintf_r+0x338>
   18894:	00250613          	addi	a2,a0,2
   18898:	00868693          	addi	a3,a3,8
   1889c:	00070513          	mv	a0,a4
   188a0:	ff040413          	addi	s0,s0,-16
   188a4:	02885c63          	ble	s0,a6,188dc <_vfiprintf_r+0x36c>
   188a8:	01078793          	addi	a5,a5,16
   188ac:	00150713          	addi	a4,a0,1
   188b0:	0166a023          	sw	s6,0(a3)
   188b4:	0106a223          	sw	a6,4(a3)
   188b8:	04f12223          	sw	a5,68(sp)
   188bc:	04e12023          	sw	a4,64(sp)
   188c0:	fceedae3          	ble	a4,t4,18894 <_vfiprintf_r+0x324>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   188c4:	52079063          	bnez	a5,18de4 <_vfiprintf_r+0x874>
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   188c8:	ff040413          	addi	s0,s0,-16
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   188cc:	00000513          	li	a0,0
   188d0:	00100613          	li	a2,1
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   188d4:	000c8693          	mv	a3,s9
   188d8:	fc8848e3          	blt	a6,s0,188a8 <_vfiprintf_r+0x338>
   188dc:	00048393          	mv	t2,s1
   188e0:	02812703          	lw	a4,40(sp)
   188e4:	00040493          	mv	s1,s0
   188e8:	02c12e03          	lw	t3,44(sp)
   188ec:	02012403          	lw	s0,32(sp)
   188f0:	01812883          	lw	a7,24(sp)
   188f4:	00f487b3          	add	a5,s1,a5
   188f8:	00700593          	li	a1,7
   188fc:	0116a023          	sw	a7,0(a3)
   18900:	0096a223          	sw	s1,4(a3)
   18904:	04f12223          	sw	a5,68(sp)
   18908:	04c12023          	sw	a2,64(sp)
   1890c:	7cc5c863          	blt	a1,a2,190dc <_vfiprintf_r+0xb6c>

		/* prefix */
		if (sign)
   18910:	03714503          	lbu	a0,55(sp)
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   18914:	00868693          	addi	a3,a3,8
   18918:	00160593          	addi	a1,a2,1

		/* prefix */
		if (sign)
   1891c:	50051a63          	bnez	a0,18e30 <_vfiprintf_r+0x8c0>
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
   18920:	540e0463          	beqz	t3,18e68 <_vfiprintf_r+0x8f8>
			PRINT (ox, 2);
   18924:	03810613          	addi	a2,sp,56
   18928:	00c6a023          	sw	a2,0(a3)
   1892c:	00200613          	li	a2,2
   18930:	00278793          	addi	a5,a5,2
   18934:	00c6a223          	sw	a2,4(a3)
   18938:	00700613          	li	a2,7
   1893c:	04f12223          	sw	a5,68(sp)
   18940:	04b12023          	sw	a1,64(sp)
   18944:	7eb65463          	ble	a1,a2,1912c <_vfiprintf_r+0xbbc>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   18948:	12079ce3          	bnez	a5,19280 <_vfiprintf_r+0xd10>
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   1894c:	08000513          	li	a0,128
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   18950:	00100593          	li	a1,1
   18954:	00000613          	li	a2,0

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
			PRINT (ox, 2);
   18958:	000c8693          	mv	a3,s9

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   1895c:	50a39a63          	bne	t2,a0,18e70 <_vfiprintf_r+0x900>
			PAD (width - realsz, zeroes);
   18960:	413904b3          	sub	s1,s2,s3
   18964:	50905663          	blez	s1,18e70 <_vfiprintf_r+0x900>
   18968:	01000813          	li	a6,16
   1896c:	369858e3          	ble	s1,a6,194dc <_vfiprintf_r+0xf6c>
   18970:	02812023          	sw	s0,32(sp)
   18974:	01812c23          	sw	s8,24(sp)
   18978:	00048413          	mv	s0,s1
   1897c:	00700393          	li	t2,7
   18980:	00070493          	mv	s1,a4
   18984:	0180006f          	j	1899c <_vfiprintf_r+0x42c>
   18988:	00260513          	addi	a0,a2,2
   1898c:	00868693          	addi	a3,a3,8
   18990:	00070613          	mv	a2,a4
   18994:	ff040413          	addi	s0,s0,-16
   18998:	02885c63          	ble	s0,a6,189d0 <_vfiprintf_r+0x460>
   1899c:	01078793          	addi	a5,a5,16
   189a0:	00160713          	addi	a4,a2,1
   189a4:	0186a023          	sw	s8,0(a3)
   189a8:	0106a223          	sw	a6,4(a3)
   189ac:	04f12223          	sw	a5,68(sp)
   189b0:	04e12023          	sw	a4,64(sp)
   189b4:	fce3dae3          	ble	a4,t2,18988 <_vfiprintf_r+0x418>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   189b8:	6e079663          	bnez	a5,190a4 <_vfiprintf_r+0xb34>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   189bc:	ff040413          	addi	s0,s0,-16
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   189c0:	00100513          	li	a0,1
   189c4:	00000613          	li	a2,0
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   189c8:	000c8693          	mv	a3,s9
   189cc:	fc8848e3          	blt	a6,s0,1899c <_vfiprintf_r+0x42c>
   189d0:	00048713          	mv	a4,s1
   189d4:	00040493          	mv	s1,s0
   189d8:	02012403          	lw	s0,32(sp)
   189dc:	01812883          	lw	a7,24(sp)
   189e0:	009787b3          	add	a5,a5,s1
   189e4:	00700613          	li	a2,7
   189e8:	0116a023          	sw	a7,0(a3)
   189ec:	0096a223          	sw	s1,4(a3)
   189f0:	04f12223          	sw	a5,68(sp)
   189f4:	04a12023          	sw	a0,64(sp)
   189f8:	0ca640e3          	blt	a2,a0,192b8 <_vfiprintf_r+0xd48>

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   189fc:	414704b3          	sub	s1,a4,s4
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   18a00:	00868693          	addi	a3,a3,8
   18a04:	00150593          	addi	a1,a0,1
   18a08:	00050613          	mv	a2,a0

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   18a0c:	46904663          	bgtz	s1,18e78 <_vfiprintf_r+0x908>
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   18a10:	00fa07b3          	add	a5,s4,a5
   18a14:	00700713          	li	a4,7
   18a18:	0086a023          	sw	s0,0(a3)
   18a1c:	0146a223          	sw	s4,4(a3)
   18a20:	04f12223          	sw	a5,68(sp)
   18a24:	04b12023          	sw	a1,64(sp)
   18a28:	54b75e63          	ble	a1,a4,18f84 <_vfiprintf_r+0xa14>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   18a2c:	7a079a63          	bnez	a5,191e0 <_vfiprintf_r+0xc70>
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   18a30:	004bf293          	andi	t0,s7,4
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   18a34:	04012023          	sw	zero,64(sp)
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   18a38:	5e028263          	beqz	t0,1901c <_vfiprintf_r+0xaac>
			PAD (width - realsz, blanks);
   18a3c:	413904b3          	sub	s1,s2,s3
   18a40:	1a9048e3          	bgtz	s1,193f0 <_vfiprintf_r+0xe80>

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   18a44:	01395463          	ble	s3,s2,18a4c <_vfiprintf_r+0x4dc>
   18a48:	00098913          	mv	s2,s3
   18a4c:	01412783          	lw	a5,20(sp)
   18a50:	012787b3          	add	a5,a5,s2
   18a54:	00f12a23          	sw	a5,20(sp)

		FLUSH ();	/* copy out the I/O vectors */
   18a58:	04012023          	sw	zero,64(sp)
   18a5c:	000c8693          	mv	a3,s9
   18a60:	bfdff06f          	j	1865c <_vfiprintf_r+0xec>
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   18a64:	00100813          	li	a6,1
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
			goto rflag;
		case '+':
			sign = '+';
   18a68:	02b00313          	li	t1,43
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   18a6c:	000d8493          	mv	s1,s11
   18a70:	c85ff06f          	j	186f4 <_vfiprintf_r+0x184>
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
   18a74:	080beb93          	ori	s7,s7,128
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   18a78:	000d8493          	mv	s1,s11
   18a7c:	c79ff06f          	j	186f4 <_vfiprintf_r+0x184>
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
   18a80:	00000913          	li	s2,0
   18a84:	fd060793          	addi	a5,a2,-48
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
   18a88:	001d8d93          	addi	s11,s11,1
   18a8c:	fffdc603          	lbu	a2,-1(s11)
			goto rflag;
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit (ch);
   18a90:	00191893          	slli	a7,s2,0x1
   18a94:	00391913          	slli	s2,s2,0x3
   18a98:	01288933          	add	s2,a7,s2
   18a9c:	01278933          	add	s2,a5,s2
				ch = *fmt++;
			} while (is_digit (ch));
   18aa0:	fd060793          	addi	a5,a2,-48
   18aa4:	fef572e3          	bleu	a5,a0,18a88 <_vfiprintf_r+0x518>
   18aa8:	c55ff06f          	j	186fc <_vfiprintf_r+0x18c>
   18aac:	2c0814e3          	bnez	a6,19574 <_vfiprintf_r+0x1004>
				size = 1;
			}
			sign = '\0';
			break;
		case 'D':  /* extension */
			flags |= LONGINT;
   18ab0:	010beb93          	ori	s7,s7,16
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   18ab4:	010bf793          	andi	a5,s7,16
   18ab8:	74078463          	beqz	a5,19200 <_vfiprintf_r+0xc90>
   18abc:	01012883          	lw	a7,16(sp)
   18ac0:	0008a783          	lw	a5,0(a7)
   18ac4:	00488893          	addi	a7,a7,4
   18ac8:	01112823          	sw	a7,16(sp)
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
#else
			if ((long) _uquad < 0)
   18acc:	0807c8e3          	bltz	a5,1935c <_vfiprintf_r+0xdec>
   18ad0:	03714583          	lbu	a1,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   18ad4:	68074263          	bltz	a4,19158 <_vfiprintf_r+0xbe8>
				flags &= ~ZEROPAD;
   18ad8:	f7fbfb93          	andi	s7,s7,-129
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   18adc:	12078263          	beqz	a5,18c00 <_vfiprintf_r+0x690>
						*--cp = '0';
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   18ae0:	00900613          	li	a2,9
   18ae4:	000c8413          	mv	s0,s9
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   18ae8:	00a00513          	li	a0,10
						*--cp = '0';
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   18aec:	10f67e63          	bleu	a5,a2,18c08 <_vfiprintf_r+0x698>
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   18af0:	02a7f633          	remu	a2,a5,a0
   18af4:	fff40413          	addi	s0,s0,-1
					       next cases. */
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
   18af8:	02a7d7b3          	divu	a5,a5,a0
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   18afc:	03060613          	addi	a2,a2,48
   18b00:	00c40023          	sb	a2,0(s0)
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
					} while (_uquad != 0);
   18b04:	fe0796e3          	bnez	a5,18af0 <_vfiprintf_r+0x580>
   18b08:	408c8a33          	sub	s4,s9,s0
   18b0c:	d29ff06f          	j	18834 <_vfiprintf_r+0x2c4>
   18b10:	24081ee3          	bnez	a6,1956c <_vfiprintf_r+0xffc>
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
   18b14:	010beb93          	ori	s7,s7,16
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   18b18:	010bf793          	andi	a5,s7,16
   18b1c:	64079e63          	bnez	a5,19178 <_vfiprintf_r+0xc08>
   18b20:	040bf793          	andi	a5,s7,64
   18b24:	64078a63          	beqz	a5,19178 <_vfiprintf_r+0xc08>
   18b28:	01012883          	lw	a7,16(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   18b2c:	02010ba3          	sb	zero,55(sp)
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   18b30:	00488613          	addi	a2,a7,4
   18b34:	0008d783          	lhu	a5,0(a7)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   18b38:	64074a63          	bltz	a4,1918c <_vfiprintf_r+0xc1c>
				flags &= ~ZEROPAD;
   18b3c:	f7fbfb93          	andi	s7,s7,-129
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   18b40:	00c12823          	sw	a2,16(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   18b44:	64079a63          	bnez	a5,19198 <_vfiprintf_r+0xc28>
   18b48:	00000593          	li	a1,0
   18b4c:	00000793          	li	a5,0
   18b50:	1e0700e3          	beqz	a4,19530 <_vfiprintf_r+0xfc0>
   18b54:	000c8413          	mv	s0,s9
				 * a variable; hence this switch.
				 */
				switch (base) {
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   18b58:	0077f613          	andi	a2,a5,7
   18b5c:	fff40413          	addi	s0,s0,-1
   18b60:	03060613          	addi	a2,a2,48
						_uquad >>= 3;
   18b64:	0037d793          	srli	a5,a5,0x3
				 * a variable; hence this switch.
				 */
				switch (base) {
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   18b68:	00c40023          	sb	a2,0(s0)
						_uquad >>= 3;
					} while (_uquad);
   18b6c:	fe0796e3          	bnez	a5,18b58 <_vfiprintf_r+0x5e8>
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
   18b70:	001bf793          	andi	a5,s7,1
   18b74:	f8078ae3          	beqz	a5,18b08 <_vfiprintf_r+0x598>
   18b78:	03000793          	li	a5,48
   18b7c:	f8f606e3          	beq	a2,a5,18b08 <_vfiprintf_r+0x598>
						*--cp = '0';
   18b80:	fff40613          	addi	a2,s0,-1
   18b84:	fef40fa3          	sb	a5,-1(s0)
   18b88:	40cc8a33          	sub	s4,s9,a2
   18b8c:	00060413          	mv	s0,a2
   18b90:	ca5ff06f          	j	18834 <_vfiprintf_r+0x2c4>
   18b94:	18081ae3          	bnez	a6,19528 <_vfiprintf_r+0xfb8>
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
				*GET_ARG (N, ap, quad_ptr_t) = ret;
			else
#endif
			if (flags & LONGINT)
   18b98:	010bf793          	andi	a5,s7,16
   18b9c:	22079663          	bnez	a5,18dc8 <_vfiprintf_r+0x858>
				*GET_ARG (N, ap, long_ptr_t) = ret;
			else if (flags & SHORTINT)
   18ba0:	040bf293          	andi	t0,s7,64
   18ba4:	22028263          	beqz	t0,18dc8 <_vfiprintf_r+0x858>
				*GET_ARG (N, ap, short_ptr_t) = ret;
   18ba8:	01012703          	lw	a4,16(sp)
   18bac:	01412883          	lw	a7,20(sp)
   18bb0:	00072783          	lw	a5,0(a4)
   18bb4:	00470713          	addi	a4,a4,4
   18bb8:	00e12823          	sw	a4,16(sp)
   18bbc:	01179023          	sh	a7,0(a5)
   18bc0:	a9dff06f          	j	1865c <_vfiprintf_r+0xec>
   18bc4:	18081ce3          	bnez	a6,1955c <_vfiprintf_r+0xfec>
			} else
				size = strlen (cp);

			break;
		case 'U': /* extension */
			flags |= LONGINT;
   18bc8:	010beb93          	ori	s7,s7,16
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   18bcc:	010bf793          	andi	a5,s7,16
   18bd0:	56079663          	bnez	a5,1913c <_vfiprintf_r+0xbcc>
   18bd4:	040bf793          	andi	a5,s7,64
   18bd8:	56078263          	beqz	a5,1913c <_vfiprintf_r+0xbcc>
   18bdc:	01012783          	lw	a5,16(sp)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   18be0:	02010ba3          	sb	zero,55(sp)
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   18be4:	00478613          	addi	a2,a5,4
   18be8:	0007d783          	lhu	a5,0(a5)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   18bec:	56074263          	bltz	a4,19150 <_vfiprintf_r+0xbe0>
				flags &= ~ZEROPAD;
   18bf0:	f7fbfb93          	andi	s7,s7,-129
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   18bf4:	00c12823          	sw	a2,16(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   18bf8:	00000593          	li	a1,0
   18bfc:	ee0792e3          	bnez	a5,18ae0 <_vfiprintf_r+0x570>
   18c00:	c20704e3          	beqz	a4,18828 <_vfiprintf_r+0x2b8>
   18c04:	00000793          	li	a5,0
					break;

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
						*--cp = to_char(_uquad);
   18c08:	03078793          	addi	a5,a5,48
   18c0c:	06f107a3          	sb	a5,111(sp)
   18c10:	02412a03          	lw	s4,36(sp)
   18c14:	06f10413          	addi	s0,sp,111
						break;
   18c18:	c1dff06f          	j	18834 <_vfiprintf_r+0x2c4>
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
   18c1c:	b0031ae3          	bnez	t1,18730 <_vfiprintf_r+0x1c0>
   18c20:	00100813          	li	a6,1
				sign = ' ';
   18c24:	02000313          	li	t1,32
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   18c28:	000d8493          	mv	s1,s11
   18c2c:	ac9ff06f          	j	186f4 <_vfiprintf_r+0x184>
			 */
			if (!sign)
				sign = ' ';
			goto rflag;
		case '#':
			flags |= ALT;
   18c30:	001beb93          	ori	s7,s7,1
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   18c34:	000d8493          	mv	s1,s11
   18c38:	abdff06f          	j	186f4 <_vfiprintf_r+0x184>
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   18c3c:	01012783          	lw	a5,16(sp)
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
   18c40:	02010ba3          	sb	zero,55(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   18c44:	0007a403          	lw	s0,0(a5)
   18c48:	00478493          	addi	s1,a5,4
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
   18c4c:	040400e3          	beqz	s0,1948c <_vfiprintf_r+0xf1c>
				}
				cp[size] = '\0';
			}
			else
#endif /* _MB_CAPABLE */
			if (prec >= 0) {
   18c50:	7a074463          	bltz	a4,193f8 <_vfiprintf_r+0xe88>
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);
   18c54:	00070613          	mv	a2,a4
   18c58:	00000593          	li	a1,0
   18c5c:	00040513          	mv	a0,s0
   18c60:	00d12423          	sw	a3,8(sp)
   18c64:	00e12223          	sw	a4,4(sp)
   18c68:	9a4fe0ef          	jal	16e0c <memchr>

				if (p != NULL)
   18c6c:	00812683          	lw	a3,8(sp)
   18c70:	00412703          	lw	a4,4(sp)
   18c74:	04050ae3          	beqz	a0,194c8 <_vfiprintf_r+0xf58>
					size = p - cp;
   18c78:	40850a33          	sub	s4,a0,s0
   18c7c:	03714583          	lbu	a1,55(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   18c80:	00912823          	sw	s1,16(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   18c84:	00000713          	li	a4,0
   18c88:	badff06f          	j	18834 <_vfiprintf_r+0x2c4>
   18c8c:	f40800e3          	beqz	a6,18bcc <_vfiprintf_r+0x65c>
   18c90:	02610ba3          	sb	t1,55(sp)
   18c94:	f39ff06f          	j	18bcc <_vfiprintf_r+0x65c>
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   18c98:	01012703          	lw	a4,16(sp)
				size = 1;
			}
			sign = '\0';
			break;
   18c9c:	00100993          	li	s3,1
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
				size = 1;
			}
			sign = '\0';
   18ca0:	02010ba3          	sb	zero,55(sp)
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   18ca4:	00072783          	lw	a5,0(a4)
   18ca8:	00470713          	addi	a4,a4,4
   18cac:	00e12823          	sw	a4,16(sp)
   18cb0:	04f10423          	sb	a5,72(sp)
				size = 1;
   18cb4:	00098a13          	mv	s4,s3
		    flags |= QUADINT;
		  goto rflag;
		case 'C':
#endif /* _WANT_IO_C99_FORMATS */
		case 'c':
			cp = buf;
   18cb8:	04810413          	addi	s0,sp,72
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   18cbc:	00000713          	li	a4,0
   18cc0:	b89ff06f          	j	18848 <_vfiprintf_r+0x2d8>
   18cc4:	de0808e3          	beqz	a6,18ab4 <_vfiprintf_r+0x544>
   18cc8:	02610ba3          	sb	t1,55(sp)
   18ccc:	de9ff06f          	j	18ab4 <_vfiprintf_r+0x544>
   18cd0:	0a0816e3          	bnez	a6,1957c <_vfiprintf_r+0x100c>
		case 'u':
			_uquad = UARG ();
			base = DEC;
			goto nosign;
		case 'X':
			xdigs = "0123456789ABCDEF";
   18cd4:	0001d7b7          	lui	a5,0x1d
   18cd8:	d0078793          	addi	a5,a5,-768 # 1cd00 <__thenan_sf+0x20>
   18cdc:	00f12e23          	sw	a5,28(sp)
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
   18ce0:	010bf793          	andi	a5,s7,16
   18ce4:	06078063          	beqz	a5,18d44 <_vfiprintf_r+0x7d4>
   18ce8:	01012883          	lw	a7,16(sp)
   18cec:	0008a783          	lw	a5,0(a7)
   18cf0:	00488893          	addi	a7,a7,4
   18cf4:	01112823          	sw	a7,16(sp)
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
   18cf8:	001bf593          	andi	a1,s7,1
   18cfc:	4a058263          	beqz	a1,191a0 <_vfiprintf_r+0xc30>
   18d00:	62079a63          	bnez	a5,19334 <_vfiprintf_r+0xdc4>

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   18d04:	02010ba3          	sb	zero,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   18d08:	60074263          	bltz	a4,1930c <_vfiprintf_r+0xd9c>
				flags &= ~ZEROPAD;
   18d0c:	f7fbfb93          	andi	s7,s7,-129
   18d10:	b11ff06f          	j	18820 <_vfiprintf_r+0x2b0>
   18d14:	e00802e3          	beqz	a6,18b18 <_vfiprintf_r+0x5a8>
   18d18:	02610ba3          	sb	t1,55(sp)
   18d1c:	dfdff06f          	j	18b18 <_vfiprintf_r+0x5a8>
			if (*fmt == 'h') {
				fmt++;
				flags |= CHARINT;
			} else
#endif
				flags |= SHORTINT;
   18d20:	040beb93          	ori	s7,s7,64
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   18d24:	000d8493          	mv	s1,s11
   18d28:	9cdff06f          	j	186f4 <_vfiprintf_r+0x184>
   18d2c:	7e081a63          	bnez	a6,19520 <_vfiprintf_r+0xfb0>
			goto nosign;
		case 'X':
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
   18d30:	0001d7b7          	lui	a5,0x1d
   18d34:	d1478793          	addi	a5,a5,-748 # 1cd14 <__thenan_sf+0x34>
   18d38:	00f12e23          	sw	a5,28(sp)
hex:			_uquad = UARG ();
   18d3c:	010bf793          	andi	a5,s7,16
   18d40:	fa0794e3          	bnez	a5,18ce8 <_vfiprintf_r+0x778>
   18d44:	040bf793          	andi	a5,s7,64
   18d48:	01012883          	lw	a7,16(sp)
   18d4c:	62078663          	beqz	a5,19378 <_vfiprintf_r+0xe08>
   18d50:	0008d783          	lhu	a5,0(a7)
   18d54:	00488893          	addi	a7,a7,4
   18d58:	01112823          	sw	a7,16(sp)
   18d5c:	f9dff06f          	j	18cf8 <_vfiprintf_r+0x788>
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
   18d60:	000dc603          	lbu	a2,0(s11)
   18d64:	001d8d93          	addi	s11,s11,1
   18d68:	78760c63          	beq	a2,t2,19500 <_vfiprintf_r+0xf90>
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   18d6c:	fd060793          	addi	a5,a2,-48
   18d70:	00000713          	li	a4,0
   18d74:	98f564e3          	bltu	a0,a5,186fc <_vfiprintf_r+0x18c>
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
   18d78:	001d8d93          	addi	s11,s11,1
   18d7c:	fffdc603          	lbu	a2,-1(s11)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
				n = 10 * n + to_digit (ch);
   18d80:	00171893          	slli	a7,a4,0x1
   18d84:	00371713          	slli	a4,a4,0x3
   18d88:	00e88733          	add	a4,a7,a4
   18d8c:	00f70733          	add	a4,a4,a5
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   18d90:	fd060793          	addi	a5,a2,-48
   18d94:	fef572e3          	bleu	a5,a0,18d78 <_vfiprintf_r+0x808>
   18d98:	960752e3          	bgez	a4,186fc <_vfiprintf_r+0x18c>
   18d9c:	fff00713          	li	a4,-1
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			}
			prec = n < 0 ? -1 : n;
			goto reswitch;
   18da0:	95dff06f          	j	186fc <_vfiprintf_r+0x18c>
   18da4:	7c081063          	bnez	a6,19564 <_vfiprintf_r+0xff4>

			size = buf + BUF - cp;
		skipsize:
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
   18da8:	18060863          	beqz	a2,18f38 <_vfiprintf_r+0x9c8>
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
   18dac:	00100993          	li	s3,1
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
   18db0:	04c10423          	sb	a2,72(sp)
			size = 1;
			sign = '\0';
   18db4:	02010ba3          	sb	zero,55(sp)
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
   18db8:	00098a13          	mv	s4,s3
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
   18dbc:	04810413          	addi	s0,sp,72
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   18dc0:	00000713          	li	a4,0
   18dc4:	a85ff06f          	j	18848 <_vfiprintf_r+0x2d8>
#ifdef _WANT_IO_C99_FORMATS
			else if (flags & CHARINT)
				*GET_ARG (N, ap, char_ptr_t) = ret;
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
   18dc8:	01012703          	lw	a4,16(sp)
   18dcc:	01412883          	lw	a7,20(sp)
   18dd0:	00072783          	lw	a5,0(a4)
   18dd4:	00470713          	addi	a4,a4,4
   18dd8:	00e12823          	sw	a4,16(sp)
   18ddc:	0117a023          	sw	a7,0(a5)
   18de0:	87dff06f          	j	1865c <_vfiprintf_r+0xec>
   18de4:	03c10613          	addi	a2,sp,60
   18de8:	000d0593          	mv	a1,s10
   18dec:	000a8513          	mv	a0,s5
   18df0:	01012223          	sw	a6,4(sp)
   18df4:	01d12423          	sw	t4,8(sp)
   18df8:	e78ff0ef          	jal	18470 <__sprint_r.part.0>
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   18dfc:	00412803          	lw	a6,4(sp)
   18e00:	00812e83          	lw	t4,8(sp)
   18e04:	14051663          	bnez	a0,18f50 <_vfiprintf_r+0x9e0>
   18e08:	04012503          	lw	a0,64(sp)
   18e0c:	04412783          	lw	a5,68(sp)
   18e10:	000c8693          	mv	a3,s9
   18e14:	00150613          	addi	a2,a0,1
   18e18:	a89ff06f          	j	188a0 <_vfiprintf_r+0x330>
   18e1c:	04012603          	lw	a2,64(sp)
   18e20:	04412783          	lw	a5,68(sp)
   18e24:	00160593          	addi	a1,a2,1

		/* prefix */
		if (sign)
   18e28:	03714503          	lbu	a0,55(sp)
   18e2c:	ae050ae3          	beqz	a0,18920 <_vfiprintf_r+0x3b0>
			PRINT (&sign, 1);
   18e30:	00100513          	li	a0,1
   18e34:	03710613          	addi	a2,sp,55
   18e38:	00a787b3          	add	a5,a5,a0
   18e3c:	00c6a023          	sw	a2,0(a3)
   18e40:	00700613          	li	a2,7
   18e44:	00a6a223          	sw	a0,4(a3)
   18e48:	04f12223          	sw	a5,68(sp)
   18e4c:	04b12023          	sw	a1,64(sp)
   18e50:	2ab65863          	ble	a1,a2,19100 <_vfiprintf_r+0xb90>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   18e54:	3e079663          	bnez	a5,19240 <_vfiprintf_r+0xcd0>
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
   18e58:	2a0e1e63          	bnez	t3,19114 <_vfiprintf_r+0xba4>
   18e5c:	00000613          	li	a2,0
   18e60:	00050593          	mv	a1,a0
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
   18e64:	000c8693          	mv	a3,s9
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   18e68:	08000513          	li	a0,128
   18e6c:	aea38ae3          	beq	t2,a0,18960 <_vfiprintf_r+0x3f0>
			PAD (width - realsz, zeroes);

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   18e70:	414704b3          	sub	s1,a4,s4
   18e74:	b8905ee3          	blez	s1,18a10 <_vfiprintf_r+0x4a0>
   18e78:	01000813          	li	a6,16
   18e7c:	01812c23          	sw	s8,24(sp)
   18e80:	04985a63          	ble	s1,a6,18ed4 <_vfiprintf_r+0x964>
   18e84:	00700393          	li	t2,7
   18e88:	0180006f          	j	18ea0 <_vfiprintf_r+0x930>
   18e8c:	00260593          	addi	a1,a2,2
   18e90:	00868693          	addi	a3,a3,8
   18e94:	00070613          	mv	a2,a4
   18e98:	ff048493          	addi	s1,s1,-16
   18e9c:	02985c63          	ble	s1,a6,18ed4 <_vfiprintf_r+0x964>
   18ea0:	01078793          	addi	a5,a5,16
   18ea4:	00160713          	addi	a4,a2,1
   18ea8:	0186a023          	sw	s8,0(a3)
   18eac:	0106a223          	sw	a6,4(a3)
   18eb0:	04f12223          	sw	a5,68(sp)
   18eb4:	04e12023          	sw	a4,64(sp)
   18eb8:	fce3dae3          	ble	a4,t2,18e8c <_vfiprintf_r+0x91c>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   18ebc:	04079263          	bnez	a5,18f00 <_vfiprintf_r+0x990>
		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   18ec0:	ff048493          	addi	s1,s1,-16
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   18ec4:	00100593          	li	a1,1
   18ec8:	00000613          	li	a2,0
		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   18ecc:	000c8693          	mv	a3,s9
   18ed0:	fc9848e3          	blt	a6,s1,18ea0 <_vfiprintf_r+0x930>
   18ed4:	01812703          	lw	a4,24(sp)
   18ed8:	009787b3          	add	a5,a5,s1
   18edc:	0096a223          	sw	s1,4(a3)
   18ee0:	00e6a023          	sw	a4,0(a3)
   18ee4:	00700713          	li	a4,7
   18ee8:	04f12223          	sw	a5,68(sp)
   18eec:	04b12023          	sw	a1,64(sp)
   18ef0:	06b74a63          	blt	a4,a1,18f64 <_vfiprintf_r+0x9f4>
   18ef4:	00868693          	addi	a3,a3,8
   18ef8:	00158593          	addi	a1,a1,1
   18efc:	b15ff06f          	j	18a10 <_vfiprintf_r+0x4a0>
   18f00:	03c10613          	addi	a2,sp,60
   18f04:	000d0593          	mv	a1,s10
   18f08:	000a8513          	mv	a0,s5
   18f0c:	00712023          	sw	t2,0(sp)
   18f10:	01012223          	sw	a6,4(sp)
   18f14:	d5cff0ef          	jal	18470 <__sprint_r.part.0>
   18f18:	00012383          	lw	t2,0(sp)
   18f1c:	00412803          	lw	a6,4(sp)
   18f20:	02051863          	bnez	a0,18f50 <_vfiprintf_r+0x9e0>
   18f24:	04012603          	lw	a2,64(sp)
   18f28:	04412783          	lw	a5,68(sp)
   18f2c:	000c8693          	mv	a3,s9
   18f30:	00160593          	addi	a1,a2,1
   18f34:	f65ff06f          	j	18e98 <_vfiprintf_r+0x928>
			_free_r (data, malloc_buf);
			malloc_buf = NULL;
		}
	}
done:
	FLUSH ();
   18f38:	04412783          	lw	a5,68(sp)
   18f3c:	00078a63          	beqz	a5,18f50 <_vfiprintf_r+0x9e0>
   18f40:	03c10613          	addi	a2,sp,60
   18f44:	000d0593          	mv	a1,s10
   18f48:	000a8513          	mv	a0,s5
   18f4c:	d24ff0ef          	jal	18470 <__sprint_r.part.0>
	if (malloc_buf != NULL)
		_free_r (data, malloc_buf);
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
   18f50:	00cd5783          	lhu	a5,12(s10)
   18f54:	0407f793          	andi	a5,a5,64
   18f58:	48079063          	bnez	a5,193d8 <_vfiprintf_r+0xe68>
   18f5c:	01412503          	lw	a0,20(sp)
   18f60:	815ff06f          	j	18774 <_vfiprintf_r+0x204>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   18f64:	36079463          	bnez	a5,192cc <_vfiprintf_r+0xd5c>
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   18f68:	00100713          	li	a4,1
   18f6c:	000a0793          	mv	a5,s4
   18f70:	06812823          	sw	s0,112(sp)
   18f74:	07412a23          	sw	s4,116(sp)
   18f78:	05412223          	sw	s4,68(sp)
   18f7c:	04e12023          	sw	a4,64(sp)
   18f80:	000c8693          	mv	a3,s9
   18f84:	00868693          	addi	a3,a3,8
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   18f88:	004bf293          	andi	t0,s7,4
   18f8c:	0e028463          	beqz	t0,19074 <_vfiprintf_r+0xb04>
			PAD (width - realsz, blanks);
   18f90:	413904b3          	sub	s1,s2,s3
   18f94:	0e905063          	blez	s1,19074 <_vfiprintf_r+0xb04>
   18f98:	01000a13          	li	s4,16
   18f9c:	509a5e63          	ble	s1,s4,194b8 <_vfiprintf_r+0xf48>
   18fa0:	04012603          	lw	a2,64(sp)
   18fa4:	01612c23          	sw	s6,24(sp)
   18fa8:	00700413          	li	s0,7
   18fac:	0180006f          	j	18fc4 <_vfiprintf_r+0xa54>
   18fb0:	00260593          	addi	a1,a2,2
   18fb4:	00868693          	addi	a3,a3,8
   18fb8:	00070613          	mv	a2,a4
   18fbc:	ff048493          	addi	s1,s1,-16
   18fc0:	029a5c63          	ble	s1,s4,18ff8 <_vfiprintf_r+0xa88>
   18fc4:	01078793          	addi	a5,a5,16
   18fc8:	00160713          	addi	a4,a2,1
   18fcc:	0166a023          	sw	s6,0(a3)
   18fd0:	0146a223          	sw	s4,4(a3)
   18fd4:	04f12223          	sw	a5,68(sp)
   18fd8:	04e12023          	sw	a4,64(sp)
   18fdc:	fce45ae3          	ble	a4,s0,18fb0 <_vfiprintf_r+0xa40>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   18fe0:	04079a63          	bnez	a5,19034 <_vfiprintf_r+0xac4>
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
			PAD (width - realsz, blanks);
   18fe4:	ff048493          	addi	s1,s1,-16
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
   18fe8:	00100593          	li	a1,1
   18fec:	00000613          	li	a2,0
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
			PAD (width - realsz, blanks);
   18ff0:	000c8693          	mv	a3,s9
   18ff4:	fc9a48e3          	blt	s4,s1,18fc4 <_vfiprintf_r+0xa54>
   18ff8:	01812883          	lw	a7,24(sp)
   18ffc:	009787b3          	add	a5,a5,s1
   19000:	00700713          	li	a4,7
   19004:	0116a023          	sw	a7,0(a3)
   19008:	0096a223          	sw	s1,4(a3)
   1900c:	04f12223          	sw	a5,68(sp)
   19010:	04b12023          	sw	a1,64(sp)
   19014:	06b75063          	ble	a1,a4,19074 <_vfiprintf_r+0xb04>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   19018:	04079263          	bnez	a5,1905c <_vfiprintf_r+0xaec>
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
			PAD (width - realsz, blanks);

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   1901c:	01395463          	ble	s3,s2,19024 <_vfiprintf_r+0xab4>
   19020:	00098913          	mv	s2,s3
   19024:	01412703          	lw	a4,20(sp)
   19028:	01270733          	add	a4,a4,s2
   1902c:	00e12a23          	sw	a4,20(sp)
   19030:	a29ff06f          	j	18a58 <_vfiprintf_r+0x4e8>
   19034:	03c10613          	addi	a2,sp,60
   19038:	000d0593          	mv	a1,s10
   1903c:	000a8513          	mv	a0,s5
   19040:	c30ff0ef          	jal	18470 <__sprint_r.part.0>
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
			PAD (width - realsz, blanks);
   19044:	f00516e3          	bnez	a0,18f50 <_vfiprintf_r+0x9e0>
   19048:	04012603          	lw	a2,64(sp)
   1904c:	04412783          	lw	a5,68(sp)
   19050:	000c8693          	mv	a3,s9
   19054:	00160593          	addi	a1,a2,1
   19058:	f65ff06f          	j	18fbc <_vfiprintf_r+0xa4c>
   1905c:	03c10613          	addi	a2,sp,60
   19060:	000d0593          	mv	a1,s10
   19064:	000a8513          	mv	a0,s5
   19068:	c08ff0ef          	jal	18470 <__sprint_r.part.0>
   1906c:	ee0512e3          	bnez	a0,18f50 <_vfiprintf_r+0x9e0>
   19070:	04412783          	lw	a5,68(sp)

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   19074:	01395463          	ble	s3,s2,1907c <_vfiprintf_r+0xb0c>
   19078:	00098913          	mv	s2,s3
   1907c:	01412883          	lw	a7,20(sp)
   19080:	012888b3          	add	a7,a7,s2
   19084:	01112a23          	sw	a7,20(sp)

		FLUSH ();	/* copy out the I/O vectors */
   19088:	9c0788e3          	beqz	a5,18a58 <_vfiprintf_r+0x4e8>
   1908c:	03c10613          	addi	a2,sp,60
   19090:	000d0593          	mv	a1,s10
   19094:	000a8513          	mv	a0,s5
   19098:	bd8ff0ef          	jal	18470 <__sprint_r.part.0>
   1909c:	9a050ee3          	beqz	a0,18a58 <_vfiprintf_r+0x4e8>
   190a0:	eb1ff06f          	j	18f50 <_vfiprintf_r+0x9e0>
   190a4:	03c10613          	addi	a2,sp,60
   190a8:	000d0593          	mv	a1,s10
   190ac:	000a8513          	mv	a0,s5
   190b0:	00712023          	sw	t2,0(sp)
   190b4:	01012223          	sw	a6,4(sp)
   190b8:	bb8ff0ef          	jal	18470 <__sprint_r.part.0>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   190bc:	00012383          	lw	t2,0(sp)
   190c0:	00412803          	lw	a6,4(sp)
   190c4:	e80516e3          	bnez	a0,18f50 <_vfiprintf_r+0x9e0>
   190c8:	04012603          	lw	a2,64(sp)
   190cc:	04412783          	lw	a5,68(sp)
   190d0:	000c8693          	mv	a3,s9
   190d4:	00160513          	addi	a0,a2,1
   190d8:	8bdff06f          	j	18994 <_vfiprintf_r+0x424>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   190dc:	2a079e63          	bnez	a5,19398 <_vfiprintf_r+0xe28>
		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
   190e0:	03714683          	lbu	a3,55(sp)
   190e4:	02068663          	beqz	a3,19110 <_vfiprintf_r+0xba0>
			PRINT (&sign, 1);
   190e8:	00100793          	li	a5,1
   190ec:	03710693          	addi	a3,sp,55
   190f0:	06d12823          	sw	a3,112(sp)
   190f4:	00078593          	mv	a1,a5
   190f8:	06f12a23          	sw	a5,116(sp)
   190fc:	000c8693          	mv	a3,s9
   19100:	00058613          	mv	a2,a1
   19104:	00868693          	addi	a3,a3,8
   19108:	00158593          	addi	a1,a1,1
   1910c:	815ff06f          	j	18920 <_vfiprintf_r+0x3b0>
		if (flags & HEXPREFIX)
   19110:	2c0e0863          	beqz	t3,193e0 <_vfiprintf_r+0xe70>
			PRINT (ox, 2);
   19114:	03810693          	addi	a3,sp,56
   19118:	00200793          	li	a5,2
   1911c:	06d12823          	sw	a3,112(sp)
   19120:	06f12a23          	sw	a5,116(sp)
   19124:	00100593          	li	a1,1
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   19128:	000c8693          	mv	a3,s9

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
			PRINT (ox, 2);
   1912c:	00058613          	mv	a2,a1
   19130:	00868693          	addi	a3,a3,8
   19134:	00158593          	addi	a1,a1,1
   19138:	d31ff06f          	j	18e68 <_vfiprintf_r+0x8f8>
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   1913c:	01012883          	lw	a7,16(sp)
   19140:	0008a783          	lw	a5,0(a7)
   19144:	00488613          	addi	a2,a7,4

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   19148:	02010ba3          	sb	zero,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   1914c:	aa0752e3          	bgez	a4,18bf0 <_vfiprintf_r+0x680>
			break;
		case 'U': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   19150:	00c12823          	sw	a2,16(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   19154:	00000593          	li	a1,0
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   19158:	980794e3          	bnez	a5,18ae0 <_vfiprintf_r+0x570>
   1915c:	00100793          	li	a5,1
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   19160:	00100613          	li	a2,1
   19164:	aac780e3          	beq	a5,a2,18c04 <_vfiprintf_r+0x694>
   19168:	00200613          	li	a2,2
   1916c:	0cc78663          	beq	a5,a2,19238 <_vfiprintf_r+0xcc8>
   19170:	00000793          	li	a5,0
   19174:	9e1ff06f          	j	18b54 <_vfiprintf_r+0x5e4>
			continue;	/* no output */
		case 'O': /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   19178:	01012783          	lw	a5,16(sp)
   1917c:	00478613          	addi	a2,a5,4
   19180:	0007a783          	lw	a5,0(a5)

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   19184:	02010ba3          	sb	zero,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   19188:	9a075ae3          	bgez	a4,18b3c <_vfiprintf_r+0x5cc>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   1918c:	00c12823          	sw	a2,16(sp)
   19190:	00000593          	li	a1,0
   19194:	fc0786e3          	beqz	a5,19160 <_vfiprintf_r+0xbf0>
   19198:	00000593          	li	a1,0
   1919c:	9b9ff06f          	j	18b54 <_vfiprintf_r+0x5e4>

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   191a0:	02010ba3          	sb	zero,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   191a4:	16074263          	bltz	a4,19308 <_vfiprintf_r+0xd98>
				flags &= ~ZEROPAD;
   191a8:	f7fbfb93          	andi	s7,s7,-129
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   191ac:	e6078a63          	beqz	a5,18820 <_vfiprintf_r+0x2b0>
   191b0:	00000593          	li	a1,0
   191b4:	01c12503          	lw	a0,28(sp)
   191b8:	000c8413          	mv	s0,s9
					} while (_uquad != 0);
					break;

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   191bc:	00f7f613          	andi	a2,a5,15
   191c0:	00c50633          	add	a2,a0,a2
   191c4:	00064603          	lbu	a2,0(a2)
   191c8:	fff40413          	addi	s0,s0,-1
						_uquad >>= 4;
   191cc:	0047d793          	srli	a5,a5,0x4
					} while (_uquad != 0);
					break;

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   191d0:	00c40023          	sb	a2,0(s0)
						_uquad >>= 4;
					} while (_uquad);
   191d4:	fe0794e3          	bnez	a5,191bc <_vfiprintf_r+0xc4c>
   191d8:	408c8a33          	sub	s4,s9,s0
   191dc:	e58ff06f          	j	18834 <_vfiprintf_r+0x2c4>
   191e0:	03c10613          	addi	a2,sp,60
   191e4:	000d0593          	mv	a1,s10
   191e8:	000a8513          	mv	a0,s5
   191ec:	a84ff0ef          	jal	18470 <__sprint_r.part.0>
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   191f0:	d60510e3          	bnez	a0,18f50 <_vfiprintf_r+0x9e0>
   191f4:	04412783          	lw	a5,68(sp)
   191f8:	000c8693          	mv	a3,s9
   191fc:	d8dff06f          	j	18f88 <_vfiprintf_r+0xa18>
		case 'D':  /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   19200:	040bf793          	andi	a5,s7,64
   19204:	01012883          	lw	a7,16(sp)
   19208:	18078063          	beqz	a5,19388 <_vfiprintf_r+0xe18>
   1920c:	00089783          	lh	a5,0(a7)
   19210:	00488893          	addi	a7,a7,4
   19214:	01112823          	sw	a7,16(sp)
   19218:	8b5ff06f          	j	18acc <_vfiprintf_r+0x55c>
   1921c:	03c10613          	addi	a2,sp,60
   19220:	000d0593          	mv	a1,s10
   19224:	000a8513          	mv	a0,s5
   19228:	a48ff0ef          	jal	18470 <__sprint_r.part.0>
#else
                while (*fmt != '\0' && *fmt != '%')
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
			PRINT (cp, m);
   1922c:	d20512e3          	bnez	a0,18f50 <_vfiprintf_r+0x9e0>
   19230:	000c8693          	mv	a3,s9
   19234:	c84ff06f          	j	186b8 <_vfiprintf_r+0x148>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   19238:	00000793          	li	a5,0
   1923c:	f79ff06f          	j	191b4 <_vfiprintf_r+0xc44>
   19240:	03c10613          	addi	a2,sp,60
   19244:	000d0593          	mv	a1,s10
   19248:	000a8513          	mv	a0,s5
   1924c:	00712023          	sw	t2,0(sp)
   19250:	00e12223          	sw	a4,4(sp)
   19254:	01c12423          	sw	t3,8(sp)
   19258:	a18ff0ef          	jal	18470 <__sprint_r.part.0>
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
   1925c:	00012383          	lw	t2,0(sp)
   19260:	00412703          	lw	a4,4(sp)
   19264:	00812e03          	lw	t3,8(sp)
   19268:	ce0514e3          	bnez	a0,18f50 <_vfiprintf_r+0x9e0>
   1926c:	04012603          	lw	a2,64(sp)
   19270:	04412783          	lw	a5,68(sp)
   19274:	000c8693          	mv	a3,s9
   19278:	00160593          	addi	a1,a2,1
   1927c:	ea4ff06f          	j	18920 <_vfiprintf_r+0x3b0>
   19280:	03c10613          	addi	a2,sp,60
   19284:	000d0593          	mv	a1,s10
   19288:	000a8513          	mv	a0,s5
   1928c:	00712023          	sw	t2,0(sp)
   19290:	00e12223          	sw	a4,4(sp)
   19294:	9dcff0ef          	jal	18470 <__sprint_r.part.0>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);
   19298:	00012383          	lw	t2,0(sp)
   1929c:	00412703          	lw	a4,4(sp)
   192a0:	ca0518e3          	bnez	a0,18f50 <_vfiprintf_r+0x9e0>
   192a4:	04012603          	lw	a2,64(sp)
   192a8:	04412783          	lw	a5,68(sp)
   192ac:	000c8693          	mv	a3,s9
   192b0:	00160593          	addi	a1,a2,1
   192b4:	bb5ff06f          	j	18e68 <_vfiprintf_r+0x8f8>
       FILE *fp _AND
       register struct __suio *uio)
{
	register int err = 0;

	if (uio->uio_resid == 0) {
   192b8:	16079263          	bnez	a5,1941c <_vfiprintf_r+0xeac>
		uio->uio_iovcnt = 0;
   192bc:	00100593          	li	a1,1
   192c0:	00000613          	li	a2,0
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   192c4:	000c8693          	mv	a3,s9
   192c8:	ba9ff06f          	j	18e70 <_vfiprintf_r+0x900>
   192cc:	03c10613          	addi	a2,sp,60
   192d0:	000d0593          	mv	a1,s10
   192d4:	000a8513          	mv	a0,s5
   192d8:	998ff0ef          	jal	18470 <__sprint_r.part.0>

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   192dc:	c6051ae3          	bnez	a0,18f50 <_vfiprintf_r+0x9e0>
   192e0:	04012583          	lw	a1,64(sp)
   192e4:	04412783          	lw	a5,68(sp)
   192e8:	000c8693          	mv	a3,s9
   192ec:	00158593          	addi	a1,a1,1
   192f0:	f20ff06f          	j	18a10 <_vfiprintf_r+0x4a0>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   192f4:	00c12823          	sw	a2,16(sp)
			base = HEX;
			xdigs = "0123456789abcdef";
   192f8:	0001d637          	lui	a2,0x1d
   192fc:	d1460613          	addi	a2,a2,-748 # 1cd14 <__thenan_sf+0x34>
			flags |= HEXPREFIX;
   19300:	00050b93          	mv	s7,a0
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   19304:	00c12e23          	sw	a2,28(sp)
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   19308:	ea0794e3          	bnez	a5,191b0 <_vfiprintf_r+0xc40>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   1930c:	00000593          	li	a1,0
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
   19310:	00200793          	li	a5,2
   19314:	e4dff06f          	j	19160 <_vfiprintf_r+0xbf0>
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   19318:	000d8913          	mv	s2,s11
   1931c:	ba8ff06f          	j	186c4 <_vfiprintf_r+0x154>
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   19320:	0001d637          	lui	a2,0x1d
   19324:	d1460613          	addi	a2,a2,-748 # 1cd14 <__thenan_sf+0x34>
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   19328:	00000593          	li	a1,0
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
			base = HEX;
			xdigs = "0123456789abcdef";
   1932c:	00c12e23          	sw	a2,28(sp)
   19330:	e85ff06f          	j	191b4 <_vfiprintf_r+0xc44>
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
				ox[0] = '0';
   19334:	03000593          	li	a1,48
				ox[1] = ch;
   19338:	02c10ca3          	sb	a2,57(sp)
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
				ox[0] = '0';
   1933c:	02b10c23          	sb	a1,56(sp)
				ox[1] = ch;
				flags |= HEXPREFIX;
   19340:	002be613          	ori	a2,s7,2

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   19344:	02010ba3          	sb	zero,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   19348:	10074a63          	bltz	a4,1945c <_vfiprintf_r+0xeec>
   1934c:	f7fbf293          	andi	t0,s7,-129
				flags &= ~ZEROPAD;
   19350:	0022eb93          	ori	s7,t0,2
   19354:	00000593          	li	a1,0
   19358:	e5dff06f          	j	191b4 <_vfiprintf_r+0xc44>
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
				sign = '-';
   1935c:	02d00613          	li	a2,45
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
   19360:	40f007b3          	neg	a5,a5
				sign = '-';
   19364:	02c10ba3          	sb	a2,55(sp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   19368:	10074a63          	bltz	a4,1947c <_vfiprintf_r+0xf0c>
				flags &= ~ZEROPAD;
   1936c:	f7fbfb93          	andi	s7,s7,-129
   19370:	02d00593          	li	a1,45
   19374:	f6cff06f          	j	18ae0 <_vfiprintf_r+0x570>
		case 'X':
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
   19378:	0008a783          	lw	a5,0(a7)
   1937c:	00488893          	addi	a7,a7,4
   19380:	01112823          	sw	a7,16(sp)
   19384:	975ff06f          	j	18cf8 <_vfiprintf_r+0x788>
		case 'D':  /* extension */
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   19388:	0008a783          	lw	a5,0(a7)
   1938c:	00488893          	addi	a7,a7,4
   19390:	01112823          	sw	a7,16(sp)
   19394:	f38ff06f          	j	18acc <_vfiprintf_r+0x55c>
   19398:	03c10613          	addi	a2,sp,60
   1939c:	000d0593          	mv	a1,s10
   193a0:	000a8513          	mv	a0,s5
   193a4:	00712023          	sw	t2,0(sp)
   193a8:	00e12223          	sw	a4,4(sp)
   193ac:	01c12423          	sw	t3,8(sp)
   193b0:	8c0ff0ef          	jal	18470 <__sprint_r.part.0>
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   193b4:	00012383          	lw	t2,0(sp)
   193b8:	00412703          	lw	a4,4(sp)
   193bc:	00812e03          	lw	t3,8(sp)
   193c0:	b80518e3          	bnez	a0,18f50 <_vfiprintf_r+0x9e0>
   193c4:	04012603          	lw	a2,64(sp)
   193c8:	04412783          	lw	a5,68(sp)
   193cc:	000c8693          	mv	a3,s9
   193d0:	00160593          	addi	a1,a2,1
   193d4:	a55ff06f          	j	18e28 <_vfiprintf_r+0x8b8>
	ORIENT(fp, -1);

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
		_newlib_flockfile_exit (fp);
		return (EOF);
   193d8:	fff00513          	li	a0,-1
   193dc:	b98ff06f          	j	18774 <_vfiprintf_r+0x204>
			PAD (width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
		if (flags & HEXPREFIX)
   193e0:	00000613          	li	a2,0
   193e4:	00100593          	li	a1,1
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
   193e8:	000c8693          	mv	a3,s9
   193ec:	a7dff06f          	j	18e68 <_vfiprintf_r+0x8f8>
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   193f0:	000c8693          	mv	a3,s9
   193f4:	ba5ff06f          	j	18f98 <_vfiprintf_r+0xa28>
				if (p != NULL)
					size = p - cp;
				else
					size = prec;
			} else
				size = strlen (cp);
   193f8:	00040513          	mv	a0,s0
   193fc:	00d12423          	sw	a3,8(sp)
   19400:	fe1fe0ef          	jal	183e0 <strlen>
   19404:	00050a13          	mv	s4,a0
   19408:	03714583          	lbu	a1,55(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   1940c:	00912823          	sw	s1,16(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   19410:	00000713          	li	a4,0
   19414:	00812683          	lw	a3,8(sp)
   19418:	c1cff06f          	j	18834 <_vfiprintf_r+0x2c4>
   1941c:	03c10613          	addi	a2,sp,60
   19420:	000d0593          	mv	a1,s10
   19424:	000a8513          	mv	a0,s5
   19428:	00e12223          	sw	a4,4(sp)
   1942c:	844ff0ef          	jal	18470 <__sprint_r.part.0>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   19430:	00412703          	lw	a4,4(sp)
   19434:	b0051ee3          	bnez	a0,18f50 <_vfiprintf_r+0x9e0>
   19438:	04012603          	lw	a2,64(sp)
   1943c:	04412783          	lw	a5,68(sp)
   19440:	000c8693          	mv	a3,s9
   19444:	00160593          	addi	a1,a2,1
   19448:	a29ff06f          	j	18e70 <_vfiprintf_r+0x900>
   1944c:	04012603          	lw	a2,64(sp)
   19450:	01612c23          	sw	s6,24(sp)
   19454:	00160613          	addi	a2,a2,1
   19458:	c98ff06f          	j	188f0 <_vfiprintf_r+0x380>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   1945c:	00000593          	li	a1,0
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG ();
			base = HEX;
   19460:	00200513          	li	a0,2
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   19464:	00100813          	li	a6,1
   19468:	09050063          	beq	a0,a6,194e8 <_vfiprintf_r+0xf78>
   1946c:	00200813          	li	a6,2
   19470:	09051063          	bne	a0,a6,194f0 <_vfiprintf_r+0xf80>
   19474:	00060b93          	mv	s7,a2
   19478:	d3dff06f          	j	191b4 <_vfiprintf_r+0xc44>
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   1947c:	000b8613          	mv	a2,s7
   19480:	02d00593          	li	a1,45
			{

				_uquad = -_uquad;
				sign = '-';
			}
			base = DEC;
   19484:	00100513          	li	a0,1
   19488:	fddff06f          	j	19464 <_vfiprintf_r+0xef4>
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
				size = ((unsigned) prec > 6U) ? 6 : prec;
   1948c:	00600793          	li	a5,6
   19490:	00e7f463          	bleu	a4,a5,19498 <_vfiprintf_r+0xf28>
   19494:	00078713          	mv	a4,a5
   19498:	00070a13          	mv	s4,a4
   1949c:	00070993          	mv	s3,a4
   194a0:	04074c63          	bltz	a4,194f8 <_vfiprintf_r+0xf88>
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
   194a4:	0001d337          	lui	t1,0x1d
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   194a8:	00912823          	sw	s1,16(sp)
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
				cp = "(null)";
   194ac:	d2830413          	addi	s0,t1,-728 # 1cd28 <__thenan_sf+0x48>
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   194b0:	00000713          	li	a4,0
   194b4:	b94ff06f          	j	18848 <_vfiprintf_r+0x2d8>
   194b8:	04012583          	lw	a1,64(sp)
   194bc:	01612c23          	sw	s6,24(sp)
   194c0:	00158593          	addi	a1,a1,1
   194c4:	b35ff06f          	j	18ff8 <_vfiprintf_r+0xa88>
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);

				if (p != NULL)
   194c8:	00070a13          	mv	s4,a4
   194cc:	03714583          	lbu	a1,55(sp)
			goto nosign;
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   194d0:	00912823          	sw	s1,16(sp)
#endif
		fmt_anchor = fmt;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
   194d4:	00000713          	li	a4,0
   194d8:	b5cff06f          	j	18834 <_vfiprintf_r+0x2c4>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
   194dc:	00058513          	mv	a0,a1
   194e0:	01812c23          	sw	s8,24(sp)
   194e4:	cf8ff06f          	j	189dc <_vfiprintf_r+0x46c>
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   194e8:	00060b93          	mv	s7,a2
   194ec:	df4ff06f          	j	18ae0 <_vfiprintf_r+0x570>
   194f0:	00060b93          	mv	s7,a2
   194f4:	e60ff06f          	j	18b54 <_vfiprintf_r+0x5e4>
   194f8:	00000993          	li	s3,0
   194fc:	fa9ff06f          	j	194a4 <_vfiprintf_r+0xf34>
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
   19500:	01012883          	lw	a7,16(sp)
   19504:	0008a703          	lw	a4,0(a7)
   19508:	00488793          	addi	a5,a7,4
   1950c:	00f12823          	sw	a5,16(sp)
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
   19510:	a2075063          	bgez	a4,18730 <_vfiprintf_r+0x1c0>
					prec = -1;
   19514:	fff00713          	li	a4,-1
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   19518:	000d8493          	mv	s1,s11
   1951c:	9d8ff06f          	j	186f4 <_vfiprintf_r+0x184>
   19520:	02610ba3          	sb	t1,55(sp)
   19524:	80dff06f          	j	18d30 <_vfiprintf_r+0x7c0>
   19528:	02610ba3          	sb	t1,55(sp)
   1952c:	e6cff06f          	j	18b98 <_vfiprintf_r+0x628>
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   19530:	001bf793          	andi	a5,s7,1
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_uquad != 0 || prec != 0) {
   19534:	00070593          	mv	a1,a4
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   19538:	00078c63          	beqz	a5,19550 <_vfiprintf_r+0xfe0>
                         *--cp = '0';
   1953c:	03000793          	li	a5,48
   19540:	06f107a3          	sb	a5,111(sp)
   19544:	02412a03          	lw	s4,36(sp)
   19548:	06f10413          	addi	s0,sp,111
   1954c:	ae8ff06f          	j	18834 <_vfiprintf_r+0x2c4>
   19550:	00000a13          	li	s4,0
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   19554:	000c8413          	mv	s0,s9
   19558:	adcff06f          	j	18834 <_vfiprintf_r+0x2c4>
   1955c:	02610ba3          	sb	t1,55(sp)
   19560:	e68ff06f          	j	18bc8 <_vfiprintf_r+0x658>
   19564:	02610ba3          	sb	t1,55(sp)
   19568:	841ff06f          	j	18da8 <_vfiprintf_r+0x838>
   1956c:	02610ba3          	sb	t1,55(sp)
   19570:	da4ff06f          	j	18b14 <_vfiprintf_r+0x5a4>
   19574:	02610ba3          	sb	t1,55(sp)
   19578:	d38ff06f          	j	18ab0 <_vfiprintf_r+0x540>
   1957c:	02610ba3          	sb	t1,55(sp)
   19580:	f54ff06f          	j	18cd4 <_vfiprintf_r+0x764>

00019584 <vfiprintf>:
       FILE * fp         _AND
       _CONST char *fmt0 _AND
       va_list ap)
{
  int result;
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
   19584:	00060693          	mv	a3,a2
   19588:	00058613          	mv	a2,a1
   1958c:	00050593          	mv	a1,a0
   19590:	8101a503          	lw	a0,-2032(gp) # 47ff0 <_impure_ptr>
   19594:	fddfe06f          	j	18570 <_vfiprintf_r>

00019598 <__sbprintf>:
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   19598:	00c5d783          	lhu	a5,12(a1)
	fake._flags2 = fp->_flags2;
   1959c:	0685a303          	lw	t1,104(a1)
	fake._file = fp->_file;
   195a0:	00e5d283          	lhu	t0,14(a1)
	fake._cookie = fp->_cookie;
   195a4:	01c5a883          	lw	a7,28(a1)
	fake._write = fp->_write;
   195a8:	0245a803          	lw	a6,36(a1)
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   195ac:	b8010113          	addi	sp,sp,-1152
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   195b0:	ffd7f793          	andi	a5,a5,-3
	fake._cookie = fp->_cookie;
	fake._write = fp->_write;

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
	fake._bf._size = fake._w = sizeof (buf);
   195b4:	40000713          	li	a4,1024
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   195b8:	46812c23          	sw	s0,1144(sp)
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   195bc:	00f11623          	sh	a5,12(sp)
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   195c0:	00058413          	mv	s0,a1
	fake._file = fp->_file;
	fake._cookie = fp->_cookie;
	fake._write = fp->_write;

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
   195c4:	07010793          	addi	a5,sp,112
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   195c8:	00010593          	mv	a1,sp
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   195cc:	46912a23          	sw	s1,1140(sp)
   195d0:	47212823          	sw	s2,1136(sp)
   195d4:	46112e23          	sw	ra,1148(sp)
   195d8:	00050913          	mv	s2,a0
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
	fake._flags2 = fp->_flags2;
   195dc:	06612423          	sw	t1,104(sp)
	fake._file = fp->_file;
   195e0:	00511723          	sh	t0,14(sp)
	fake._cookie = fp->_cookie;
   195e4:	01112e23          	sw	a7,28(sp)
	fake._write = fp->_write;
   195e8:	03012223          	sw	a6,36(sp)

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
   195ec:	00f12023          	sw	a5,0(sp)
   195f0:	00f12823          	sw	a5,16(sp)
	fake._bf._size = fake._w = sizeof (buf);
   195f4:	00e12423          	sw	a4,8(sp)
   195f8:	00e12a23          	sw	a4,20(sp)
	fake._lbfsize = 0;	/* not actually used, but Just In Case */
   195fc:	00012c23          	sw	zero,24(sp)
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   19600:	f71fe0ef          	jal	18570 <_vfiprintf_r>
   19604:	00050493          	mv	s1,a0
	if (ret >= 0 && _fflush_r (rptr, &fake))
   19608:	00054a63          	bltz	a0,1961c <__sbprintf+0x84>
   1960c:	00010593          	mv	a1,sp
   19610:	00090513          	mv	a0,s2
   19614:	cecfc0ef          	jal	15b00 <_fflush_r>
   19618:	02051c63          	bnez	a0,19650 <__sbprintf+0xb8>
		ret = EOF;
	if (fake._flags & __SERR)
   1961c:	00c15783          	lhu	a5,12(sp)
   19620:	0407f793          	andi	a5,a5,64
   19624:	00078863          	beqz	a5,19634 <__sbprintf+0x9c>
		fp->_flags |= __SERR;
   19628:	00c45783          	lhu	a5,12(s0)
   1962c:	0407e793          	ori	a5,a5,64
   19630:	00f41623          	sh	a5,12(s0)

#ifndef __SINGLE_THREAD__
	__lock_close_recursive (fake._lock);
#endif
	return (ret);
}
   19634:	47c12083          	lw	ra,1148(sp)
   19638:	00048513          	mv	a0,s1
   1963c:	47812403          	lw	s0,1144(sp)
   19640:	47412483          	lw	s1,1140(sp)
   19644:	47012903          	lw	s2,1136(sp)
   19648:	48010113          	addi	sp,sp,1152
   1964c:	00008067          	ret
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
	if (ret >= 0 && _fflush_r (rptr, &fake))
		ret = EOF;
   19650:	fff00493          	li	s1,-1
   19654:	fc9ff06f          	j	1961c <__sbprintf+0x84>

00019658 <_calloc_r>:
  MALLOC_LOCK;
  oldtop = top;
  oldtopsize = chunksize(top);
#endif

  mem = mALLOc (RCALL sz);
   19658:	02c585b3          	mul	a1,a1,a2
#if __STD_C
Void_t* cALLOc(RARG size_t n, size_t elem_size)
#else
Void_t* cALLOc(RARG n, elem_size) RDECL size_t n; size_t elem_size;
#endif
{
   1965c:	ff010113          	addi	sp,sp,-16
   19660:	00112623          	sw	ra,12(sp)
   19664:	00812423          	sw	s0,8(sp)
  MALLOC_LOCK;
  oldtop = top;
  oldtopsize = chunksize(top);
#endif

  mem = mALLOc (RCALL sz);
   19668:	82cfd0ef          	jal	16694 <_malloc_r>

  if (mem == 0) 
   1966c:	08050c63          	beqz	a0,19704 <_calloc_r+0xac>
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
   19670:	ffc52603          	lw	a2,-4(a0)
   19674:	02400713          	li	a4,36
   19678:	00050413          	mv	s0,a0
   1967c:	ffc67613          	andi	a2,a2,-4
   19680:	ffc60613          	addi	a2,a2,-4
   19684:	04c76e63          	bltu	a4,a2,196e0 <_calloc_r+0x88>
   19688:	01300693          	li	a3,19
   1968c:	00050793          	mv	a5,a0
   19690:	02c6f863          	bleu	a2,a3,196c0 <_calloc_r+0x68>
   19694:	01b00793          	li	a5,27
   19698:	00052023          	sw	zero,0(a0)
   1969c:	00052223          	sw	zero,4(a0)
   196a0:	04c7fe63          	bleu	a2,a5,196fc <_calloc_r+0xa4>
   196a4:	00052423          	sw	zero,8(a0)
   196a8:	00052623          	sw	zero,12(a0)
   196ac:	01050793          	addi	a5,a0,16
   196b0:	00e61863          	bne	a2,a4,196c0 <_calloc_r+0x68>
   196b4:	00052823          	sw	zero,16(a0)
   196b8:	01850793          	addi	a5,a0,24
   196bc:	00052a23          	sw	zero,20(a0)
   196c0:	0007a023          	sw	zero,0(a5)
   196c4:	0007a223          	sw	zero,4(a5)
   196c8:	0007a423          	sw	zero,8(a5)
   196cc:	00040513          	mv	a0,s0
    return mem;
  }
}
   196d0:	00c12083          	lw	ra,12(sp)
   196d4:	00812403          	lw	s0,8(sp)
   196d8:	01010113          	addi	sp,sp,16
   196dc:	00008067          	ret
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
   196e0:	00000593          	li	a1,0
   196e4:	91dfd0ef          	jal	17000 <memset>
    return mem;
  }
}
   196e8:	00c12083          	lw	ra,12(sp)
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
   196ec:	00040513          	mv	a0,s0
    return mem;
  }
}
   196f0:	00812403          	lw	s0,8(sp)
   196f4:	01010113          	addi	sp,sp,16
   196f8:	00008067          	ret
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
   196fc:	00850793          	addi	a5,a0,8
   19700:	fc1ff06f          	j	196c0 <_calloc_r+0x68>
  if (mem == 0) 
  {
#if MORECORE_CLEARS
    MALLOC_UNLOCK;
#endif
    return 0;
   19704:	00000513          	li	a0,0
   19708:	fc9ff06f          	j	196d0 <_calloc_r+0x78>

0001970c <_fclose_r>:
      struct _reent *rptr _AND
      register FILE * fp)
{
  int r;

  if (fp == NULL)
   1970c:	0e058463          	beqz	a1,197f4 <_fclose_r+0xe8>

int
_DEFUN(_fclose_r, (rptr, fp),
      struct _reent *rptr _AND
      register FILE * fp)
{
   19710:	ff010113          	addi	sp,sp,-16
   19714:	00812423          	sw	s0,8(sp)
   19718:	00912223          	sw	s1,4(sp)
   1971c:	00112623          	sw	ra,12(sp)
   19720:	01212023          	sw	s2,0(sp)
   19724:	00050493          	mv	s1,a0
   19728:	00058413          	mv	s0,a1
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */

  CHECK_INIT (rptr, fp);
   1972c:	00050663          	beqz	a0,19738 <_fclose_r+0x2c>
   19730:	03852783          	lw	a5,56(a0)
   19734:	0a078063          	beqz	a5,197d4 <_fclose_r+0xc8>
  int __oldcancel;
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  _flockfile (fp);

  if (fp->_flags == 0)		/* not open! */
   19738:	00c41783          	lh	a5,12(s0)
      register FILE * fp)
{
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */
   1973c:	00000513          	li	a0,0
  int __oldcancel;
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  _flockfile (fp);

  if (fp->_flags == 0)		/* not open! */
   19740:	00079e63          	bnez	a5,1975c <_fclose_r+0x50>
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
}
   19744:	00c12083          	lw	ra,12(sp)
   19748:	00812403          	lw	s0,8(sp)
   1974c:	00412483          	lw	s1,4(sp)
   19750:	00012903          	lw	s2,0(sp)
   19754:	01010113          	addi	sp,sp,16
   19758:	00008067          	ret
  r = (fp->_flags & __SWR) ? __sflush_r (rptr, fp) : 0;
#else
  /* Follow POSIX semantics exactly.  Unconditionally flush to allow
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
   1975c:	00040593          	mv	a1,s0
   19760:	00048513          	mv	a0,s1
   19764:	90cfc0ef          	jal	15870 <__sflush_r>
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
   19768:	02c42783          	lw	a5,44(s0)
  r = (fp->_flags & __SWR) ? __sflush_r (rptr, fp) : 0;
#else
  /* Follow POSIX semantics exactly.  Unconditionally flush to allow
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
   1976c:	00050913          	mv	s2,a0
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
   19770:	00078a63          	beqz	a5,19784 <_fclose_r+0x78>
   19774:	01c42583          	lw	a1,28(s0)
   19778:	00048513          	mv	a0,s1
   1977c:	000780e7          	jalr	a5
   19780:	04054e63          	bltz	a0,197dc <_fclose_r+0xd0>
    r = EOF;
  if (fp->_flags & __SMBF)
   19784:	00c45783          	lhu	a5,12(s0)
   19788:	0807f793          	andi	a5,a5,128
   1978c:	04079c63          	bnez	a5,197e4 <_fclose_r+0xd8>
    _free_r (rptr, (char *) fp->_bf._base);
  if (HASUB (fp))
   19790:	03042583          	lw	a1,48(s0)
   19794:	00058c63          	beqz	a1,197ac <_fclose_r+0xa0>
    FREEUB (rptr, fp);
   19798:	04040793          	addi	a5,s0,64
   1979c:	00f58663          	beq	a1,a5,197a8 <_fclose_r+0x9c>
   197a0:	00048513          	mv	a0,s1
   197a4:	84dfc0ef          	jal	15ff0 <_free_r>
   197a8:	02042823          	sw	zero,48(s0)
  if (HASLB (fp))
   197ac:	04442583          	lw	a1,68(s0)
   197b0:	00058863          	beqz	a1,197c0 <_fclose_r+0xb4>
    FREELB (rptr, fp);
   197b4:	00048513          	mv	a0,s1
   197b8:	839fc0ef          	jal	15ff0 <_free_r>
   197bc:	04042223          	sw	zero,68(s0)
  __sfp_lock_acquire ();
   197c0:	f00fc0ef          	jal	15ec0 <__sfp_lock_acquire>
  fp->_flags = 0;		/* release this FILE for reuse */
   197c4:	00041623          	sh	zero,12(s0)
  _funlockfile (fp);
#ifndef __SINGLE_THREAD__
  __lock_close_recursive (fp->_lock);
#endif

  __sfp_lock_release ();
   197c8:	efcfc0ef          	jal	15ec4 <__sfp_lock_release>
   197cc:	00090513          	mv	a0,s2
   197d0:	f75ff06f          	j	19744 <_fclose_r+0x38>
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */

  CHECK_INIT (rptr, fp);
   197d4:	edcfc0ef          	jal	15eb0 <__sinit>
   197d8:	f61ff06f          	j	19738 <_fclose_r+0x2c>
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
    r = EOF;
   197dc:	fff00913          	li	s2,-1
   197e0:	fa5ff06f          	j	19784 <_fclose_r+0x78>
  if (fp->_flags & __SMBF)
    _free_r (rptr, (char *) fp->_bf._base);
   197e4:	01042583          	lw	a1,16(s0)
   197e8:	00048513          	mv	a0,s1
   197ec:	805fc0ef          	jal	15ff0 <_free_r>
   197f0:	fa1ff06f          	j	19790 <_fclose_r+0x84>
      register FILE * fp)
{
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */
   197f4:	00000513          	li	a0,0
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
}
   197f8:	00008067          	ret

000197fc <fclose>:

int
_DEFUN(fclose, (fp),
       register FILE * fp)
{
  return _fclose_r(_REENT, fp);
   197fc:	00050593          	mv	a1,a0
   19800:	8101a503          	lw	a0,-2032(gp) # 47ff0 <_impure_ptr>
   19804:	f09ff06f          	j	1970c <_fclose_r>

00019808 <__fputwc>:
wint_t
_DEFUN(__fputwc, (ptr, wc, fp),
	struct _reent *ptr _AND
	wchar_t wc _AND
	FILE *fp)
{
   19808:	fd010113          	addi	sp,sp,-48
   1980c:	02812423          	sw	s0,40(sp)
   19810:	01412c23          	sw	s4,24(sp)
   19814:	01512a23          	sw	s5,20(sp)
   19818:	02112623          	sw	ra,44(sp)
   1981c:	02912223          	sw	s1,36(sp)
   19820:	03212023          	sw	s2,32(sp)
   19824:	01312e23          	sw	s3,28(sp)
   19828:	01612823          	sw	s6,16(sp)
   1982c:	00050a93          	mv	s5,a0
   19830:	00058a13          	mv	s4,a1
   19834:	00060413          	mv	s0,a2
  char buf[MB_LEN_MAX];
  size_t i, len;

  if (MB_CUR_MAX == 1 && wc > 0 && wc <= UCHAR_MAX)
   19838:	c89fc0ef          	jal	164c0 <__locale_mb_cur_max>
   1983c:	00100793          	li	a5,1
   19840:	10f50063          	beq	a0,a5,19940 <__fputwc+0x138>
      *buf = (unsigned char)wc;
      len = 1;
    }
  else
    {
      if ((len = _wcrtomb_r (ptr, buf, wc, &fp->_mbstate)) == (size_t) -1)
   19844:	00c10493          	addi	s1,sp,12
   19848:	06040693          	addi	a3,s0,96
   1984c:	000a0613          	mv	a2,s4
   19850:	00048593          	mv	a1,s1
   19854:	000a8513          	mv	a0,s5
   19858:	665000ef          	jal	1a6bc <_wcrtomb_r>
   1985c:	fff00793          	li	a5,-1
   19860:	00050993          	mv	s3,a0
   19864:	08f50863          	beq	a0,a5,198f4 <__fputwc+0xec>
	  fp->_flags |= __SERR;
	  return WEOF;
	}
    }

  for (i = 0; i < len; i++)
   19868:	0e050c63          	beqz	a0,19960 <__fputwc+0x158>
   1986c:	00c14583          	lbu	a1,12(sp)
       * Assume single-byte locale with no special encoding.
       * A more careful test would be to check
       * _CurrentRuneLocale->encoding.
       */
      *buf = (unsigned char)wc;
      len = 1;
   19870:	00000913          	li	s2,0
	  return WEOF;
	}
    }

  for (i = 0; i < len; i++)
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
   19874:	00a00b13          	li	s6,10
   19878:	0280006f          	j	198a0 <__fputwc+0x98>
   1987c:	00042783          	lw	a5,0(s0)
   19880:	00b78023          	sb	a1,0(a5)
   19884:	00042783          	lw	a5,0(s0)
   19888:	00178793          	addi	a5,a5,1
   1988c:	00f42023          	sw	a5,0(s0)
	  fp->_flags |= __SERR;
	  return WEOF;
	}
    }

  for (i = 0; i < len; i++)
   19890:	00190913          	addi	s2,s2,1
   19894:	00148493          	addi	s1,s1,1
   19898:	0d397463          	bleu	s3,s2,19960 <__fputwc+0x158>
   1989c:	0004c583          	lbu	a1,0(s1)
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
   198a0:	00842783          	lw	a5,8(s0)
   198a4:	fff78793          	addi	a5,a5,-1
   198a8:	00f42423          	sw	a5,8(s0)
   198ac:	fc07d8e3          	bgez	a5,1987c <__fputwc+0x74>
   198b0:	01842703          	lw	a4,24(s0)
   198b4:	06e7ca63          	blt	a5,a4,19928 <__fputwc+0x120>
   198b8:	00042783          	lw	a5,0(s0)
   198bc:	00b78023          	sb	a1,0(a5)
   198c0:	00042783          	lw	a5,0(s0)
   198c4:	0007c703          	lbu	a4,0(a5)
   198c8:	00178793          	addi	a5,a5,1
   198cc:	fd6710e3          	bne	a4,s6,1988c <__fputwc+0x84>
   198d0:	00040613          	mv	a2,s0
   198d4:	000b0593          	mv	a1,s6
   198d8:	000a8513          	mv	a0,s5
   198dc:	471000ef          	jal	1a54c <__swbuf_r>
   198e0:	00150513          	addi	a0,a0,1
   198e4:	00153513          	seqz	a0,a0
   198e8:	fa0504e3          	beqz	a0,19890 <__fputwc+0x88>
      return WEOF;
   198ec:	fff00513          	li	a0,-1
   198f0:	0100006f          	j	19900 <__fputwc+0xf8>
    }
  else
    {
      if ((len = _wcrtomb_r (ptr, buf, wc, &fp->_mbstate)) == (size_t) -1)
	{
	  fp->_flags |= __SERR;
   198f4:	00c45783          	lhu	a5,12(s0)
   198f8:	0407e793          	ori	a5,a5,64
   198fc:	00f41623          	sh	a5,12(s0)
  for (i = 0; i < len; i++)
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
      return WEOF;

  return (wint_t) wc;
}
   19900:	02c12083          	lw	ra,44(sp)
   19904:	02812403          	lw	s0,40(sp)
   19908:	02412483          	lw	s1,36(sp)
   1990c:	02012903          	lw	s2,32(sp)
   19910:	01c12983          	lw	s3,28(sp)
   19914:	01812a03          	lw	s4,24(sp)
   19918:	01412a83          	lw	s5,20(sp)
   1991c:	01012b03          	lw	s6,16(sp)
   19920:	03010113          	addi	sp,sp,48
   19924:	00008067          	ret
	  return WEOF;
	}
    }

  for (i = 0; i < len; i++)
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
   19928:	00040613          	mv	a2,s0
   1992c:	000a8513          	mv	a0,s5
   19930:	41d000ef          	jal	1a54c <__swbuf_r>
   19934:	00150513          	addi	a0,a0,1
   19938:	00153513          	seqz	a0,a0
   1993c:	fadff06f          	j	198e8 <__fputwc+0xe0>
	FILE *fp)
{
  char buf[MB_LEN_MAX];
  size_t i, len;

  if (MB_CUR_MAX == 1 && wc > 0 && wc <= UCHAR_MAX)
   19940:	fffa0793          	addi	a5,s4,-1
   19944:	0fe00713          	li	a4,254
   19948:	eef76ee3          	bltu	a4,a5,19844 <__fputwc+0x3c>
      /*
       * Assume single-byte locale with no special encoding.
       * A more careful test would be to check
       * _CurrentRuneLocale->encoding.
       */
      *buf = (unsigned char)wc;
   1994c:	0ffa7593          	andi	a1,s4,255
   19950:	00b10623          	sb	a1,12(sp)
      len = 1;
   19954:	00050993          	mv	s3,a0
   19958:	00c10493          	addi	s1,sp,12
   1995c:	f15ff06f          	j	19870 <__fputwc+0x68>

  for (i = 0; i < len; i++)
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
      return WEOF;

  return (wint_t) wc;
   19960:	000a0513          	mv	a0,s4
   19964:	f9dff06f          	j	19900 <__fputwc+0xf8>

00019968 <_fputwc_r>:
	FILE *fp)
{
  wint_t r;

  _newlib_flockfile_start (fp);
  ORIENT(fp, 1);
   19968:	00c61783          	lh	a5,12(a2)
   1996c:	00002737          	lui	a4,0x2
   19970:	01279693          	slli	a3,a5,0x12
   19974:	0006cc63          	bltz	a3,1998c <_fputwc_r+0x24>
	wchar_t wc _AND
	FILE *fp)
{
  wint_t r;

  _newlib_flockfile_start (fp);
   19978:	06862683          	lw	a3,104(a2)
  ORIENT(fp, 1);
   1997c:	00e7e7b3          	or	a5,a5,a4
   19980:	00f61623          	sh	a5,12(a2)
   19984:	00e6e733          	or	a4,a3,a4
   19988:	06e62423          	sw	a4,104(a2)
  r = __fputwc(ptr, wc, fp);
   1998c:	e7dff06f          	j	19808 <__fputwc>

00019990 <fputwc>:

wint_t
_DEFUN(fputwc, (wc, fp),
	wchar_t wc _AND
	FILE *fp)
{
   19990:	fe010113          	addi	sp,sp,-32
   19994:	00812c23          	sw	s0,24(sp)
  struct _reent *reent = _REENT;
   19998:	8101a403          	lw	s0,-2032(gp) # 47ff0 <_impure_ptr>

wint_t
_DEFUN(fputwc, (wc, fp),
	wchar_t wc _AND
	FILE *fp)
{
   1999c:	00912a23          	sw	s1,20(sp)
   199a0:	00112e23          	sw	ra,28(sp)
   199a4:	00050493          	mv	s1,a0
   199a8:	00058613          	mv	a2,a1
  struct _reent *reent = _REENT;

  CHECK_INIT(reent, fp);
   199ac:	00040663          	beqz	s0,199b8 <fputwc+0x28>
   199b0:	03842783          	lw	a5,56(s0)
   199b4:	04078263          	beqz	a5,199f8 <fputwc+0x68>
	FILE *fp)
{
  wint_t r;

  _newlib_flockfile_start (fp);
  ORIENT(fp, 1);
   199b8:	00c61783          	lh	a5,12(a2)
   199bc:	00002737          	lui	a4,0x2
   199c0:	01279693          	slli	a3,a5,0x12
   199c4:	0006cc63          	bltz	a3,199dc <fputwc+0x4c>
	wchar_t wc _AND
	FILE *fp)
{
  wint_t r;

  _newlib_flockfile_start (fp);
   199c8:	06862683          	lw	a3,104(a2)
  ORIENT(fp, 1);
   199cc:	00e7e7b3          	or	a5,a5,a4
   199d0:	00f61623          	sh	a5,12(a2)
   199d4:	00e6e733          	or	a4,a3,a4
   199d8:	06e62423          	sw	a4,104(a2)
  r = __fputwc(ptr, wc, fp);
   199dc:	00048593          	mv	a1,s1
   199e0:	00040513          	mv	a0,s0
{
  struct _reent *reent = _REENT;

  CHECK_INIT(reent, fp);
  return _fputwc_r (reent, wc, fp);
}
   199e4:	01c12083          	lw	ra,28(sp)
   199e8:	01812403          	lw	s0,24(sp)
   199ec:	01412483          	lw	s1,20(sp)
   199f0:	02010113          	addi	sp,sp,32
{
  wint_t r;

  _newlib_flockfile_start (fp);
  ORIENT(fp, 1);
  r = __fputwc(ptr, wc, fp);
   199f4:	e15ff06f          	j	19808 <__fputwc>
	wchar_t wc _AND
	FILE *fp)
{
  struct _reent *reent = _REENT;

  CHECK_INIT(reent, fp);
   199f8:	00040513          	mv	a0,s0
   199fc:	00b12623          	sw	a1,12(sp)
   19a00:	cb0fc0ef          	jal	15eb0 <__sinit>
   19a04:	00c12603          	lw	a2,12(sp)
   19a08:	fb1ff06f          	j	199b8 <fputwc+0x28>

00019a0c <__sfvwrite_r>:
  register struct __siov *iov;
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
   19a0c:	00862783          	lw	a5,8(a2)
   19a10:	1a078e63          	beqz	a5,19bcc <__sfvwrite_r+0x1c0>
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   19a14:	00c5d703          	lhu	a4,12(a1)
int
_DEFUN(__sfvwrite_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       register FILE *fp _AND
       register struct __suio *uio)
{
   19a18:	fd010113          	addi	sp,sp,-48
   19a1c:	02812423          	sw	s0,40(sp)

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   19a20:	00877793          	andi	a5,a4,8
int
_DEFUN(__sfvwrite_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       register FILE *fp _AND
       register struct __suio *uio)
{
   19a24:	01412c23          	sw	s4,24(sp)
   19a28:	01512a23          	sw	s5,20(sp)
   19a2c:	02112623          	sw	ra,44(sp)
   19a30:	02912223          	sw	s1,36(sp)
   19a34:	03212023          	sw	s2,32(sp)
   19a38:	01312e23          	sw	s3,28(sp)
   19a3c:	01612823          	sw	s6,16(sp)
   19a40:	01712623          	sw	s7,12(sp)
   19a44:	01812423          	sw	s8,8(sp)
   19a48:	01912223          	sw	s9,4(sp)
   19a4c:	01a12023          	sw	s10,0(sp)
   19a50:	00058413          	mv	s0,a1
   19a54:	00050a93          	mv	s5,a0
   19a58:	00060a13          	mv	s4,a2

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   19a5c:	0a078463          	beqz	a5,19b04 <__sfvwrite_r+0xf8>
   19a60:	0105a783          	lw	a5,16(a1)
   19a64:	0a078063          	beqz	a5,19b04 <__sfvwrite_r+0xf8>
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   19a68:	00277793          	andi	a5,a4,2

  /* make sure we can write */
  if (cantwrite (ptr, fp))
    return EOF;

  iov = uio->uio_iov;
   19a6c:	000a2483          	lw	s1,0(s4)
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   19a70:	0a078c63          	beqz	a5,19b28 <__sfvwrite_r+0x11c>
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
   19a74:	80000b37          	lui	s6,0x80000
   19a78:	00000993          	li	s3,0
   19a7c:	00000913          	li	s2,0
   19a80:	c00b4b13          	xori	s6,s6,-1024
   19a84:	00098613          	mv	a2,s3
   19a88:	000a8513          	mv	a0,s5
       * Unbuffered: Split buffer in the largest multiple of BUFSIZ < INT_MAX
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
   19a8c:	12090863          	beqz	s2,19bbc <__sfvwrite_r+0x1b0>
	  w = fp->_write (ptr, fp->_cookie, p,
   19a90:	00090693          	mv	a3,s2
   19a94:	012b7463          	bleu	s2,s6,19a9c <__sfvwrite_r+0x90>
   19a98:	000b0693          	mv	a3,s6
   19a9c:	02442783          	lw	a5,36(s0)
   19aa0:	01c42583          	lw	a1,28(s0)
   19aa4:	000780e7          	jalr	a5
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
	  if (w <= 0)
   19aa8:	16a05863          	blez	a0,19c18 <__sfvwrite_r+0x20c>
	    goto err;
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
   19aac:	008a2783          	lw	a5,8(s4)
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
	  if (w <= 0)
	    goto err;
	  p += w;
   19ab0:	00a989b3          	add	s3,s3,a0
	  len -= w;
   19ab4:	40a90933          	sub	s2,s2,a0
	}
      while ((uio->uio_resid -= w) != 0);
   19ab8:	40a78533          	sub	a0,a5,a0
   19abc:	00aa2423          	sw	a0,8(s4)
   19ac0:	fc0512e3          	bnez	a0,19a84 <__sfvwrite_r+0x78>
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
    return 0;
   19ac4:	00000793          	li	a5,0
  return 0;

err:
  fp->_flags |= __SERR;
  return EOF;
}
   19ac8:	02c12083          	lw	ra,44(sp)
   19acc:	00078513          	mv	a0,a5
   19ad0:	02812403          	lw	s0,40(sp)
   19ad4:	02412483          	lw	s1,36(sp)
   19ad8:	02012903          	lw	s2,32(sp)
   19adc:	01c12983          	lw	s3,28(sp)
   19ae0:	01812a03          	lw	s4,24(sp)
   19ae4:	01412a83          	lw	s5,20(sp)
   19ae8:	01012b03          	lw	s6,16(sp)
   19aec:	00c12b83          	lw	s7,12(sp)
   19af0:	00812c03          	lw	s8,8(sp)
   19af4:	00412c83          	lw	s9,4(sp)
   19af8:	00012d03          	lw	s10,0(sp)
   19afc:	03010113          	addi	sp,sp,48
   19b00:	00008067          	ret

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   19b04:	00040593          	mv	a1,s0
   19b08:	000a8513          	mv	a0,s5
   19b0c:	c1cfa0ef          	jal	13f28 <__swsetup_r>
    return EOF;
   19b10:	fff00793          	li	a5,-1

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   19b14:	fa051ae3          	bnez	a0,19ac8 <__sfvwrite_r+0xbc>
   19b18:	00c45703          	lhu	a4,12(s0)
    return EOF;

  iov = uio->uio_iov;
   19b1c:	000a2483          	lw	s1,0(s4)
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   19b20:	00277793          	andi	a5,a4,2
   19b24:	f40798e3          	bnez	a5,19a74 <__sfvwrite_r+0x68>
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
    }
  else if ((fp->_flags & __SLBF) == 0)
   19b28:	00177793          	andi	a5,a4,1
   19b2c:	10079063          	bnez	a5,19c2c <__sfvwrite_r+0x220>
		goto err;
	    }
	  else
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
   19b30:	80000b37          	lui	s6,0x80000
   19b34:	00000b93          	li	s7,0
   19b38:	00000913          	li	s2,0
   19b3c:	fffb4b13          	not	s6,s6
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
   19b40:	06090663          	beqz	s2,19bac <__sfvwrite_r+0x1a0>
	  w = fp->_w;
	  if (fp->_flags & __SSTR)
   19b44:	20077793          	andi	a5,a4,512
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
	  w = fp->_w;
   19b48:	00842983          	lw	s3,8(s0)
	  if (fp->_flags & __SSTR)
   19b4c:	08078663          	beqz	a5,19bd8 <__sfvwrite_r+0x1cc>
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
   19b50:	23396e63          	bltu	s2,s3,19d8c <__sfvwrite_r+0x380>
   19b54:	48077793          	andi	a5,a4,1152
   19b58:	26079463          	bnez	a5,19dc0 <__sfvwrite_r+0x3b4>
   19b5c:	00042503          	lw	a0,0(s0)
   19b60:	00098c13          	mv	s8,s3
		  w = len;
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
	      COPY (w);		/* copy MIN(fp->_w,len), */
   19b64:	000c0613          	mv	a2,s8
   19b68:	000b8593          	mv	a1,s7
   19b6c:	338000ef          	jal	19ea4 <memmove>
	      fp->_w -= w;
   19b70:	00842783          	lw	a5,8(s0)
	      fp->_p += w;
   19b74:	00042603          	lw	a2,0(s0)
   19b78:	00090513          	mv	a0,s2
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
	      COPY (w);		/* copy MIN(fp->_w,len), */
	      fp->_w -= w;
   19b7c:	413789b3          	sub	s3,a5,s3
	      fp->_p += w;
   19b80:	01860633          	add	a2,a2,s8
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
	      COPY (w);		/* copy MIN(fp->_w,len), */
	      fp->_w -= w;
   19b84:	01342423          	sw	s3,8(s0)
	      fp->_p += w;
   19b88:	00c42023          	sw	a2,0(s0)
		goto err;
	    }
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
   19b8c:	008a2783          	lw	a5,8(s4)
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
	      w = fp->_write (ptr, fp->_cookie, p, w);
	      if (w <= 0)
		goto err;
	    }
	  p += w;
   19b90:	00ab8bb3          	add	s7,s7,a0
	  len -= w;
   19b94:	40a90933          	sub	s2,s2,a0
	}
      while ((uio->uio_resid -= w) != 0);
   19b98:	40a789b3          	sub	s3,a5,a0
   19b9c:	013a2423          	sw	s3,8(s4)
   19ba0:	f20982e3          	beqz	s3,19ac4 <__sfvwrite_r+0xb8>
   19ba4:	00c45703          	lhu	a4,12(s0)
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
   19ba8:	f8091ee3          	bnez	s2,19b44 <__sfvwrite_r+0x138>
   19bac:	0004ab83          	lw	s7,0(s1)
   19bb0:	0044a903          	lw	s2,4(s1)
   19bb4:	00848493          	addi	s1,s1,8
   19bb8:	f89ff06f          	j	19b40 <__sfvwrite_r+0x134>
       * Unbuffered: Split buffer in the largest multiple of BUFSIZ < INT_MAX
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
   19bbc:	0004a983          	lw	s3,0(s1)
   19bc0:	0044a903          	lw	s2,4(s1)
   19bc4:	00848493          	addi	s1,s1,8
   19bc8:	ebdff06f          	j	19a84 <__sfvwrite_r+0x78>
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
    return 0;
   19bcc:	00000793          	li	a5,0
  return 0;

err:
  fp->_flags |= __SERR;
  return EOF;
}
   19bd0:	00078513          	mv	a0,a5
   19bd4:	00008067          	ret
	      COPY (w);		/* copy MIN(fp->_w,len), */
	      fp->_w -= w;
	      fp->_p += w;
	      w = len;		/* but pretend copied all */
	    }
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
   19bd8:	00042503          	lw	a0,0(s0)
   19bdc:	01042783          	lw	a5,16(s0)
   19be0:	12a7ea63          	bltu	a5,a0,19d14 <__sfvwrite_r+0x308>
   19be4:	01442783          	lw	a5,20(s0)
   19be8:	12f96663          	bltu	s2,a5,19d14 <__sfvwrite_r+0x308>
		goto err;
	    }
	  else
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
   19bec:	00090693          	mv	a3,s2
   19bf0:	012b7463          	bleu	s2,s6,19bf8 <__sfvwrite_r+0x1ec>
   19bf4:	000b0693          	mv	a3,s6
   19bf8:	02f6c6b3          	div	a3,a3,a5
	      w = fp->_write (ptr, fp->_cookie, p, w);
   19bfc:	02442703          	lw	a4,36(s0)
   19c00:	01c42583          	lw	a1,28(s0)
   19c04:	000b8613          	mv	a2,s7
   19c08:	000a8513          	mv	a0,s5
   19c0c:	02f686b3          	mul	a3,a3,a5
   19c10:	000700e7          	jalr	a4
	      if (w <= 0)
   19c14:	f6a04ce3          	bgtz	a0,19b8c <__sfvwrite_r+0x180>
   19c18:	00c41783          	lh	a5,12(s0)
      while ((uio->uio_resid -= w) != 0);
    }
  return 0;

err:
  fp->_flags |= __SERR;
   19c1c:	0407e793          	ori	a5,a5,64
   19c20:	00f41623          	sh	a5,12(s0)
  return EOF;
   19c24:	fff00793          	li	a5,-1
   19c28:	ea1ff06f          	j	19ac8 <__sfvwrite_r+0xbc>
   19c2c:	00000993          	li	s3,0
   19c30:	00000c13          	li	s8,0
   19c34:	00000d13          	li	s10,0
   19c38:	00000913          	li	s2,0
       */
      nlknown = 0;
      nldist = 0;
      do
	{
	  GETIOV (nlknown = 0);
   19c3c:	06090c63          	beqz	s2,19cb4 <__sfvwrite_r+0x2a8>
	  if (!nlknown)
   19c40:	140c0e63          	beqz	s8,19d9c <__sfvwrite_r+0x390>
	    {
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
	      nlknown = 1;
	    }
	  s = MIN (len, nldist);
   19c44:	00098b93          	mv	s7,s3
   19c48:	01397463          	bleu	s3,s2,19c50 <__sfvwrite_r+0x244>
   19c4c:	00090b93          	mv	s7,s2
	  w = fp->_w + fp->_bf._size;
	  if (fp->_p > fp->_bf._base && s > w)
   19c50:	00042503          	lw	a0,0(s0)
   19c54:	01042783          	lw	a5,16(s0)
	    {
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
	      nlknown = 1;
	    }
	  s = MIN (len, nldist);
   19c58:	000b8b13          	mv	s6,s7
	  w = fp->_w + fp->_bf._size;
   19c5c:	01442683          	lw	a3,20(s0)
	  if (fp->_p > fp->_bf._base && s > w)
   19c60:	00a7f863          	bleu	a0,a5,19c70 <__sfvwrite_r+0x264>
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
	      nlknown = 1;
	    }
	  s = MIN (len, nldist);
	  w = fp->_w + fp->_bf._size;
   19c64:	00842c83          	lw	s9,8(s0)
   19c68:	01968cb3          	add	s9,a3,s9
	  if (fp->_p > fp->_bf._base && s > w)
   19c6c:	057cce63          	blt	s9,s7,19cc8 <__sfvwrite_r+0x2bc>
	      /* fp->_w -= w; */
	      fp->_p += w;
	      if (_fflush_r (ptr, fp))
		goto err;
	    }
	  else if (s >= (w = fp->_bf._size))
   19c70:	0edbca63          	blt	s7,a3,19d64 <__sfvwrite_r+0x358>
	    {
	      w = fp->_write (ptr, fp->_cookie, p, w);
   19c74:	02442783          	lw	a5,36(s0)
   19c78:	01c42583          	lw	a1,28(s0)
   19c7c:	000d0613          	mv	a2,s10
   19c80:	000a8513          	mv	a0,s5
   19c84:	000780e7          	jalr	a5
   19c88:	00050b13          	mv	s6,a0
	      if (w <= 0)
   19c8c:	f8a056e3          	blez	a0,19c18 <__sfvwrite_r+0x20c>
	      w = s;
	      COPY (w);
	      fp->_w -= w;
	      fp->_p += w;
	    }
	  if ((nldist -= w) == 0)
   19c90:	416989b3          	sub	s3,s3,s6
   19c94:	06098463          	beqz	s3,19cfc <__sfvwrite_r+0x2f0>
	      nlknown = 0;
	    }
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
   19c98:	008a2783          	lw	a5,8(s4)
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
		goto err;
	      nlknown = 0;
	    }
	  p += w;
   19c9c:	016d0d33          	add	s10,s10,s6
	  len -= w;
   19ca0:	41690933          	sub	s2,s2,s6
	}
      while ((uio->uio_resid -= w) != 0);
   19ca4:	41678b33          	sub	s6,a5,s6
   19ca8:	016a2423          	sw	s6,8(s4)
   19cac:	e00b0ce3          	beqz	s6,19ac4 <__sfvwrite_r+0xb8>
       */
      nlknown = 0;
      nldist = 0;
      do
	{
	  GETIOV (nlknown = 0);
   19cb0:	f80918e3          	bnez	s2,19c40 <__sfvwrite_r+0x234>
   19cb4:	0004ad03          	lw	s10,0(s1)
   19cb8:	0044a903          	lw	s2,4(s1)
   19cbc:	00000c13          	li	s8,0
   19cc0:	00848493          	addi	s1,s1,8
   19cc4:	f79ff06f          	j	19c3c <__sfvwrite_r+0x230>
	    }
	  s = MIN (len, nldist);
	  w = fp->_w + fp->_bf._size;
	  if (fp->_p > fp->_bf._base && s > w)
	    {
	      COPY (w);
   19cc8:	000d0593          	mv	a1,s10
   19ccc:	000c8613          	mv	a2,s9
   19cd0:	1d4000ef          	jal	19ea4 <memmove>
	      /* fp->_w -= w; */
	      fp->_p += w;
   19cd4:	00042783          	lw	a5,0(s0)
	      if (_fflush_r (ptr, fp))
   19cd8:	00040593          	mv	a1,s0
   19cdc:	000a8513          	mv	a0,s5
	  w = fp->_w + fp->_bf._size;
	  if (fp->_p > fp->_bf._base && s > w)
	    {
	      COPY (w);
	      /* fp->_w -= w; */
	      fp->_p += w;
   19ce0:	019787b3          	add	a5,a5,s9
   19ce4:	00f42023          	sw	a5,0(s0)
	      if (_fflush_r (ptr, fp))
   19ce8:	e19fb0ef          	jal	15b00 <_fflush_r>
   19cec:	f20516e3          	bnez	a0,19c18 <__sfvwrite_r+0x20c>
   19cf0:	000c8b13          	mv	s6,s9
	      w = s;
	      COPY (w);
	      fp->_w -= w;
	      fp->_p += w;
	    }
	  if ((nldist -= w) == 0)
   19cf4:	416989b3          	sub	s3,s3,s6
   19cf8:	fa0990e3          	bnez	s3,19c98 <__sfvwrite_r+0x28c>
	    {
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
   19cfc:	00040593          	mv	a1,s0
   19d00:	000a8513          	mv	a0,s5
   19d04:	dfdfb0ef          	jal	15b00 <_fflush_r>
   19d08:	f00518e3          	bnez	a0,19c18 <__sfvwrite_r+0x20c>
		goto err;
	      nlknown = 0;
   19d0c:	00000c13          	li	s8,0
   19d10:	f89ff06f          	j	19c98 <__sfvwrite_r+0x28c>
	      w = len;		/* but pretend copied all */
	    }
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
   19d14:	01397463          	bleu	s3,s2,19d1c <__sfvwrite_r+0x310>
   19d18:	00090993          	mv	s3,s2
	      COPY (w);
   19d1c:	00098613          	mv	a2,s3
   19d20:	000b8593          	mv	a1,s7
   19d24:	180000ef          	jal	19ea4 <memmove>
	      fp->_w -= w;
   19d28:	00842783          	lw	a5,8(s0)
	      fp->_p += w;
   19d2c:	00042703          	lw	a4,0(s0)
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
	      COPY (w);
	      fp->_w -= w;
   19d30:	413787b3          	sub	a5,a5,s3
	      fp->_p += w;
   19d34:	01370733          	add	a4,a4,s3
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
	      COPY (w);
	      fp->_w -= w;
   19d38:	00f42423          	sw	a5,8(s0)
	      fp->_p += w;
   19d3c:	00e42023          	sw	a4,0(s0)
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
   19d40:	00078663          	beqz	a5,19d4c <__sfvwrite_r+0x340>
   19d44:	00098513          	mv	a0,s3
   19d48:	e45ff06f          	j	19b8c <__sfvwrite_r+0x180>
   19d4c:	00040593          	mv	a1,s0
   19d50:	000a8513          	mv	a0,s5
   19d54:	dadfb0ef          	jal	15b00 <_fflush_r>
   19d58:	ec0510e3          	bnez	a0,19c18 <__sfvwrite_r+0x20c>
   19d5c:	00098513          	mv	a0,s3
   19d60:	e2dff06f          	j	19b8c <__sfvwrite_r+0x180>
		goto err;
	    }
	  else
	    {
	      w = s;
	      COPY (w);
   19d64:	000b8613          	mv	a2,s7
   19d68:	000d0593          	mv	a1,s10
   19d6c:	138000ef          	jal	19ea4 <memmove>
	      fp->_w -= w;
   19d70:	00842703          	lw	a4,8(s0)
	      fp->_p += w;
   19d74:	00042783          	lw	a5,0(s0)
	    }
	  else
	    {
	      w = s;
	      COPY (w);
	      fp->_w -= w;
   19d78:	41770733          	sub	a4,a4,s7
	      fp->_p += w;
   19d7c:	01778bb3          	add	s7,a5,s7
	    }
	  else
	    {
	      w = s;
	      COPY (w);
	      fp->_w -= w;
   19d80:	00e42423          	sw	a4,8(s0)
	      fp->_p += w;
   19d84:	01742023          	sw	s7,0(s0)
   19d88:	f09ff06f          	j	19c90 <__sfvwrite_r+0x284>
   19d8c:	00042503          	lw	a0,0(s0)
		  fp->_bf._size = newsize;
		  w = len;
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
   19d90:	00090993          	mv	s3,s2
   19d94:	00090c13          	mv	s8,s2
   19d98:	dcdff06f          	j	19b64 <__sfvwrite_r+0x158>
      do
	{
	  GETIOV (nlknown = 0);
	  if (!nlknown)
	    {
	      nl = memchr ((_PTR) p, '\n', len);
   19d9c:	00090613          	mv	a2,s2
   19da0:	00a00593          	li	a1,10
   19da4:	000d0513          	mv	a0,s10
   19da8:	864fd0ef          	jal	16e0c <memchr>
	      nldist = nl ? nl + 1 - p : len + 1;
   19dac:	0c050e63          	beqz	a0,19e88 <__sfvwrite_r+0x47c>
   19db0:	00150513          	addi	a0,a0,1
   19db4:	41a509b3          	sub	s3,a0,s10
	      nlknown = 1;
   19db8:	00100c13          	li	s8,1
   19dbc:	e89ff06f          	j	19c44 <__sfvwrite_r+0x238>
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   19dc0:	01442983          	lw	s3,20(s0)
	  if (fp->_flags & __SSTR)
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
   19dc4:	01042583          	lw	a1,16(s0)
   19dc8:	00042c03          	lw	s8,0(s0)
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   19dcc:	00199793          	slli	a5,s3,0x1
   19dd0:	013789b3          	add	s3,a5,s3
   19dd4:	01f9d793          	srli	a5,s3,0x1f
	  if (fp->_flags & __SSTR)
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
   19dd8:	40bc0c33          	sub	s8,s8,a1
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   19ddc:	013789b3          	add	s3,a5,s3
		  if (newsize < curpos + len + 1)
   19de0:	001c0793          	addi	a5,s8,1
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   19de4:	4019d993          	srai	s3,s3,0x1
		  if (newsize < curpos + len + 1)
   19de8:	012787b3          	add	a5,a5,s2
   19dec:	00098613          	mv	a2,s3
   19df0:	00f9f663          	bleu	a5,s3,19dfc <__sfvwrite_r+0x3f0>
		    newsize = curpos + len + 1;
   19df4:	00078993          	mv	s3,a5
   19df8:	00078613          	mv	a2,a5
		  if (fp->_flags & __SOPT)
   19dfc:	40077713          	andi	a4,a4,1024
   19e00:	04070c63          	beqz	a4,19e58 <__sfvwrite_r+0x44c>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
   19e04:	00060593          	mv	a1,a2
   19e08:	000a8513          	mv	a0,s5
   19e0c:	889fc0ef          	jal	16694 <_malloc_r>
   19e10:	00050c93          	mv	s9,a0
		      if (!str)
   19e14:	08050063          	beqz	a0,19e94 <__sfvwrite_r+0x488>
			{
			  ptr->_errno = ENOMEM;
			  goto err;
			}
		      memcpy (str, fp->_bf._base, curpos);
   19e18:	01042583          	lw	a1,16(s0)
   19e1c:	000c0613          	mv	a2,s8
   19e20:	8c0fd0ef          	jal	16ee0 <memcpy>
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
   19e24:	00c45783          	lhu	a5,12(s0)
   19e28:	b7f7f793          	andi	a5,a5,-1153
   19e2c:	0807e793          	ori	a5,a5,128
   19e30:	00f41623          	sh	a5,12(s0)
			  ptr->_errno = ENOMEM;
			  goto err;
			}
		    }
		  fp->_bf._base = str;
		  fp->_p = str + curpos;
   19e34:	018c8533          	add	a0,s9,s8
		  fp->_bf._size = newsize;
		  w = len;
		  fp->_w = newsize - curpos;
   19e38:	41898c33          	sub	s8,s3,s8
			  goto err;
			}
		    }
		  fp->_bf._base = str;
		  fp->_p = str + curpos;
		  fp->_bf._size = newsize;
   19e3c:	01342a23          	sw	s3,20(s0)
		  w = len;
		  fp->_w = newsize - curpos;
   19e40:	01842423          	sw	s8,8(s0)
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
			  goto err;
			}
		    }
		  fp->_bf._base = str;
   19e44:	01942823          	sw	s9,16(s0)
		  fp->_p = str + curpos;
   19e48:	00a42023          	sw	a0,0(s0)
		  fp->_bf._size = newsize;
		  w = len;
   19e4c:	00090993          	mv	s3,s2
   19e50:	00090c13          	mv	s8,s2
   19e54:	d11ff06f          	j	19b64 <__sfvwrite_r+0x158>
		      memcpy (str, fp->_bf._base, curpos);
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
		    }
		  else
		    {
		      str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
   19e58:	000a8513          	mv	a0,s5
   19e5c:	168000ef          	jal	19fc4 <_realloc_r>
   19e60:	00050c93          	mv	s9,a0
							 newsize);
		      if (!str)
   19e64:	fc0518e3          	bnez	a0,19e34 <__sfvwrite_r+0x428>
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
   19e68:	01042583          	lw	a1,16(s0)
   19e6c:	000a8513          	mv	a0,s5
   19e70:	980fc0ef          	jal	15ff0 <_free_r>
			  fp->_flags &=  ~__SMBF;
   19e74:	00c41783          	lh	a5,12(s0)
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
   19e78:	00c00713          	li	a4,12
   19e7c:	00eaa023          	sw	a4,0(s5)
		      if (!str)
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
			  fp->_flags &=  ~__SMBF;
   19e80:	f7f7f793          	andi	a5,a5,-129
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
			  goto err;
   19e84:	d99ff06f          	j	19c1c <__sfvwrite_r+0x210>
	{
	  GETIOV (nlknown = 0);
	  if (!nlknown)
	    {
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
   19e88:	00190993          	addi	s3,s2,1
	      nlknown = 1;
   19e8c:	00100c13          	li	s8,1
   19e90:	db5ff06f          	j	19c44 <__sfvwrite_r+0x238>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
		      if (!str)
			{
			  ptr->_errno = ENOMEM;
   19e94:	00c00793          	li	a5,12
   19e98:	00faa023          	sw	a5,0(s5)
   19e9c:	00c41783          	lh	a5,12(s0)
			  goto err;
   19ea0:	d7dff06f          	j	19c1c <__sfvwrite_r+0x210>

00019ea4 <memmove>:
  char *dst = dst_void;
  _CONST char *src = src_void;
  long *aligned_dst;
  _CONST long *aligned_src;

  if (src < dst && dst < src + length)
   19ea4:	02a5f863          	bleu	a0,a1,19ed4 <memmove+0x30>
   19ea8:	00c58733          	add	a4,a1,a2
   19eac:	02e57463          	bleu	a4,a0,19ed4 <memmove+0x30>
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
      dst += length;
   19eb0:	00c507b3          	add	a5,a0,a2
   19eb4:	40c785b3          	sub	a1,a5,a2
      while (length--)
   19eb8:	0e060263          	beqz	a2,19f9c <memmove+0xf8>
	{
	  *--dst = *--src;
   19ebc:	fff70713          	addi	a4,a4,-1 # 1fff <_reset+0x1dff>
   19ec0:	00074683          	lbu	a3,0(a4)
   19ec4:	fff78793          	addi	a5,a5,-1
   19ec8:	00d78023          	sb	a3,0(a5)
  if (src < dst && dst < src + length)
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
      dst += length;
      while (length--)
   19ecc:	fef598e3          	bne	a1,a5,19ebc <memmove+0x18>
   19ed0:	00008067          	ret
  else
    {
      /* Use optimizing algorithm for a non-destructive copy to closely 
         match memcpy. If the size is small or either SRC or DST is unaligned,
         then punt into the byte copy loop.  This should be rare.  */
      if (!TOO_SMALL(length) && !UNALIGNED (src, dst))
   19ed4:	00f00893          	li	a7,15
   19ed8:	0cc8f463          	bleu	a2,a7,19fa0 <memmove+0xfc>
   19edc:	00a5e7b3          	or	a5,a1,a0
   19ee0:	0037f793          	andi	a5,a5,3
   19ee4:	0c079463          	bnez	a5,19fac <memmove+0x108>
   19ee8:	00058713          	mv	a4,a1
   19eec:	00050793          	mv	a5,a0
   19ef0:	00060693          	mv	a3,a2
          aligned_src = (long*)src;

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
            {
              *aligned_dst++ = *aligned_src++;
   19ef4:	00072803          	lw	a6,0(a4)
   19ef8:	01078793          	addi	a5,a5,16
   19efc:	01070713          	addi	a4,a4,16
   19f00:	ff07a823          	sw	a6,-16(a5)
              *aligned_dst++ = *aligned_src++;
   19f04:	ff472803          	lw	a6,-12(a4)
              *aligned_dst++ = *aligned_src++;
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
   19f08:	ff068693          	addi	a3,a3,-16

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
            {
              *aligned_dst++ = *aligned_src++;
              *aligned_dst++ = *aligned_src++;
   19f0c:	ff07aa23          	sw	a6,-12(a5)
              *aligned_dst++ = *aligned_src++;
   19f10:	ff872803          	lw	a6,-8(a4)
   19f14:	ff07ac23          	sw	a6,-8(a5)
              *aligned_dst++ = *aligned_src++;
   19f18:	ffc72803          	lw	a6,-4(a4)
   19f1c:	ff07ae23          	sw	a6,-4(a5)
        {
          aligned_dst = (long*)dst;
          aligned_src = (long*)src;

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
   19f20:	fcd8eae3          	bltu	a7,a3,19ef4 <memmove+0x50>
   19f24:	ff060713          	addi	a4,a2,-16
   19f28:	ff077713          	andi	a4,a4,-16
   19f2c:	01070713          	addi	a4,a4,16
   19f30:	00f67313          	andi	t1,a2,15
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   19f34:	00300293          	li	t0,3
   19f38:	00e507b3          	add	a5,a0,a4
   19f3c:	00e585b3          	add	a1,a1,a4
   19f40:	0662fc63          	bleu	t1,t0,19fb8 <memmove+0x114>
   19f44:	00058813          	mv	a6,a1
   19f48:	00078693          	mv	a3,a5
   19f4c:	00030713          	mv	a4,t1
            {
              *aligned_dst++ = *aligned_src++;
   19f50:	00480813          	addi	a6,a6,4
   19f54:	ffc82883          	lw	a7,-4(a6)
   19f58:	00468693          	addi	a3,a3,4
              length -= LITTLEBLOCKSIZE;
   19f5c:	ffc70713          	addi	a4,a4,-4
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
            {
              *aligned_dst++ = *aligned_src++;
   19f60:	ff16ae23          	sw	a7,-4(a3)
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   19f64:	fee2e6e3          	bltu	t0,a4,19f50 <memmove+0xac>
   19f68:	ffc30713          	addi	a4,t1,-4
   19f6c:	ffc77713          	andi	a4,a4,-4
   19f70:	00470713          	addi	a4,a4,4
   19f74:	00367613          	andi	a2,a2,3
   19f78:	00e787b3          	add	a5,a5,a4
   19f7c:	00e585b3          	add	a1,a1,a4
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   19f80:	02060a63          	beqz	a2,19fb4 <memmove+0x110>
   19f84:	00c78633          	add	a2,a5,a2
        {
          *dst++ = *src++;
   19f88:	00158593          	addi	a1,a1,1
   19f8c:	fff5c703          	lbu	a4,-1(a1)
   19f90:	00178793          	addi	a5,a5,1
   19f94:	fee78fa3          	sb	a4,-1(a5)
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   19f98:	fec798e3          	bne	a5,a2,19f88 <memmove+0xe4>
        }
    }

  return dst_void;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   19f9c:	00008067          	ret
   19fa0:	00050793          	mv	a5,a0
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   19fa4:	fe0610e3          	bnez	a2,19f84 <memmove+0xe0>
   19fa8:	00c0006f          	j	19fb4 <memmove+0x110>
   19fac:	00050793          	mv	a5,a0
   19fb0:	fd5ff06f          	j	19f84 <memmove+0xe0>
   19fb4:	00008067          	ret
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   19fb8:	00030613          	mv	a2,t1
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   19fbc:	fc0614e3          	bnez	a2,19f84 <memmove+0xe0>
   19fc0:	ff5ff06f          	j	19fb4 <memmove+0x110>

00019fc4 <_realloc_r>:
#if __STD_C
Void_t* rEALLOc(RARG Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(RARG oldmem, bytes) RDECL Void_t* oldmem; size_t bytes;
#endif
{
   19fc4:	fd010113          	addi	sp,sp,-48
   19fc8:	01312e23          	sw	s3,28(sp)
   19fcc:	02112623          	sw	ra,44(sp)
   19fd0:	02812423          	sw	s0,40(sp)
   19fd4:	02912223          	sw	s1,36(sp)
   19fd8:	03212023          	sw	s2,32(sp)
   19fdc:	01412c23          	sw	s4,24(sp)
   19fe0:	01512a23          	sw	s5,20(sp)
   19fe4:	01612823          	sw	s6,16(sp)
   19fe8:	01712623          	sw	s7,12(sp)
   19fec:	01812423          	sw	s8,8(sp)
   19ff0:	01912223          	sw	s9,4(sp)
   19ff4:	00060993          	mv	s3,a2
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
   19ff8:	1c058863          	beqz	a1,1a1c8 <_realloc_r+0x204>
   19ffc:	00058a13          	mv	s4,a1
   1a000:	00050493          	mv	s1,a0

  MALLOC_LOCK;
   1a004:	8d8fd0ef          	jal	170dc <__malloc_lock>

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
   1a008:	ffca2783          	lw	a5,-4(s4)


  nb = request2size(bytes);
   1a00c:	00b98713          	addi	a4,s3,11
   1a010:	01600693          	li	a3,22
  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);

  MALLOC_LOCK;

  newp    = oldp    = mem2chunk(oldmem);
   1a014:	ff8a0b13          	addi	s6,s4,-8
  newsize = oldsize = chunksize(oldp);
   1a018:	ffc7fa93          	andi	s5,a5,-4


  nb = request2size(bytes);
   1a01c:	0ce6f263          	bleu	a4,a3,1a0e0 <_realloc_r+0x11c>
   1a020:	ff877913          	andi	s2,a4,-8

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   1a024:	00090713          	mv	a4,s2
   1a028:	14094c63          	bltz	s2,1a180 <_realloc_r+0x1bc>
   1a02c:	15396a63          	bltu	s2,s3,1a180 <_realloc_r+0x1bc>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
   1a030:	0aeade63          	ble	a4,s5,1a0ec <_realloc_r+0x128>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next)) 
   1a034:	00048c37          	lui	s8,0x48
   1a038:	bd8c0c13          	addi	s8,s8,-1064 # 47bd8 <__malloc_av_>
   1a03c:	008c2683          	lw	a3,8(s8)
  if ((long)(oldsize) < (long)(nb))  
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
   1a040:	015b0533          	add	a0,s6,s5
    if (next == top || !inuse(next)) 
   1a044:	30d50263          	beq	a0,a3,1a348 <_realloc_r+0x384>
   1a048:	00452683          	lw	a3,4(a0)
   1a04c:	ffe6f613          	andi	a2,a3,-2
   1a050:	00c50633          	add	a2,a0,a2
   1a054:	00462603          	lw	a2,4(a2)
   1a058:	00167613          	andi	a2,a2,1
   1a05c:	0e060e63          	beqz	a2,1a158 <_realloc_r+0x194>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   1a060:	0017f793          	andi	a5,a5,1
   1a064:	26078463          	beqz	a5,1a2cc <_realloc_r+0x308>
      }
    }

    /* Must allocate */

    newmem = mALLOc (RCALL bytes);
   1a068:	00098593          	mv	a1,s3
   1a06c:	00048513          	mv	a0,s1
   1a070:	e24fc0ef          	jal	16694 <_malloc_r>
   1a074:	00050413          	mv	s0,a0

    if (newmem == 0)  /* propagate failure */
   1a078:	4a050463          	beqz	a0,1a520 <_realloc_r+0x55c>
    }

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
   1a07c:	ffca2783          	lw	a5,-4(s4)
   1a080:	ff850693          	addi	a3,a0,-8
   1a084:	ffe7f713          	andi	a4,a5,-2
   1a088:	00eb0733          	add	a4,s6,a4
   1a08c:	42e68463          	beq	a3,a4,1a4b4 <_realloc_r+0x4f0>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1a090:	ffca8613          	addi	a2,s5,-4
   1a094:	02400793          	li	a5,36
   1a098:	3cc7ea63          	bltu	a5,a2,1a46c <_realloc_r+0x4a8>
   1a09c:	01300713          	li	a4,19
   1a0a0:	36c76a63          	bltu	a4,a2,1a414 <_realloc_r+0x450>
   1a0a4:	00050793          	mv	a5,a0
   1a0a8:	000a0713          	mv	a4,s4
   1a0ac:	00072683          	lw	a3,0(a4)
   1a0b0:	00d7a023          	sw	a3,0(a5)
   1a0b4:	00472683          	lw	a3,4(a4)
   1a0b8:	00d7a223          	sw	a3,4(a5)
   1a0bc:	00872703          	lw	a4,8(a4)
   1a0c0:	00e7a423          	sw	a4,8(a5)
    fREe(RCALL oldmem);
   1a0c4:	000a0593          	mv	a1,s4
   1a0c8:	00048513          	mv	a0,s1
   1a0cc:	f25fb0ef          	jal	15ff0 <_free_r>
    MALLOC_UNLOCK;
   1a0d0:	00048513          	mv	a0,s1
   1a0d4:	80cfd0ef          	jal	170e0 <__malloc_unlock>
    return newmem;
   1a0d8:	00040513          	mv	a0,s0
   1a0dc:	0480006f          	j	1a124 <_realloc_r+0x160>


  nb = request2size(bytes);

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   1a0e0:	01000713          	li	a4,16

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);


  nb = request2size(bytes);
   1a0e4:	00070913          	mv	s2,a4
   1a0e8:	f45ff06f          	j	1a02c <_realloc_r+0x68>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
   1a0ec:	000a0993          	mv	s3,s4
  }


 split:  /* split off extra room in old or expanded chunk */

  remainder_size = long_sub_size_t(newsize, nb);
   1a0f0:	412a86b3          	sub	a3,s5,s2

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
   1a0f4:	00f00713          	li	a4,15
   1a0f8:	08d76c63          	bltu	a4,a3,1a190 <_realloc_r+0x1cc>
    set_inuse_bit_at_offset(remainder, remainder_size);
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
  }
  else
  {
    set_head_size(newp, newsize);
   1a0fc:	0017f793          	andi	a5,a5,1
   1a100:	0157e7b3          	or	a5,a5,s5
   1a104:	00fb2223          	sw	a5,4(s6) # 80000004 <_gp+0x7ffb7824>
    set_inuse_bit_at_offset(newp, newsize);
   1a108:	015b0633          	add	a2,s6,s5
   1a10c:	00462783          	lw	a5,4(a2)
   1a110:	0017e793          	ori	a5,a5,1
   1a114:	00f62223          	sw	a5,4(a2)
  }

  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
   1a118:	00048513          	mv	a0,s1
   1a11c:	fc5fc0ef          	jal	170e0 <__malloc_unlock>
  return chunk2mem(newp);
   1a120:	00098513          	mv	a0,s3

#endif /* MALLOC_PROVIDED */
}
   1a124:	02c12083          	lw	ra,44(sp)
   1a128:	02812403          	lw	s0,40(sp)
   1a12c:	02412483          	lw	s1,36(sp)
   1a130:	02012903          	lw	s2,32(sp)
   1a134:	01c12983          	lw	s3,28(sp)
   1a138:	01812a03          	lw	s4,24(sp)
   1a13c:	01412a83          	lw	s5,20(sp)
   1a140:	01012b03          	lw	s6,16(sp)
   1a144:	00c12b83          	lw	s7,12(sp)
   1a148:	00812c03          	lw	s8,8(sp)
   1a14c:	00412c83          	lw	s9,4(sp)
   1a150:	03010113          	addi	sp,sp,48
   1a154:	00008067          	ret
          return chunk2mem(oldp);
        }
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
   1a158:	ffc6f693          	andi	a3,a3,-4
   1a15c:	015686b3          	add	a3,a3,s5
   1a160:	0ae6c063          	blt	a3,a4,1a200 <_realloc_r+0x23c>
      { 
        unlink(next, bck, fwd);
   1a164:	00c52703          	lw	a4,12(a0)
   1a168:	00852603          	lw	a2,8(a0)
        newsize  += nextsize;
        goto split;
   1a16c:	000a0993          	mv	s3,s4

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
      { 
        unlink(next, bck, fwd);
        newsize  += nextsize;
   1a170:	00068a93          	mv	s5,a3
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
      { 
        unlink(next, bck, fwd);
   1a174:	00e62623          	sw	a4,12(a2)
   1a178:	00c72423          	sw	a2,8(a4)
        newsize  += nextsize;
        goto split;
   1a17c:	f75ff06f          	j	1a0f0 <_realloc_r+0x12c>
  nb = request2size(bytes);

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
  {
    RERRNO = ENOMEM;
   1a180:	00c00793          	li	a5,12
   1a184:	00f4a023          	sw	a5,0(s1)
    return 0;
   1a188:	00000513          	li	a0,0
   1a18c:	f99ff06f          	j	1a124 <_realloc_r+0x160>
  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
   1a190:	0017f713          	andi	a4,a5,1

  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
   1a194:	012b05b3          	add	a1,s6,s2
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
   1a198:	0016e793          	ori	a5,a3,1
  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
   1a19c:	01276733          	or	a4,a4,s2
   1a1a0:	00eb2223          	sw	a4,4(s6)
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
   1a1a4:	00d586b3          	add	a3,a1,a3

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
   1a1a8:	00f5a223          	sw	a5,4(a1)
    set_inuse_bit_at_offset(remainder, remainder_size);
   1a1ac:	0046a783          	lw	a5,4(a3)
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
   1a1b0:	00858593          	addi	a1,a1,8
   1a1b4:	00048513          	mv	a0,s1
  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
   1a1b8:	0017e793          	ori	a5,a5,1
   1a1bc:	00f6a223          	sw	a5,4(a3)
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
   1a1c0:	e31fb0ef          	jal	15ff0 <_free_r>
   1a1c4:	f55ff06f          	j	1a118 <_realloc_r+0x154>
  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
  return chunk2mem(newp);

#endif /* MALLOC_PROVIDED */
}
   1a1c8:	02c12083          	lw	ra,44(sp)
   1a1cc:	02812403          	lw	s0,40(sp)
   1a1d0:	02412483          	lw	s1,36(sp)
   1a1d4:	02012903          	lw	s2,32(sp)
   1a1d8:	01c12983          	lw	s3,28(sp)
   1a1dc:	01812a03          	lw	s4,24(sp)
   1a1e0:	01412a83          	lw	s5,20(sp)
   1a1e4:	01012b03          	lw	s6,16(sp)
   1a1e8:	00c12b83          	lw	s7,12(sp)
   1a1ec:	00812c03          	lw	s8,8(sp)
   1a1f0:	00412c83          	lw	s9,4(sp)
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
   1a1f4:	00060593          	mv	a1,a2
  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
  return chunk2mem(newp);

#endif /* MALLOC_PROVIDED */
}
   1a1f8:	03010113          	addi	sp,sp,48
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
   1a1fc:	c98fc06f          	j	16694 <_malloc_r>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   1a200:	0017f793          	andi	a5,a5,1
   1a204:	e60792e3          	bnez	a5,1a068 <_realloc_r+0xa4>
    {
      prev = prev_chunk(oldp);
   1a208:	ff8a2b83          	lw	s7,-8(s4)
   1a20c:	417b0bb3          	sub	s7,s6,s7
      prevsize = chunksize(prev);
   1a210:	004ba783          	lw	a5,4(s7)
   1a214:	ffc7f793          	andi	a5,a5,-4
            return newmem;
          }
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
   1a218:	00f68433          	add	s0,a3,a5
   1a21c:	0ce44063          	blt	s0,a4,1a2dc <_realloc_r+0x318>
        {
          unlink(next, bck, fwd);
   1a220:	00c52783          	lw	a5,12(a0)
   1a224:	00852703          	lw	a4,8(a0)
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1a228:	ffca8613          	addi	a2,s5,-4
        {
          unlink(next, bck, fwd);
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
   1a22c:	008b8993          	addi	s3,s7,8
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
        {
          unlink(next, bck, fwd);
   1a230:	00f72623          	sw	a5,12(a4)
   1a234:	00e7a423          	sw	a4,8(a5)
          unlink(prev, bck, fwd);
   1a238:	008ba703          	lw	a4,8(s7)
   1a23c:	00cba783          	lw	a5,12(s7)
   1a240:	00f72623          	sw	a5,12(a4)
   1a244:	00e7a423          	sw	a4,8(a5)
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1a248:	02400793          	li	a5,36
   1a24c:	22c7e663          	bltu	a5,a2,1a478 <_realloc_r+0x4b4>
   1a250:	01300713          	li	a4,19
   1a254:	00098793          	mv	a5,s3
   1a258:	04c77663          	bleu	a2,a4,1a2a4 <_realloc_r+0x2e0>
   1a25c:	000a2783          	lw	a5,0(s4)
   1a260:	00fba423          	sw	a5,8(s7)
   1a264:	004a2783          	lw	a5,4(s4)
   1a268:	00fba623          	sw	a5,12(s7)
   1a26c:	01b00793          	li	a5,27
   1a270:	24c7fc63          	bleu	a2,a5,1a4c8 <_realloc_r+0x504>
   1a274:	008a2783          	lw	a5,8(s4)
   1a278:	00fba823          	sw	a5,16(s7)
   1a27c:	00ca2783          	lw	a5,12(s4)
   1a280:	00fbaa23          	sw	a5,20(s7)
   1a284:	02400793          	li	a5,36
   1a288:	0af61a63          	bne	a2,a5,1a33c <_realloc_r+0x378>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1a28c:	010a2703          	lw	a4,16(s4)
   1a290:	020b8793          	addi	a5,s7,32
   1a294:	018a0a13          	addi	s4,s4,24
   1a298:	00ebac23          	sw	a4,24(s7)
   1a29c:	ffca2703          	lw	a4,-4(s4)
   1a2a0:	00ebae23          	sw	a4,28(s7)
   1a2a4:	000a2703          	lw	a4,0(s4)
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
   1a2a8:	00040a93          	mv	s5,s0
   1a2ac:	000b8b13          	mv	s6,s7
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1a2b0:	00e7a023          	sw	a4,0(a5)
   1a2b4:	004a2703          	lw	a4,4(s4)
   1a2b8:	00e7a223          	sw	a4,4(a5)
   1a2bc:	008a2703          	lw	a4,8(s4)
   1a2c0:	00e7a423          	sw	a4,8(a5)
   1a2c4:	004ba783          	lw	a5,4(s7)
   1a2c8:	e29ff06f          	j	1a0f0 <_realloc_r+0x12c>

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
    {
      prev = prev_chunk(oldp);
   1a2cc:	ff8a2b83          	lw	s7,-8(s4)
   1a2d0:	417b0bb3          	sub	s7,s6,s7
      prevsize = chunksize(prev);
   1a2d4:	004ba783          	lw	a5,4(s7)
   1a2d8:	ffc7f793          	andi	a5,a5,-4
          goto split;
        }
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
   1a2dc:	00fa8433          	add	s0,s5,a5
   1a2e0:	d8e444e3          	blt	s0,a4,1a068 <_realloc_r+0xa4>
      {
        unlink(prev, bck, fwd);
   1a2e4:	00cba783          	lw	a5,12(s7)
   1a2e8:	008ba703          	lw	a4,8(s7)
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1a2ec:	ffca8613          	addi	a2,s5,-4
   1a2f0:	02400693          	li	a3,36
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
   1a2f4:	00f72623          	sw	a5,12(a4)
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
   1a2f8:	008b8993          	addi	s3,s7,8
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
   1a2fc:	00e7a423          	sw	a4,8(a5)
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1a300:	16c6ec63          	bltu	a3,a2,1a478 <_realloc_r+0x4b4>
   1a304:	01300713          	li	a4,19
   1a308:	00098793          	mv	a5,s3
   1a30c:	f8c77ce3          	bleu	a2,a4,1a2a4 <_realloc_r+0x2e0>
   1a310:	000a2783          	lw	a5,0(s4)
   1a314:	00fba423          	sw	a5,8(s7)
   1a318:	004a2783          	lw	a5,4(s4)
   1a31c:	00fba623          	sw	a5,12(s7)
   1a320:	01b00793          	li	a5,27
   1a324:	1ac7f263          	bleu	a2,a5,1a4c8 <_realloc_r+0x504>
   1a328:	008a2783          	lw	a5,8(s4)
   1a32c:	00fba823          	sw	a5,16(s7)
   1a330:	00ca2783          	lw	a5,12(s4)
   1a334:	00fbaa23          	sw	a5,20(s7)
   1a338:	f4d60ae3          	beq	a2,a3,1a28c <_realloc_r+0x2c8>
   1a33c:	018b8793          	addi	a5,s7,24
   1a340:	010a0a13          	addi	s4,s4,16
   1a344:	f61ff06f          	j	1a2a4 <_realloc_r+0x2e0>
      nextsize = chunksize(next);

      /* Forward into top only if a remainder */
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
   1a348:	00452683          	lw	a3,4(a0)
   1a34c:	01090613          	addi	a2,s2,16
   1a350:	ffc6f693          	andi	a3,a3,-4
   1a354:	015686b3          	add	a3,a3,s5
   1a358:	0ec6d063          	ble	a2,a3,1a438 <_realloc_r+0x474>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   1a35c:	0017f793          	andi	a5,a5,1
   1a360:	d00794e3          	bnez	a5,1a068 <_realloc_r+0xa4>
    {
      prev = prev_chunk(oldp);
   1a364:	ff8a2b83          	lw	s7,-8(s4)
   1a368:	417b0bb3          	sub	s7,s6,s7
      prevsize = chunksize(prev);
   1a36c:	004ba783          	lw	a5,4(s7)
   1a370:	ffc7f793          	andi	a5,a5,-4
      if (next != 0)
      {
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
   1a374:	00d78cb3          	add	s9,a5,a3
   1a378:	f6ccc2e3          	blt	s9,a2,1a2dc <_realloc_r+0x318>
          {
            unlink(prev, bck, fwd);
   1a37c:	00cba783          	lw	a5,12(s7)
   1a380:	008ba703          	lw	a4,8(s7)
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1a384:	ffca8613          	addi	a2,s5,-4
   1a388:	02400693          	li	a3,36
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
          {
            unlink(prev, bck, fwd);
   1a38c:	00f72623          	sw	a5,12(a4)
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
   1a390:	008b8413          	addi	s0,s7,8
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
          {
            unlink(prev, bck, fwd);
   1a394:	00e7a423          	sw	a4,8(a5)
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1a398:	14c6ec63          	bltu	a3,a2,1a4f0 <_realloc_r+0x52c>
   1a39c:	01300713          	li	a4,19
   1a3a0:	00040793          	mv	a5,s0
   1a3a4:	02c77263          	bleu	a2,a4,1a3c8 <_realloc_r+0x404>
   1a3a8:	000a2783          	lw	a5,0(s4)
   1a3ac:	00fba423          	sw	a5,8(s7)
   1a3b0:	004a2783          	lw	a5,4(s4)
   1a3b4:	00fba623          	sw	a5,12(s7)
   1a3b8:	01b00793          	li	a5,27
   1a3bc:	14c7e263          	bltu	a5,a2,1a500 <_realloc_r+0x53c>
   1a3c0:	010b8793          	addi	a5,s7,16
   1a3c4:	008a0a13          	addi	s4,s4,8
   1a3c8:	000a2703          	lw	a4,0(s4)
   1a3cc:	00e7a023          	sw	a4,0(a5)
   1a3d0:	004a2703          	lw	a4,4(s4)
   1a3d4:	00e7a223          	sw	a4,4(a5)
   1a3d8:	008a2703          	lw	a4,8(s4)
   1a3dc:	00e7a423          	sw	a4,8(a5)
            top = chunk_at_offset(newp, nb);
            set_head(top, (newsize - nb) | PREV_INUSE);
   1a3e0:	412c86b3          	sub	a3,s9,s2
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
   1a3e4:	012b87b3          	add	a5,s7,s2
            set_head(top, (newsize - nb) | PREV_INUSE);
   1a3e8:	0016e693          	ori	a3,a3,1
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
   1a3ec:	00fc2423          	sw	a5,8(s8)
            set_head(top, (newsize - nb) | PREV_INUSE);
   1a3f0:	00d7a223          	sw	a3,4(a5)
            set_head_size(newp, nb);
   1a3f4:	004ba703          	lw	a4,4(s7)
	    MALLOC_UNLOCK;
   1a3f8:	00048513          	mv	a0,s1
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
            set_head(top, (newsize - nb) | PREV_INUSE);
            set_head_size(newp, nb);
   1a3fc:	00177713          	andi	a4,a4,1
   1a400:	01276733          	or	a4,a4,s2
   1a404:	00eba223          	sw	a4,4(s7)
	    MALLOC_UNLOCK;
   1a408:	cd9fc0ef          	jal	170e0 <__malloc_unlock>
            return newmem;
   1a40c:	00040513          	mv	a0,s0
   1a410:	d15ff06f          	j	1a124 <_realloc_r+0x160>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1a414:	000a2703          	lw	a4,0(s4)
   1a418:	00e52023          	sw	a4,0(a0)
   1a41c:	004a2703          	lw	a4,4(s4)
   1a420:	00e52223          	sw	a4,4(a0)
   1a424:	01b00713          	li	a4,27
   1a428:	06c76663          	bltu	a4,a2,1a494 <_realloc_r+0x4d0>
   1a42c:	00850793          	addi	a5,a0,8
   1a430:	008a0713          	addi	a4,s4,8
   1a434:	c79ff06f          	j	1a0ac <_realloc_r+0xe8>
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
          set_head(top, (newsize - nb) | PREV_INUSE);
   1a438:	412686b3          	sub	a3,a3,s2
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
   1a43c:	012b0b33          	add	s6,s6,s2
          set_head(top, (newsize - nb) | PREV_INUSE);
   1a440:	0016e693          	ori	a3,a3,1
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
   1a444:	016c2423          	sw	s6,8(s8)
          set_head(top, (newsize - nb) | PREV_INUSE);
   1a448:	00db2223          	sw	a3,4(s6)
          set_head_size(oldp, nb);
   1a44c:	ffca2703          	lw	a4,-4(s4)
	  MALLOC_UNLOCK;
   1a450:	00048513          	mv	a0,s1
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
          set_head(top, (newsize - nb) | PREV_INUSE);
          set_head_size(oldp, nb);
   1a454:	00177713          	andi	a4,a4,1
   1a458:	01276733          	or	a4,a4,s2
   1a45c:	feea2e23          	sw	a4,-4(s4)
	  MALLOC_UNLOCK;
   1a460:	c81fc0ef          	jal	170e0 <__malloc_unlock>
          return chunk2mem(oldp);
   1a464:	000a0513          	mv	a0,s4
   1a468:	cbdff06f          	j	1a124 <_realloc_r+0x160>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1a46c:	000a0593          	mv	a1,s4
   1a470:	a35ff0ef          	jal	19ea4 <memmove>
   1a474:	c51ff06f          	j	1a0c4 <_realloc_r+0x100>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1a478:	000a0593          	mv	a1,s4
   1a47c:	00098513          	mv	a0,s3
   1a480:	a25ff0ef          	jal	19ea4 <memmove>
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
   1a484:	00040a93          	mv	s5,s0
   1a488:	004ba783          	lw	a5,4(s7)
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1a48c:	000b8b13          	mv	s6,s7
   1a490:	c61ff06f          	j	1a0f0 <_realloc_r+0x12c>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1a494:	008a2703          	lw	a4,8(s4)
   1a498:	00e52423          	sw	a4,8(a0)
   1a49c:	00ca2703          	lw	a4,12(s4)
   1a4a0:	00e52623          	sw	a4,12(a0)
   1a4a4:	02f60863          	beq	a2,a5,1a4d4 <_realloc_r+0x510>
   1a4a8:	01050793          	addi	a5,a0,16
   1a4ac:	010a0713          	addi	a4,s4,16
   1a4b0:	bfdff06f          	j	1a0ac <_realloc_r+0xe8>
    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
    {
      newsize += chunksize(newp);
   1a4b4:	ffc52703          	lw	a4,-4(a0)
      newp = oldp;
      goto split;
   1a4b8:	000a0993          	mv	s3,s4
    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
    {
      newsize += chunksize(newp);
   1a4bc:	ffc77713          	andi	a4,a4,-4
   1a4c0:	00ea8ab3          	add	s5,s5,a4
      newp = oldp;
      goto split;
   1a4c4:	c2dff06f          	j	1a0f0 <_realloc_r+0x12c>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1a4c8:	010b8793          	addi	a5,s7,16
   1a4cc:	008a0a13          	addi	s4,s4,8
   1a4d0:	dd5ff06f          	j	1a2a4 <_realloc_r+0x2e0>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1a4d4:	010a2683          	lw	a3,16(s4)
   1a4d8:	01850793          	addi	a5,a0,24
   1a4dc:	018a0713          	addi	a4,s4,24
   1a4e0:	00d52823          	sw	a3,16(a0)
   1a4e4:	014a2683          	lw	a3,20(s4)
   1a4e8:	00d52a23          	sw	a3,20(a0)
   1a4ec:	bc1ff06f          	j	1a0ac <_realloc_r+0xe8>
          {
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1a4f0:	000a0593          	mv	a1,s4
   1a4f4:	00040513          	mv	a0,s0
   1a4f8:	9adff0ef          	jal	19ea4 <memmove>
   1a4fc:	ee5ff06f          	j	1a3e0 <_realloc_r+0x41c>
   1a500:	008a2783          	lw	a5,8(s4)
   1a504:	00fba823          	sw	a5,16(s7)
   1a508:	00ca2783          	lw	a5,12(s4)
   1a50c:	00fbaa23          	sw	a5,20(s7)
   1a510:	02d60063          	beq	a2,a3,1a530 <_realloc_r+0x56c>
   1a514:	018b8793          	addi	a5,s7,24
   1a518:	010a0a13          	addi	s4,s4,16
   1a51c:	eadff06f          	j	1a3c8 <_realloc_r+0x404>

    newmem = mALLOc (RCALL bytes);

    if (newmem == 0)  /* propagate failure */
    {
      MALLOC_UNLOCK;
   1a520:	00048513          	mv	a0,s1
   1a524:	bbdfc0ef          	jal	170e0 <__malloc_unlock>
      return 0;
   1a528:	00000513          	li	a0,0
   1a52c:	bf9ff06f          	j	1a124 <_realloc_r+0x160>
          {
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1a530:	010a2703          	lw	a4,16(s4)
   1a534:	020b8793          	addi	a5,s7,32
   1a538:	018a0a13          	addi	s4,s4,24
   1a53c:	00ebac23          	sw	a4,24(s7)
   1a540:	ffca2703          	lw	a4,-4(s4)
   1a544:	00ebae23          	sw	a4,28(s7)
   1a548:	e81ff06f          	j	1a3c8 <_realloc_r+0x404>

0001a54c <__swbuf_r>:
int
_DEFUN(__swbuf_r, (ptr, c, fp),
       struct _reent *ptr _AND
       register int c _AND
       register FILE *fp)
{
   1a54c:	fe010113          	addi	sp,sp,-32
   1a550:	00812c23          	sw	s0,24(sp)
   1a554:	00912a23          	sw	s1,20(sp)
   1a558:	01312623          	sw	s3,12(sp)
   1a55c:	00112e23          	sw	ra,28(sp)
   1a560:	01212823          	sw	s2,16(sp)
   1a564:	00050493          	mv	s1,a0
   1a568:	00058993          	mv	s3,a1
   1a56c:	00060413          	mv	s0,a2
  register int n;

  /* Ensure stdio has been initialized.  */

  CHECK_INIT (ptr, fp);
   1a570:	00050663          	beqz	a0,1a57c <__swbuf_r+0x30>
   1a574:	03852783          	lw	a5,56(a0)
   1a578:	12078263          	beqz	a5,1a69c <__swbuf_r+0x150>
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
   1a57c:	00c41683          	lh	a3,12(s0)
   * (if line buffered) so that we will get called again.
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
   1a580:	01842603          	lw	a2,24(s0)
  if (cantwrite (ptr, fp))
   1a584:	01069713          	slli	a4,a3,0x10
   1a588:	01075713          	srli	a4,a4,0x10
   1a58c:	00877793          	andi	a5,a4,8
   * (if line buffered) so that we will get called again.
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
   1a590:	00c42423          	sw	a2,8(s0)
  if (cantwrite (ptr, fp))
   1a594:	0e078263          	beqz	a5,1a678 <__swbuf_r+0x12c>
   1a598:	01042783          	lw	a5,16(s0)
   1a59c:	0c078e63          	beqz	a5,1a678 <__swbuf_r+0x12c>
    return EOF;
  c = (unsigned char) c;

  ORIENT (fp, -1);
   1a5a0:	01271613          	slli	a2,a4,0x12
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
  c = (unsigned char) c;
   1a5a4:	0ff9f913          	andi	s2,s3,255

  ORIENT (fp, -1);
   1a5a8:	06065663          	bgez	a2,1a614 <__swbuf_r+0xc8>
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
   1a5ac:	00042703          	lw	a4,0(s0)
  if (n >= fp->_bf._size)
   1a5b0:	01442683          	lw	a3,20(s0)
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
   1a5b4:	40f707b3          	sub	a5,a4,a5
  if (n >= fp->_bf._size)
   1a5b8:	08d7d663          	ble	a3,a5,1a644 <__swbuf_r+0xf8>
   1a5bc:	00178793          	addi	a5,a5,1
    {
      if (_fflush_r (ptr, fp))
	return EOF;
      n = 0;
    }
  fp->_w--;
   1a5c0:	00842683          	lw	a3,8(s0)
  *fp->_p++ = c;
   1a5c4:	00170613          	addi	a2,a4,1
   1a5c8:	00c42023          	sw	a2,0(s0)
    {
      if (_fflush_r (ptr, fp))
	return EOF;
      n = 0;
    }
  fp->_w--;
   1a5cc:	fff68693          	addi	a3,a3,-1
   1a5d0:	00d42423          	sw	a3,8(s0)
  *fp->_p++ = c;
   1a5d4:	01370023          	sb	s3,0(a4)
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
   1a5d8:	01442703          	lw	a4,20(s0)
   1a5dc:	08f70263          	beq	a4,a5,1a660 <__swbuf_r+0x114>
   1a5e0:	00c45783          	lhu	a5,12(s0)
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
  c = (unsigned char) c;
   1a5e4:	00090513          	mv	a0,s2
	return EOF;
      n = 0;
    }
  fp->_w--;
  *fp->_p++ = c;
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
   1a5e8:	0017f793          	andi	a5,a5,1
   1a5ec:	00078663          	beqz	a5,1a5f8 <__swbuf_r+0xac>
   1a5f0:	00a00793          	li	a5,10
   1a5f4:	06f90663          	beq	s2,a5,1a660 <__swbuf_r+0x114>
    if (_fflush_r (ptr, fp))
      return EOF;
  return c;
}
   1a5f8:	01c12083          	lw	ra,28(sp)
   1a5fc:	01812403          	lw	s0,24(sp)
   1a600:	01412483          	lw	s1,20(sp)
   1a604:	01012903          	lw	s2,16(sp)
   1a608:	00c12983          	lw	s3,12(sp)
   1a60c:	02010113          	addi	sp,sp,32
   1a610:	00008067          	ret
  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
  c = (unsigned char) c;

  ORIENT (fp, -1);
   1a614:	06842583          	lw	a1,104(s0)
   1a618:	ffffe737          	lui	a4,0xffffe
   1a61c:	fff70713          	addi	a4,a4,-1 # ffffdfff <_gp+0xfffb581f>
   1a620:	00e5f733          	and	a4,a1,a4
   1a624:	00002637          	lui	a2,0x2
   1a628:	00c6e6b3          	or	a3,a3,a2
   1a62c:	06e42423          	sw	a4,104(s0)
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
   1a630:	00042703          	lw	a4,0(s0)
  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
  c = (unsigned char) c;

  ORIENT (fp, -1);
   1a634:	00d41623          	sh	a3,12(s0)
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
  if (n >= fp->_bf._size)
   1a638:	01442683          	lw	a3,20(s0)
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
   1a63c:	40f707b3          	sub	a5,a4,a5
  if (n >= fp->_bf._size)
   1a640:	f6d7cee3          	blt	a5,a3,1a5bc <__swbuf_r+0x70>
    {
      if (_fflush_r (ptr, fp))
   1a644:	00040593          	mv	a1,s0
   1a648:	00048513          	mv	a0,s1
   1a64c:	cb4fb0ef          	jal	15b00 <_fflush_r>
   1a650:	04051a63          	bnez	a0,1a6a4 <__swbuf_r+0x158>
   1a654:	00042703          	lw	a4,0(s0)
   1a658:	00100793          	li	a5,1
   1a65c:	f65ff06f          	j	1a5c0 <__swbuf_r+0x74>
      n = 0;
    }
  fp->_w--;
  *fp->_p++ = c;
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
    if (_fflush_r (ptr, fp))
   1a660:	00040593          	mv	a1,s0
   1a664:	00048513          	mv	a0,s1
   1a668:	c98fb0ef          	jal	15b00 <_fflush_r>
   1a66c:	02051c63          	bnez	a0,1a6a4 <__swbuf_r+0x158>
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
  c = (unsigned char) c;
   1a670:	00090513          	mv	a0,s2
   1a674:	f85ff06f          	j	1a5f8 <__swbuf_r+0xac>
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
   1a678:	00040593          	mv	a1,s0
   1a67c:	00048513          	mv	a0,s1
   1a680:	8a9f90ef          	jal	13f28 <__swsetup_r>
   1a684:	02051063          	bnez	a0,1a6a4 <__swbuf_r+0x158>
   1a688:	00c41683          	lh	a3,12(s0)
   1a68c:	01042783          	lw	a5,16(s0)
   1a690:	01069713          	slli	a4,a3,0x10
   1a694:	01075713          	srli	a4,a4,0x10
   1a698:	f09ff06f          	j	1a5a0 <__swbuf_r+0x54>
{
  register int n;

  /* Ensure stdio has been initialized.  */

  CHECK_INIT (ptr, fp);
   1a69c:	815fb0ef          	jal	15eb0 <__sinit>
   1a6a0:	eddff06f          	j	1a57c <__swbuf_r+0x30>
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
  if (cantwrite (ptr, fp))
    return EOF;
   1a6a4:	fff00513          	li	a0,-1
   1a6a8:	f51ff06f          	j	1a5f8 <__swbuf_r+0xac>

0001a6ac <__swbuf>:
int
_DEFUN(__swbuf, (c, fp),
       register int c _AND
       register FILE *fp)
{
  return __swbuf_r (_REENT, c, fp);
   1a6ac:	00058613          	mv	a2,a1
   1a6b0:	00050593          	mv	a1,a0
   1a6b4:	8101a503          	lw	a0,-2032(gp) # 47ff0 <_impure_ptr>
   1a6b8:	e95ff06f          	j	1a54c <__swbuf_r>

0001a6bc <_wcrtomb_r>:
_DEFUN (_wcrtomb_r, (ptr, s, wc, ps),
	struct _reent *ptr _AND
	char *s _AND
	wchar_t wc _AND
	mbstate_t *ps)
{
   1a6bc:	fd010113          	addi	sp,sp,-48
   1a6c0:	02812423          	sw	s0,40(sp)
   1a6c4:	02912223          	sw	s1,36(sp)
   1a6c8:	03212023          	sw	s2,32(sp)
   1a6cc:	02112623          	sw	ra,44(sp)
   1a6d0:	00050413          	mv	s0,a0
   1a6d4:	00068493          	mv	s1,a3
      ps = &(_REENT_WCRTOMB_STATE(ptr));
    }
#endif

  if (s == NULL)
    retval = __wctomb (ptr, buf, L'\0', __locale_charset (), ps);
   1a6d8:	8201a903          	lw	s2,-2016(gp) # 48000 <__wctomb>
      _REENT_CHECK_MISC(ptr);
      ps = &(_REENT_WCRTOMB_STATE(ptr));
    }
#endif

  if (s == NULL)
   1a6dc:	04058a63          	beqz	a1,1a730 <_wcrtomb_r+0x74>
    retval = __wctomb (ptr, buf, L'\0', __locale_charset (), ps);
  else
    retval = __wctomb (ptr, s, wc, __locale_charset (), ps);
   1a6e0:	00b12623          	sw	a1,12(sp)
   1a6e4:	00c12423          	sw	a2,8(sp)
   1a6e8:	dcdfb0ef          	jal	164b4 <__locale_charset>
   1a6ec:	00812603          	lw	a2,8(sp)
   1a6f0:	00c12583          	lw	a1,12(sp)
   1a6f4:	00050693          	mv	a3,a0
   1a6f8:	00048713          	mv	a4,s1
   1a6fc:	00040513          	mv	a0,s0
   1a700:	000900e7          	jalr	s2

  if (retval == -1)
   1a704:	fff00793          	li	a5,-1
   1a708:	00f51863          	bne	a0,a5,1a718 <_wcrtomb_r+0x5c>
    {
      ps->__count = 0;
      ptr->_errno = EILSEQ;
   1a70c:	08a00793          	li	a5,138
  else
    retval = __wctomb (ptr, s, wc, __locale_charset (), ps);

  if (retval == -1)
    {
      ps->__count = 0;
   1a710:	0004a023          	sw	zero,0(s1)
      ptr->_errno = EILSEQ;
   1a714:	00f42023          	sw	a5,0(s0)
      return (size_t)(-1);
    }
  else
    return (size_t)retval;
}
   1a718:	02c12083          	lw	ra,44(sp)
   1a71c:	02812403          	lw	s0,40(sp)
   1a720:	02412483          	lw	s1,36(sp)
   1a724:	02012903          	lw	s2,32(sp)
   1a728:	03010113          	addi	sp,sp,48
   1a72c:	00008067          	ret
      ps = &(_REENT_WCRTOMB_STATE(ptr));
    }
#endif

  if (s == NULL)
    retval = __wctomb (ptr, buf, L'\0', __locale_charset (), ps);
   1a730:	d85fb0ef          	jal	164b4 <__locale_charset>
   1a734:	00050693          	mv	a3,a0
   1a738:	00048713          	mv	a4,s1
   1a73c:	00000613          	li	a2,0
   1a740:	01410593          	addi	a1,sp,20
   1a744:	00040513          	mv	a0,s0
   1a748:	000900e7          	jalr	s2
   1a74c:	fb9ff06f          	j	1a704 <_wcrtomb_r+0x48>

0001a750 <wcrtomb>:
size_t
_DEFUN (wcrtomb, (s, wc, ps),
	char *__restrict s _AND
	wchar_t wc _AND
	mbstate_t *__restrict ps)
{
   1a750:	fd010113          	addi	sp,sp,-48
   1a754:	02912223          	sw	s1,36(sp)
   1a758:	03212023          	sw	s2,32(sp)
   1a75c:	02112623          	sw	ra,44(sp)
   1a760:	02812423          	sw	s0,40(sp)
   1a764:	01312e23          	sw	s3,28(sp)
   1a768:	01412c23          	sw	s4,24(sp)
   1a76c:	00060913          	mv	s2,a2
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  return _wcrtomb_r (_REENT, s, wc, ps);
#else
  int retval = 0;
  struct _reent *reent = _REENT;
   1a770:	8101a483          	lw	s1,-2032(gp) # 47ff0 <_impure_ptr>
      _REENT_CHECK_MISC(reent);
      ps = &(_REENT_WCRTOMB_STATE(reent));
    }
#endif

  if (s == NULL)
   1a774:	06050063          	beqz	a0,1a7d4 <wcrtomb+0x84>
    retval = __wctomb (reent, buf, L'\0', __locale_charset (), ps);
  else
    retval = __wctomb (reent, s, wc, __locale_charset (), ps);
   1a778:	8201aa03          	lw	s4,-2016(gp) # 48000 <__wctomb>
   1a77c:	00058993          	mv	s3,a1
   1a780:	00050413          	mv	s0,a0
   1a784:	d31fb0ef          	jal	164b4 <__locale_charset>
   1a788:	00050693          	mv	a3,a0
   1a78c:	00090713          	mv	a4,s2
   1a790:	00098613          	mv	a2,s3
   1a794:	00040593          	mv	a1,s0
   1a798:	00048513          	mv	a0,s1
   1a79c:	000a00e7          	jalr	s4

  if (retval == -1)
   1a7a0:	fff00793          	li	a5,-1
   1a7a4:	00f51863          	bne	a0,a5,1a7b4 <wcrtomb+0x64>
    {
      ps->__count = 0;
      reent->_errno = EILSEQ;
   1a7a8:	08a00793          	li	a5,138
  else
    retval = __wctomb (reent, s, wc, __locale_charset (), ps);

  if (retval == -1)
    {
      ps->__count = 0;
   1a7ac:	00092023          	sw	zero,0(s2)
      reent->_errno = EILSEQ;
   1a7b0:	00f4a023          	sw	a5,0(s1)
      return (size_t)(-1);
    }
  else
    return (size_t)retval;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   1a7b4:	02c12083          	lw	ra,44(sp)
   1a7b8:	02812403          	lw	s0,40(sp)
   1a7bc:	02412483          	lw	s1,36(sp)
   1a7c0:	02012903          	lw	s2,32(sp)
   1a7c4:	01c12983          	lw	s3,28(sp)
   1a7c8:	01812a03          	lw	s4,24(sp)
   1a7cc:	03010113          	addi	sp,sp,48
   1a7d0:	00008067          	ret
      ps = &(_REENT_WCRTOMB_STATE(reent));
    }
#endif

  if (s == NULL)
    retval = __wctomb (reent, buf, L'\0', __locale_charset (), ps);
   1a7d4:	8201a403          	lw	s0,-2016(gp) # 48000 <__wctomb>
   1a7d8:	cddfb0ef          	jal	164b4 <__locale_charset>
   1a7dc:	00050693          	mv	a3,a0
   1a7e0:	00090713          	mv	a4,s2
   1a7e4:	00000613          	li	a2,0
   1a7e8:	00410593          	addi	a1,sp,4
   1a7ec:	00048513          	mv	a0,s1
   1a7f0:	000400e7          	jalr	s0
   1a7f4:	fadff06f          	j	1a7a0 <wcrtomb+0x50>

0001a7f8 <__ascii_wctomb>:
  /* Avoids compiler warnings about comparisons that are always false
     due to limited range when sizeof(wchar_t) is 2 but sizeof(wint_t)
     is 4, as is the case on cygwin.  */
  wint_t wchar = _wchar;

  if (s == NULL)
   1a7f8:	00058c63          	beqz	a1,1a810 <__ascii_wctomb+0x18>
    return 0;
 
#ifdef __CYGWIN__
  if ((size_t)wchar >= 0x80)
#else
  if ((size_t)wchar >= 0x100)
   1a7fc:	0ff00793          	li	a5,255
   1a800:	00c7ec63          	bltu	a5,a2,1a818 <__ascii_wctomb+0x20>
    {
      r->_errno = EILSEQ;
      return -1;
    }

  *s = (char) wchar;
   1a804:	00c58023          	sb	a2,0(a1)
  return 1;
   1a808:	00100513          	li	a0,1
   1a80c:	00008067          	ret
     due to limited range when sizeof(wchar_t) is 2 but sizeof(wint_t)
     is 4, as is the case on cygwin.  */
  wint_t wchar = _wchar;

  if (s == NULL)
    return 0;
   1a810:	00000513          	li	a0,0
      return -1;
    }

  *s = (char) wchar;
  return 1;
}
   1a814:	00008067          	ret
  if ((size_t)wchar >= 0x80)
#else
  if ((size_t)wchar >= 0x100)
#endif
    {
      r->_errno = EILSEQ;
   1a818:	08a00793          	li	a5,138
   1a81c:	00f52023          	sw	a5,0(a0)
      return -1;
   1a820:	fff00513          	li	a0,-1
   1a824:	00008067          	ret

0001a828 <_wctomb_r>:
_DEFUN (_wctomb_r, (r, s, wchar, state),
        struct _reent *r     _AND 
        char          *s     _AND
        wchar_t        _wchar _AND
        mbstate_t     *state)
{
   1a828:	fe010113          	addi	sp,sp,-32
   1a82c:	00812c23          	sw	s0,24(sp)
  return __wctomb (r, s, _wchar, __locale_charset (), state);
   1a830:	8201a403          	lw	s0,-2016(gp) # 48000 <__wctomb>
_DEFUN (_wctomb_r, (r, s, wchar, state),
        struct _reent *r     _AND 
        char          *s     _AND
        wchar_t        _wchar _AND
        mbstate_t     *state)
{
   1a834:	00112e23          	sw	ra,28(sp)
   1a838:	00912a23          	sw	s1,20(sp)
   1a83c:	01212823          	sw	s2,16(sp)
   1a840:	00050493          	mv	s1,a0
   1a844:	00068913          	mv	s2,a3
  return __wctomb (r, s, _wchar, __locale_charset (), state);
   1a848:	00b12623          	sw	a1,12(sp)
   1a84c:	00c12423          	sw	a2,8(sp)
   1a850:	c65fb0ef          	jal	164b4 <__locale_charset>
   1a854:	00050693          	mv	a3,a0
   1a858:	00090713          	mv	a4,s2
   1a85c:	00812603          	lw	a2,8(sp)
   1a860:	00c12583          	lw	a1,12(sp)
   1a864:	00048513          	mv	a0,s1
   1a868:	00040313          	mv	t1,s0
}
   1a86c:	01c12083          	lw	ra,28(sp)
   1a870:	01812403          	lw	s0,24(sp)
   1a874:	01412483          	lw	s1,20(sp)
   1a878:	01012903          	lw	s2,16(sp)
   1a87c:	02010113          	addi	sp,sp,32
        struct _reent *r     _AND 
        char          *s     _AND
        wchar_t        _wchar _AND
        mbstate_t     *state)
{
  return __wctomb (r, s, _wchar, __locale_charset (), state);
   1a880:	00030067          	jr	t1

0001a884 <_fpadd_parts>:
#if defined(L_addsub_sf) || defined(L_addsub_df) || defined(L_addsub_tf)
static const fp_number_type *
_fpadd_parts (fp_number_type * a,
	      fp_number_type * b,
	      fp_number_type * tmp)
{
   1a884:	00052783          	lw	a5,0(a0)
  int a_normal_exp;
  int b_normal_exp;
  fractype a_fraction;
  fractype b_fraction;

  if (isnan (a))
   1a888:	00100693          	li	a3,1
   1a88c:	12f6f263          	bleu	a5,a3,1a9b0 <_fpadd_parts+0x12c>
   1a890:	0005a703          	lw	a4,0(a1)
    {
      return a;
    }
  if (isnan (b))
   1a894:	10e6fc63          	bleu	a4,a3,1a9ac <_fpadd_parts+0x128>
    {
      return b;
    }
  if (isinf (a))
   1a898:	00400693          	li	a3,4
   1a89c:	24d78063          	beq	a5,a3,1aadc <_fpadd_parts+0x258>
      /* Adding infinities with opposite signs yields a NaN.  */
      if (isinf (b) && a->sign != b->sign)
	return makenan ();
      return a;
    }
  if (isinf (b))
   1a8a0:	10d70663          	beq	a4,a3,1a9ac <_fpadd_parts+0x128>
    {
      return b;
    }
  if (iszero (b))
   1a8a4:	00200693          	li	a3,2
   1a8a8:	1cd70263          	beq	a4,a3,1aa6c <_fpadd_parts+0x1e8>
	  tmp->sign = a->sign & b->sign;
	  return tmp;
	}
      return a;
    }
  if (iszero (a))
   1a8ac:	10d78063          	beq	a5,a3,1a9ac <_fpadd_parts+0x128>
     they're the same */
  {
    int diff;
    int sdiff;

    a_normal_exp = a->normal_exp;
   1a8b0:	00852303          	lw	t1,8(a0)
    b_normal_exp = b->normal_exp;
   1a8b4:	0085a683          	lw	a3,8(a1)
    a_fraction = a->fraction.ll;
   1a8b8:	01052883          	lw	a7,16(a0)
   1a8bc:	01452e03          	lw	t3,20(a0)
    b_fraction = b->fraction.ll;

    diff = a_normal_exp - b_normal_exp;
   1a8c0:	40d30833          	sub	a6,t1,a3
   1a8c4:	41f85793          	srai	a5,a6,0x1f
   1a8c8:	0107c733          	xor	a4,a5,a6
   1a8cc:	40f70733          	sub	a4,a4,a5
    sdiff = diff;

    if (diff < 0)
      diff = -diff;
    if (diff < FRAC_NBITS)
   1a8d0:	03f00793          	li	a5,63
    int sdiff;

    a_normal_exp = a->normal_exp;
    b_normal_exp = b->normal_exp;
    a_fraction = a->fraction.ll;
    b_fraction = b->fraction.ll;
   1a8d4:	0105a283          	lw	t0,16(a1)
   1a8d8:	0145a383          	lw	t2,20(a1)
    diff = a_normal_exp - b_normal_exp;
    sdiff = diff;

    if (diff < 0)
      diff = -diff;
    if (diff < FRAC_NBITS)
   1a8dc:	0ce7dc63          	ble	a4,a5,1a9b4 <_fpadd_parts+0x130>
	  }
      }
    else
      {
	/* Somethings's up.. choose the biggest */
	if (a_normal_exp > b_normal_exp)
   1a8e0:	1e66c863          	blt	a3,t1,1aad0 <_fpadd_parts+0x24c>
   1a8e4:	00068313          	mv	t1,a3
	    b_fraction = 0;
	  }
	else
	  {
	    a_normal_exp = b_normal_exp;
	    a_fraction = 0;
   1a8e8:	00000893          	li	a7,0
   1a8ec:	00000e13          	li	t3,0
	  }
      }
  }

  if (a->sign != b->sign)
   1a8f0:	00452503          	lw	a0,4(a0)
   1a8f4:	0045a783          	lw	a5,4(a1)
   1a8f8:	10f50863          	beq	a0,a5,1aa08 <_fpadd_parts+0x184>
    {
      if (a->sign)
   1a8fc:	1c050063          	beqz	a0,1aabc <_fpadd_parts+0x238>
	{
	  tfraction = -a_fraction + b_fraction;
   1a900:	411287b3          	sub	a5,t0,a7
   1a904:	00f2b6b3          	sltu	a3,t0,a5
   1a908:	41c38733          	sub	a4,t2,t3
   1a90c:	40d706b3          	sub	a3,a4,a3
	}
      else
	{
	  tfraction = a_fraction - b_fraction;
	}
      if (tfraction >= 0)
   1a910:	1e06c463          	bltz	a3,1aaf8 <_fpadd_parts+0x274>
	{
	  tmp->sign = 0;
   1a914:	00062223          	sw	zero,4(a2) # 2004 <_reset+0x1e04>
	  tmp->normal_exp = a_normal_exp;
   1a918:	00662423          	sw	t1,8(a2)
	  tmp->fraction.ll = tfraction;
   1a91c:	00f62823          	sw	a5,16(a2)
   1a920:	00d62a23          	sw	a3,20(a2)
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1a924:	fff78513          	addi	a0,a5,-1
   1a928:	fff68593          	addi	a1,a3,-1
   1a92c:	00f53733          	sltu	a4,a0,a5
   1a930:	00b70733          	add	a4,a4,a1
   1a934:	100005b7          	lui	a1,0x10000
   1a938:	0eb77863          	bleu	a1,a4,1aa28 <_fpadd_parts+0x1a4>
   1a93c:	fff58593          	addi	a1,a1,-1 # fffffff <_gp+0xffb781f>
   1a940:	24b70e63          	beq	a4,a1,1ab9c <_fpadd_parts+0x318>
   1a944:	00862503          	lw	a0,8(a2)
   1a948:	100002b7          	lui	t0,0x10000
   1a94c:	fff28313          	addi	t1,t0,-1 # fffffff <_gp+0xffb781f>
   1a950:	fff50513          	addi	a0,a0,-1
   1a954:	ffe00393          	li	t2,-2
   1a958:	0080006f          	j	1a960 <_fpadd_parts+0xdc>
   1a95c:	14670c63          	beq	a4,t1,1aab4 <_fpadd_parts+0x230>
	{
	  tmp->fraction.ll <<= 1;
   1a960:	01f7d713          	srli	a4,a5,0x1f
   1a964:	00169593          	slli	a1,a3,0x1
   1a968:	00179793          	slli	a5,a5,0x1
   1a96c:	00b765b3          	or	a1,a4,a1
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1a970:	fff78813          	addi	a6,a5,-1
   1a974:	fff58893          	addi	a7,a1,-1
   1a978:	00f83733          	sltu	a4,a6,a5
   1a97c:	01170733          	add	a4,a4,a7
	{
	  tmp->fraction.ll <<= 1;
   1a980:	00058693          	mv	a3,a1
	  tmp->normal_exp--;
   1a984:	00050893          	mv	a7,a0
   1a988:	fff50513          	addi	a0,a0,-1
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1a98c:	fc5768e3          	bltu	a4,t0,1a95c <_fpadd_parts+0xd8>
   1a990:	00f62823          	sw	a5,16(a2)
    {
      tmp->sign = a->sign;
      tmp->normal_exp = a_normal_exp;
      tmp->fraction.ll = a_fraction + b_fraction;
    }
  tmp->class = CLASS_NUMBER;
   1a994:	00300793          	li	a5,3
   1a998:	00b62a23          	sw	a1,20(a2)
   1a99c:	01162423          	sw	a7,8(a2)
   1a9a0:	00f62023          	sw	a5,0(a2)
   1a9a4:	00060513          	mv	a0,a2
   1a9a8:	00008067          	ret
   1a9ac:	00058513          	mv	a0,a1
    {
      LSHIFT (tmp->fraction.ll, 1);
      tmp->normal_exp++;
    }
  return tmp;
}
   1a9b0:	00008067          	ret

    if (diff < 0)
      diff = -diff;
    if (diff < FRAC_NBITS)
      {
	if (sdiff > 0)
   1a9b4:	19005a63          	blez	a6,1ab48 <_fpadd_parts+0x2c4>
	  {
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
   1a9b8:	02077793          	andi	a5,a4,32
   1a9bc:	16078263          	beqz	a5,1ab20 <_fpadd_parts+0x29c>
   1a9c0:	00100793          	li	a5,1
   1a9c4:	00e3deb3          	srl	t4,t2,a4
   1a9c8:	00e797b3          	sll	a5,a5,a4
   1a9cc:	00000f13          	li	t5,0
   1a9d0:	00000713          	li	a4,0
   1a9d4:	fff70693          	addi	a3,a4,-1
   1a9d8:	fff78793          	addi	a5,a5,-1
   1a9dc:	00e6b733          	sltu	a4,a3,a4
   1a9e0:	00f70733          	add	a4,a4,a5
   1a9e4:	00777733          	and	a4,a4,t2
   1a9e8:	0056f7b3          	and	a5,a3,t0
   1a9ec:	00e7e7b3          	or	a5,a5,a4
   1a9f0:	00f037b3          	snez	a5,a5
   1a9f4:	00fee2b3          	or	t0,t4,a5
	    a_fraction = 0;
	  }
      }
  }

  if (a->sign != b->sign)
   1a9f8:	00452503          	lw	a0,4(a0)
   1a9fc:	0045a783          	lw	a5,4(a1)
    if (diff < FRAC_NBITS)
      {
	if (sdiff > 0)
	  {
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
   1aa00:	000f0393          	mv	t2,t5
	    a_fraction = 0;
	  }
      }
  }

  if (a->sign != b->sign)
   1aa04:	eef51ce3          	bne	a0,a5,1a8fc <_fpadd_parts+0x78>
    }
  else
    {
      tmp->sign = a->sign;
      tmp->normal_exp = a_normal_exp;
      tmp->fraction.ll = a_fraction + b_fraction;
   1aa08:	005887b3          	add	a5,a7,t0
   1aa0c:	0117b8b3          	sltu	a7,a5,a7
   1aa10:	007e0733          	add	a4,t3,t2
   1aa14:	00e886b3          	add	a3,a7,a4
	  tmp->normal_exp--;
	}
    }
  else
    {
      tmp->sign = a->sign;
   1aa18:	00a62223          	sw	a0,4(a2)
      tmp->normal_exp = a_normal_exp;
   1aa1c:	00662423          	sw	t1,8(a2)
      tmp->fraction.ll = a_fraction + b_fraction;
   1aa20:	00f62823          	sw	a5,16(a2)
   1aa24:	00d62a23          	sw	a3,20(a2)
    }
  tmp->class = CLASS_NUMBER;
   1aa28:	00300713          	li	a4,3
   1aa2c:	00e62023          	sw	a4,0(a2)
  /* Now the fraction is added, we have to shift down to renormalize the
     number */

  if (tmp->fraction.ll >= IMPLICIT_2)
   1aa30:	20000737          	lui	a4,0x20000
   1aa34:	02e6e863          	bltu	a3,a4,1aa64 <_fpadd_parts+0x1e0>
    {
      LSHIFT (tmp->fraction.ll, 1);
      tmp->normal_exp++;
   1aa38:	00862703          	lw	a4,8(a2)
  /* Now the fraction is added, we have to shift down to renormalize the
     number */

  if (tmp->fraction.ll >= IMPLICIT_2)
    {
      LSHIFT (tmp->fraction.ll, 1);
   1aa3c:	01f69513          	slli	a0,a3,0x1f
   1aa40:	0017d593          	srli	a1,a5,0x1
   1aa44:	00b565b3          	or	a1,a0,a1
   1aa48:	0017f793          	andi	a5,a5,1
   1aa4c:	0016d693          	srli	a3,a3,0x1
   1aa50:	00f5e7b3          	or	a5,a1,a5
      tmp->normal_exp++;
   1aa54:	00170713          	addi	a4,a4,1 # 20000001 <_gp+0x1ffb7821>
  /* Now the fraction is added, we have to shift down to renormalize the
     number */

  if (tmp->fraction.ll >= IMPLICIT_2)
    {
      LSHIFT (tmp->fraction.ll, 1);
   1aa58:	00f62823          	sw	a5,16(a2)
   1aa5c:	00d62a23          	sw	a3,20(a2)
      tmp->normal_exp++;
   1aa60:	00e62423          	sw	a4,8(a2)
   1aa64:	00060513          	mv	a0,a2
   1aa68:	00008067          	ret
    {
      return b;
    }
  if (iszero (b))
    {
      if (iszero (a))
   1aa6c:	f4e792e3          	bne	a5,a4,1a9b0 <_fpadd_parts+0x12c>
	{
	  *tmp = *a;
   1aa70:	00f62023          	sw	a5,0(a2)
   1aa74:	00452783          	lw	a5,4(a0)
   1aa78:	00f62223          	sw	a5,4(a2)
   1aa7c:	00852703          	lw	a4,8(a0)
	  tmp->sign = a->sign & b->sign;
   1aa80:	00452683          	lw	a3,4(a0)
   1aa84:	0045a783          	lw	a5,4(a1)
    }
  if (iszero (b))
    {
      if (iszero (a))
	{
	  *tmp = *a;
   1aa88:	00e62423          	sw	a4,8(a2)
   1aa8c:	00c52703          	lw	a4,12(a0)
	  tmp->sign = a->sign & b->sign;
   1aa90:	00f6f7b3          	and	a5,a3,a5
    }
  if (iszero (b))
    {
      if (iszero (a))
	{
	  *tmp = *a;
   1aa94:	00e62623          	sw	a4,12(a2)
   1aa98:	01052703          	lw	a4,16(a0)
   1aa9c:	00e62823          	sw	a4,16(a2)
   1aaa0:	01452703          	lw	a4,20(a0)
	  tmp->sign = a->sign & b->sign;
   1aaa4:	00f62223          	sw	a5,4(a2)
	  return tmp;
   1aaa8:	00060513          	mv	a0,a2
    }
  if (iszero (b))
    {
      if (iszero (a))
	{
	  *tmp = *a;
   1aaac:	00e62a23          	sw	a4,20(a2)
	  tmp->sign = a->sign & b->sign;
	  return tmp;
   1aab0:	00008067          	ret
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1aab4:	eb03f6e3          	bleu	a6,t2,1a960 <_fpadd_parts+0xdc>
   1aab8:	ed9ff06f          	j	1a990 <_fpadd_parts+0x10c>
	{
	  tfraction = -a_fraction + b_fraction;
	}
      else
	{
	  tfraction = a_fraction - b_fraction;
   1aabc:	405887b3          	sub	a5,a7,t0
   1aac0:	00f8b6b3          	sltu	a3,a7,a5
   1aac4:	407e0733          	sub	a4,t3,t2
   1aac8:	40d706b3          	sub	a3,a4,a3
   1aacc:	e45ff06f          	j	1a910 <_fpadd_parts+0x8c>
      {
	/* Somethings's up.. choose the biggest */
	if (a_normal_exp > b_normal_exp)
	  {
	    b_normal_exp = a_normal_exp;
	    b_fraction = 0;
   1aad0:	00000293          	li	t0,0
   1aad4:	00000393          	li	t2,0
   1aad8:	e19ff06f          	j	1a8f0 <_fpadd_parts+0x6c>
      return b;
    }
  if (isinf (a))
    {
      /* Adding infinities with opposite signs yields a NaN.  */
      if (isinf (b) && a->sign != b->sign)
   1aadc:	ecf71ae3          	bne	a4,a5,1a9b0 <_fpadd_parts+0x12c>
   1aae0:	00452703          	lw	a4,4(a0)
   1aae4:	0045a783          	lw	a5,4(a1)
   1aae8:	ecf704e3          	beq	a4,a5,1a9b0 <_fpadd_parts+0x12c>
	return makenan ();
   1aaec:	0001d537          	lui	a0,0x1d
   1aaf0:	cc850513          	addi	a0,a0,-824 # 1ccc8 <__thenan_df>
   1aaf4:	00008067          	ret
	}
      else
	{
	  tmp->sign = 1;
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
   1aaf8:	40f007b3          	neg	a5,a5
   1aafc:	00f03733          	snez	a4,a5
   1ab00:	40d006b3          	neg	a3,a3
   1ab04:	40e686b3          	sub	a3,a3,a4
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = tfraction;
	}
      else
	{
	  tmp->sign = 1;
   1ab08:	00100713          	li	a4,1
   1ab0c:	00e62223          	sw	a4,4(a2)
	  tmp->normal_exp = a_normal_exp;
   1ab10:	00662423          	sw	t1,8(a2)
	  tmp->fraction.ll = -tfraction;
   1ab14:	00f62823          	sw	a5,16(a2)
   1ab18:	00d62a23          	sw	a3,20(a2)
   1ab1c:	e09ff06f          	j	1a924 <_fpadd_parts+0xa0>
    if (diff < FRAC_NBITS)
      {
	if (sdiff > 0)
	  {
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
   1ab20:	fff74693          	not	a3,a4
   1ab24:	00139793          	slli	a5,t2,0x1
   1ab28:	00d797b3          	sll	a5,a5,a3
   1ab2c:	00e2deb3          	srl	t4,t0,a4
   1ab30:	00100813          	li	a6,1
   1ab34:	01d7eeb3          	or	t4,a5,t4
   1ab38:	00e3df33          	srl	t5,t2,a4
   1ab3c:	00000793          	li	a5,0
   1ab40:	00e81733          	sll	a4,a6,a4
   1ab44:	e91ff06f          	j	1a9d4 <_fpadd_parts+0x150>
	  }
	else if (sdiff < 0)
   1ab48:	da0804e3          	beqz	a6,1a8f0 <_fpadd_parts+0x6c>
	  {
	    a_normal_exp += diff;
	    LSHIFT (a_fraction, diff);
   1ab4c:	02077793          	andi	a5,a4,32
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
	  }
	else if (sdiff < 0)
	  {
	    a_normal_exp += diff;
   1ab50:	00e30333          	add	t1,t1,a4
	    LSHIFT (a_fraction, diff);
   1ab54:	06078263          	beqz	a5,1abb8 <_fpadd_parts+0x334>
   1ab58:	00ee5833          	srl	a6,t3,a4
   1ab5c:	00000e93          	li	t4,0
   1ab60:	04079463          	bnez	a5,1aba8 <_fpadd_parts+0x324>
   1ab64:	00100793          	li	a5,1
   1ab68:	00000693          	li	a3,0
   1ab6c:	00e79733          	sll	a4,a5,a4
   1ab70:	fff70793          	addi	a5,a4,-1
   1ab74:	00e7b733          	sltu	a4,a5,a4
   1ab78:	fff68693          	addi	a3,a3,-1
   1ab7c:	00d70733          	add	a4,a4,a3
   1ab80:	0117f7b3          	and	a5,a5,a7
   1ab84:	01c77733          	and	a4,a4,t3
   1ab88:	00e7e7b3          	or	a5,a5,a4
   1ab8c:	00f037b3          	snez	a5,a5
   1ab90:	00f868b3          	or	a7,a6,a5
   1ab94:	000e8e13          	mv	t3,t4
   1ab98:	d59ff06f          	j	1a8f0 <_fpadd_parts+0x6c>
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1ab9c:	ffe00713          	li	a4,-2
   1aba0:	daa772e3          	bleu	a0,a4,1a944 <_fpadd_parts+0xc0>
   1aba4:	e85ff06f          	j	1aa28 <_fpadd_parts+0x1a4>
	    LSHIFT (b_fraction, diff);
	  }
	else if (sdiff < 0)
	  {
	    a_normal_exp += diff;
	    LSHIFT (a_fraction, diff);
   1aba8:	00100693          	li	a3,1
   1abac:	00e696b3          	sll	a3,a3,a4
   1abb0:	00000713          	li	a4,0
   1abb4:	fbdff06f          	j	1ab70 <_fpadd_parts+0x2ec>
   1abb8:	001e1793          	slli	a5,t3,0x1
   1abbc:	fff74693          	not	a3,a4
   1abc0:	00d797b3          	sll	a5,a5,a3
   1abc4:	00e8d833          	srl	a6,a7,a4
   1abc8:	0107e833          	or	a6,a5,a6
   1abcc:	00ee5eb3          	srl	t4,t3,a4
   1abd0:	f95ff06f          	j	1ab64 <_fpadd_parts+0x2e0>

0001abd4 <__pack_d>:
extern FLO_type pack_d (const fp_number_type * );

#if defined(L_pack_df) || defined(L_pack_sf) || defined(L_pack_tf)
FLO_type
pack_d (const fp_number_type *src)
{
   1abd4:	00052783          	lw	a5,0(a0)
  FLO_union_type dst;
  fractype fraction = src->fraction.ll;	/* wasn't unsigned before? */
  int sign = src->sign;
  int exp = 0;

  if (isnan (src))
   1abd8:	00100593          	li	a1,1
#if defined(L_pack_df) || defined(L_pack_sf) || defined(L_pack_tf)
FLO_type
pack_d (const fp_number_type *src)
{
  FLO_union_type dst;
  fractype fraction = src->fraction.ll;	/* wasn't unsigned before? */
   1abdc:	01052603          	lw	a2,16(a0)
   1abe0:	01452683          	lw	a3,20(a0)
  int sign = src->sign;
   1abe4:	00452803          	lw	a6,4(a0)
  int exp = 0;

  if (isnan (src))
   1abe8:	0ef5fa63          	bleu	a5,a1,1acdc <__pack_d+0x108>
	  /* Set the quiet/signaling bit.  */
	  fraction |= QUIET_NAN;
#endif
	}
    }
  else if (isinf (src))
   1abec:	00400713          	li	a4,4
   1abf0:	0ce78e63          	beq	a5,a4,1accc <__pack_d+0xf8>
    {
      exp = EXPMAX;
      fraction = 0;
    }
  else if (iszero (src))
   1abf4:	00200713          	li	a4,2
   1abf8:	06e78263          	beq	a5,a4,1ac5c <__pack_d+0x88>
    {
      exp = 0;
      fraction = 0;
    }
  else if (fraction == 0)
   1abfc:	00d667b3          	or	a5,a2,a3
   1ac00:	04078e63          	beqz	a5,1ac5c <__pack_d+0x88>
    {
      exp = 0;
    }
  else
    {
      if (__builtin_expect (src->normal_exp < NORMAL_EXPMIN, 0))
   1ac04:	00852783          	lw	a5,8(a0)
   1ac08:	c0200713          	li	a4,-1022
   1ac0c:	12e7c063          	blt	a5,a4,1ad2c <__pack_d+0x158>
	      exp += 1;
	    }
	  fraction >>= NGARDS;
#endif /* NO_DENORMALS */
	}
      else if (__builtin_expect (src->normal_exp > EXPBIAS, 0))
   1ac10:	3ff00713          	li	a4,1023
   1ac14:	0af74c63          	blt	a4,a5,1accc <__pack_d+0xf8>
	{
	  exp = src->normal_exp + EXPBIAS;
	  /* IF the gard bits are the all zero, but the first, then we're
	     half way between two numbers, choose the one which makes the
	     lsb of the answer 0.  */
	  if ((fraction & GARDMASK) == GARDMSB)
   1ac18:	0ff67713          	andi	a4,a2,255
   1ac1c:	08000593          	li	a1,128
   1ac20:	0eb70863          	beq	a4,a1,1ad10 <__pack_d+0x13c>
		fraction += GARDROUND + 1;
	    }
	  else
	    {
	      /* Add a one to the guards to round up */
	      fraction += GARDROUND;
   1ac24:	07f60713          	addi	a4,a2,127
   1ac28:	00c73633          	sltu	a2,a4,a2
   1ac2c:	00d606b3          	add	a3,a2,a3
   1ac30:	00070613          	mv	a2,a4
	    }
	  if (fraction >= IMPLICIT_2)
   1ac34:	20000737          	lui	a4,0x20000
   1ac38:	06e6fe63          	bleu	a4,a3,1acb4 <__pack_d+0xe0>
	  exp = EXPMAX;
	  fraction = 0;
	}
      else
	{
	  exp = src->normal_exp + EXPBIAS;
   1ac3c:	3ff78793          	addi	a5,a5,1023
   1ac40:	01869713          	slli	a4,a3,0x18
   1ac44:	00865613          	srli	a2,a2,0x8
   1ac48:	00469693          	slli	a3,a3,0x4
   1ac4c:	00c76633          	or	a2,a4,a2
   1ac50:	00c6d693          	srli	a3,a3,0xc
   1ac54:	7ff7f793          	andi	a5,a5,2047
   1ac58:	0100006f          	j	1ac68 <__pack_d+0x94>
   1ac5c:	00000793          	li	a5,0
   1ac60:	00000613          	li	a2,0
   1ac64:	00000693          	li	a3,0

  /* We previously used bitfields to store the number, but this doesn't
     handle little/big endian systems conveniently, so use shifts and
     masks */
#ifdef FLOAT_BIT_ORDER_MISMATCH
  dst.bits.fraction = fraction;
   1ac68:	00100737          	lui	a4,0x100
   1ac6c:	00000593          	li	a1,0
   1ac70:	00060513          	mv	a0,a2
   1ac74:	fff70713          	addi	a4,a4,-1 # fffff <_gp+0xb781f>
   1ac78:	fff00637          	lui	a2,0xfff00
   1ac7c:	00b67633          	and	a2,a2,a1
   1ac80:	00e6f6b3          	and	a3,a3,a4
  dst.bits.exp = exp;
   1ac84:	01479713          	slli	a4,a5,0x14
   1ac88:	801007b7          	lui	a5,0x80100

  /* We previously used bitfields to store the number, but this doesn't
     handle little/big endian systems conveniently, so use shifts and
     masks */
#ifdef FLOAT_BIT_ORDER_MISMATCH
  dst.bits.fraction = fraction;
   1ac8c:	00d666b3          	or	a3,a2,a3
  dst.bits.exp = exp;
   1ac90:	fff78793          	addi	a5,a5,-1 # 800fffff <_gp+0x800b781f>
   1ac94:	00f6f7b3          	and	a5,a3,a5
   1ac98:	00e7e7b3          	or	a5,a5,a4
  dst.bits.sign = sign;
   1ac9c:	80000737          	lui	a4,0x80000
   1aca0:	fff74713          	not	a4,a4
   1aca4:	01f81813          	slli	a6,a6,0x1f
   1aca8:	00e7f7b3          	and	a5,a5,a4
   1acac:	0107e5b3          	or	a1,a5,a6
  }
#endif
#endif

  return dst.value;
}
   1acb0:	00008067          	ret
	      /* Add a one to the guards to round up */
	      fraction += GARDROUND;
	    }
	  if (fraction >= IMPLICIT_2)
	    {
	      fraction >>= 1;
   1acb4:	01f69713          	slli	a4,a3,0x1f
   1acb8:	00165613          	srli	a2,a2,0x1
   1acbc:	00c76633          	or	a2,a4,a2
   1acc0:	0016d693          	srli	a3,a3,0x1
	      exp += 1;
   1acc4:	40078793          	addi	a5,a5,1024
   1acc8:	f79ff06f          	j	1ac40 <__pack_d+0x6c>
   1accc:	7ff00793          	li	a5,2047
   1acd0:	00000613          	li	a2,0
   1acd4:	00000693          	li	a3,0
   1acd8:	f91ff06f          	j	1ac68 <__pack_d+0x94>
  if (isnan (src))
    {
      exp = EXPMAX;
      /* Restore the NaN's payload.  */
      fraction >>= NGARDS;
      fraction &= QUIET_NAN - 1;
   1acdc:	00080737          	lui	a4,0x80

  if (isnan (src))
    {
      exp = EXPMAX;
      /* Restore the NaN's payload.  */
      fraction >>= NGARDS;
   1ace0:	0086d593          	srli	a1,a3,0x8
      fraction &= QUIET_NAN - 1;
   1ace4:	fff70793          	addi	a5,a4,-1 # 7ffff <_gp+0x3781f>
   1ace8:	00f5f7b3          	and	a5,a1,a5

  if (isnan (src))
    {
      exp = EXPMAX;
      /* Restore the NaN's payload.  */
      fraction >>= NGARDS;
   1acec:	01869593          	slli	a1,a3,0x18
   1acf0:	00e7e6b3          	or	a3,a5,a4
   1acf4:	001007b7          	lui	a5,0x100
   1acf8:	fff78793          	addi	a5,a5,-1 # fffff <_gp+0xb781f>
   1acfc:	00865613          	srli	a2,a2,0x8
   1ad00:	00f6f6b3          	and	a3,a3,a5
   1ad04:	00c5e633          	or	a2,a1,a2
	  /* Make sure the fraction has a non-zero value.  */
	  if (fraction == 0)
	    fraction |= QUIET_NAN - 1;
#else
	  /* Set the quiet/signaling bit.  */
	  fraction |= QUIET_NAN;
   1ad08:	7ff00793          	li	a5,2047
   1ad0c:	f5dff06f          	j	1ac68 <__pack_d+0x94>
	  /* IF the gard bits are the all zero, but the first, then we're
	     half way between two numbers, choose the one which makes the
	     lsb of the answer 0.  */
	  if ((fraction & GARDMASK) == GARDMSB)
	    {
	      if (fraction & (1 << NGARDS))
   1ad10:	10067713          	andi	a4,a2,256
   1ad14:	f20700e3          	beqz	a4,1ac34 <__pack_d+0x60>
		fraction += GARDROUND + 1;
   1ad18:	00b60733          	add	a4,a2,a1
   1ad1c:	00c73633          	sltu	a2,a4,a2
   1ad20:	00d606b3          	add	a3,a2,a3
   1ad24:	00070613          	mv	a2,a4
   1ad28:	f0dff06f          	j	1ac34 <__pack_d+0x60>
#else /* NO_DENORMALS */
	  /* This number's exponent is too low to fit into the bits
	     available in the number, so we'll store 0 in the exponent and
	     shift the fraction to the right to make up for it.  */

	  int shift = NORMAL_EXPMIN - src->normal_exp;
   1ad2c:	40f707b3          	sub	a5,a4,a5

	  exp = 0;

	  if (shift > FRAC_NBITS - NGARDS)
   1ad30:	03800713          	li	a4,56
   1ad34:	f2f744e3          	blt	a4,a5,1ac5c <__pack_d+0x88>
	      fraction = 0;
	    }
	  else
	    {
	      int lowbit = (fraction & (((fractype)1 << shift) - 1)) ? 1 : 0;
	      fraction = (fraction >> shift) | lowbit;
   1ad38:	0207f713          	andi	a4,a5,32
   1ad3c:	0a070663          	beqz	a4,1ade8 <__pack_d+0x214>
   1ad40:	00f6d8b3          	srl	a7,a3,a5
   1ad44:	00f595b3          	sll	a1,a1,a5
   1ad48:	00000713          	li	a4,0
   1ad4c:	00000793          	li	a5,0
   1ad50:	fff78513          	addi	a0,a5,-1
   1ad54:	00f537b3          	sltu	a5,a0,a5
   1ad58:	fff58593          	addi	a1,a1,-1
   1ad5c:	00b785b3          	add	a1,a5,a1
   1ad60:	00d5f6b3          	and	a3,a1,a3
   1ad64:	00c577b3          	and	a5,a0,a2
   1ad68:	00d7e7b3          	or	a5,a5,a3
   1ad6c:	00f037b3          	snez	a5,a5
   1ad70:	00f8e633          	or	a2,a7,a5
	    }
	  if ((fraction & GARDMASK) == GARDMSB)
   1ad74:	0ff67693          	andi	a3,a2,255
   1ad78:	08000793          	li	a5,128
   1ad7c:	02f69a63          	bne	a3,a5,1adb0 <__pack_d+0x1dc>
	    {
	      if ((fraction & (1 << NGARDS)))
   1ad80:	10067793          	andi	a5,a2,256
   1ad84:	08079663          	bnez	a5,1ae10 <__pack_d+0x23c>
   1ad88:	01871793          	slli	a5,a4,0x18
   1ad8c:	00865613          	srli	a2,a2,0x8
   1ad90:	00471693          	slli	a3,a4,0x4
   1ad94:	100005b7          	lui	a1,0x10000
   1ad98:	00c7e633          	or	a2,a5,a2
   1ad9c:	00c6d693          	srli	a3,a3,0xc
   1ada0:	00100793          	li	a5,1
   1ada4:	02b76c63          	bltu	a4,a1,1addc <__pack_d+0x208>
   1ada8:	0017f793          	andi	a5,a5,1
   1adac:	ebdff06f          	j	1ac68 <__pack_d+0x94>
   1adb0:	07f60793          	addi	a5,a2,127 # fff0007f <_gp+0xffeb789f>
		fraction += GARDROUND + 1;
   1adb4:	00c7b633          	sltu	a2,a5,a2
   1adb8:	00e60733          	add	a4,a2,a4
   1adbc:	01871593          	slli	a1,a4,0x18
   1adc0:	0087d613          	srli	a2,a5,0x8
   1adc4:	00471693          	slli	a3,a4,0x4
   1adc8:	00c5e633          	or	a2,a1,a2
   1adcc:	100005b7          	lui	a1,0x10000
   1add0:	00c6d693          	srli	a3,a3,0xc
   1add4:	00100793          	li	a5,1
   1add8:	fcb778e3          	bleu	a1,a4,1ada8 <__pack_d+0x1d4>
   1addc:	00000793          	li	a5,0
   1ade0:	0017f793          	andi	a5,a5,1
   1ade4:	e85ff06f          	j	1ac68 <__pack_d+0x94>
	      fraction = 0;
	    }
	  else
	    {
	      int lowbit = (fraction & (((fractype)1 << shift) - 1)) ? 1 : 0;
	      fraction = (fraction >> shift) | lowbit;
   1ade8:	fff7c593          	not	a1,a5
   1adec:	00169713          	slli	a4,a3,0x1
   1adf0:	00b71733          	sll	a4,a4,a1
   1adf4:	00f658b3          	srl	a7,a2,a5
   1adf8:	00100513          	li	a0,1
   1adfc:	011768b3          	or	a7,a4,a7
   1ae00:	00000593          	li	a1,0
   1ae04:	00f6d733          	srl	a4,a3,a5
   1ae08:	00f517b3          	sll	a5,a0,a5
   1ae0c:	f45ff06f          	j	1ad50 <__pack_d+0x17c>
	    }
	  if ((fraction & GARDMASK) == GARDMSB)
	    {
	      if ((fraction & (1 << NGARDS)))
		fraction += GARDROUND + 1;
   1ae10:	08060793          	addi	a5,a2,128
   1ae14:	fa1ff06f          	j	1adb4 <__pack_d+0x1e0>

0001ae18 <__unpack_d>:
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
  exp = src->bits.exp;
   1ae18:	00655683          	lhu	a3,6(a0)
  sign = src->bits.sign;
   1ae1c:	00754703          	lbu	a4,7(a0)
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1ae20:	00452803          	lw	a6,4(a0)
  exp = src->bits.exp;
   1ae24:	0046d693          	srli	a3,a3,0x4
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1ae28:	001007b7          	lui	a5,0x100
  exp = ((int)(src->value_raw >> FRACBITS)) & ((1 << EXPBITS) - 1);
  sign = ((int)(src->value_raw >> (FRACBITS + EXPBITS))) & 1;
# endif
#endif

  dst->sign = sign;
   1ae2c:	00775613          	srli	a2,a4,0x7
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1ae30:	fff78793          	addi	a5,a5,-1 # fffff <_gp+0xb781f>
  exp = src->bits.exp;
   1ae34:	7ff6f693          	andi	a3,a3,2047
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1ae38:	00052703          	lw	a4,0(a0)
   1ae3c:	00f877b3          	and	a5,a6,a5
  exp = ((int)(src->value_raw >> FRACBITS)) & ((1 << EXPBITS) - 1);
  sign = ((int)(src->value_raw >> (FRACBITS + EXPBITS))) & 1;
# endif
#endif

  dst->sign = sign;
   1ae40:	00c5a223          	sw	a2,4(a1) # 10000004 <_gp+0xffb7824>
  if (exp == 0)
   1ae44:	04069c63          	bnez	a3,1ae9c <__unpack_d+0x84>
    {
      /* Hmm.  Looks like 0 */
      if (fraction == 0
   1ae48:	00f766b3          	or	a3,a4,a5
   1ae4c:	08068663          	beqz	a3,1aed8 <__unpack_d+0xc0>
	{
	  /* Zero exponent with nonzero fraction - it's denormalized,
	     so there isn't a leading implicit one - we'll shift it so
	     it gets one.  */
	  dst->normal_exp = exp - EXPBIAS + 1;
	  fraction <<= NGARDS;
   1ae50:	01875693          	srli	a3,a4,0x18
   1ae54:	00879793          	slli	a5,a5,0x8
   1ae58:	00f6e7b3          	or	a5,a3,a5

	  dst->class = CLASS_NUMBER;
   1ae5c:	00300693          	li	a3,3
   1ae60:	00d5a023          	sw	a3,0(a1)
	{
	  /* Zero exponent with nonzero fraction - it's denormalized,
	     so there isn't a leading implicit one - we'll shift it so
	     it gets one.  */
	  dst->normal_exp = exp - EXPBIAS + 1;
	  fraction <<= NGARDS;
   1ae64:	00871713          	slli	a4,a4,0x8

	  dst->class = CLASS_NUMBER;
   1ae68:	c0100693          	li	a3,-1023
#if 1
	  while (fraction < IMPLICIT_1)
   1ae6c:	10000537          	lui	a0,0x10000
	    {
	      fraction <<= 1;
   1ae70:	01f75613          	srli	a2,a4,0x1f
   1ae74:	00179793          	slli	a5,a5,0x1
   1ae78:	00f667b3          	or	a5,a2,a5
   1ae7c:	00171713          	slli	a4,a4,0x1
	      dst->normal_exp--;
   1ae80:	00068613          	mv	a2,a3
   1ae84:	fff68693          	addi	a3,a3,-1
	  dst->normal_exp = exp - EXPBIAS + 1;
	  fraction <<= NGARDS;

	  dst->class = CLASS_NUMBER;
#if 1
	  while (fraction < IMPLICIT_1)
   1ae88:	fea7e4e3          	bltu	a5,a0,1ae70 <__unpack_d+0x58>
   1ae8c:	00c5a423          	sw	a2,8(a1)
	    {
	      fraction <<= 1;
	      dst->normal_exp--;
	    }
#endif
	  dst->fraction.ll = fraction;
   1ae90:	00e5a823          	sw	a4,16(a1)
   1ae94:	00f5aa23          	sw	a5,20(a1)
   1ae98:	00008067          	ret
	}
    }
  else if (__builtin_expect (exp == EXPMAX, 0))
   1ae9c:	7ff00613          	li	a2,2047
   1aea0:	04c68263          	beq	a3,a2,1aee4 <__unpack_d+0xcc>
  else
    {
      /* Nothing strange about this number */
      dst->normal_exp = exp - EXPBIAS;
      dst->class = CLASS_NUMBER;
      dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;
   1aea4:	01875613          	srli	a2,a4,0x18
   1aea8:	00879793          	slli	a5,a5,0x8
   1aeac:	00f667b3          	or	a5,a2,a5
	}
    }
  else
    {
      /* Nothing strange about this number */
      dst->normal_exp = exp - EXPBIAS;
   1aeb0:	c0168693          	addi	a3,a3,-1023
      dst->class = CLASS_NUMBER;
      dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;
   1aeb4:	10000637          	lui	a2,0x10000
   1aeb8:	00871713          	slli	a4,a4,0x8
   1aebc:	00c7e7b3          	or	a5,a5,a2
	}
    }
  else
    {
      /* Nothing strange about this number */
      dst->normal_exp = exp - EXPBIAS;
   1aec0:	00d5a423          	sw	a3,8(a1)
      dst->class = CLASS_NUMBER;
   1aec4:	00300693          	li	a3,3
   1aec8:	00d5a023          	sw	a3,0(a1)
      dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;
   1aecc:	00e5a823          	sw	a4,16(a1)
   1aed0:	00f5aa23          	sw	a5,20(a1)
   1aed4:	00008067          	ret
	  || 1
#endif
	  )
	{
	  /* tastes like zero */
	  dst->class = CLASS_ZERO;
   1aed8:	00200793          	li	a5,2
   1aedc:	00f5a023          	sw	a5,0(a1)
   1aee0:	00008067          	ret
	}
    }
  else if (__builtin_expect (exp == EXPMAX, 0))
    {
      /* Huge exponent*/
      if (fraction == 0)
   1aee4:	00f766b3          	or	a3,a4,a5
   1aee8:	02068e63          	beqz	a3,1af24 <__unpack_d+0x10c>
	{
	  /* Nonzero fraction, means nan */
#ifdef QUIET_NAN_NEGATED
	  if ((fraction & QUIET_NAN) == 0)
#else
	  if (fraction & QUIET_NAN)
   1aeec:	00c79693          	slli	a3,a5,0xc
   1aef0:	0406d063          	bgez	a3,1af30 <__unpack_d+0x118>
#endif
	    {
	      dst->class = CLASS_QNAN;
   1aef4:	00100693          	li	a3,1
   1aef8:	00d5a023          	sw	a3,0(a1)
	      dst->class = CLASS_SNAN;
	    }
	  /* Now that we know which kind of NaN we got, discard the
	     quiet/signaling bit, but do preserve the NaN payload.  */
	  fraction &= ~QUIET_NAN;
	  dst->fraction.ll = fraction << NGARDS;
   1aefc:	fff806b7          	lui	a3,0xfff80
   1af00:	fff68693          	addi	a3,a3,-1 # fff7ffff <_gp+0xfff3781f>
   1af04:	00d7f7b3          	and	a5,a5,a3
   1af08:	00879793          	slli	a5,a5,0x8
   1af0c:	01875693          	srli	a3,a4,0x18
   1af10:	00d7e7b3          	or	a5,a5,a3
   1af14:	00871713          	slli	a4,a4,0x8
   1af18:	00f5aa23          	sw	a5,20(a1)
   1af1c:	00e5a823          	sw	a4,16(a1)
   1af20:	00008067          	ret
    {
      /* Huge exponent*/
      if (fraction == 0)
	{
	  /* Attached to a zero fraction - means infinity */
	  dst->class = CLASS_INFINITY;
   1af24:	00400793          	li	a5,4
   1af28:	00f5a023          	sw	a5,0(a1)
   1af2c:	00008067          	ret
	    {
	      dst->class = CLASS_QNAN;
	    }
	  else
	    {
	      dst->class = CLASS_SNAN;
   1af30:	0005a023          	sw	zero,0(a1)
   1af34:	fc9ff06f          	j	1aefc <__unpack_d+0xe4>

0001af38 <__adddf3>:
  return tmp;
}

FLO_type
add (FLO_type arg_a, FLO_type arg_b)
{
   1af38:	f9010113          	addi	sp,sp,-112
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1af3c:	00a12423          	sw	a0,8(sp)
   1af40:	00b12623          	sw	a1,12(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1af44:	00810513          	addi	a0,sp,8
   1af48:	01810593          	addi	a1,sp,24
  return tmp;
}

FLO_type
add (FLO_type arg_a, FLO_type arg_b)
{
   1af4c:	06112623          	sw	ra,108(sp)
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1af50:	00d12a23          	sw	a3,20(sp)
   1af54:	00c12823          	sw	a2,16(sp)

  unpack_d (&au, &a);
   1af58:	ec1ff0ef          	jal	1ae18 <__unpack_d>
  unpack_d (&bu, &b);
   1af5c:	03010593          	addi	a1,sp,48
   1af60:	01010513          	addi	a0,sp,16
   1af64:	eb5ff0ef          	jal	1ae18 <__unpack_d>

  res = _fpadd_parts (&a, &b, &tmp);
   1af68:	04810613          	addi	a2,sp,72
   1af6c:	03010593          	addi	a1,sp,48
   1af70:	01810513          	addi	a0,sp,24
   1af74:	911ff0ef          	jal	1a884 <_fpadd_parts>

  return pack_d (res);
   1af78:	c5dff0ef          	jal	1abd4 <__pack_d>
}
   1af7c:	06c12083          	lw	ra,108(sp)
   1af80:	07010113          	addi	sp,sp,112
   1af84:	00008067          	ret

0001af88 <__subdf3>:

FLO_type
sub (FLO_type arg_a, FLO_type arg_b)
{
   1af88:	f9010113          	addi	sp,sp,-112
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1af8c:	00a12423          	sw	a0,8(sp)
   1af90:	00b12623          	sw	a1,12(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1af94:	00810513          	addi	a0,sp,8
   1af98:	01810593          	addi	a1,sp,24
  return pack_d (res);
}

FLO_type
sub (FLO_type arg_a, FLO_type arg_b)
{
   1af9c:	06112623          	sw	ra,108(sp)
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1afa0:	00d12a23          	sw	a3,20(sp)
   1afa4:	00c12823          	sw	a2,16(sp)

  unpack_d (&au, &a);
   1afa8:	e71ff0ef          	jal	1ae18 <__unpack_d>
  unpack_d (&bu, &b);
   1afac:	03010593          	addi	a1,sp,48
   1afb0:	01010513          	addi	a0,sp,16
   1afb4:	e65ff0ef          	jal	1ae18 <__unpack_d>

  b.sign ^= 1;
   1afb8:	03412783          	lw	a5,52(sp)

  res = _fpadd_parts (&a, &b, &tmp);
   1afbc:	04810613          	addi	a2,sp,72
   1afc0:	03010593          	addi	a1,sp,48
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  b.sign ^= 1;
   1afc4:	0017c793          	xori	a5,a5,1

  res = _fpadd_parts (&a, &b, &tmp);
   1afc8:	01810513          	addi	a0,sp,24
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  b.sign ^= 1;
   1afcc:	02f12a23          	sw	a5,52(sp)

  res = _fpadd_parts (&a, &b, &tmp);
   1afd0:	8b5ff0ef          	jal	1a884 <_fpadd_parts>

  return pack_d (res);
   1afd4:	c01ff0ef          	jal	1abd4 <__pack_d>
}
   1afd8:	06c12083          	lw	ra,108(sp)
   1afdc:	07010113          	addi	sp,sp,112
   1afe0:	00008067          	ret

0001afe4 <__muldf3>:
  return tmp;
}

FLO_type
multiply (FLO_type arg_a, FLO_type arg_b)
{
   1afe4:	f9010113          	addi	sp,sp,-112
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1afe8:	00a12423          	sw	a0,8(sp)
   1afec:	00b12623          	sw	a1,12(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1aff0:	00810513          	addi	a0,sp,8
   1aff4:	01810593          	addi	a1,sp,24
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1aff8:	00d12a23          	sw	a3,20(sp)
  return tmp;
}

FLO_type
multiply (FLO_type arg_a, FLO_type arg_b)
{
   1affc:	06112623          	sw	ra,108(sp)
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1b000:	00c12823          	sw	a2,16(sp)

  unpack_d (&au, &a);
   1b004:	e15ff0ef          	jal	1ae18 <__unpack_d>
  unpack_d (&bu, &b);
   1b008:	03010593          	addi	a1,sp,48
   1b00c:	01010513          	addi	a0,sp,16
   1b010:	e09ff0ef          	jal	1ae18 <__unpack_d>
   1b014:	01812783          	lw	a5,24(sp)
	       fp_number_type * tmp)
{
  fractype low = 0;
  fractype high = 0;

  if (isnan (a))
   1b018:	00100693          	li	a3,1
   1b01c:	16f6fc63          	bleu	a5,a3,1b194 <__muldf3+0x1b0>
   1b020:	03012703          	lw	a4,48(sp)
    {
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isnan (b))
   1b024:	14e6f063          	bleu	a4,a3,1b164 <__muldf3+0x180>
    {
      b->sign = a->sign != b->sign;
      return b;
    }
  if (isinf (a))
   1b028:	00400693          	li	a3,4
   1b02c:	16d78063          	beq	a5,a3,1b18c <__muldf3+0x1a8>
      if (iszero (b))
	return makenan ();
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isinf (b))
   1b030:	12d70663          	beq	a4,a3,1b15c <__muldf3+0x178>
	  return makenan ();
	}
      b->sign = a->sign != b->sign;
      return b;
    }
  if (iszero (a))
   1b034:	00200693          	li	a3,2
   1b038:	14d78e63          	beq	a5,a3,1b194 <__muldf3+0x1b0>
    {
      a->sign = a->sign != b->sign;
      return a;
    }
  if (iszero (b))
   1b03c:	12d70463          	beq	a4,a3,1b164 <__muldf3+0x180>
#else
    /* fractype is DImode, but we need the result to be twice as wide.
       Assuming a widening multiply from DImode to TImode is not
       available, build one by hand.  */
    {
      USItype nl = a->fraction.ll;
   1b040:	02812503          	lw	a0,40(sp)
   1b044:	02c12703          	lw	a4,44(sp)
      USItype nh = a->fraction.ll >> BITS_PER_SI;
      USItype ml = b->fraction.ll;
   1b048:	04012783          	lw	a5,64(sp)
   1b04c:	04412803          	lw	a6,68(sp)
      UDItype pp_hl = (UDItype) mh * nl;
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
      UDItype res2 = 0;
      UDItype res0 = 0;
      UDItype ps_hh__ = pp_hl + pp_lh;
   1b050:	02f70633          	mul	a2,a4,a5
      USItype nl = a->fraction.ll;
      USItype nh = a->fraction.ll >> BITS_PER_SI;
      USItype ml = b->fraction.ll;
      USItype mh = b->fraction.ll >> BITS_PER_SI;
      UDItype pp_ll = (UDItype) ml * nl;
      UDItype pp_hl = (UDItype) mh * nl;
   1b054:	02a803b3          	mul	t2,a6,a0
   1b058:	02a832b3          	mulhu	t0,a6,a0
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
      UDItype res2 = 0;
      UDItype res0 = 0;
      UDItype ps_hh__ = pp_hl + pp_lh;
   1b05c:	00760333          	add	t1,a2,t2
   1b060:	00c33633          	sltu	a2,t1,a2
   1b064:	02f735b3          	mulhu	a1,a4,a5
   1b068:	005585b3          	add	a1,a1,t0
   1b06c:	00b60633          	add	a2,a2,a1
      USItype ml = b->fraction.ll;
      USItype mh = b->fraction.ll >> BITS_PER_SI;
      UDItype pp_ll = (UDItype) ml * nl;
      UDItype pp_hl = (UDItype) mh * nl;
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
   1b070:	030708b3          	mul	a7,a4,a6
    {
      USItype nl = a->fraction.ll;
      USItype nh = a->fraction.ll >> BITS_PER_SI;
      USItype ml = b->fraction.ll;
      USItype mh = b->fraction.ll >> BITS_PER_SI;
      UDItype pp_ll = (UDItype) ml * nl;
   1b074:	02a785b3          	mul	a1,a5,a0
      UDItype pp_hl = (UDItype) mh * nl;
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
   1b078:	03073833          	mulhu	a6,a4,a6
    {
      USItype nl = a->fraction.ll;
      USItype nh = a->fraction.ll >> BITS_PER_SI;
      USItype ml = b->fraction.ll;
      USItype mh = b->fraction.ll >> BITS_PER_SI;
      UDItype pp_ll = (UDItype) ml * nl;
   1b07c:	02a7b533          	mulhu	a0,a5,a0
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
      UDItype res2 = 0;
      UDItype res0 = 0;
      UDItype ps_hh__ = pp_hl + pp_lh;
      if (ps_hh__ < pp_hl)
   1b080:	14566063          	bltu	a2,t0,1b1c0 <__muldf3+0x1dc>
   1b084:	12c28c63          	beq	t0,a2,1b1bc <__muldf3+0x1d8>
      USItype mh = b->fraction.ll >> BITS_PER_SI;
      UDItype pp_ll = (UDItype) ml * nl;
      UDItype pp_hl = (UDItype) mh * nl;
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
      UDItype res2 = 0;
   1b088:	00000793          	li	a5,0
   1b08c:	00000713          	li	a4,0
      UDItype res0 = 0;
      UDItype ps_hh__ = pp_hl + pp_lh;
      if (ps_hh__ < pp_hl)
	res2 += (UDItype)1 << BITS_PER_SI;
      pp_hl = (UDItype)(USItype)ps_hh__ << BITS_PER_SI;
      res0 = pp_ll + pp_hl;
   1b090:	00a306b3          	add	a3,t1,a0
      if (res0 < pp_ll)
   1b094:	00a6f463          	bleu	a0,a3,1b09c <__muldf3+0xb8>
	res2++;
   1b098:	00100793          	li	a5,1
      res2 += (ps_hh__ >> BITS_PER_SI) + pp_hh;
   1b09c:	011608b3          	add	a7,a2,a7
   1b0a0:	00c8b533          	sltu	a0,a7,a2
   1b0a4:	01050833          	add	a6,a0,a6
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1b0a8:	02012603          	lw	a2,32(sp)
   1b0ac:	03812503          	lw	a0,56(sp)
	res2 += (UDItype)1 << BITS_PER_SI;
      pp_hl = (UDItype)(USItype)ps_hh__ << BITS_PER_SI;
      res0 = pp_ll + pp_hl;
      if (res0 < pp_ll)
	res2++;
      res2 += (ps_hh__ >> BITS_PER_SI) + pp_hh;
   1b0b0:	00f887b3          	add	a5,a7,a5
   1b0b4:	0117b8b3          	sltu	a7,a5,a7
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1b0b8:	00a60533          	add	a0,a2,a0
	res2 += (UDItype)1 << BITS_PER_SI;
      pp_hl = (UDItype)(USItype)ps_hh__ << BITS_PER_SI;
      res0 = pp_ll + pp_hl;
      if (res0 < pp_ll)
	res2++;
      res2 += (ps_hh__ >> BITS_PER_SI) + pp_hh;
   1b0bc:	00e80633          	add	a2,a6,a4
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
   1b0c0:	01c12703          	lw	a4,28(sp)
   1b0c4:	03412803          	lw	a6,52(sp)
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1b0c8:	00450293          	addi	t0,a0,4 # 10000004 <_gp+0xffb7824>
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
  while (high >= IMPLICIT_2)
   1b0cc:	200003b7          	lui	t2,0x20000
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
   1b0d0:	41070833          	sub	a6,a4,a6
   1b0d4:	01003833          	snez	a6,a6
	res2 += (UDItype)1 << BITS_PER_SI;
      pp_hl = (UDItype)(USItype)ps_hh__ << BITS_PER_SI;
      res0 = pp_ll + pp_hl;
      if (res0 < pp_ll)
	res2++;
      res2 += (ps_hh__ >> BITS_PER_SI) + pp_hh;
   1b0d8:	00c88733          	add	a4,a7,a2
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1b0dc:	04512823          	sw	t0,80(sp)
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
   1b0e0:	05012623          	sw	a6,76(sp)
   1b0e4:	00550613          	addi	a2,a0,5
    {
      tmp->normal_exp++;
      if (high & 1)
	{
	  low >>= 1;
	  low |= FRACHIGH;
   1b0e8:	80000eb7          	lui	t4,0x80000
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
  while (high >= IMPLICIT_2)
   1b0ec:	10776863          	bltu	a4,t2,1b1fc <__muldf3+0x218>
    {
      tmp->normal_exp++;
      if (high & 1)
   1b0f0:	0017f813          	andi	a6,a5,1
	{
	  low >>= 1;
	  low |= FRACHIGH;
	}
      high >>= 1;
   1b0f4:	01f71513          	slli	a0,a4,0x1f
   1b0f8:	0017d793          	srli	a5,a5,0x1
   1b0fc:	00175713          	srli	a4,a4,0x1
  while (high >= IMPLICIT_2)
    {
      tmp->normal_exp++;
      if (high & 1)
	{
	  low >>= 1;
   1b100:	01f69313          	slli	t1,a3,0x1f
   1b104:	0015d293          	srli	t0,a1,0x1
   1b108:	0016d893          	srli	a7,a3,0x1
  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
  while (high >= IMPLICIT_2)
    {
      tmp->normal_exp++;
   1b10c:	00060e13          	mv	t3,a2
      if (high & 1)
   1b110:	00080663          	beqz	a6,1b11c <__muldf3+0x138>
	{
	  low >>= 1;
	  low |= FRACHIGH;
   1b114:	005365b3          	or	a1,t1,t0
   1b118:	01d8e6b3          	or	a3,a7,t4
	}
      high >>= 1;
   1b11c:	00f567b3          	or	a5,a0,a5
   1b120:	00160613          	addi	a2,a2,1 # 10000001 <_gp+0xffb7821>
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
  while (high >= IMPLICIT_2)
   1b124:	fc7776e3          	bleu	t2,a4,1b0f0 <__muldf3+0x10c>
   1b128:	05c12823          	sw	t3,80(sp)
      if (low & FRACHIGH)
	high |= 1;
      low <<= 1;
    }

  if ((high & GARDMASK) == GARDMSB)
   1b12c:	0ff7f613          	andi	a2,a5,255
   1b130:	08000513          	li	a0,128
   1b134:	08a60c63          	beq	a2,a0,1b1cc <__muldf3+0x1e8>

	  /* Avoid further rounding in pack_d.  */
	  high &= ~(fractype) GARDMASK;
	}
    }
  tmp->fraction.ll = high;
   1b138:	04f12c23          	sw	a5,88(sp)
  tmp->class = CLASS_NUMBER;
   1b13c:	00300793          	li	a5,3

	  /* Avoid further rounding in pack_d.  */
	  high &= ~(fractype) GARDMASK;
	}
    }
  tmp->fraction.ll = high;
   1b140:	04e12e23          	sw	a4,92(sp)
  tmp->class = CLASS_NUMBER;
   1b144:	04f12423          	sw	a5,72(sp)
  return tmp;
   1b148:	04810513          	addi	a0,sp,72
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
   1b14c:	a89ff0ef          	jal	1abd4 <__pack_d>
}
   1b150:	06c12083          	lw	ra,108(sp)
   1b154:	07010113          	addi	sp,sp,112
   1b158:	00008067          	ret
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isinf (b))
    {
      if (iszero (a))
   1b15c:	00200713          	li	a4,2
   1b160:	08e78863          	beq	a5,a4,1b1f0 <__muldf3+0x20c>
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isnan (b))
    {
      b->sign = a->sign != b->sign;
   1b164:	03412703          	lw	a4,52(sp)
   1b168:	01c12783          	lw	a5,28(sp)
      return b;
   1b16c:	03010513          	addi	a0,sp,48
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isnan (b))
    {
      b->sign = a->sign != b->sign;
   1b170:	40e787b3          	sub	a5,a5,a4
   1b174:	00f037b3          	snez	a5,a5
   1b178:	02f12a23          	sw	a5,52(sp)
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
   1b17c:	a59ff0ef          	jal	1abd4 <__pack_d>
}
   1b180:	06c12083          	lw	ra,108(sp)
   1b184:	07010113          	addi	sp,sp,112
   1b188:	00008067          	ret
      b->sign = a->sign != b->sign;
      return b;
    }
  if (isinf (a))
    {
      if (iszero (b))
   1b18c:	00200793          	li	a5,2
   1b190:	06f70063          	beq	a4,a5,1b1f0 <__muldf3+0x20c>
  fractype low = 0;
  fractype high = 0;

  if (isnan (a))
    {
      a->sign = a->sign != b->sign;
   1b194:	03412703          	lw	a4,52(sp)
   1b198:	01c12783          	lw	a5,28(sp)
      return a;
   1b19c:	01810513          	addi	a0,sp,24
  fractype low = 0;
  fractype high = 0;

  if (isnan (a))
    {
      a->sign = a->sign != b->sign;
   1b1a0:	40e787b3          	sub	a5,a5,a4
   1b1a4:	00f037b3          	snez	a5,a5
   1b1a8:	00f12e23          	sw	a5,28(sp)
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
   1b1ac:	a29ff0ef          	jal	1abd4 <__pack_d>
}
   1b1b0:	06c12083          	lw	ra,108(sp)
   1b1b4:	07010113          	addi	sp,sp,112
   1b1b8:	00008067          	ret
      UDItype pp_lh = (UDItype) ml * nh;
      UDItype pp_hh = (UDItype) mh * nh;
      UDItype res2 = 0;
      UDItype res0 = 0;
      UDItype ps_hh__ = pp_hl + pp_lh;
      if (ps_hh__ < pp_hl)
   1b1bc:	ec7376e3          	bleu	t2,t1,1b088 <__muldf3+0xa4>
	res2 += (UDItype)1 << BITS_PER_SI;
   1b1c0:	00000793          	li	a5,0
   1b1c4:	00100713          	li	a4,1
   1b1c8:	ec9ff06f          	j	1b090 <__muldf3+0xac>
      low <<= 1;
    }

  if ((high & GARDMASK) == GARDMSB)
    {
      if (high & (1 << NGARDS))
   1b1cc:	1007f613          	andi	a2,a5,256
   1b1d0:	f60614e3          	bnez	a2,1b138 <__muldf3+0x154>
	     function, and rounding twice will lose precision and cause
	     the result to be too far off.  Example: 32-bit floats with
	     bit patterns 0xfff * 0x3f800400 ~= 0xfff (less than 0.5ulp
	     off), not 0x1000 (more than 0.5ulp off).  */
	}
      else if (low)
   1b1d4:	00d5e6b3          	or	a3,a1,a3
   1b1d8:	f60680e3          	beqz	a3,1b138 <__muldf3+0x154>
	{
	  /* We're a further than half way by a small amount corresponding
	     to the bits set in "low".  Knowing that, we round here and
	     not in pack_d, because there we don't have "low" available
	     anymore.  */
	  high += GARDROUND + 1;
   1b1dc:	00a786b3          	add	a3,a5,a0
   1b1e0:	00f6b7b3          	sltu	a5,a3,a5

	  /* Avoid further rounding in pack_d.  */
	  high &= ~(fractype) GARDMASK;
   1b1e4:	00e78733          	add	a4,a5,a4
   1b1e8:	f006f793          	andi	a5,a3,-256
   1b1ec:	f4dff06f          	j	1b138 <__muldf3+0x154>
      return b;
    }
  if (isinf (a))
    {
      if (iszero (b))
	return makenan ();
   1b1f0:	0001d537          	lui	a0,0x1d
   1b1f4:	cc850513          	addi	a0,a0,-824 # 1ccc8 <__thenan_df>
   1b1f8:	f55ff06f          	j	1b14c <__muldf3+0x168>
	  low >>= 1;
	  low |= FRACHIGH;
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
   1b1fc:	10000337          	lui	t1,0x10000
   1b200:	00350513          	addi	a0,a0,3
   1b204:	f26774e3          	bleu	t1,a4,1b12c <__muldf3+0x148>
    {
      tmp->normal_exp--;

      high <<= 1;
   1b208:	01f7d813          	srli	a6,a5,0x1f
   1b20c:	00171613          	slli	a2,a4,0x1
   1b210:	00c86633          	or	a2,a6,a2
      if (low & FRACHIGH)
	high |= 1;
      low <<= 1;
   1b214:	01f5d893          	srli	a7,a1,0x1f
   1b218:	00169813          	slli	a6,a3,0x1
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
    {
      tmp->normal_exp--;
   1b21c:	00050293          	mv	t0,a0

      high <<= 1;
   1b220:	00179793          	slli	a5,a5,0x1
   1b224:	00060713          	mv	a4,a2
      if (low & FRACHIGH)
   1b228:	0006d463          	bgez	a3,1b230 <__muldf3+0x24c>
	high |= 1;
   1b22c:	0017e793          	ori	a5,a5,1
      low <<= 1;
   1b230:	00159593          	slli	a1,a1,0x1
   1b234:	0108e6b3          	or	a3,a7,a6
   1b238:	fff50513          	addi	a0,a0,-1
	  low >>= 1;
	  low |= FRACHIGH;
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
   1b23c:	fc6666e3          	bltu	a2,t1,1b208 <__muldf3+0x224>
   1b240:	04512823          	sw	t0,80(sp)
   1b244:	ee9ff06f          	j	1b12c <__muldf3+0x148>

0001b248 <__divdf3>:
  }
}

FLO_type
divide (FLO_type arg_a, FLO_type arg_b)
{
   1b248:	fb010113          	addi	sp,sp,-80
  fp_number_type a;
  fp_number_type b;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1b24c:	00a12023          	sw	a0,0(sp)
   1b250:	00b12223          	sw	a1,4(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1b254:	00010513          	mv	a0,sp
   1b258:	01010593          	addi	a1,sp,16
  fp_number_type b;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1b25c:	00c12423          	sw	a2,8(sp)
  }
}

FLO_type
divide (FLO_type arg_a, FLO_type arg_b)
{
   1b260:	04112623          	sw	ra,76(sp)
  fp_number_type b;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1b264:	00d12623          	sw	a3,12(sp)

  unpack_d (&au, &a);
   1b268:	bb1ff0ef          	jal	1ae18 <__unpack_d>
  unpack_d (&bu, &b);
   1b26c:	02810593          	addi	a1,sp,40
   1b270:	00810513          	addi	a0,sp,8
   1b274:	ba5ff0ef          	jal	1ae18 <__unpack_d>
   1b278:	01012603          	lw	a2,16(sp)
  fractype bit;
  fractype numerator;
  fractype denominator;
  fractype quotient;

  if (isnan (a))
   1b27c:	00100793          	li	a5,1
   1b280:	0ec7fa63          	bleu	a2,a5,1b374 <__divdf3+0x12c>
   1b284:	02812683          	lw	a3,40(sp)
    {
      return a;
    }
  if (isnan (b))
   1b288:	14d7fe63          	bleu	a3,a5,1b3e4 <__divdf3+0x19c>
    {
      return b;
    }

  a->sign = a->sign ^ b->sign;
   1b28c:	01412583          	lw	a1,20(sp)
   1b290:	02c12703          	lw	a4,44(sp)

  if (isinf (a) || iszero (a))
   1b294:	ffe60793          	addi	a5,a2,-2
   1b298:	ffd7f793          	andi	a5,a5,-3
  if (isnan (b))
    {
      return b;
    }

  a->sign = a->sign ^ b->sign;
   1b29c:	00e5c733          	xor	a4,a1,a4
   1b2a0:	00e12a23          	sw	a4,20(sp)

  if (isinf (a) || iszero (a))
   1b2a4:	0e078263          	beqz	a5,1b388 <__divdf3+0x140>
      if (a->class == b->class)
	return makenan ();
      return a;
    }

  if (isinf (b))
   1b2a8:	00400793          	li	a5,4
   1b2ac:	0ef68663          	beq	a3,a5,1b398 <__divdf3+0x150>
    {
      a->fraction.ll = 0;
      a->normal_exp = 0;
      return a;
    }
  if (iszero (b))
   1b2b0:	00200713          	li	a4,2
   1b2b4:	12e68263          	beq	a3,a4,1b3d8 <__divdf3+0x190>
  {
    /* quotient =
       ( numerator / denominator) * 2^(numerator exponent -  denominator exponent)
     */

    a->normal_exp = a->normal_exp - b->normal_exp;
   1b2b8:	01812703          	lw	a4,24(sp)
   1b2bc:	03012603          	lw	a2,48(sp)
    numerator = a->fraction.ll;
   1b2c0:	02412783          	lw	a5,36(sp)
    denominator = b->fraction.ll;
   1b2c4:	03c12883          	lw	a7,60(sp)
  {
    /* quotient =
       ( numerator / denominator) * 2^(numerator exponent -  denominator exponent)
     */

    a->normal_exp = a->normal_exp - b->normal_exp;
   1b2c8:	40c70633          	sub	a2,a4,a2
   1b2cc:	00c12c23          	sw	a2,24(sp)
    numerator = a->fraction.ll;
   1b2d0:	02012683          	lw	a3,32(sp)
    denominator = b->fraction.ll;
   1b2d4:	03812f03          	lw	t5,56(sp)

    if (numerator < denominator)
   1b2d8:	0117e663          	bltu	a5,a7,1b2e4 <__divdf3+0x9c>
   1b2dc:	02f89063          	bne	a7,a5,1b2fc <__divdf3+0xb4>
   1b2e0:	01e6fe63          	bleu	t5,a3,1b2fc <__divdf3+0xb4>
      {
	/* Fraction will be less than 1.0 */
	numerator *= 2;
   1b2e4:	01f6d593          	srli	a1,a3,0x1f
   1b2e8:	00179713          	slli	a4,a5,0x1
	a->normal_exp--;
   1b2ec:	fff60613          	addi	a2,a2,-1
    denominator = b->fraction.ll;

    if (numerator < denominator)
      {
	/* Fraction will be less than 1.0 */
	numerator *= 2;
   1b2f0:	00e5e7b3          	or	a5,a1,a4
   1b2f4:	00169693          	slli	a3,a3,0x1
	a->normal_exp--;
   1b2f8:	00c12c23          	sw	a2,24(sp)
  }
}

FLO_type
divide (FLO_type arg_a, FLO_type arg_b)
{
   1b2fc:	03d00513          	li	a0,61
	/* Fraction will be less than 1.0 */
	numerator *= 2;
	a->normal_exp--;
      }
    bit = IMPLICIT_1;
    quotient = 0;
   1b300:	00000393          	li	t2,0
   1b304:	00000e13          	li	t3,0
      {
	/* Fraction will be less than 1.0 */
	numerator *= 2;
	a->normal_exp--;
      }
    bit = IMPLICIT_1;
   1b308:	00000813          	li	a6,0
   1b30c:	100005b7          	lui	a1,0x10000
	if (numerator >= denominator)
	  {
	    quotient |= bit;
	    numerator -= denominator;
	  }
	bit >>= 1;
   1b310:	01f59313          	slli	t1,a1,0x1f
   1b314:	00185293          	srli	t0,a6,0x1
   1b318:	fff50513          	addi	a0,a0,-1
    bit = IMPLICIT_1;
    quotient = 0;
    /* ??? Does divide one bit at a time.  Optimize.  */
    while (bit)
      {
	if (numerator >= denominator)
   1b31c:	0317e463          	bltu	a5,a7,1b344 <__divdf3+0xfc>
	  {
	    quotient |= bit;
	    numerator -= denominator;
   1b320:	41e68733          	sub	a4,a3,t5
   1b324:	00e6b633          	sltu	a2,a3,a4
   1b328:	41178eb3          	sub	t4,a5,a7
    bit = IMPLICIT_1;
    quotient = 0;
    /* ??? Does divide one bit at a time.  Optimize.  */
    while (bit)
      {
	if (numerator >= denominator)
   1b32c:	00f89463          	bne	a7,a5,1b334 <__divdf3+0xec>
   1b330:	01e6ea63          	bltu	a3,t5,1b344 <__divdf3+0xfc>
	  {
	    quotient |= bit;
	    numerator -= denominator;
   1b334:	00070693          	mv	a3,a4
   1b338:	40ce87b3          	sub	a5,t4,a2
    /* ??? Does divide one bit at a time.  Optimize.  */
    while (bit)
      {
	if (numerator >= denominator)
	  {
	    quotient |= bit;
   1b33c:	0103e3b3          	or	t2,t2,a6
   1b340:	00be6e33          	or	t3,t3,a1
	    numerator -= denominator;
	  }
	bit >>= 1;
	numerator *= 2;
   1b344:	01f6d613          	srli	a2,a3,0x1f
   1b348:	00179713          	slli	a4,a5,0x1
	if (numerator >= denominator)
	  {
	    quotient |= bit;
	    numerator -= denominator;
	  }
	bit >>= 1;
   1b34c:	00536833          	or	a6,t1,t0
   1b350:	0015d593          	srli	a1,a1,0x1
	numerator *= 2;
   1b354:	00e667b3          	or	a5,a2,a4
   1b358:	00169693          	slli	a3,a3,0x1
	a->normal_exp--;
      }
    bit = IMPLICIT_1;
    quotient = 0;
    /* ??? Does divide one bit at a time.  Optimize.  */
    while (bit)
   1b35c:	fa051ae3          	bnez	a0,1b310 <__divdf3+0xc8>
	  }
	bit >>= 1;
	numerator *= 2;
      }

    if ((quotient & GARDMASK) == GARDMSB)
   1b360:	0ff3f713          	andi	a4,t2,255
   1b364:	08000613          	li	a2,128
   1b368:	04c70663          	beq	a4,a2,1b3b4 <__divdf3+0x16c>
	    /* Avoid further rounding in pack_d.  */
	    quotient &= ~(fractype) GARDMASK;
	  }
      }

    a->fraction.ll = quotient;
   1b36c:	02712023          	sw	t2,32(sp)
   1b370:	03c12223          	sw	t3,36(sp)
    return (a);
   1b374:	01010513          	addi	a0,sp,16
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpdiv_parts (&a, &b);

  return pack_d (res);
   1b378:	85dff0ef          	jal	1abd4 <__pack_d>
}
   1b37c:	04c12083          	lw	ra,76(sp)
   1b380:	05010113          	addi	sp,sp,80
   1b384:	00008067          	ret

  a->sign = a->sign ^ b->sign;

  if (isinf (a) || iszero (a))
    {
      if (a->class == b->class)
   1b388:	fed616e3          	bne	a2,a3,1b374 <__divdf3+0x12c>
	return makenan ();
   1b38c:	0001d537          	lui	a0,0x1d
   1b390:	cc850513          	addi	a0,a0,-824 # 1ccc8 <__thenan_df>
   1b394:	fe5ff06f          	j	1b378 <__divdf3+0x130>
      return a;
    }

  if (isinf (b))
    {
      a->fraction.ll = 0;
   1b398:	00000713          	li	a4,0
   1b39c:	00000793          	li	a5,0
   1b3a0:	02e12023          	sw	a4,32(sp)
   1b3a4:	02f12223          	sw	a5,36(sp)
      a->normal_exp = 0;
   1b3a8:	00012c23          	sw	zero,24(sp)
      return a;
   1b3ac:	01010513          	addi	a0,sp,16
   1b3b0:	fc9ff06f          	j	1b378 <__divdf3+0x130>
	numerator *= 2;
      }

    if ((quotient & GARDMASK) == GARDMSB)
      {
	if (quotient & (1 << NGARDS))
   1b3b4:	1003f713          	andi	a4,t2,256
   1b3b8:	fa071ae3          	bnez	a4,1b36c <__divdf3+0x124>
	    /* Because we're half way, we would round to even by adding
	       GARDROUND + 1, except that's also done in the packing
	       function, and rounding twice will lose precision and cause
	       the result to be too far off.  */
	  }
	else if (numerator)
   1b3bc:	00f6e7b3          	or	a5,a3,a5
   1b3c0:	fa0786e3          	beqz	a5,1b36c <__divdf3+0x124>
	  {
	    /* We're a further than half way by the small amount
	       corresponding to the bits set in "numerator".  Knowing
	       that, we round here and not in pack_d, because there we
	       don't have "numerator" available anymore.  */
	    quotient += GARDROUND + 1;
   1b3c4:	00c387b3          	add	a5,t2,a2
   1b3c8:	0077b3b3          	sltu	t2,a5,t2

	    /* Avoid further rounding in pack_d.  */
	    quotient &= ~(fractype) GARDMASK;
   1b3cc:	01c38e33          	add	t3,t2,t3
   1b3d0:	f007f393          	andi	t2,a5,-256
   1b3d4:	f99ff06f          	j	1b36c <__divdf3+0x124>
      a->normal_exp = 0;
      return a;
    }
  if (iszero (b))
    {
      a->class = CLASS_INFINITY;
   1b3d8:	00f12823          	sw	a5,16(sp)
      return a;
   1b3dc:	01010513          	addi	a0,sp,16
   1b3e0:	f99ff06f          	j	1b378 <__divdf3+0x130>
    {
      return a;
    }
  if (isnan (b))
    {
      return b;
   1b3e4:	02810513          	addi	a0,sp,40
   1b3e8:	f91ff06f          	j	1b378 <__divdf3+0x130>

0001b3ec <__fpcmp_parts_d>:
   a>b -> +1
 */

int
__fpcmp_parts (fp_number_type * a, fp_number_type * b)
{
   1b3ec:	00052703          	lw	a4,0(a0)
    {
      return 1;			/* still unordered! */
    }
#endif

  if (isnan (a) || isnan (b))
   1b3f0:	00100793          	li	a5,1
   a>b -> +1
 */

int
__fpcmp_parts (fp_number_type * a, fp_number_type * b)
{
   1b3f4:	00050613          	mv	a2,a0
    {
      return 1;			/* still unordered! */
    }
#endif

  if (isnan (a) || isnan (b))
   1b3f8:	08e7f263          	bleu	a4,a5,1b47c <__fpcmp_parts_d+0x90>
   1b3fc:	0005a683          	lw	a3,0(a1) # 10000000 <_gp+0xffb7820>
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1b400:	00078513          	mv	a0,a5
    {
      return 1;			/* still unordered! */
    }
#endif

  if (isnan (a) || isnan (b))
   1b404:	04d7f263          	bleu	a3,a5,1b448 <__fpcmp_parts_d+0x5c>
    {
      return 1;			/* how to indicate unordered compare? */
    }
  if (isinf (a) && isinf (b))
   1b408:	00400793          	li	a5,4
   1b40c:	04f70c63          	beq	a4,a5,1b464 <__fpcmp_parts_d+0x78>
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
    }
  if (isinf (b))
   1b410:	04f68063          	beq	a3,a5,1b450 <__fpcmp_parts_d+0x64>
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (a) && iszero (b))
   1b414:	00200793          	li	a5,2
   1b418:	02f70a63          	beq	a4,a5,1b44c <__fpcmp_parts_d+0x60>
    }
  if (iszero (a))
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (b))
   1b41c:	04f68663          	beq	a3,a5,1b468 <__fpcmp_parts_d+0x7c>
    {
      return a->sign ? -1 : 1;
    }
  /* now both are "normal".  */
  if (a->sign != b->sign)
   1b420:	00462783          	lw	a5,4(a2)
   1b424:	0045a703          	lw	a4,4(a1)
   1b428:	04e78e63          	beq	a5,a4,1b484 <__fpcmp_parts_d+0x98>
    {
      return a->sign ? -1 : 1;
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
   1b42c:	00f03533          	snez	a0,a5
   1b430:	40a00533          	neg	a0,a0
   1b434:	00156513          	ori	a0,a0,1
   1b438:	00008067          	ret
  /* same exponents; check size.  */
  if (a->fraction.ll > b->fraction.ll)
    {
      return a->sign ? -1 : 1;
    }
  if (a->fraction.ll < b->fraction.ll)
   1b43c:	00e69463          	bne	a3,a4,1b444 <__fpcmp_parts_d+0x58>
   1b440:	06b66a63          	bltu	a2,a1,1b4b4 <__fpcmp_parts_d+0xc8>
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (a) && iszero (b))
    {
      return 0;
   1b444:	00000513          	li	a0,0
    {
      return a->sign ? 1 : -1;
    }
  /* after all that, they're equal.  */
  return 0;
}
   1b448:	00008067          	ret
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (a) && iszero (b))
   1b44c:	fee68ce3          	beq	a3,a4,1b444 <__fpcmp_parts_d+0x58>
    {
      return a->sign ? -1 : 1;
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
   1b450:	0045a503          	lw	a0,4(a1)
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1b454:	00153513          	seqz	a0,a0
   1b458:	40a00533          	neg	a0,a0
   1b45c:	00156513          	ori	a0,a0,1
   1b460:	00008067          	ret

  if (isnan (a) || isnan (b))
    {
      return 1;			/* how to indicate unordered compare? */
    }
  if (isinf (a) && isinf (b))
   1b464:	06e68063          	beq	a3,a4,1b4c4 <__fpcmp_parts_d+0xd8>
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1b468:	00462503          	lw	a0,4(a2)
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
   1b46c:	00a03533          	snez	a0,a0
   1b470:	40a00533          	neg	a0,a0
   1b474:	00156513          	ori	a0,a0,1
   1b478:	00008067          	ret
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1b47c:	00078513          	mv	a0,a5
   1b480:	00008067          	ret
    {
      /* opposite signs */
      return a->sign ? -1 : 1;
    }
  /* same sign; exponents? */
  if (a->normal_exp > b->normal_exp)
   1b484:	00862683          	lw	a3,8(a2)
   1b488:	0085a703          	lw	a4,8(a1)
   1b48c:	fad740e3          	blt	a4,a3,1b42c <__fpcmp_parts_d+0x40>
    {
      return a->sign ? -1 : 1;
    }
  if (a->normal_exp < b->normal_exp)
   1b490:	02e6c263          	blt	a3,a4,1b4b4 <__fpcmp_parts_d+0xc8>
    {
      return a->sign ? 1 : -1;
    }
  /* same exponents; check size.  */
  if (a->fraction.ll > b->fraction.ll)
   1b494:	01462703          	lw	a4,20(a2)
   1b498:	0145a683          	lw	a3,20(a1)
   1b49c:	01062603          	lw	a2,16(a2)
   1b4a0:	0105a583          	lw	a1,16(a1)
   1b4a4:	f8e6e4e3          	bltu	a3,a4,1b42c <__fpcmp_parts_d+0x40>
   1b4a8:	00d71463          	bne	a4,a3,1b4b0 <__fpcmp_parts_d+0xc4>
   1b4ac:	f8c5e0e3          	bltu	a1,a2,1b42c <__fpcmp_parts_d+0x40>
    {
      return a->sign ? -1 : 1;
    }
  if (a->fraction.ll < b->fraction.ll)
   1b4b0:	f8d776e3          	bleu	a3,a4,1b43c <__fpcmp_parts_d+0x50>
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1b4b4:	0017b513          	seqz	a0,a5
   1b4b8:	40a00533          	neg	a0,a0
   1b4bc:	00156513          	ori	a0,a0,1
   1b4c0:	00008067          	ret
       -------+--------+--------
       -inf(1)| a>b(1) | a==b(0)
       -------+--------+--------
       So since unordered must be nonzero, just line up the columns...
       */
      return b->sign - a->sign;
   1b4c4:	0045a783          	lw	a5,4(a1)
   1b4c8:	00462503          	lw	a0,4(a2)
   1b4cc:	40a78533          	sub	a0,a5,a0
   1b4d0:	00008067          	ret

0001b4d4 <__cmpdf2>:
#endif

#if defined(L_compare_sf) || defined(L_compare_df) || defined(L_compoare_tf)
CMPtype
compare (FLO_type arg_a, FLO_type arg_b)
{
   1b4d4:	fb010113          	addi	sp,sp,-80
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1b4d8:	00a12023          	sw	a0,0(sp)
   1b4dc:	00b12223          	sw	a1,4(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1b4e0:	00010513          	mv	a0,sp
   1b4e4:	01010593          	addi	a1,sp,16
#endif

#if defined(L_compare_sf) || defined(L_compare_df) || defined(L_compoare_tf)
CMPtype
compare (FLO_type arg_a, FLO_type arg_b)
{
   1b4e8:	04112623          	sw	ra,76(sp)
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1b4ec:	00c12423          	sw	a2,8(sp)
   1b4f0:	00d12623          	sw	a3,12(sp)

  unpack_d (&au, &a);
   1b4f4:	925ff0ef          	jal	1ae18 <__unpack_d>
  unpack_d (&bu, &b);
   1b4f8:	02810593          	addi	a1,sp,40
   1b4fc:	00810513          	addi	a0,sp,8
   1b500:	919ff0ef          	jal	1ae18 <__unpack_d>

  return __fpcmp_parts (&a, &b);
   1b504:	02810593          	addi	a1,sp,40
   1b508:	01010513          	addi	a0,sp,16
   1b50c:	ee1ff0ef          	jal	1b3ec <__fpcmp_parts_d>
}
   1b510:	04c12083          	lw	ra,76(sp)
   1b514:	05010113          	addi	sp,sp,80
   1b518:	00008067          	ret

0001b51c <__gedf2>:
#endif /* L_gt_sf || L_gt_df */

#if defined(L_ge_sf) || defined(L_ge_df) || defined(L_ge_tf)
CMPtype
_ge_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1b51c:	fb010113          	addi	sp,sp,-80
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1b520:	00a12023          	sw	a0,0(sp)
   1b524:	00b12223          	sw	a1,4(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1b528:	00010513          	mv	a0,sp
   1b52c:	01010593          	addi	a1,sp,16
#endif /* L_gt_sf || L_gt_df */

#if defined(L_ge_sf) || defined(L_ge_df) || defined(L_ge_tf)
CMPtype
_ge_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1b530:	04112623          	sw	ra,76(sp)
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1b534:	00c12423          	sw	a2,8(sp)
   1b538:	00d12623          	sw	a3,12(sp)

  unpack_d (&au, &a);
   1b53c:	8ddff0ef          	jal	1ae18 <__unpack_d>
  unpack_d (&bu, &b);
   1b540:	00810513          	addi	a0,sp,8
   1b544:	02810593          	addi	a1,sp,40
   1b548:	8d1ff0ef          	jal	1ae18 <__unpack_d>

  if (isnan (&a) || isnan (&b))
   1b54c:	01012703          	lw	a4,16(sp)
   1b550:	00100793          	li	a5,1
    return -1;			/* false, truth >= 0 */
   1b554:	fff00513          	li	a0,-1
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  if (isnan (&a) || isnan (&b))
   1b558:	00e7fc63          	bleu	a4,a5,1b570 <__gedf2+0x54>
   1b55c:	02812703          	lw	a4,40(sp)
   1b560:	00e7f863          	bleu	a4,a5,1b570 <__gedf2+0x54>
    return -1;			/* false, truth >= 0 */
  return __fpcmp_parts (&a, &b) ;
   1b564:	02810593          	addi	a1,sp,40
   1b568:	01010513          	addi	a0,sp,16
   1b56c:	e81ff0ef          	jal	1b3ec <__fpcmp_parts_d>
}
   1b570:	04c12083          	lw	ra,76(sp)
   1b574:	05010113          	addi	sp,sp,80
   1b578:	00008067          	ret

0001b57c <__gtdf2>:
   1b57c:	fa1ff06f          	j	1b51c <__gedf2>

0001b580 <__ledf2>:
#endif /* L_lt_sf || L_lt_df */

#if defined(L_le_sf) || defined(L_le_df) || defined(L_le_tf)
CMPtype
_le_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1b580:	fb010113          	addi	sp,sp,-80
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1b584:	00a12023          	sw	a0,0(sp)
   1b588:	00b12223          	sw	a1,4(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1b58c:	00010513          	mv	a0,sp
   1b590:	01010593          	addi	a1,sp,16
#endif /* L_lt_sf || L_lt_df */

#if defined(L_le_sf) || defined(L_le_df) || defined(L_le_tf)
CMPtype
_le_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1b594:	04112623          	sw	ra,76(sp)
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1b598:	00c12423          	sw	a2,8(sp)
   1b59c:	00d12623          	sw	a3,12(sp)

  unpack_d (&au, &a);
   1b5a0:	879ff0ef          	jal	1ae18 <__unpack_d>
  unpack_d (&bu, &b);
   1b5a4:	00810513          	addi	a0,sp,8
   1b5a8:	02810593          	addi	a1,sp,40
   1b5ac:	86dff0ef          	jal	1ae18 <__unpack_d>

  if (isnan (&a) || isnan (&b))
   1b5b0:	01012783          	lw	a5,16(sp)
   1b5b4:	00100513          	li	a0,1
   1b5b8:	00f57c63          	bleu	a5,a0,1b5d0 <__ledf2+0x50>
   1b5bc:	02812783          	lw	a5,40(sp)
   1b5c0:	00f57863          	bleu	a5,a0,1b5d0 <__ledf2+0x50>
    return 1;			/* false, truth <= 0 */

  return __fpcmp_parts (&a, &b) ;
   1b5c4:	02810593          	addi	a1,sp,40
   1b5c8:	01010513          	addi	a0,sp,16
   1b5cc:	e21ff0ef          	jal	1b3ec <__fpcmp_parts_d>
}
   1b5d0:	04c12083          	lw	ra,76(sp)
   1b5d4:	05010113          	addi	sp,sp,80
   1b5d8:	00008067          	ret

0001b5dc <__ltdf2>:
   1b5dc:	fa5ff06f          	j	1b580 <__ledf2>

0001b5e0 <__nedf2>:
   1b5e0:	fa1ff06f          	j	1b580 <__ledf2>

0001b5e4 <__eqdf2>:
   1b5e4:	f9dff06f          	j	1b580 <__ledf2>

0001b5e8 <__unorddf2>:
#endif /* L_le_sf || L_le_df */

#if defined(L_unord_sf) || defined(L_unord_df) || defined(L_unord_tf)
CMPtype
_unord_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1b5e8:	fb010113          	addi	sp,sp,-80
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1b5ec:	00a12023          	sw	a0,0(sp)
   1b5f0:	00b12223          	sw	a1,4(sp)
  bu.value = arg_b;

  unpack_d (&au, &a);
   1b5f4:	00010513          	mv	a0,sp
   1b5f8:	01010593          	addi	a1,sp,16
#endif /* L_le_sf || L_le_df */

#if defined(L_unord_sf) || defined(L_unord_df) || defined(L_unord_tf)
CMPtype
_unord_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1b5fc:	04112623          	sw	ra,76(sp)
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;
   1b600:	00c12423          	sw	a2,8(sp)
   1b604:	00d12623          	sw	a3,12(sp)

  unpack_d (&au, &a);
   1b608:	811ff0ef          	jal	1ae18 <__unpack_d>
  unpack_d (&bu, &b);
   1b60c:	00810513          	addi	a0,sp,8
   1b610:	02810593          	addi	a1,sp,40
   1b614:	805ff0ef          	jal	1ae18 <__unpack_d>

  return (isnan (&a) || isnan (&b));
   1b618:	01012783          	lw	a5,16(sp)
   1b61c:	00100513          	li	a0,1
   1b620:	00f57663          	bleu	a5,a0,1b62c <__unorddf2+0x44>
   1b624:	02812503          	lw	a0,40(sp)
   1b628:	00253513          	sltiu	a0,a0,2
}
   1b62c:	04c12083          	lw	ra,76(sp)
   1b630:	05010113          	addi	sp,sp,80
   1b634:	00008067          	ret

0001b638 <__floatsidf>:
#endif /* L_unord_sf || L_unord_df */

#if defined(L_si_to_sf) || defined(L_si_to_df) || defined(L_si_to_tf)
FLO_type
si_to_float (SItype arg_a)
{
   1b638:	fd010113          	addi	sp,sp,-48
  fp_number_type in;

  in.class = CLASS_NUMBER;
  in.sign = arg_a < 0;
   1b63c:	01f55793          	srli	a5,a0,0x1f
FLO_type
si_to_float (SItype arg_a)
{
  fp_number_type in;

  in.class = CLASS_NUMBER;
   1b640:	00300713          	li	a4,3
#endif /* L_unord_sf || L_unord_df */

#if defined(L_si_to_sf) || defined(L_si_to_df) || defined(L_si_to_tf)
FLO_type
si_to_float (SItype arg_a)
{
   1b644:	02112623          	sw	ra,44(sp)
   1b648:	02812423          	sw	s0,40(sp)
  fp_number_type in;

  in.class = CLASS_NUMBER;
   1b64c:	00e12423          	sw	a4,8(sp)
  in.sign = arg_a < 0;
   1b650:	00f12623          	sw	a5,12(sp)
  if (!arg_a)
   1b654:	02051263          	bnez	a0,1b678 <__floatsidf+0x40>
    {
      in.class = CLASS_ZERO;
   1b658:	00200793          	li	a5,2
   1b65c:	00f12423          	sw	a5,8(sp)
	{
	  in.fraction.ll <<= shift;
	  in.normal_exp -= shift;
	}
    }
  return pack_d (&in);
   1b660:	00810513          	addi	a0,sp,8
   1b664:	d70ff0ef          	jal	1abd4 <__pack_d>
}
   1b668:	02c12083          	lw	ra,44(sp)
   1b66c:	02812403          	lw	s0,40(sp)
   1b670:	03010113          	addi	sp,sp,48
   1b674:	00008067          	ret
  else
    {
      USItype uarg;
      int shift;
      in.normal_exp = FRACBITS + NGARDS;
      if (in.sign) 
   1b678:	02054c63          	bltz	a0,1b6b0 <__floatsidf+0x78>
	      return (FLO_type)(- MAX_SI_INT - 1);
	    }
	  uarg = (-arg_a);
	}
      else
	uarg = arg_a;
   1b67c:	00050413          	mv	s0,a0
static int
clzusi (USItype n)
{
  extern int __clzsi2 (USItype);
  if (sizeof (USItype) == sizeof (unsigned int))
    return __builtin_clz (n);
   1b680:	00040513          	mv	a0,s0
   1b684:	27c000ef          	jal	1b900 <__clzsi2>
	}
      else
	uarg = arg_a;

      in.fraction.ll = uarg;
      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
   1b688:	01d50513          	addi	a0,a0,29
      if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1b68c:	02057793          	andi	a5,a0,32
   1b690:	04078063          	beqz	a5,1b6d0 <__floatsidf+0x98>
   1b694:	00a41433          	sll	s0,s0,a0
   1b698:	00812e23          	sw	s0,28(sp)
   1b69c:	00012c23          	sw	zero,24(sp)
	  in.normal_exp -= shift;
   1b6a0:	03c00793          	li	a5,60
   1b6a4:	40a78533          	sub	a0,a5,a0
   1b6a8:	00a12823          	sw	a0,16(sp)
   1b6ac:	fb5ff06f          	j	1b660 <__floatsidf+0x28>
      in.normal_exp = FRACBITS + NGARDS;
      if (in.sign) 
	{
	  /* Special case for minint, since there is no +ve integer
	     representation for it */
	  if (arg_a == (- MAX_SI_INT - 1))
   1b6b0:	800007b7          	lui	a5,0x80000
   1b6b4:	02f50c63          	beq	a0,a5,1b6ec <__floatsidf+0xb4>
	    {
	      return (FLO_type)(- MAX_SI_INT - 1);
	    }
	  uarg = (-arg_a);
   1b6b8:	40a00433          	neg	s0,a0
static int
clzusi (USItype n)
{
  extern int __clzsi2 (USItype);
  if (sizeof (USItype) == sizeof (unsigned int))
    return __builtin_clz (n);
   1b6bc:	00040513          	mv	a0,s0
   1b6c0:	240000ef          	jal	1b900 <__clzsi2>
	}
      else
	uarg = arg_a;

      in.fraction.ll = uarg;
      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
   1b6c4:	01d50513          	addi	a0,a0,29
      if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1b6c8:	02057793          	andi	a5,a0,32
   1b6cc:	fc0794e3          	bnez	a5,1b694 <__floatsidf+0x5c>
   1b6d0:	00145793          	srli	a5,s0,0x1
   1b6d4:	fff54713          	not	a4,a0
   1b6d8:	00e7d7b3          	srl	a5,a5,a4
   1b6dc:	00a41433          	sll	s0,s0,a0
   1b6e0:	00f12e23          	sw	a5,28(sp)
   1b6e4:	00812c23          	sw	s0,24(sp)
   1b6e8:	fb9ff06f          	j	1b6a0 <__floatsidf+0x68>
	{
	  /* Special case for minint, since there is no +ve integer
	     representation for it */
	  if (arg_a == (- MAX_SI_INT - 1))
	    {
	      return (FLO_type)(- MAX_SI_INT - 1);
   1b6ec:	8701a503          	lw	a0,-1936(gp) # 48050 <__wctomb+0x50>
   1b6f0:	8741a583          	lw	a1,-1932(gp) # 48054 <__wctomb+0x54>
   1b6f4:	f75ff06f          	j	1b668 <__floatsidf+0x30>

0001b6f8 <__floatunsidf>:
#endif /* L_si_to_sf || L_si_to_df */

#if defined(L_usi_to_sf) || defined(L_usi_to_df) || defined(L_usi_to_tf)
FLO_type
usi_to_float (USItype arg_a)
{
   1b6f8:	fd010113          	addi	sp,sp,-48
   1b6fc:	02112623          	sw	ra,44(sp)
   1b700:	02812423          	sw	s0,40(sp)
  fp_number_type in;

  in.sign = 0;
   1b704:	00012623          	sw	zero,12(sp)
  if (!arg_a)
   1b708:	06050663          	beqz	a0,1b774 <__floatunsidf+0x7c>
      in.class = CLASS_ZERO;
    }
  else
    {
      int shift;
      in.class = CLASS_NUMBER;
   1b70c:	00300793          	li	a5,3
   1b710:	00f12423          	sw	a5,8(sp)
   1b714:	00050413          	mv	s0,a0
static int
clzusi (USItype n)
{
  extern int __clzsi2 (USItype);
  if (sizeof (USItype) == sizeof (unsigned int))
    return __builtin_clz (n);
   1b718:	1e8000ef          	jal	1b900 <__clzsi2>
      int shift;
      in.class = CLASS_NUMBER;
      in.normal_exp = FRACBITS + NGARDS;
      in.fraction.ll = arg_a;

      shift = clzusi (arg_a) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
   1b71c:	01d50513          	addi	a0,a0,29
	  in.fraction.ll |= (guard != 0);
	  in.normal_exp -= shift;
	}
      else if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1b720:	02057793          	andi	a5,a0,32
   1b724:	02078a63          	beqz	a5,1b758 <__floatunsidf+0x60>
   1b728:	00a41433          	sll	s0,s0,a0
   1b72c:	00812e23          	sw	s0,28(sp)
   1b730:	00012c23          	sw	zero,24(sp)
	  in.normal_exp -= shift;
   1b734:	03c00793          	li	a5,60
   1b738:	40a78533          	sub	a0,a5,a0
   1b73c:	00a12823          	sw	a0,16(sp)
	}
    }
  return pack_d (&in);
   1b740:	00810513          	addi	a0,sp,8
   1b744:	c90ff0ef          	jal	1abd4 <__pack_d>
}
   1b748:	02c12083          	lw	ra,44(sp)
   1b74c:	02812403          	lw	s0,40(sp)
   1b750:	03010113          	addi	sp,sp,48
   1b754:	00008067          	ret
	  in.fraction.ll |= (guard != 0);
	  in.normal_exp -= shift;
	}
      else if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1b758:	00145793          	srli	a5,s0,0x1
   1b75c:	fff54713          	not	a4,a0
   1b760:	00e7d7b3          	srl	a5,a5,a4
   1b764:	00a41433          	sll	s0,s0,a0
   1b768:	00f12e23          	sw	a5,28(sp)
   1b76c:	00812c23          	sw	s0,24(sp)
   1b770:	fc5ff06f          	j	1b734 <__floatunsidf+0x3c>
  fp_number_type in;

  in.sign = 0;
  if (!arg_a)
    {
      in.class = CLASS_ZERO;
   1b774:	00200793          	li	a5,2
   1b778:	00f12423          	sw	a5,8(sp)
   1b77c:	fc5ff06f          	j	1b740 <__floatunsidf+0x48>

0001b780 <__fixdfsi>:
#endif

#if defined(L_sf_to_si) || defined(L_df_to_si) || defined(L_tf_to_si)
SItype
float_to_si (FLO_type arg_a)
{
   1b780:	fd010113          	addi	sp,sp,-48
  fp_number_type a;
  SItype tmp;
  FLO_union_type au;

  au.value = arg_a;
   1b784:	00a12023          	sw	a0,0(sp)
   1b788:	00b12223          	sw	a1,4(sp)
  unpack_d (&au, &a);
   1b78c:	00010513          	mv	a0,sp
   1b790:	00810593          	addi	a1,sp,8
#endif

#if defined(L_sf_to_si) || defined(L_df_to_si) || defined(L_tf_to_si)
SItype
float_to_si (FLO_type arg_a)
{
   1b794:	02112623          	sw	ra,44(sp)
  fp_number_type a;
  SItype tmp;
  FLO_union_type au;

  au.value = arg_a;
  unpack_d (&au, &a);
   1b798:	e80ff0ef          	jal	1ae18 <__unpack_d>
   1b79c:	00812783          	lw	a5,8(sp)

  if (iszero (&a))
    return 0;
  if (isnan (&a))
   1b7a0:	00200713          	li	a4,2
   1b7a4:	06f77463          	bleu	a5,a4,1b80c <__fixdfsi+0x8c>
    return 0;
  /* get reasonable MAX_SI_INT...  */
  if (isinf (&a))
   1b7a8:	00400713          	li	a4,4
   1b7ac:	00e78a63          	beq	a5,a4,1b7c0 <__fixdfsi+0x40>
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  /* it is a number, but a small one */
  if (a.normal_exp < 0)
   1b7b0:	01012503          	lw	a0,16(sp)
   1b7b4:	04054c63          	bltz	a0,1b80c <__fixdfsi+0x8c>
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
   1b7b8:	01e00793          	li	a5,30
   1b7bc:	02a7d063          	ble	a0,a5,1b7dc <__fixdfsi+0x5c>
    return 0;
  if (isnan (&a))
    return 0;
  /* get reasonable MAX_SI_INT...  */
  if (isinf (&a))
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
   1b7c0:	00c12783          	lw	a5,12(sp)
   1b7c4:	80000537          	lui	a0,0x80000
   1b7c8:	00079463          	bnez	a5,1b7d0 <__fixdfsi+0x50>
   1b7cc:	fff54513          	not	a0,a0
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
  return a.sign ? (-tmp) : (tmp);
}
   1b7d0:	02c12083          	lw	ra,44(sp)
   1b7d4:	03010113          	addi	sp,sp,48
   1b7d8:	00008067          	ret
  /* it is a number, but a small one */
  if (a.normal_exp < 0)
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
   1b7dc:	03c00793          	li	a5,60
   1b7e0:	40a78533          	sub	a0,a5,a0
   1b7e4:	02057793          	andi	a5,a0,32
   1b7e8:	02078a63          	beqz	a5,1b81c <__fixdfsi+0x9c>
   1b7ec:	01c12783          	lw	a5,28(sp)
   1b7f0:	00a7d533          	srl	a0,a5,a0
  return a.sign ? (-tmp) : (tmp);
   1b7f4:	00c12783          	lw	a5,12(sp)
   1b7f8:	fc078ce3          	beqz	a5,1b7d0 <__fixdfsi+0x50>
}
   1b7fc:	02c12083          	lw	ra,44(sp)
  if (a.normal_exp < 0)
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
  return a.sign ? (-tmp) : (tmp);
   1b800:	40a00533          	neg	a0,a0
}
   1b804:	03010113          	addi	sp,sp,48
   1b808:	00008067          	ret
   1b80c:	02c12083          	lw	ra,44(sp)
  unpack_d (&au, &a);

  if (iszero (&a))
    return 0;
  if (isnan (&a))
    return 0;
   1b810:	00000513          	li	a0,0
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
  return a.sign ? (-tmp) : (tmp);
}
   1b814:	03010113          	addi	sp,sp,48
   1b818:	00008067          	ret
  /* it is a number, but a small one */
  if (a.normal_exp < 0)
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
   1b81c:	01c12783          	lw	a5,28(sp)
   1b820:	fff54713          	not	a4,a0
   1b824:	00179793          	slli	a5,a5,0x1
   1b828:	00e797b3          	sll	a5,a5,a4
   1b82c:	01812703          	lw	a4,24(sp)
   1b830:	00a75533          	srl	a0,a4,a0
   1b834:	00a7e533          	or	a0,a5,a0
   1b838:	fbdff06f          	j	1b7f4 <__fixdfsi+0x74>

0001b83c <__negdf2>:
#endif /* L_tf_to_usi */

#if defined(L_negate_sf) || defined(L_negate_df) || defined(L_negate_tf)
FLO_type
negate (FLO_type arg_a)
{
   1b83c:	fd010113          	addi	sp,sp,-48
  fp_number_type a;
  FLO_union_type au;

  au.value = arg_a;
   1b840:	00a12023          	sw	a0,0(sp)
   1b844:	00b12223          	sw	a1,4(sp)
  unpack_d (&au, &a);
   1b848:	00010513          	mv	a0,sp
   1b84c:	00810593          	addi	a1,sp,8
#endif /* L_tf_to_usi */

#if defined(L_negate_sf) || defined(L_negate_df) || defined(L_negate_tf)
FLO_type
negate (FLO_type arg_a)
{
   1b850:	02112623          	sw	ra,44(sp)
  fp_number_type a;
  FLO_union_type au;

  au.value = arg_a;
  unpack_d (&au, &a);
   1b854:	dc4ff0ef          	jal	1ae18 <__unpack_d>

INLINE 
static void
flip_sign ( fp_number_type *  x)
{
  x->sign = !x->sign;
   1b858:	00c12783          	lw	a5,12(sp)

  au.value = arg_a;
  unpack_d (&au, &a);

  flip_sign (&a);
  return pack_d (&a);
   1b85c:	00810513          	addi	a0,sp,8

INLINE 
static void
flip_sign ( fp_number_type *  x)
{
  x->sign = !x->sign;
   1b860:	0017b793          	seqz	a5,a5
   1b864:	00f12623          	sw	a5,12(sp)

  au.value = arg_a;
  unpack_d (&au, &a);

  flip_sign (&a);
  return pack_d (&a);
   1b868:	b6cff0ef          	jal	1abd4 <__pack_d>
}
   1b86c:	02c12083          	lw	ra,44(sp)
   1b870:	03010113          	addi	sp,sp,48
   1b874:	00008067          	ret

0001b878 <__make_dp>:
extern SFtype __make_fp (fp_class_type, unsigned int, int, USItype);

#if defined(L_make_df)
DFtype
__make_dp (fp_class_type class, unsigned int sign, int exp, UDItype frac)
{
   1b878:	fd010113          	addi	sp,sp,-48
  fp_number_type in;

  in.class = class;
   1b87c:	00a12423          	sw	a0,8(sp)
  in.sign = sign;
  in.normal_exp = exp;
  in.fraction.ll = frac;
  return pack_d (&in);
   1b880:	00810513          	addi	a0,sp,8
extern SFtype __make_fp (fp_class_type, unsigned int, int, USItype);

#if defined(L_make_df)
DFtype
__make_dp (fp_class_type class, unsigned int sign, int exp, UDItype frac)
{
   1b884:	02112623          	sw	ra,44(sp)
  fp_number_type in;

  in.class = class;
  in.sign = sign;
   1b888:	00b12623          	sw	a1,12(sp)
  in.normal_exp = exp;
   1b88c:	00c12823          	sw	a2,16(sp)
  in.fraction.ll = frac;
   1b890:	00e12c23          	sw	a4,24(sp)
   1b894:	00f12e23          	sw	a5,28(sp)
  return pack_d (&in);
   1b898:	b3cff0ef          	jal	1abd4 <__pack_d>
}
   1b89c:	02c12083          	lw	ra,44(sp)
   1b8a0:	03010113          	addi	sp,sp,48
   1b8a4:	00008067          	ret

0001b8a8 <__truncdfsf2>:
#endif /* L_make_df */

#if defined(L_df_to_sf)
SFtype
df_to_sf (DFtype arg_a)
{
   1b8a8:	fd010113          	addi	sp,sp,-48
  fp_number_type in;
  USItype sffrac;
  FLO_union_type au;

  au.value = arg_a;
   1b8ac:	00a12023          	sw	a0,0(sp)
   1b8b0:	00b12223          	sw	a1,4(sp)
  unpack_d (&au, &in);
   1b8b4:	00010513          	mv	a0,sp
   1b8b8:	00810593          	addi	a1,sp,8
#endif /* L_make_df */

#if defined(L_df_to_sf)
SFtype
df_to_sf (DFtype arg_a)
{
   1b8bc:	02112623          	sw	ra,44(sp)
  fp_number_type in;
  USItype sffrac;
  FLO_union_type au;

  au.value = arg_a;
  unpack_d (&au, &in);
   1b8c0:	d58ff0ef          	jal	1ae18 <__unpack_d>

  sffrac = in.fraction.ll >> F_D_BITOFF;
   1b8c4:	01812703          	lw	a4,24(sp)
   1b8c8:	01c12683          	lw	a3,28(sp)
   1b8cc:	01e75793          	srli	a5,a4,0x1e
   1b8d0:	00269693          	slli	a3,a3,0x2
   1b8d4:	00f6e6b3          	or	a3,a3,a5

  /* We set the lowest guard bit in SFFRAC if we discarded any non
     zero bits.  */
  if ((in.fraction.ll & (((USItype) 1 << F_D_BITOFF) - 1)) != 0)
   1b8d8:	00271793          	slli	a5,a4,0x2
   1b8dc:	00078463          	beqz	a5,1b8e4 <__truncdfsf2+0x3c>
    sffrac |= 1;
   1b8e0:	0016e693          	ori	a3,a3,1

  return __make_fp (in.class, in.sign, in.normal_exp, sffrac);
   1b8e4:	01012603          	lw	a2,16(sp)
   1b8e8:	00c12583          	lw	a1,12(sp)
   1b8ec:	00812503          	lw	a0,8(sp)
   1b8f0:	401000ef          	jal	1c4f0 <__make_fp>
}
   1b8f4:	02c12083          	lw	ra,44(sp)
   1b8f8:	03010113          	addi	sp,sp,48
   1b8fc:	00008067          	ret

0001b900 <__clzsi2>:
int
__clzSI2 (UWtype x)
{
  Wtype ret;

  count_leading_zeros (ret, x);
   1b900:	000107b7          	lui	a5,0x10
   1b904:	02f57c63          	bleu	a5,a0,1b93c <__clzsi2+0x3c>
   1b908:	0ff00693          	li	a3,255
   1b90c:	01800713          	li	a4,24
   1b910:	00800793          	li	a5,8
   1b914:	00a6e663          	bltu	a3,a0,1b920 <__clzsi2+0x20>
   1b918:	02000713          	li	a4,32
   1b91c:	00000793          	li	a5,0
   1b920:	00f55533          	srl	a0,a0,a5
   1b924:	0001c7b7          	lui	a5,0x1c
   1b928:	79478793          	addi	a5,a5,1940 # 1c794 <__clz_tab>
   1b92c:	00f507b3          	add	a5,a0,a5

  return ret;
   1b930:	0007c503          	lbu	a0,0(a5)
}
   1b934:	40a70533          	sub	a0,a4,a0
   1b938:	00008067          	ret
int
__clzSI2 (UWtype x)
{
  Wtype ret;

  count_leading_zeros (ret, x);
   1b93c:	010006b7          	lui	a3,0x1000
   1b940:	00800713          	li	a4,8
   1b944:	01800793          	li	a5,24
   1b948:	fcd57ce3          	bleu	a3,a0,1b920 <__clzsi2+0x20>
   1b94c:	01000713          	li	a4,16
   1b950:	00070793          	mv	a5,a4
   1b954:	00f55533          	srl	a0,a0,a5
   1b958:	0001c7b7          	lui	a5,0x1c
   1b95c:	79478793          	addi	a5,a5,1940 # 1c794 <__clz_tab>
   1b960:	00f507b3          	add	a5,a0,a5

  return ret;
   1b964:	0007c503          	lbu	a0,0(a5)
}
   1b968:	40a70533          	sub	a0,a4,a0
   1b96c:	00008067          	ret

0001b970 <_fpadd_parts>:
#if defined(L_addsub_sf) || defined(L_addsub_df) || defined(L_addsub_tf)
static const fp_number_type *
_fpadd_parts (fp_number_type * a,
	      fp_number_type * b,
	      fp_number_type * tmp)
{
   1b970:	00052783          	lw	a5,0(a0) # 80000000 <_gp+0x7ffb7820>
  int a_normal_exp;
  int b_normal_exp;
  fractype a_fraction;
  fractype b_fraction;

  if (isnan (a))
   1b974:	00100713          	li	a4,1
   1b978:	0ef77463          	bleu	a5,a4,1ba60 <_fpadd_parts+0xf0>
   1b97c:	0005a683          	lw	a3,0(a1)
    {
      return a;
    }
  if (isnan (b))
   1b980:	0cd77e63          	bleu	a3,a4,1ba5c <_fpadd_parts+0xec>
    {
      return b;
    }
  if (isinf (a))
   1b984:	00400813          	li	a6,4
   1b988:	15078c63          	beq	a5,a6,1bae0 <_fpadd_parts+0x170>
      /* Adding infinities with opposite signs yields a NaN.  */
      if (isinf (b) && a->sign != b->sign)
	return makenan ();
      return a;
    }
  if (isinf (b))
   1b98c:	0d068863          	beq	a3,a6,1ba5c <_fpadd_parts+0xec>
    {
      return b;
    }
  if (iszero (b))
   1b990:	00200813          	li	a6,2
   1b994:	11068663          	beq	a3,a6,1baa0 <_fpadd_parts+0x130>
	  tmp->sign = a->sign & b->sign;
	  return tmp;
	}
      return a;
    }
  if (iszero (a))
   1b998:	0d078263          	beq	a5,a6,1ba5c <_fpadd_parts+0xec>
     they're the same */
  {
    int diff;
    int sdiff;

    a_normal_exp = a->normal_exp;
   1b99c:	00852303          	lw	t1,8(a0)
    b_normal_exp = b->normal_exp;
   1b9a0:	0085a783          	lw	a5,8(a1)
    diff = a_normal_exp - b_normal_exp;
    sdiff = diff;

    if (diff < 0)
      diff = -diff;
    if (diff < FRAC_NBITS)
   1b9a4:	01f00693          	li	a3,31
    int diff;
    int sdiff;

    a_normal_exp = a->normal_exp;
    b_normal_exp = b->normal_exp;
    a_fraction = a->fraction.ll;
   1b9a8:	00c52383          	lw	t2,12(a0)
    b_fraction = b->fraction.ll;

    diff = a_normal_exp - b_normal_exp;
   1b9ac:	40f30833          	sub	a6,t1,a5
   1b9b0:	41f85293          	srai	t0,a6,0x1f
   1b9b4:	0102c8b3          	xor	a7,t0,a6
   1b9b8:	405888b3          	sub	a7,a7,t0
    int sdiff;

    a_normal_exp = a->normal_exp;
    b_normal_exp = b->normal_exp;
    a_fraction = a->fraction.ll;
    b_fraction = b->fraction.ll;
   1b9bc:	00c5a283          	lw	t0,12(a1)
    diff = a_normal_exp - b_normal_exp;
    sdiff = diff;

    if (diff < 0)
      diff = -diff;
    if (diff < FRAC_NBITS)
   1b9c0:	0b16d263          	ble	a7,a3,1ba64 <_fpadd_parts+0xf4>
	  }
      }
    else
      {
	/* Somethings's up.. choose the biggest */
	if (a_normal_exp > b_normal_exp)
   1b9c4:	1067ca63          	blt	a5,t1,1bad8 <_fpadd_parts+0x168>
   1b9c8:	00078313          	mv	t1,a5
	    b_fraction = 0;
	  }
	else
	  {
	    a_normal_exp = b_normal_exp;
	    a_fraction = 0;
   1b9cc:	00000393          	li	t2,0
	  }
      }
  }

  if (a->sign != b->sign)
   1b9d0:	00452703          	lw	a4,4(a0)
   1b9d4:	0045a783          	lw	a5,4(a1)
   1b9d8:	0af70a63          	beq	a4,a5,1ba8c <_fpadd_parts+0x11c>
	{
	  tfraction = -a_fraction + b_fraction;
	}
      else
	{
	  tfraction = a_fraction - b_fraction;
   1b9dc:	405387b3          	sub	a5,t2,t0
      }
  }

  if (a->sign != b->sign)
    {
      if (a->sign)
   1b9e0:	00070463          	beqz	a4,1b9e8 <_fpadd_parts+0x78>
	{
	  tfraction = -a_fraction + b_fraction;
   1b9e4:	407287b3          	sub	a5,t0,t2
	}
      else
	{
	  tfraction = a_fraction - b_fraction;
	}
      if (tfraction >= 0)
   1b9e8:	1007ca63          	bltz	a5,1bafc <_fpadd_parts+0x18c>
	{
	  tmp->sign = 0;
   1b9ec:	00062223          	sw	zero,4(a2)
	  tmp->normal_exp = a_normal_exp;
   1b9f0:	00662423          	sw	t1,8(a2)
	  tmp->fraction.ll = tfraction;
   1b9f4:	00f62623          	sw	a5,12(a2)
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1b9f8:	400005b7          	lui	a1,0x40000
   1b9fc:	fff78713          	addi	a4,a5,-1
   1ba00:	ffe58593          	addi	a1,a1,-2 # 3ffffffe <_gp+0x3ffb781e>
   1ba04:	02e5e463          	bltu	a1,a4,1ba2c <_fpadd_parts+0xbc>
   1ba08:	00862703          	lw	a4,8(a2)
   1ba0c:	fff70713          	addi	a4,a4,-1
	{
	  tmp->fraction.ll <<= 1;
   1ba10:	00179793          	slli	a5,a5,0x1
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1ba14:	fff78693          	addi	a3,a5,-1
	{
	  tmp->fraction.ll <<= 1;
	  tmp->normal_exp--;
   1ba18:	00070513          	mv	a0,a4
   1ba1c:	fff70713          	addi	a4,a4,-1
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
	}
      /* and renormalize it */

      while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)
   1ba20:	fed5f8e3          	bleu	a3,a1,1ba10 <_fpadd_parts+0xa0>
   1ba24:	00f62623          	sw	a5,12(a2)
   1ba28:	00a62423          	sw	a0,8(a2)
    {
      tmp->sign = a->sign;
      tmp->normal_exp = a_normal_exp;
      tmp->fraction.ll = a_fraction + b_fraction;
    }
  tmp->class = CLASS_NUMBER;
   1ba2c:	00300713          	li	a4,3
   1ba30:	00e62023          	sw	a4,0(a2)
   1ba34:	00060513          	mv	a0,a2
  /* Now the fraction is added, we have to shift down to renormalize the
     number */

  if (tmp->fraction.ll >= IMPLICIT_2)
   1ba38:	0207d463          	bgez	a5,1ba60 <_fpadd_parts+0xf0>
    {
      LSHIFT (tmp->fraction.ll, 1);
      tmp->normal_exp++;
   1ba3c:	00862703          	lw	a4,8(a2)
  /* Now the fraction is added, we have to shift down to renormalize the
     number */

  if (tmp->fraction.ll >= IMPLICIT_2)
    {
      LSHIFT (tmp->fraction.ll, 1);
   1ba40:	0017d693          	srli	a3,a5,0x1
   1ba44:	0017f793          	andi	a5,a5,1
   1ba48:	00f6e7b3          	or	a5,a3,a5
      tmp->normal_exp++;
   1ba4c:	00170713          	addi	a4,a4,1
  /* Now the fraction is added, we have to shift down to renormalize the
     number */

  if (tmp->fraction.ll >= IMPLICIT_2)
    {
      LSHIFT (tmp->fraction.ll, 1);
   1ba50:	00f62623          	sw	a5,12(a2)
      tmp->normal_exp++;
   1ba54:	00e62423          	sw	a4,8(a2)
   1ba58:	00008067          	ret
   1ba5c:	00058513          	mv	a0,a1
    }
  return tmp;
}
   1ba60:	00008067          	ret

    if (diff < 0)
      diff = -diff;
    if (diff < FRAC_NBITS)
      {
	if (sdiff > 0)
   1ba64:	0b005863          	blez	a6,1bb14 <_fpadd_parts+0x1a4>
	  {
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
   1ba68:	011716b3          	sll	a3,a4,a7
   1ba6c:	fff68693          	addi	a3,a3,-1 # ffffff <_gp+0xfb781f>
   1ba70:	0056f6b3          	and	a3,a3,t0
   1ba74:	00d03733          	snez	a4,a3
   1ba78:	0112d2b3          	srl	t0,t0,a7
   1ba7c:	00e2e2b3          	or	t0,t0,a4
	    a_fraction = 0;
	  }
      }
  }

  if (a->sign != b->sign)
   1ba80:	0045a783          	lw	a5,4(a1)
   1ba84:	00452703          	lw	a4,4(a0)
   1ba88:	f4f71ae3          	bne	a4,a5,1b9dc <_fpadd_parts+0x6c>
    }
  else
    {
      tmp->sign = a->sign;
      tmp->normal_exp = a_normal_exp;
      tmp->fraction.ll = a_fraction + b_fraction;
   1ba8c:	005387b3          	add	a5,t2,t0
	  tmp->normal_exp--;
	}
    }
  else
    {
      tmp->sign = a->sign;
   1ba90:	00e62223          	sw	a4,4(a2)
      tmp->normal_exp = a_normal_exp;
   1ba94:	00662423          	sw	t1,8(a2)
      tmp->fraction.ll = a_fraction + b_fraction;
   1ba98:	00f62623          	sw	a5,12(a2)
   1ba9c:	f91ff06f          	j	1ba2c <_fpadd_parts+0xbc>
    {
      return b;
    }
  if (iszero (b))
    {
      if (iszero (a))
   1baa0:	fcd790e3          	bne	a5,a3,1ba60 <_fpadd_parts+0xf0>
	{
	  *tmp = *a;
   1baa4:	00f62023          	sw	a5,0(a2)
   1baa8:	00452783          	lw	a5,4(a0)
   1baac:	00f62223          	sw	a5,4(a2)
   1bab0:	00852703          	lw	a4,8(a0)
	  tmp->sign = a->sign & b->sign;
   1bab4:	00452683          	lw	a3,4(a0)
   1bab8:	0045a783          	lw	a5,4(a1)
    }
  if (iszero (b))
    {
      if (iszero (a))
	{
	  *tmp = *a;
   1babc:	00e62423          	sw	a4,8(a2)
   1bac0:	00c52703          	lw	a4,12(a0)
	  tmp->sign = a->sign & b->sign;
   1bac4:	00f6f7b3          	and	a5,a3,a5
   1bac8:	00f62223          	sw	a5,4(a2)
    }
  if (iszero (b))
    {
      if (iszero (a))
	{
	  *tmp = *a;
   1bacc:	00e62623          	sw	a4,12(a2)
	  tmp->sign = a->sign & b->sign;
	  return tmp;
   1bad0:	00060513          	mv	a0,a2
   1bad4:	00008067          	ret
      {
	/* Somethings's up.. choose the biggest */
	if (a_normal_exp > b_normal_exp)
	  {
	    b_normal_exp = a_normal_exp;
	    b_fraction = 0;
   1bad8:	00000293          	li	t0,0
   1badc:	ef5ff06f          	j	1b9d0 <_fpadd_parts+0x60>
      return b;
    }
  if (isinf (a))
    {
      /* Adding infinities with opposite signs yields a NaN.  */
      if (isinf (b) && a->sign != b->sign)
   1bae0:	f8f690e3          	bne	a3,a5,1ba60 <_fpadd_parts+0xf0>
   1bae4:	00452703          	lw	a4,4(a0)
   1bae8:	0045a783          	lw	a5,4(a1)
   1baec:	f6f70ae3          	beq	a4,a5,1ba60 <_fpadd_parts+0xf0>
	return makenan ();
   1baf0:	0001d537          	lui	a0,0x1d
   1baf4:	ce050513          	addi	a0,a0,-800 # 1cce0 <__thenan_sf>
   1baf8:	00008067          	ret
	}
      else
	{
	  tmp->sign = 1;
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = -tfraction;
   1bafc:	40f007b3          	neg	a5,a5
	  tmp->normal_exp = a_normal_exp;
	  tmp->fraction.ll = tfraction;
	}
      else
	{
	  tmp->sign = 1;
   1bb00:	00100713          	li	a4,1
   1bb04:	00e62223          	sw	a4,4(a2)
	  tmp->normal_exp = a_normal_exp;
   1bb08:	00662423          	sw	t1,8(a2)
	  tmp->fraction.ll = -tfraction;
   1bb0c:	00f62623          	sw	a5,12(a2)
   1bb10:	ee9ff06f          	j	1b9f8 <_fpadd_parts+0x88>
	if (sdiff > 0)
	  {
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
	  }
	else if (sdiff < 0)
   1bb14:	ea080ee3          	beqz	a6,1b9d0 <_fpadd_parts+0x60>
	  {
	    a_normal_exp += diff;
	    LSHIFT (a_fraction, diff);
   1bb18:	01171833          	sll	a6,a4,a7
   1bb1c:	fff80813          	addi	a6,a6,-1
   1bb20:	00787833          	and	a6,a6,t2
   1bb24:	0113d7b3          	srl	a5,t2,a7
   1bb28:	010036b3          	snez	a3,a6
	    b_normal_exp += diff;
	    LSHIFT (b_fraction, diff);
	  }
	else if (sdiff < 0)
	  {
	    a_normal_exp += diff;
   1bb2c:	01130333          	add	t1,t1,a7
	    LSHIFT (a_fraction, diff);
   1bb30:	00d7e3b3          	or	t2,a5,a3
   1bb34:	e9dff06f          	j	1b9d0 <_fpadd_parts+0x60>

0001bb38 <__pack_f>:
extern FLO_type pack_d (const fp_number_type * );

#if defined(L_pack_df) || defined(L_pack_sf) || defined(L_pack_tf)
FLO_type
pack_d (const fp_number_type *src)
{
   1bb38:	00052783          	lw	a5,0(a0)
  FLO_union_type dst;
  fractype fraction = src->fraction.ll;	/* wasn't unsigned before? */
  int sign = src->sign;
  int exp = 0;

  if (isnan (src))
   1bb3c:	00100613          	li	a2,1
#if defined(L_pack_df) || defined(L_pack_sf) || defined(L_pack_tf)
FLO_type
pack_d (const fp_number_type *src)
{
  FLO_union_type dst;
  fractype fraction = src->fraction.ll;	/* wasn't unsigned before? */
   1bb40:	00c52683          	lw	a3,12(a0)
  int sign = src->sign;
   1bb44:	00452583          	lw	a1,4(a0)
  int exp = 0;

  if (isnan (src))
   1bb48:	08f67a63          	bleu	a5,a2,1bbdc <__pack_f+0xa4>
	  /* Set the quiet/signaling bit.  */
	  fraction |= QUIET_NAN;
#endif
	}
    }
  else if (isinf (src))
   1bb4c:	00400713          	li	a4,4
   1bb50:	08e78063          	beq	a5,a4,1bbd0 <__pack_f+0x98>
    {
      exp = EXPMAX;
      fraction = 0;
    }
  else if (iszero (src))
   1bb54:	00200713          	li	a4,2
   1bb58:	04e78263          	beq	a5,a4,1bb9c <__pack_f+0x64>
    {
      exp = 0;
      fraction = 0;
    }
  else if (fraction == 0)
   1bb5c:	04068063          	beqz	a3,1bb9c <__pack_f+0x64>
    {
      exp = 0;
    }
  else
    {
      if (__builtin_expect (src->normal_exp < NORMAL_EXPMIN, 0))
   1bb60:	00852703          	lw	a4,8(a0)
   1bb64:	f8200793          	li	a5,-126
   1bb68:	0af74c63          	blt	a4,a5,1bc20 <__pack_f+0xe8>
	      exp += 1;
	    }
	  fraction >>= NGARDS;
#endif /* NO_DENORMALS */
	}
      else if (__builtin_expect (src->normal_exp > EXPBIAS, 0))
   1bb6c:	07f00793          	li	a5,127
   1bb70:	06e7c063          	blt	a5,a4,1bbd0 <__pack_f+0x98>
	{
	  exp = src->normal_exp + EXPBIAS;
	  /* IF the gard bits are the all zero, but the first, then we're
	     half way between two numbers, choose the one which makes the
	     lsb of the answer 0.  */
	  if ((fraction & GARDMASK) == GARDMSB)
   1bb74:	00f6f7b3          	and	a5,a3,a5
   1bb78:	04000613          	li	a2,64
   1bb7c:	08c78463          	beq	a5,a2,1bc04 <__pack_f+0xcc>
		fraction += GARDROUND + 1;
	    }
	  else
	    {
	      /* Add a one to the guards to round up */
	      fraction += GARDROUND;
   1bb80:	03f68693          	addi	a3,a3,63
	    }
	  if (fraction >= IMPLICIT_2)
   1bb84:	0806c863          	bltz	a3,1bc14 <__pack_f+0xdc>
	  exp = EXPMAX;
	  fraction = 0;
	}
      else
	{
	  exp = src->normal_exp + EXPBIAS;
   1bb88:	07f70713          	addi	a4,a4,127
   1bb8c:	00269693          	slli	a3,a3,0x2
   1bb90:	0096d693          	srli	a3,a3,0x9
   1bb94:	0ff77713          	andi	a4,a4,255
   1bb98:	00c0006f          	j	1bba4 <__pack_f+0x6c>
   1bb9c:	00000713          	li	a4,0
   1bba0:	00000693          	li	a3,0

  /* We previously used bitfields to store the number, but this doesn't
     handle little/big endian systems conveniently, so use shifts and
     masks */
#ifdef FLOAT_BIT_ORDER_MISMATCH
  dst.bits.fraction = fraction;
   1bba4:	008007b7          	lui	a5,0x800
   1bba8:	fff78793          	addi	a5,a5,-1 # 7fffff <_gp+0x7b781f>
  dst.bits.exp = exp;
   1bbac:	80800637          	lui	a2,0x80800

  /* We previously used bitfields to store the number, but this doesn't
     handle little/big endian systems conveniently, so use shifts and
     masks */
#ifdef FLOAT_BIT_ORDER_MISMATCH
  dst.bits.fraction = fraction;
   1bbb0:	00f6f7b3          	and	a5,a3,a5
  dst.bits.exp = exp;
   1bbb4:	fff60613          	addi	a2,a2,-1 # 807fffff <_gp+0x807b781f>
   1bbb8:	01771713          	slli	a4,a4,0x17
   1bbbc:	00c7f7b3          	and	a5,a5,a2
  dst.bits.sign = sign;
   1bbc0:	01f59513          	slli	a0,a1,0x1f
   1bbc4:	00e7e7b3          	or	a5,a5,a4
    dst.words[1] = tmp;
  }
#endif
#endif

  return dst.value;
   1bbc8:	00a7e533          	or	a0,a5,a0
}
   1bbcc:	00008067          	ret
   1bbd0:	0ff00713          	li	a4,255
   1bbd4:	00000693          	li	a3,0
   1bbd8:	fcdff06f          	j	1bba4 <__pack_f+0x6c>
  if (isnan (src))
    {
      exp = EXPMAX;
      /* Restore the NaN's payload.  */
      fraction >>= NGARDS;
      fraction &= QUIET_NAN - 1;
   1bbdc:	004007b7          	lui	a5,0x400

  if (isnan (src))
    {
      exp = EXPMAX;
      /* Restore the NaN's payload.  */
      fraction >>= NGARDS;
   1bbe0:	0076d713          	srli	a4,a3,0x7
      fraction &= QUIET_NAN - 1;
   1bbe4:	fff78693          	addi	a3,a5,-1 # 3fffff <_gp+0x3b781f>
   1bbe8:	00d776b3          	and	a3,a4,a3
   1bbec:	00f6e6b3          	or	a3,a3,a5
   1bbf0:	008007b7          	lui	a5,0x800
   1bbf4:	fff78793          	addi	a5,a5,-1 # 7fffff <_gp+0x7b781f>
   1bbf8:	00f6f6b3          	and	a3,a3,a5
	  /* Make sure the fraction has a non-zero value.  */
	  if (fraction == 0)
	    fraction |= QUIET_NAN - 1;
#else
	  /* Set the quiet/signaling bit.  */
	  fraction |= QUIET_NAN;
   1bbfc:	0ff00713          	li	a4,255
   1bc00:	fa5ff06f          	j	1bba4 <__pack_f+0x6c>
	  /* IF the gard bits are the all zero, but the first, then we're
	     half way between two numbers, choose the one which makes the
	     lsb of the answer 0.  */
	  if ((fraction & GARDMASK) == GARDMSB)
	    {
	      if (fraction & (1 << NGARDS))
   1bc04:	0806f793          	andi	a5,a3,128
   1bc08:	f6078ee3          	beqz	a5,1bb84 <__pack_f+0x4c>
		fraction += GARDROUND + 1;
   1bc0c:	00c686b3          	add	a3,a3,a2
   1bc10:	f75ff06f          	j	1bb84 <__pack_f+0x4c>
	      /* Add a one to the guards to round up */
	      fraction += GARDROUND;
	    }
	  if (fraction >= IMPLICIT_2)
	    {
	      fraction >>= 1;
   1bc14:	0016d693          	srli	a3,a3,0x1
	      exp += 1;
   1bc18:	08070713          	addi	a4,a4,128
   1bc1c:	f71ff06f          	j	1bb8c <__pack_f+0x54>
#else /* NO_DENORMALS */
	  /* This number's exponent is too low to fit into the bits
	     available in the number, so we'll store 0 in the exponent and
	     shift the fraction to the right to make up for it.  */

	  int shift = NORMAL_EXPMIN - src->normal_exp;
   1bc20:	40e78733          	sub	a4,a5,a4

	  exp = 0;

	  if (shift > FRAC_NBITS - NGARDS)
   1bc24:	01900793          	li	a5,25
   1bc28:	f6e7cae3          	blt	a5,a4,1bb9c <__pack_f+0x64>
	      fraction = 0;
	    }
	  else
	    {
	      int lowbit = (fraction & (((fractype)1 << shift) - 1)) ? 1 : 0;
	      fraction = (fraction >> shift) | lowbit;
   1bc2c:	00e617b3          	sll	a5,a2,a4
   1bc30:	fff78793          	addi	a5,a5,-1
   1bc34:	00d7f7b3          	and	a5,a5,a3
   1bc38:	00e6d6b3          	srl	a3,a3,a4
   1bc3c:	00f03733          	snez	a4,a5
   1bc40:	00e6e6b3          	or	a3,a3,a4
	    }
	  if ((fraction & GARDMASK) == GARDMSB)
   1bc44:	07f6f713          	andi	a4,a3,127
   1bc48:	04000793          	li	a5,64
   1bc4c:	02f71263          	bne	a4,a5,1bc70 <__pack_f+0x138>
	    {
	      if ((fraction & (1 << NGARDS)))
   1bc50:	0806f793          	andi	a5,a3,128
   1bc54:	02079c63          	bnez	a5,1bc8c <__pack_f+0x154>
   1bc58:	40000737          	lui	a4,0x40000
   1bc5c:	00e6b733          	sltu	a4,a3,a4
   1bc60:	00269613          	slli	a2,a3,0x2
   1bc64:	00965693          	srli	a3,a2,0x9
   1bc68:	00174713          	xori	a4,a4,1
   1bc6c:	f39ff06f          	j	1bba4 <__pack_f+0x6c>
   1bc70:	03f68713          	addi	a4,a3,63
   1bc74:	400007b7          	lui	a5,0x40000
   1bc78:	00271693          	slli	a3,a4,0x2
   1bc7c:	00f73733          	sltu	a4,a4,a5
   1bc80:	0096d693          	srli	a3,a3,0x9
   1bc84:	00174713          	xori	a4,a4,1
   1bc88:	f1dff06f          	j	1bba4 <__pack_f+0x6c>
		fraction += GARDROUND + 1;
   1bc8c:	04068713          	addi	a4,a3,64
   1bc90:	fe5ff06f          	j	1bc74 <__pack_f+0x13c>

0001bc94 <__unpack_f>:
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
  exp = src->bits.exp;
   1bc94:	00255703          	lhu	a4,2(a0)
  sign = src->bits.sign;
   1bc98:	00354683          	lbu	a3,3(a0)
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1bc9c:	00052603          	lw	a2,0(a0)
  exp = src->bits.exp;
   1bca0:	00775713          	srli	a4,a4,0x7
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1bca4:	008007b7          	lui	a5,0x800
  exp = ((int)(src->value_raw >> FRACBITS)) & ((1 << EXPBITS) - 1);
  sign = ((int)(src->value_raw >> (FRACBITS + EXPBITS))) & 1;
# endif
#endif

  dst->sign = sign;
   1bca8:	0076d693          	srli	a3,a3,0x7
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1bcac:	fff78793          	addi	a5,a5,-1 # 7fffff <_gp+0x7b781f>
  exp = src->bits.exp;
   1bcb0:	0ff77713          	andi	a4,a4,255
#endif
  src = &swapped;
#endif
  
#ifdef FLOAT_BIT_ORDER_MISMATCH
  fraction = src->bits.fraction;
   1bcb4:	00f677b3          	and	a5,a2,a5
  exp = ((int)(src->value_raw >> FRACBITS)) & ((1 << EXPBITS) - 1);
  sign = ((int)(src->value_raw >> (FRACBITS + EXPBITS))) & 1;
# endif
#endif

  dst->sign = sign;
   1bcb8:	00d5a223          	sw	a3,4(a1)
  if (exp == 0)
   1bcbc:	02071c63          	bnez	a4,1bcf4 <__unpack_f+0x60>
    {
      /* Hmm.  Looks like 0 */
      if (fraction == 0
   1bcc0:	06078063          	beqz	a5,1bd20 <__unpack_f+0x8c>
	     so there isn't a leading implicit one - we'll shift it so
	     it gets one.  */
	  dst->normal_exp = exp - EXPBIAS + 1;
	  fraction <<= NGARDS;

	  dst->class = CLASS_NUMBER;
   1bcc4:	00300713          	li	a4,3
   1bcc8:	00e5a023          	sw	a4,0(a1)
	{
	  /* Zero exponent with nonzero fraction - it's denormalized,
	     so there isn't a leading implicit one - we'll shift it so
	     it gets one.  */
	  dst->normal_exp = exp - EXPBIAS + 1;
	  fraction <<= NGARDS;
   1bccc:	00779793          	slli	a5,a5,0x7

	  dst->class = CLASS_NUMBER;
   1bcd0:	f8100713          	li	a4,-127
#if 1
	  while (fraction < IMPLICIT_1)
   1bcd4:	40000637          	lui	a2,0x40000
	    {
	      fraction <<= 1;
   1bcd8:	00179793          	slli	a5,a5,0x1
	      dst->normal_exp--;
   1bcdc:	00070693          	mv	a3,a4
   1bce0:	fff70713          	addi	a4,a4,-1 # 3fffffff <_gp+0x3ffb781f>
	  dst->normal_exp = exp - EXPBIAS + 1;
	  fraction <<= NGARDS;

	  dst->class = CLASS_NUMBER;
#if 1
	  while (fraction < IMPLICIT_1)
   1bce4:	fec7eae3          	bltu	a5,a2,1bcd8 <__unpack_f+0x44>
   1bce8:	00d5a423          	sw	a3,8(a1)
	    {
	      fraction <<= 1;
	      dst->normal_exp--;
	    }
#endif
	  dst->fraction.ll = fraction;
   1bcec:	00f5a623          	sw	a5,12(a1)
   1bcf0:	00008067          	ret
	}
    }
  else if (__builtin_expect (exp == EXPMAX, 0))
   1bcf4:	0ff00693          	li	a3,255
   1bcf8:	02d70a63          	beq	a4,a3,1bd2c <__unpack_f+0x98>
	}
    }
  else
    {
      /* Nothing strange about this number */
      dst->normal_exp = exp - EXPBIAS;
   1bcfc:	f8170713          	addi	a4,a4,-127
      dst->class = CLASS_NUMBER;
      dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;
   1bd00:	00779793          	slli	a5,a5,0x7
   1bd04:	400006b7          	lui	a3,0x40000
   1bd08:	00d7e7b3          	or	a5,a5,a3
	}
    }
  else
    {
      /* Nothing strange about this number */
      dst->normal_exp = exp - EXPBIAS;
   1bd0c:	00e5a423          	sw	a4,8(a1)
      dst->class = CLASS_NUMBER;
   1bd10:	00300713          	li	a4,3
   1bd14:	00e5a023          	sw	a4,0(a1)
      dst->fraction.ll = (fraction << NGARDS) | IMPLICIT_1;
   1bd18:	00f5a623          	sw	a5,12(a1)
   1bd1c:	00008067          	ret
	  || 1
#endif
	  )
	{
	  /* tastes like zero */
	  dst->class = CLASS_ZERO;
   1bd20:	00200793          	li	a5,2
   1bd24:	00f5a023          	sw	a5,0(a1)
   1bd28:	00008067          	ret
	}
    }
  else if (__builtin_expect (exp == EXPMAX, 0))
    {
      /* Huge exponent*/
      if (fraction == 0)
   1bd2c:	02078663          	beqz	a5,1bd58 <__unpack_f+0xc4>
	{
	  /* Nonzero fraction, means nan */
#ifdef QUIET_NAN_NEGATED
	  if ((fraction & QUIET_NAN) == 0)
#else
	  if (fraction & QUIET_NAN)
   1bd30:	00979713          	slli	a4,a5,0x9
   1bd34:	02075863          	bgez	a4,1bd64 <__unpack_f+0xd0>
#endif
	    {
	      dst->class = CLASS_QNAN;
   1bd38:	00100713          	li	a4,1
   1bd3c:	00e5a023          	sw	a4,0(a1)
	      dst->class = CLASS_SNAN;
	    }
	  /* Now that we know which kind of NaN we got, discard the
	     quiet/signaling bit, but do preserve the NaN payload.  */
	  fraction &= ~QUIET_NAN;
	  dst->fraction.ll = fraction << NGARDS;
   1bd40:	ffc00737          	lui	a4,0xffc00
   1bd44:	fff70713          	addi	a4,a4,-1 # ffbfffff <_gp+0xffbb781f>
   1bd48:	00e7f7b3          	and	a5,a5,a4
   1bd4c:	00779793          	slli	a5,a5,0x7
   1bd50:	00f5a623          	sw	a5,12(a1)
   1bd54:	00008067          	ret
    {
      /* Huge exponent*/
      if (fraction == 0)
	{
	  /* Attached to a zero fraction - means infinity */
	  dst->class = CLASS_INFINITY;
   1bd58:	00400793          	li	a5,4
   1bd5c:	00f5a023          	sw	a5,0(a1)
   1bd60:	00008067          	ret
	    {
	      dst->class = CLASS_QNAN;
	    }
	  else
	    {
	      dst->class = CLASS_SNAN;
   1bd64:	0005a023          	sw	zero,0(a1)
   1bd68:	fd9ff06f          	j	1bd40 <__unpack_f+0xac>

0001bd6c <__addsf3>:
  return tmp;
}

FLO_type
add (FLO_type arg_a, FLO_type arg_b)
{
   1bd6c:	fb010113          	addi	sp,sp,-80
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1bd70:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1bd74:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1bd78:	00810513          	addi	a0,sp,8
   1bd7c:	01010593          	addi	a1,sp,16
  return tmp;
}

FLO_type
add (FLO_type arg_a, FLO_type arg_b)
{
   1bd80:	04112623          	sw	ra,76(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1bd84:	f11ff0ef          	jal	1bc94 <__unpack_f>
  unpack_d (&bu, &b);
   1bd88:	02010593          	addi	a1,sp,32
   1bd8c:	00c10513          	addi	a0,sp,12
   1bd90:	f05ff0ef          	jal	1bc94 <__unpack_f>

  res = _fpadd_parts (&a, &b, &tmp);
   1bd94:	03010613          	addi	a2,sp,48
   1bd98:	02010593          	addi	a1,sp,32
   1bd9c:	01010513          	addi	a0,sp,16
   1bda0:	bd1ff0ef          	jal	1b970 <_fpadd_parts>

  return pack_d (res);
   1bda4:	d95ff0ef          	jal	1bb38 <__pack_f>
}
   1bda8:	04c12083          	lw	ra,76(sp)
   1bdac:	05010113          	addi	sp,sp,80
   1bdb0:	00008067          	ret

0001bdb4 <__subsf3>:

FLO_type
sub (FLO_type arg_a, FLO_type arg_b)
{
   1bdb4:	fb010113          	addi	sp,sp,-80
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1bdb8:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1bdbc:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1bdc0:	00810513          	addi	a0,sp,8
   1bdc4:	01010593          	addi	a1,sp,16
  return pack_d (res);
}

FLO_type
sub (FLO_type arg_a, FLO_type arg_b)
{
   1bdc8:	04112623          	sw	ra,76(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1bdcc:	ec9ff0ef          	jal	1bc94 <__unpack_f>
  unpack_d (&bu, &b);
   1bdd0:	02010593          	addi	a1,sp,32
   1bdd4:	00c10513          	addi	a0,sp,12
   1bdd8:	ebdff0ef          	jal	1bc94 <__unpack_f>

  b.sign ^= 1;
   1bddc:	02412783          	lw	a5,36(sp)

  res = _fpadd_parts (&a, &b, &tmp);
   1bde0:	03010613          	addi	a2,sp,48
   1bde4:	02010593          	addi	a1,sp,32
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  b.sign ^= 1;
   1bde8:	0017c793          	xori	a5,a5,1

  res = _fpadd_parts (&a, &b, &tmp);
   1bdec:	01010513          	addi	a0,sp,16
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  b.sign ^= 1;
   1bdf0:	02f12223          	sw	a5,36(sp)

  res = _fpadd_parts (&a, &b, &tmp);
   1bdf4:	b7dff0ef          	jal	1b970 <_fpadd_parts>

  return pack_d (res);
   1bdf8:	d41ff0ef          	jal	1bb38 <__pack_f>
}
   1bdfc:	04c12083          	lw	ra,76(sp)
   1be00:	05010113          	addi	sp,sp,80
   1be04:	00008067          	ret

0001be08 <__mulsf3>:
  return tmp;
}

FLO_type
multiply (FLO_type arg_a, FLO_type arg_b)
{
   1be08:	fb010113          	addi	sp,sp,-80
  fp_number_type b;
  fp_number_type tmp;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1be0c:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1be10:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1be14:	00810513          	addi	a0,sp,8
   1be18:	01010593          	addi	a1,sp,16
  return tmp;
}

FLO_type
multiply (FLO_type arg_a, FLO_type arg_b)
{
   1be1c:	04112623          	sw	ra,76(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1be20:	e75ff0ef          	jal	1bc94 <__unpack_f>
  unpack_d (&bu, &b);
   1be24:	02010593          	addi	a1,sp,32
   1be28:	00c10513          	addi	a0,sp,12
   1be2c:	e69ff0ef          	jal	1bc94 <__unpack_f>
   1be30:	01012783          	lw	a5,16(sp)
	       fp_number_type * tmp)
{
  fractype low = 0;
  fractype high = 0;

  if (isnan (a))
   1be34:	00100693          	li	a3,1
   1be38:	0ef6f463          	bleu	a5,a3,1bf20 <__mulsf3+0x118>
   1be3c:	02012703          	lw	a4,32(sp)
    {
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isnan (b))
   1be40:	0ae6f863          	bleu	a4,a3,1bef0 <__mulsf3+0xe8>
    {
      b->sign = a->sign != b->sign;
      return b;
    }
  if (isinf (a))
   1be44:	00400693          	li	a3,4
   1be48:	0cd78863          	beq	a5,a3,1bf18 <__mulsf3+0x110>
      if (iszero (b))
	return makenan ();
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isinf (b))
   1be4c:	08d70e63          	beq	a4,a3,1bee8 <__mulsf3+0xe0>
	  return makenan ();
	}
      b->sign = a->sign != b->sign;
      return b;
    }
  if (iszero (a))
   1be50:	00200693          	li	a3,2
   1be54:	0cd78663          	beq	a5,a3,1bf20 <__mulsf3+0x118>
    {
      a->sign = a->sign != b->sign;
      return a;
    }
  if (iszero (b))
   1be58:	08d70c63          	beq	a4,a3,1bef0 <__mulsf3+0xe8>
	}
    }
#elif defined(FLOAT) 
    /* Multiplying two USIs to get a UDI, we're safe.  */
    {
      UDItype answer = (UDItype)a->fraction.ll * (UDItype)b->fraction.ll;
   1be5c:	01c12703          	lw	a4,28(sp)
   1be60:	02c12583          	lw	a1,44(sp)
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1be64:	02812683          	lw	a3,40(sp)
   1be68:	01812783          	lw	a5,24(sp)
	}
    }
#elif defined(FLOAT) 
    /* Multiplying two USIs to get a UDI, we're safe.  */
    {
      UDItype answer = (UDItype)a->fraction.ll * (UDItype)b->fraction.ll;
   1be6c:	02b73633          	mulhu	a2,a4,a1
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
   1be70:	02412803          	lw	a6,36(sp)
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1be74:	00d787b3          	add	a5,a5,a3
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
   1be78:	01412683          	lw	a3,20(sp)
      low = res0;
    }
#endif
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
   1be7c:	00278513          	addi	a0,a5,2
   1be80:	02a12c23          	sw	a0,56(sp)
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
   1be84:	410686b3          	sub	a3,a3,a6
   1be88:	00d036b3          	snez	a3,a3
   1be8c:	02d12a23          	sw	a3,52(sp)
    /* Multiplying two USIs to get a UDI, we're safe.  */
    {
      UDItype answer = (UDItype)a->fraction.ll * (UDItype)b->fraction.ll;
      
      high = answer >> BITS_PER_SI;
      low = answer;
   1be90:	02b70733          	mul	a4,a4,a1
#elif defined(FLOAT) 
    /* Multiplying two USIs to get a UDI, we're safe.  */
    {
      UDItype answer = (UDItype)a->fraction.ll * (UDItype)b->fraction.ll;
      
      high = answer >> BITS_PER_SI;
   1be94:	00060693          	mv	a3,a2
  }

  tmp->normal_exp = a->normal_exp + b->normal_exp
    + FRAC_NBITS - (FRACBITS + NGARDS);
  tmp->sign = a->sign != b->sign;
  while (high >= IMPLICIT_2)
   1be98:	0c065a63          	bgez	a2,1bf6c <__mulsf3+0x164>
    {
      tmp->normal_exp++;
      if (high & 1)
   1be9c:	00167693          	andi	a3,a2,1
   1bea0:	00378793          	addi	a5,a5,3
   1bea4:	00068863          	beqz	a3,1beb4 <__mulsf3+0xac>
	{
	  low >>= 1;
   1bea8:	00175713          	srli	a4,a4,0x1
	  low |= FRACHIGH;
   1beac:	800006b7          	lui	a3,0x80000
   1beb0:	00d76733          	or	a4,a4,a3
	}
      high >>= 1;
   1beb4:	00165693          	srli	a3,a2,0x1
   1beb8:	02f12c23          	sw	a5,56(sp)
      if (low & FRACHIGH)
	high |= 1;
      low <<= 1;
    }

  if ((high & GARDMASK) == GARDMSB)
   1bebc:	07f6f793          	andi	a5,a3,127
   1bec0:	04000613          	li	a2,64
   1bec4:	08c78263          	beq	a5,a2,1bf48 <__mulsf3+0x140>
	  /* Avoid further rounding in pack_d.  */
	  high &= ~(fractype) GARDMASK;
	}
    }
  tmp->fraction.ll = high;
  tmp->class = CLASS_NUMBER;
   1bec8:	00300793          	li	a5,3

	  /* Avoid further rounding in pack_d.  */
	  high &= ~(fractype) GARDMASK;
	}
    }
  tmp->fraction.ll = high;
   1becc:	02d12e23          	sw	a3,60(sp)
  tmp->class = CLASS_NUMBER;
   1bed0:	02f12823          	sw	a5,48(sp)
  return tmp;
   1bed4:	03010513          	addi	a0,sp,48
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
   1bed8:	c61ff0ef          	jal	1bb38 <__pack_f>
}
   1bedc:	04c12083          	lw	ra,76(sp)
   1bee0:	05010113          	addi	sp,sp,80
   1bee4:	00008067          	ret
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isinf (b))
    {
      if (iszero (a))
   1bee8:	00200713          	li	a4,2
   1beec:	06e78a63          	beq	a5,a4,1bf60 <__mulsf3+0x158>
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isnan (b))
    {
      b->sign = a->sign != b->sign;
   1bef0:	02412703          	lw	a4,36(sp)
   1bef4:	01412783          	lw	a5,20(sp)
      return b;
   1bef8:	02010513          	addi	a0,sp,32
      a->sign = a->sign != b->sign;
      return a;
    }
  if (isnan (b))
    {
      b->sign = a->sign != b->sign;
   1befc:	40e787b3          	sub	a5,a5,a4
   1bf00:	00f037b3          	snez	a5,a5
   1bf04:	02f12223          	sw	a5,36(sp)
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
   1bf08:	c31ff0ef          	jal	1bb38 <__pack_f>
}
   1bf0c:	04c12083          	lw	ra,76(sp)
   1bf10:	05010113          	addi	sp,sp,80
   1bf14:	00008067          	ret
      b->sign = a->sign != b->sign;
      return b;
    }
  if (isinf (a))
    {
      if (iszero (b))
   1bf18:	00200793          	li	a5,2
   1bf1c:	04f70263          	beq	a4,a5,1bf60 <__mulsf3+0x158>
  fractype low = 0;
  fractype high = 0;

  if (isnan (a))
    {
      a->sign = a->sign != b->sign;
   1bf20:	02412703          	lw	a4,36(sp)
   1bf24:	01412783          	lw	a5,20(sp)
      return a;
   1bf28:	01010513          	addi	a0,sp,16
  fractype low = 0;
  fractype high = 0;

  if (isnan (a))
    {
      a->sign = a->sign != b->sign;
   1bf2c:	40e787b3          	sub	a5,a5,a4
   1bf30:	00f037b3          	snez	a5,a5
   1bf34:	00f12a23          	sw	a5,20(sp)
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpmul_parts (&a, &b, &tmp);

  return pack_d (res);
   1bf38:	c01ff0ef          	jal	1bb38 <__pack_f>
}
   1bf3c:	04c12083          	lw	ra,76(sp)
   1bf40:	05010113          	addi	sp,sp,80
   1bf44:	00008067          	ret
      low <<= 1;
    }

  if ((high & GARDMASK) == GARDMSB)
    {
      if (high & (1 << NGARDS))
   1bf48:	0806f793          	andi	a5,a3,128
   1bf4c:	f6079ee3          	bnez	a5,1bec8 <__mulsf3+0xc0>
	     function, and rounding twice will lose precision and cause
	     the result to be too far off.  Example: 32-bit floats with
	     bit patterns 0xfff * 0x3f800400 ~= 0xfff (less than 0.5ulp
	     off), not 0x1000 (more than 0.5ulp off).  */
	}
      else if (low)
   1bf50:	f6070ce3          	beqz	a4,1bec8 <__mulsf3+0xc0>
	{
	  /* We're a further than half way by a small amount corresponding
	     to the bits set in "low".  Knowing that, we round here and
	     not in pack_d, because there we don't have "low" available
	     anymore.  */
	  high += GARDROUND + 1;
   1bf54:	00c686b3          	add	a3,a3,a2

	  /* Avoid further rounding in pack_d.  */
	  high &= ~(fractype) GARDMASK;
   1bf58:	f806f693          	andi	a3,a3,-128
   1bf5c:	f6dff06f          	j	1bec8 <__mulsf3+0xc0>
      return b;
    }
  if (isinf (a))
    {
      if (iszero (b))
	return makenan ();
   1bf60:	0001d537          	lui	a0,0x1d
   1bf64:	ce050513          	addi	a0,a0,-800 # 1cce0 <__thenan_sf>
   1bf68:	f71ff06f          	j	1bed8 <__mulsf3+0xd0>
	  low >>= 1;
	  low |= FRACHIGH;
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
   1bf6c:	40000637          	lui	a2,0x40000
   1bf70:	f4c6f6e3          	bleu	a2,a3,1bebc <__mulsf3+0xb4>
   1bf74:	00178793          	addi	a5,a5,1
   1bf78:	0100006f          	j	1bf88 <__mulsf3+0x180>
      tmp->normal_exp--;

      high <<= 1;
      if (low & FRACHIGH)
	high |= 1;
      low <<= 1;
   1bf7c:	00171713          	slli	a4,a4,0x1
   1bf80:	fff78793          	addi	a5,a5,-1
	  low >>= 1;
	  low |= FRACHIGH;
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
   1bf84:	02c6f063          	bleu	a2,a3,1bfa4 <__mulsf3+0x19c>
    {
      tmp->normal_exp--;

      high <<= 1;
   1bf88:	00169693          	slli	a3,a3,0x1
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
    {
      tmp->normal_exp--;
   1bf8c:	00078593          	mv	a1,a5

      high <<= 1;
      if (low & FRACHIGH)
   1bf90:	fe0756e3          	bgez	a4,1bf7c <__mulsf3+0x174>
	high |= 1;
   1bf94:	0016e693          	ori	a3,a3,1
      low <<= 1;
   1bf98:	00171713          	slli	a4,a4,0x1
   1bf9c:	fff78793          	addi	a5,a5,-1
	  low >>= 1;
	  low |= FRACHIGH;
	}
      high >>= 1;
    }
  while (high < IMPLICIT_1)
   1bfa0:	fec6e4e3          	bltu	a3,a2,1bf88 <__mulsf3+0x180>
   1bfa4:	02b12c23          	sw	a1,56(sp)
   1bfa8:	f15ff06f          	j	1bebc <__mulsf3+0xb4>

0001bfac <__divsf3>:
  }
}

FLO_type
divide (FLO_type arg_a, FLO_type arg_b)
{
   1bfac:	fc010113          	addi	sp,sp,-64
  fp_number_type a;
  fp_number_type b;
  const fp_number_type *res;
  FLO_union_type au, bu;

  au.value = arg_a;
   1bfb0:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1bfb4:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1bfb8:	00810513          	addi	a0,sp,8
   1bfbc:	01010593          	addi	a1,sp,16
  }
}

FLO_type
divide (FLO_type arg_a, FLO_type arg_b)
{
   1bfc0:	02112e23          	sw	ra,60(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1bfc4:	cd1ff0ef          	jal	1bc94 <__unpack_f>
  unpack_d (&bu, &b);
   1bfc8:	02010593          	addi	a1,sp,32
   1bfcc:	00c10513          	addi	a0,sp,12
   1bfd0:	cc5ff0ef          	jal	1bc94 <__unpack_f>
   1bfd4:	01012683          	lw	a3,16(sp)
  fractype bit;
  fractype numerator;
  fractype denominator;
  fractype quotient;

  if (isnan (a))
   1bfd8:	00100793          	li	a5,1
   1bfdc:	08d7f663          	bleu	a3,a5,1c068 <__divsf3+0xbc>
   1bfe0:	02012603          	lw	a2,32(sp)
    {
      return a;
    }
  if (isnan (b))
   1bfe4:	0ec7f663          	bleu	a2,a5,1c0d0 <__divsf3+0x124>
    {
      return b;
    }

  a->sign = a->sign ^ b->sign;
   1bfe8:	01412583          	lw	a1,20(sp)
   1bfec:	02412703          	lw	a4,36(sp)

  if (isinf (a) || iszero (a))
   1bff0:	ffe68793          	addi	a5,a3,-2 # 7ffffffe <_gp+0x7ffb781e>
   1bff4:	ffd7f793          	andi	a5,a5,-3
  if (isnan (b))
    {
      return b;
    }

  a->sign = a->sign ^ b->sign;
   1bff8:	00e5c733          	xor	a4,a1,a4
   1bffc:	00e12a23          	sw	a4,20(sp)

  if (isinf (a) || iszero (a))
   1c000:	06078e63          	beqz	a5,1c07c <__divsf3+0xd0>
      if (a->class == b->class)
	return makenan ();
      return a;
    }

  if (isinf (b))
   1c004:	00400793          	li	a5,4
   1c008:	08f60a63          	beq	a2,a5,1c09c <__divsf3+0xf0>
    {
      a->fraction.ll = 0;
      a->normal_exp = 0;
      return a;
    }
  if (iszero (b))
   1c00c:	00200713          	li	a4,2
   1c010:	0ae60a63          	beq	a2,a4,1c0c4 <__divsf3+0x118>
  {
    /* quotient =
       ( numerator / denominator) * 2^(numerator exponent -  denominator exponent)
     */

    a->normal_exp = a->normal_exp - b->normal_exp;
   1c014:	01812703          	lw	a4,24(sp)
   1c018:	02812683          	lw	a3,40(sp)
    numerator = a->fraction.ll;
   1c01c:	01c12783          	lw	a5,28(sp)
    denominator = b->fraction.ll;
   1c020:	02c12603          	lw	a2,44(sp)
  {
    /* quotient =
       ( numerator / denominator) * 2^(numerator exponent -  denominator exponent)
     */

    a->normal_exp = a->normal_exp - b->normal_exp;
   1c024:	40d70733          	sub	a4,a4,a3
   1c028:	00e12c23          	sw	a4,24(sp)
    numerator = a->fraction.ll;
    denominator = b->fraction.ll;

    if (numerator < denominator)
   1c02c:	06c7e063          	bltu	a5,a2,1c08c <__divsf3+0xe0>
  }
}

FLO_type
divide (FLO_type arg_a, FLO_type arg_b)
{
   1c030:	01f00713          	li	a4,31
	/* Fraction will be less than 1.0 */
	numerator *= 2;
	a->normal_exp--;
      }
    bit = IMPLICIT_1;
    quotient = 0;
   1c034:	00000593          	li	a1,0
      {
	/* Fraction will be less than 1.0 */
	numerator *= 2;
	a->normal_exp--;
      }
    bit = IMPLICIT_1;
   1c038:	400006b7          	lui	a3,0x40000
   1c03c:	fff70713          	addi	a4,a4,-1
    quotient = 0;
    /* ??? Does divide one bit at a time.  Optimize.  */
    while (bit)
      {
	if (numerator >= denominator)
   1c040:	00c7e663          	bltu	a5,a2,1c04c <__divsf3+0xa0>
	  {
	    quotient |= bit;
   1c044:	00d5e5b3          	or	a1,a1,a3
	    numerator -= denominator;
   1c048:	40c787b3          	sub	a5,a5,a2
	  }
	bit >>= 1;
   1c04c:	0016d693          	srli	a3,a3,0x1
	numerator *= 2;
   1c050:	00179793          	slli	a5,a5,0x1
	a->normal_exp--;
      }
    bit = IMPLICIT_1;
    quotient = 0;
    /* ??? Does divide one bit at a time.  Optimize.  */
    while (bit)
   1c054:	fe0714e3          	bnez	a4,1c03c <__divsf3+0x90>
	  }
	bit >>= 1;
	numerator *= 2;
      }

    if ((quotient & GARDMASK) == GARDMSB)
   1c058:	07f5f713          	andi	a4,a1,127
   1c05c:	04000693          	li	a3,64
   1c060:	04d70663          	beq	a4,a3,1c0ac <__divsf3+0x100>
	    /* Avoid further rounding in pack_d.  */
	    quotient &= ~(fractype) GARDMASK;
	  }
      }

    a->fraction.ll = quotient;
   1c064:	00b12e23          	sw	a1,28(sp)
    return (a);
   1c068:	01010513          	addi	a0,sp,16
  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  res = _fpdiv_parts (&a, &b);

  return pack_d (res);
   1c06c:	acdff0ef          	jal	1bb38 <__pack_f>
}
   1c070:	03c12083          	lw	ra,60(sp)
   1c074:	04010113          	addi	sp,sp,64
   1c078:	00008067          	ret

  a->sign = a->sign ^ b->sign;

  if (isinf (a) || iszero (a))
    {
      if (a->class == b->class)
   1c07c:	fec696e3          	bne	a3,a2,1c068 <__divsf3+0xbc>
	return makenan ();
   1c080:	0001d537          	lui	a0,0x1d
   1c084:	ce050513          	addi	a0,a0,-800 # 1cce0 <__thenan_sf>
   1c088:	fe5ff06f          	j	1c06c <__divsf3+0xc0>

    if (numerator < denominator)
      {
	/* Fraction will be less than 1.0 */
	numerator *= 2;
	a->normal_exp--;
   1c08c:	fff70713          	addi	a4,a4,-1
    denominator = b->fraction.ll;

    if (numerator < denominator)
      {
	/* Fraction will be less than 1.0 */
	numerator *= 2;
   1c090:	00179793          	slli	a5,a5,0x1
	a->normal_exp--;
   1c094:	00e12c23          	sw	a4,24(sp)
   1c098:	f99ff06f          	j	1c030 <__divsf3+0x84>
      return a;
    }

  if (isinf (b))
    {
      a->fraction.ll = 0;
   1c09c:	00012e23          	sw	zero,28(sp)
      a->normal_exp = 0;
   1c0a0:	00012c23          	sw	zero,24(sp)
      return a;
   1c0a4:	01010513          	addi	a0,sp,16
   1c0a8:	fc5ff06f          	j	1c06c <__divsf3+0xc0>
	numerator *= 2;
      }

    if ((quotient & GARDMASK) == GARDMSB)
      {
	if (quotient & (1 << NGARDS))
   1c0ac:	0805f713          	andi	a4,a1,128
   1c0b0:	fa071ae3          	bnez	a4,1c064 <__divsf3+0xb8>
	    /* Because we're half way, we would round to even by adding
	       GARDROUND + 1, except that's also done in the packing
	       function, and rounding twice will lose precision and cause
	       the result to be too far off.  */
	  }
	else if (numerator)
   1c0b4:	fa0788e3          	beqz	a5,1c064 <__divsf3+0xb8>
	  {
	    /* We're a further than half way by the small amount
	       corresponding to the bits set in "numerator".  Knowing
	       that, we round here and not in pack_d, because there we
	       don't have "numerator" available anymore.  */
	    quotient += GARDROUND + 1;
   1c0b8:	00d585b3          	add	a1,a1,a3

	    /* Avoid further rounding in pack_d.  */
	    quotient &= ~(fractype) GARDMASK;
   1c0bc:	f805f593          	andi	a1,a1,-128
   1c0c0:	fa5ff06f          	j	1c064 <__divsf3+0xb8>
      a->normal_exp = 0;
      return a;
    }
  if (iszero (b))
    {
      a->class = CLASS_INFINITY;
   1c0c4:	00f12823          	sw	a5,16(sp)
      return a;
   1c0c8:	01010513          	addi	a0,sp,16
   1c0cc:	fa1ff06f          	j	1c06c <__divsf3+0xc0>
    {
      return a;
    }
  if (isnan (b))
    {
      return b;
   1c0d0:	02010513          	addi	a0,sp,32
   1c0d4:	f99ff06f          	j	1c06c <__divsf3+0xc0>

0001c0d8 <__fpcmp_parts_f>:
   a>b -> +1
 */

int
__fpcmp_parts (fp_number_type * a, fp_number_type * b)
{
   1c0d8:	00052703          	lw	a4,0(a0)
    {
      return 1;			/* still unordered! */
    }
#endif

  if (isnan (a) || isnan (b))
   1c0dc:	00100793          	li	a5,1
   a>b -> +1
 */

int
__fpcmp_parts (fp_number_type * a, fp_number_type * b)
{
   1c0e0:	00050613          	mv	a2,a0
    {
      return 1;			/* still unordered! */
    }
#endif

  if (isnan (a) || isnan (b))
   1c0e4:	06e7fe63          	bleu	a4,a5,1c160 <__fpcmp_parts_f+0x88>
   1c0e8:	0005a683          	lw	a3,0(a1)
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1c0ec:	00078513          	mv	a0,a5
    {
      return 1;			/* still unordered! */
    }
#endif

  if (isnan (a) || isnan (b))
   1c0f0:	04d7f063          	bleu	a3,a5,1c130 <__fpcmp_parts_f+0x58>
    {
      return 1;			/* how to indicate unordered compare? */
    }
  if (isinf (a) && isinf (b))
   1c0f4:	00400793          	li	a5,4
   1c0f8:	04f70863          	beq	a4,a5,1c148 <__fpcmp_parts_f+0x70>
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
    }
  if (isinf (b))
   1c0fc:	02f68c63          	beq	a3,a5,1c134 <__fpcmp_parts_f+0x5c>
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (a) && iszero (b))
   1c100:	00200793          	li	a5,2
   1c104:	02f70263          	beq	a4,a5,1c128 <__fpcmp_parts_f+0x50>
    }
  if (iszero (a))
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (b))
   1c108:	04f68263          	beq	a3,a5,1c14c <__fpcmp_parts_f+0x74>
    {
      return a->sign ? -1 : 1;
    }
  /* now both are "normal".  */
  if (a->sign != b->sign)
   1c10c:	00462783          	lw	a5,4(a2) # 40000004 <_gp+0x3ffb7824>
   1c110:	0045a703          	lw	a4,4(a1)
   1c114:	04e78a63          	beq	a5,a4,1c168 <__fpcmp_parts_f+0x90>
    {
      return a->sign ? -1 : 1;
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
   1c118:	00f03533          	snez	a0,a5
   1c11c:	40a00533          	neg	a0,a0
   1c120:	00156513          	ori	a0,a0,1
   1c124:	00008067          	ret
    }
  if (iszero (a) && iszero (b))
   1c128:	00e69663          	bne	a3,a4,1c134 <__fpcmp_parts_f+0x5c>
    {
      return 0;
   1c12c:	00000513          	li	a0,0
    {
      return a->sign ? 1 : -1;
    }
  /* after all that, they're equal.  */
  return 0;
}
   1c130:	00008067          	ret
    {
      return a->sign ? -1 : 1;
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
   1c134:	0045a503          	lw	a0,4(a1)
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1c138:	00153513          	seqz	a0,a0
   1c13c:	40a00533          	neg	a0,a0
   1c140:	00156513          	ori	a0,a0,1
   1c144:	00008067          	ret

  if (isnan (a) || isnan (b))
    {
      return 1;			/* how to indicate unordered compare? */
    }
  if (isinf (a) && isinf (b))
   1c148:	04e68a63          	beq	a3,a4,1c19c <__fpcmp_parts_f+0xc4>
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1c14c:	00462503          	lw	a0,4(a2)
    }
  if (isinf (b))
    {
      return b->sign ? 1 : -1;
   1c150:	00a03533          	snez	a0,a0
   1c154:	40a00533          	neg	a0,a0
   1c158:	00156513          	ori	a0,a0,1
   1c15c:	00008067          	ret
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1c160:	00078513          	mv	a0,a5
   1c164:	00008067          	ret
    {
      /* opposite signs */
      return a->sign ? -1 : 1;
    }
  /* same sign; exponents? */
  if (a->normal_exp > b->normal_exp)
   1c168:	00862683          	lw	a3,8(a2)
   1c16c:	0085a703          	lw	a4,8(a1)
   1c170:	fad744e3          	blt	a4,a3,1c118 <__fpcmp_parts_f+0x40>
    {
      return a->sign ? -1 : 1;
    }
  if (a->normal_exp < b->normal_exp)
   1c174:	00e6cc63          	blt	a3,a4,1c18c <__fpcmp_parts_f+0xb4>
    {
      return a->sign ? 1 : -1;
    }
  /* same exponents; check size.  */
  if (a->fraction.ll > b->fraction.ll)
   1c178:	00c62683          	lw	a3,12(a2)
   1c17c:	00c5a703          	lw	a4,12(a1)
   1c180:	f8d76ce3          	bltu	a4,a3,1c118 <__fpcmp_parts_f+0x40>
    {
      return b->sign ? 1 : -1;
    }
  if (iszero (a) && iszero (b))
    {
      return 0;
   1c184:	00000513          	li	a0,0
  /* same exponents; check size.  */
  if (a->fraction.ll > b->fraction.ll)
    {
      return a->sign ? -1 : 1;
    }
  if (a->fraction.ll < b->fraction.ll)
   1c188:	fae6f4e3          	bleu	a4,a3,1c130 <__fpcmp_parts_f+0x58>
      return b->sign - a->sign;
    }
  /* but not both...  */
  if (isinf (a))
    {
      return a->sign ? -1 : 1;
   1c18c:	0017b513          	seqz	a0,a5
   1c190:	40a00533          	neg	a0,a0
   1c194:	00156513          	ori	a0,a0,1
   1c198:	00008067          	ret
       -------+--------+--------
       -inf(1)| a>b(1) | a==b(0)
       -------+--------+--------
       So since unordered must be nonzero, just line up the columns...
       */
      return b->sign - a->sign;
   1c19c:	0045a783          	lw	a5,4(a1)
   1c1a0:	00462503          	lw	a0,4(a2)
   1c1a4:	40a78533          	sub	a0,a5,a0
   1c1a8:	00008067          	ret

0001c1ac <__cmpsf2>:
#endif

#if defined(L_compare_sf) || defined(L_compare_df) || defined(L_compoare_tf)
CMPtype
compare (FLO_type arg_a, FLO_type arg_b)
{
   1c1ac:	fc010113          	addi	sp,sp,-64
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1c1b0:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1c1b4:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1c1b8:	00810513          	addi	a0,sp,8
   1c1bc:	01010593          	addi	a1,sp,16
#endif

#if defined(L_compare_sf) || defined(L_compare_df) || defined(L_compoare_tf)
CMPtype
compare (FLO_type arg_a, FLO_type arg_b)
{
   1c1c0:	02112e23          	sw	ra,60(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1c1c4:	ad1ff0ef          	jal	1bc94 <__unpack_f>
  unpack_d (&bu, &b);
   1c1c8:	02010593          	addi	a1,sp,32
   1c1cc:	00c10513          	addi	a0,sp,12
   1c1d0:	ac5ff0ef          	jal	1bc94 <__unpack_f>

  return __fpcmp_parts (&a, &b);
   1c1d4:	02010593          	addi	a1,sp,32
   1c1d8:	01010513          	addi	a0,sp,16
   1c1dc:	efdff0ef          	jal	1c0d8 <__fpcmp_parts_f>
}
   1c1e0:	03c12083          	lw	ra,60(sp)
   1c1e4:	04010113          	addi	sp,sp,64
   1c1e8:	00008067          	ret

0001c1ec <__gesf2>:
#endif /* L_gt_sf || L_gt_df */

#if defined(L_ge_sf) || defined(L_ge_df) || defined(L_ge_tf)
CMPtype
_ge_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1c1ec:	fc010113          	addi	sp,sp,-64
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1c1f0:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1c1f4:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1c1f8:	00810513          	addi	a0,sp,8
   1c1fc:	01010593          	addi	a1,sp,16
#endif /* L_gt_sf || L_gt_df */

#if defined(L_ge_sf) || defined(L_ge_df) || defined(L_ge_tf)
CMPtype
_ge_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1c200:	02112e23          	sw	ra,60(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1c204:	a91ff0ef          	jal	1bc94 <__unpack_f>
  unpack_d (&bu, &b);
   1c208:	00c10513          	addi	a0,sp,12
   1c20c:	02010593          	addi	a1,sp,32
   1c210:	a85ff0ef          	jal	1bc94 <__unpack_f>

  if (isnan (&a) || isnan (&b))
   1c214:	01012703          	lw	a4,16(sp)
   1c218:	00100793          	li	a5,1
    return -1;			/* false, truth >= 0 */
   1c21c:	fff00513          	li	a0,-1
  bu.value = arg_b;

  unpack_d (&au, &a);
  unpack_d (&bu, &b);

  if (isnan (&a) || isnan (&b))
   1c220:	00e7fc63          	bleu	a4,a5,1c238 <__gesf2+0x4c>
   1c224:	02012703          	lw	a4,32(sp)
   1c228:	00e7f863          	bleu	a4,a5,1c238 <__gesf2+0x4c>
    return -1;			/* false, truth >= 0 */
  return __fpcmp_parts (&a, &b) ;
   1c22c:	02010593          	addi	a1,sp,32
   1c230:	01010513          	addi	a0,sp,16
   1c234:	ea5ff0ef          	jal	1c0d8 <__fpcmp_parts_f>
}
   1c238:	03c12083          	lw	ra,60(sp)
   1c23c:	04010113          	addi	sp,sp,64
   1c240:	00008067          	ret

0001c244 <__gtsf2>:
   1c244:	fa9ff06f          	j	1c1ec <__gesf2>

0001c248 <__lesf2>:
#endif /* L_lt_sf || L_lt_df */

#if defined(L_le_sf) || defined(L_le_df) || defined(L_le_tf)
CMPtype
_le_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1c248:	fc010113          	addi	sp,sp,-64
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1c24c:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1c250:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1c254:	00810513          	addi	a0,sp,8
   1c258:	01010593          	addi	a1,sp,16
#endif /* L_lt_sf || L_lt_df */

#if defined(L_le_sf) || defined(L_le_df) || defined(L_le_tf)
CMPtype
_le_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1c25c:	02112e23          	sw	ra,60(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1c260:	a35ff0ef          	jal	1bc94 <__unpack_f>
  unpack_d (&bu, &b);
   1c264:	00c10513          	addi	a0,sp,12
   1c268:	02010593          	addi	a1,sp,32
   1c26c:	a29ff0ef          	jal	1bc94 <__unpack_f>

  if (isnan (&a) || isnan (&b))
   1c270:	01012783          	lw	a5,16(sp)
   1c274:	00100513          	li	a0,1
   1c278:	00f57c63          	bleu	a5,a0,1c290 <__lesf2+0x48>
   1c27c:	02012783          	lw	a5,32(sp)
   1c280:	00f57863          	bleu	a5,a0,1c290 <__lesf2+0x48>
    return 1;			/* false, truth <= 0 */

  return __fpcmp_parts (&a, &b) ;
   1c284:	02010593          	addi	a1,sp,32
   1c288:	01010513          	addi	a0,sp,16
   1c28c:	e4dff0ef          	jal	1c0d8 <__fpcmp_parts_f>
}
   1c290:	03c12083          	lw	ra,60(sp)
   1c294:	04010113          	addi	sp,sp,64
   1c298:	00008067          	ret

0001c29c <__ltsf2>:
   1c29c:	fadff06f          	j	1c248 <__lesf2>

0001c2a0 <__nesf2>:
   1c2a0:	fa9ff06f          	j	1c248 <__lesf2>

0001c2a4 <__eqsf2>:
   1c2a4:	fa5ff06f          	j	1c248 <__lesf2>

0001c2a8 <__unordsf2>:
#endif /* L_le_sf || L_le_df */

#if defined(L_unord_sf) || defined(L_unord_df) || defined(L_unord_tf)
CMPtype
_unord_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1c2a8:	fc010113          	addi	sp,sp,-64
  fp_number_type a;
  fp_number_type b;
  FLO_union_type au, bu;

  au.value = arg_a;
   1c2ac:	00a12423          	sw	a0,8(sp)
  bu.value = arg_b;
   1c2b0:	00b12623          	sw	a1,12(sp)

  unpack_d (&au, &a);
   1c2b4:	00810513          	addi	a0,sp,8
   1c2b8:	01010593          	addi	a1,sp,16
#endif /* L_le_sf || L_le_df */

#if defined(L_unord_sf) || defined(L_unord_df) || defined(L_unord_tf)
CMPtype
_unord_f2 (FLO_type arg_a, FLO_type arg_b)
{
   1c2bc:	02112e23          	sw	ra,60(sp)
  FLO_union_type au, bu;

  au.value = arg_a;
  bu.value = arg_b;

  unpack_d (&au, &a);
   1c2c0:	9d5ff0ef          	jal	1bc94 <__unpack_f>
  unpack_d (&bu, &b);
   1c2c4:	00c10513          	addi	a0,sp,12
   1c2c8:	02010593          	addi	a1,sp,32
   1c2cc:	9c9ff0ef          	jal	1bc94 <__unpack_f>

  return (isnan (&a) || isnan (&b));
   1c2d0:	01012783          	lw	a5,16(sp)
   1c2d4:	00100513          	li	a0,1
   1c2d8:	00f57663          	bleu	a5,a0,1c2e4 <__unordsf2+0x3c>
   1c2dc:	02012503          	lw	a0,32(sp)
   1c2e0:	00253513          	sltiu	a0,a0,2
}
   1c2e4:	03c12083          	lw	ra,60(sp)
   1c2e8:	04010113          	addi	sp,sp,64
   1c2ec:	00008067          	ret

0001c2f0 <__floatsisf>:
#endif /* L_unord_sf || L_unord_df */

#if defined(L_si_to_sf) || defined(L_si_to_df) || defined(L_si_to_tf)
FLO_type
si_to_float (SItype arg_a)
{
   1c2f0:	fe010113          	addi	sp,sp,-32
  fp_number_type in;

  in.class = CLASS_NUMBER;
  in.sign = arg_a < 0;
   1c2f4:	01f55793          	srli	a5,a0,0x1f
FLO_type
si_to_float (SItype arg_a)
{
  fp_number_type in;

  in.class = CLASS_NUMBER;
   1c2f8:	00300713          	li	a4,3
#endif /* L_unord_sf || L_unord_df */

#if defined(L_si_to_sf) || defined(L_si_to_df) || defined(L_si_to_tf)
FLO_type
si_to_float (SItype arg_a)
{
   1c2fc:	00112e23          	sw	ra,28(sp)
   1c300:	00812c23          	sw	s0,24(sp)
  fp_number_type in;

  in.class = CLASS_NUMBER;
   1c304:	00e12023          	sw	a4,0(sp)
  in.sign = arg_a < 0;
   1c308:	00f12223          	sw	a5,4(sp)
  if (!arg_a)
   1c30c:	02051263          	bnez	a0,1c330 <__floatsisf+0x40>
    {
      in.class = CLASS_ZERO;
   1c310:	00200793          	li	a5,2
   1c314:	00f12023          	sw	a5,0(sp)
	{
	  in.fraction.ll <<= shift;
	  in.normal_exp -= shift;
	}
    }
  return pack_d (&in);
   1c318:	00010513          	mv	a0,sp
   1c31c:	81dff0ef          	jal	1bb38 <__pack_f>
}
   1c320:	01c12083          	lw	ra,28(sp)
   1c324:	01812403          	lw	s0,24(sp)
   1c328:	02010113          	addi	sp,sp,32
   1c32c:	00008067          	ret
    }
  else
    {
      USItype uarg;
      int shift;
      in.normal_exp = FRACBITS + NGARDS;
   1c330:	01e00793          	li	a5,30
   1c334:	00f12423          	sw	a5,8(sp)
      if (in.sign) 
   1c338:	02054863          	bltz	a0,1c368 <__floatsisf+0x78>
	      return (FLO_type)(- MAX_SI_INT - 1);
	    }
	  uarg = (-arg_a);
	}
      else
	uarg = arg_a;
   1c33c:	00050413          	mv	s0,a0
static int
clzusi (USItype n)
{
  extern int __clzsi2 (USItype);
  if (sizeof (USItype) == sizeof (unsigned int))
    return __builtin_clz (n);
   1c340:	00040513          	mv	a0,s0
   1c344:	dbcff0ef          	jal	1b900 <__clzsi2>
	}
      else
	uarg = arg_a;

      in.fraction.ll = uarg;
      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
   1c348:	fff50793          	addi	a5,a0,-1
      if (shift > 0)
   1c34c:	02078c63          	beqz	a5,1c384 <__floatsisf+0x94>
	{
	  in.fraction.ll <<= shift;
	  in.normal_exp -= shift;
   1c350:	01e00713          	li	a4,30

      in.fraction.ll = uarg;
      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
      if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1c354:	00f41533          	sll	a0,s0,a5
	  in.normal_exp -= shift;
   1c358:	40f707b3          	sub	a5,a4,a5

      in.fraction.ll = uarg;
      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
      if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1c35c:	00a12623          	sw	a0,12(sp)
	  in.normal_exp -= shift;
   1c360:	00f12423          	sw	a5,8(sp)
   1c364:	fb5ff06f          	j	1c318 <__floatsisf+0x28>
      in.normal_exp = FRACBITS + NGARDS;
      if (in.sign) 
	{
	  /* Special case for minint, since there is no +ve integer
	     representation for it */
	  if (arg_a == (- MAX_SI_INT - 1))
   1c368:	800007b7          	lui	a5,0x80000
   1c36c:	02f50063          	beq	a0,a5,1c38c <__floatsisf+0x9c>
	    {
	      return (FLO_type)(- MAX_SI_INT - 1);
	    }
	  uarg = (-arg_a);
   1c370:	40a00433          	neg	s0,a0
static int
clzusi (USItype n)
{
  extern int __clzsi2 (USItype);
  if (sizeof (USItype) == sizeof (unsigned int))
    return __builtin_clz (n);
   1c374:	00040513          	mv	a0,s0
   1c378:	d88ff0ef          	jal	1b900 <__clzsi2>
	}
      else
	uarg = arg_a;

      in.fraction.ll = uarg;
      shift = clzusi (uarg) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
   1c37c:	fff50793          	addi	a5,a0,-1
      if (shift > 0)
   1c380:	fc0798e3          	bnez	a5,1c350 <__floatsisf+0x60>
	  uarg = (-arg_a);
	}
      else
	uarg = arg_a;

      in.fraction.ll = uarg;
   1c384:	00812623          	sw	s0,12(sp)
   1c388:	f91ff06f          	j	1c318 <__floatsisf+0x28>
	{
	  /* Special case for minint, since there is no +ve integer
	     representation for it */
	  if (arg_a == (- MAX_SI_INT - 1))
	    {
	      return (FLO_type)(- MAX_SI_INT - 1);
   1c38c:	8781a503          	lw	a0,-1928(gp) # 48058 <__wctomb+0x58>
   1c390:	f91ff06f          	j	1c320 <__floatsisf+0x30>

0001c394 <__floatunsisf>:
#endif /* L_si_to_sf || L_si_to_df */

#if defined(L_usi_to_sf) || defined(L_usi_to_df) || defined(L_usi_to_tf)
FLO_type
usi_to_float (USItype arg_a)
{
   1c394:	fe010113          	addi	sp,sp,-32
   1c398:	00112e23          	sw	ra,28(sp)
   1c39c:	00812c23          	sw	s0,24(sp)
   1c3a0:	00912a23          	sw	s1,20(sp)
  fp_number_type in;

  in.sign = 0;
   1c3a4:	00012223          	sw	zero,4(sp)
  if (!arg_a)
   1c3a8:	04050a63          	beqz	a0,1c3fc <__floatunsisf+0x68>
      in.class = CLASS_ZERO;
    }
  else
    {
      int shift;
      in.class = CLASS_NUMBER;
   1c3ac:	00300793          	li	a5,3
      in.normal_exp = FRACBITS + NGARDS;
   1c3b0:	01e00493          	li	s1,30
      in.class = CLASS_ZERO;
    }
  else
    {
      int shift;
      in.class = CLASS_NUMBER;
   1c3b4:	00f12023          	sw	a5,0(sp)
   1c3b8:	00050413          	mv	s0,a0
      in.normal_exp = FRACBITS + NGARDS;
   1c3bc:	00912423          	sw	s1,8(sp)
static int
clzusi (USItype n)
{
  extern int __clzsi2 (USItype);
  if (sizeof (USItype) == sizeof (unsigned int))
    return __builtin_clz (n);
   1c3c0:	d40ff0ef          	jal	1b900 <__clzsi2>
      in.class = CLASS_NUMBER;
      in.normal_exp = FRACBITS + NGARDS;
      in.fraction.ll = arg_a;

      shift = clzusi (arg_a) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
      if (shift < 0)
   1c3c4:	fff50793          	addi	a5,a0,-1
   1c3c8:	04050063          	beqz	a0,1c408 <__floatunsisf+0x74>
	  fractype guard = in.fraction.ll & (((fractype)1 << -shift) - 1);
	  in.fraction.ll >>= -shift;
	  in.fraction.ll |= (guard != 0);
	  in.normal_exp -= shift;
	}
      else if (shift > 0)
   1c3cc:	04078c63          	beqz	a5,1c424 <__floatunsisf+0x90>
	{
	  in.fraction.ll <<= shift;
   1c3d0:	00f41433          	sll	s0,s0,a5
	  in.normal_exp -= shift;
   1c3d4:	40f484b3          	sub	s1,s1,a5
	  in.fraction.ll |= (guard != 0);
	  in.normal_exp -= shift;
	}
      else if (shift > 0)
	{
	  in.fraction.ll <<= shift;
   1c3d8:	00812623          	sw	s0,12(sp)
	  in.normal_exp -= shift;
   1c3dc:	00912423          	sw	s1,8(sp)
	}
    }
  return pack_d (&in);
   1c3e0:	00010513          	mv	a0,sp
   1c3e4:	f54ff0ef          	jal	1bb38 <__pack_f>
}
   1c3e8:	01c12083          	lw	ra,28(sp)
   1c3ec:	01812403          	lw	s0,24(sp)
   1c3f0:	01412483          	lw	s1,20(sp)
   1c3f4:	02010113          	addi	sp,sp,32
   1c3f8:	00008067          	ret
  fp_number_type in;

  in.sign = 0;
  if (!arg_a)
    {
      in.class = CLASS_ZERO;
   1c3fc:	00200793          	li	a5,2
   1c400:	00f12023          	sw	a5,0(sp)
   1c404:	fddff06f          	j	1c3e0 <__floatunsisf+0x4c>
      shift = clzusi (arg_a) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
      if (shift < 0)
	{
	  fractype guard = in.fraction.ll & (((fractype)1 << -shift) - 1);
	  in.fraction.ll >>= -shift;
	  in.fraction.ll |= (guard != 0);
   1c408:	00147793          	andi	a5,s0,1
   1c40c:	00145413          	srli	s0,s0,0x1
   1c410:	0087e433          	or	s0,a5,s0
	  in.normal_exp -= shift;
   1c414:	01f00793          	li	a5,31
      shift = clzusi (arg_a) - (BITS_PER_SI - 1 - FRACBITS - NGARDS);
      if (shift < 0)
	{
	  fractype guard = in.fraction.ll & (((fractype)1 << -shift) - 1);
	  in.fraction.ll >>= -shift;
	  in.fraction.ll |= (guard != 0);
   1c418:	00812623          	sw	s0,12(sp)
	  in.normal_exp -= shift;
   1c41c:	00f12423          	sw	a5,8(sp)
   1c420:	fc1ff06f          	j	1c3e0 <__floatunsisf+0x4c>
  else
    {
      int shift;
      in.class = CLASS_NUMBER;
      in.normal_exp = FRACBITS + NGARDS;
      in.fraction.ll = arg_a;
   1c424:	00812623          	sw	s0,12(sp)
   1c428:	fb9ff06f          	j	1c3e0 <__floatunsisf+0x4c>

0001c42c <__fixsfsi>:
#endif

#if defined(L_sf_to_si) || defined(L_df_to_si) || defined(L_tf_to_si)
SItype
float_to_si (FLO_type arg_a)
{
   1c42c:	fd010113          	addi	sp,sp,-48
  fp_number_type a;
  SItype tmp;
  FLO_union_type au;

  au.value = arg_a;
   1c430:	00a12623          	sw	a0,12(sp)
  unpack_d (&au, &a);
   1c434:	01010593          	addi	a1,sp,16
   1c438:	00c10513          	addi	a0,sp,12
#endif

#if defined(L_sf_to_si) || defined(L_df_to_si) || defined(L_tf_to_si)
SItype
float_to_si (FLO_type arg_a)
{
   1c43c:	02112623          	sw	ra,44(sp)
  fp_number_type a;
  SItype tmp;
  FLO_union_type au;

  au.value = arg_a;
  unpack_d (&au, &a);
   1c440:	855ff0ef          	jal	1bc94 <__unpack_f>
   1c444:	01012783          	lw	a5,16(sp)

  if (iszero (&a))
    return 0;
  if (isnan (&a))
   1c448:	00200713          	li	a4,2
   1c44c:	04f77e63          	bleu	a5,a4,1c4a8 <__fixsfsi+0x7c>
    return 0;
  /* get reasonable MAX_SI_INT...  */
  if (isinf (&a))
   1c450:	00400713          	li	a4,4
   1c454:	00e78a63          	beq	a5,a4,1c468 <__fixsfsi+0x3c>
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  /* it is a number, but a small one */
  if (a.normal_exp < 0)
   1c458:	01812783          	lw	a5,24(sp)
   1c45c:	0407c663          	bltz	a5,1c4a8 <__fixsfsi+0x7c>
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
   1c460:	01e00513          	li	a0,30
   1c464:	02f55063          	ble	a5,a0,1c484 <__fixsfsi+0x58>
    return 0;
  if (isnan (&a))
    return 0;
  /* get reasonable MAX_SI_INT...  */
  if (isinf (&a))
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
   1c468:	01412783          	lw	a5,20(sp)
   1c46c:	80000537          	lui	a0,0x80000
   1c470:	00079463          	bnez	a5,1c478 <__fixsfsi+0x4c>
   1c474:	fff54513          	not	a0,a0
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
  return a.sign ? (-tmp) : (tmp);
}
   1c478:	02c12083          	lw	ra,44(sp)
   1c47c:	03010113          	addi	sp,sp,48
   1c480:	00008067          	ret
  /* it is a number, but a small one */
  if (a.normal_exp < 0)
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
   1c484:	40f50533          	sub	a0,a0,a5
  return a.sign ? (-tmp) : (tmp);
   1c488:	01c12783          	lw	a5,28(sp)
   1c48c:	00a7d533          	srl	a0,a5,a0
   1c490:	01412783          	lw	a5,20(sp)
   1c494:	fe0782e3          	beqz	a5,1c478 <__fixsfsi+0x4c>
}
   1c498:	02c12083          	lw	ra,44(sp)
  if (a.normal_exp < 0)
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
  return a.sign ? (-tmp) : (tmp);
   1c49c:	40a00533          	neg	a0,a0
}
   1c4a0:	03010113          	addi	sp,sp,48
   1c4a4:	00008067          	ret
   1c4a8:	02c12083          	lw	ra,44(sp)
  unpack_d (&au, &a);

  if (iszero (&a))
    return 0;
  if (isnan (&a))
    return 0;
   1c4ac:	00000513          	li	a0,0
    return 0;
  if (a.normal_exp > BITS_PER_SI - 2)
    return a.sign ? (-MAX_SI_INT)-1 : MAX_SI_INT;
  tmp = a.fraction.ll >> ((FRACBITS + NGARDS) - a.normal_exp);
  return a.sign ? (-tmp) : (tmp);
}
   1c4b0:	03010113          	addi	sp,sp,48
   1c4b4:	00008067          	ret

0001c4b8 <__negsf2>:
#endif /* L_tf_to_usi */

#if defined(L_negate_sf) || defined(L_negate_df) || defined(L_negate_tf)
FLO_type
negate (FLO_type arg_a)
{
   1c4b8:	fd010113          	addi	sp,sp,-48
  fp_number_type a;
  FLO_union_type au;

  au.value = arg_a;
   1c4bc:	00a12623          	sw	a0,12(sp)
  unpack_d (&au, &a);
   1c4c0:	01010593          	addi	a1,sp,16
   1c4c4:	00c10513          	addi	a0,sp,12
#endif /* L_tf_to_usi */

#if defined(L_negate_sf) || defined(L_negate_df) || defined(L_negate_tf)
FLO_type
negate (FLO_type arg_a)
{
   1c4c8:	02112623          	sw	ra,44(sp)
  fp_number_type a;
  FLO_union_type au;

  au.value = arg_a;
  unpack_d (&au, &a);
   1c4cc:	fc8ff0ef          	jal	1bc94 <__unpack_f>

INLINE 
static void
flip_sign ( fp_number_type *  x)
{
  x->sign = !x->sign;
   1c4d0:	01412783          	lw	a5,20(sp)

  au.value = arg_a;
  unpack_d (&au, &a);

  flip_sign (&a);
  return pack_d (&a);
   1c4d4:	01010513          	addi	a0,sp,16

INLINE 
static void
flip_sign ( fp_number_type *  x)
{
  x->sign = !x->sign;
   1c4d8:	0017b793          	seqz	a5,a5
   1c4dc:	00f12a23          	sw	a5,20(sp)

  au.value = arg_a;
  unpack_d (&au, &a);

  flip_sign (&a);
  return pack_d (&a);
   1c4e0:	e58ff0ef          	jal	1bb38 <__pack_f>
}
   1c4e4:	02c12083          	lw	ra,44(sp)
   1c4e8:	03010113          	addi	sp,sp,48
   1c4ec:	00008067          	ret

0001c4f0 <__make_fp>:
SFtype
__make_fp(fp_class_type class,
	     unsigned int sign,
	     int exp, 
	     USItype frac)
{
   1c4f0:	fe010113          	addi	sp,sp,-32
  fp_number_type in;

  in.class = class;
   1c4f4:	00a12023          	sw	a0,0(sp)
  in.sign = sign;
  in.normal_exp = exp;
  in.fraction.ll = frac;
  return pack_d (&in);
   1c4f8:	00010513          	mv	a0,sp
SFtype
__make_fp(fp_class_type class,
	     unsigned int sign,
	     int exp, 
	     USItype frac)
{
   1c4fc:	00112e23          	sw	ra,28(sp)
  fp_number_type in;

  in.class = class;
  in.sign = sign;
   1c500:	00b12223          	sw	a1,4(sp)
  in.normal_exp = exp;
   1c504:	00c12423          	sw	a2,8(sp)
  in.fraction.ll = frac;
   1c508:	00d12623          	sw	a3,12(sp)
  return pack_d (&in);
   1c50c:	e2cff0ef          	jal	1bb38 <__pack_f>
}
   1c510:	01c12083          	lw	ra,28(sp)
   1c514:	02010113          	addi	sp,sp,32
   1c518:	00008067          	ret

0001c51c <__extendsfdf2>:
   are 8-bytes in size, so we just don't support double for them at all.  */

#if defined(L_sf_to_df)
DFtype
sf_to_df (SFtype arg_a)
{
   1c51c:	fd010113          	addi	sp,sp,-48
  fp_number_type in;
  FLO_union_type au;

  au.value = arg_a;
   1c520:	00a12623          	sw	a0,12(sp)
  unpack_d (&au, &in);
   1c524:	01010593          	addi	a1,sp,16
   1c528:	00c10513          	addi	a0,sp,12
   are 8-bytes in size, so we just don't support double for them at all.  */

#if defined(L_sf_to_df)
DFtype
sf_to_df (SFtype arg_a)
{
   1c52c:	02112623          	sw	ra,44(sp)
  fp_number_type in;
  FLO_union_type au;

  au.value = arg_a;
  unpack_d (&au, &in);
   1c530:	f64ff0ef          	jal	1bc94 <__unpack_f>

  return __make_dp (in.class, in.sign, in.normal_exp,
   1c534:	01c12783          	lw	a5,28(sp)
   1c538:	01812603          	lw	a2,24(sp)
   1c53c:	01412583          	lw	a1,20(sp)
   1c540:	01012503          	lw	a0,16(sp)
   1c544:	01e79713          	slli	a4,a5,0x1e
   1c548:	0027d793          	srli	a5,a5,0x2
   1c54c:	b2cff0ef          	jal	1b878 <__make_dp>
		    ((UDItype) in.fraction.ll) << F_D_BITOFF);
}
   1c550:	02c12083          	lw	ra,44(sp)
   1c554:	03010113          	addi	sp,sp,48
   1c558:	00008067          	ret

Disassembly of section .startup:

00000000 <_reset-0x200>:
	...

00000200 <_reset>:
 200:	00100137          	lui	sp,0x100
 204:	00016113          	ori	sp,sp,0
 208:	00012023          	sw	zero,0(sp) # 100000 <_gp+0xb7820>
 20c:	fe012e23          	sw	zero,-4(sp)
 210:	00003437          	lui	s0,0x3
 214:	00640413          	addi	s0,s0,6 # 3006 <_reset+0x2e06>
 218:	30041073          	csrw	mstatus,s0
 21c:	10000413          	li	s0,256
 220:	0c042023          	sw	zero,192(s0)
 224:	30141073          	csrw	mtvec,s0
 228:	5d90f06f          	j	10000 <_ftext>
