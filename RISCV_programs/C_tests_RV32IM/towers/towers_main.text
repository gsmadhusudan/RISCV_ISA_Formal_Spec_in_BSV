
towers_main:     file format elf32-littleriscv
towers_main
architecture: riscv, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000200

Program Header:
    LOAD off    0x00001000 vaddr 0x00000000 paddr 0x00000000 align 2**12
         filesz 0x0000022c memsz 0x0000022c flags r-x
    LOAD off    0x00002000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x000058bc memsz 0x0000595c flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004460  00010000  00010000  00002000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000124  00014460  00014460  00006460  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init_array   00000008  00014584  00014584  00006584  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .fini_array   00000004  0001458c  0001458c  0000658c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .eh_frame     00000ab4  00014590  00014590  00006590  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .jcr          00000004  00015044  00015044  00007044  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000848  00015050  00015050  00007050  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  7 .sdata        0000001c  000158a0  000158a0  000078a0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .sbss         00000010  000158c0  000158c0  000078bc  2**2
                  ALLOC
  9 .bss          0000008c  000158d0  000158d0  000078bc  2**2
                  ALLOC
 10 .startup      0000022c  00000000  00000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .comment      00000011  00000000  00000000  000078bc  2**0
                  CONTENTS, READONLY
 12 .debug_info   0000cac3  00000000  00000000  000078cd  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00002eb8  00000000  00000000  00014390  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 000003b0  00000000  00000000  00017248  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   000077d3  00000000  00000000  000175f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00001d29  00000000  00000000  0001edcb  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    000055a3  00000000  00000000  00020af4  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00000520  00000000  00000000  00026097  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
00014460 l    d  .rodata	00000000 .rodata
00014584 l    d  .init_array	00000000 .init_array
0001458c l    d  .fini_array	00000000 .fini_array
00014590 l    d  .eh_frame	00000000 .eh_frame
00015044 l    d  .jcr	00000000 .jcr
00015050 l    d  .data	00000000 .data
000158a0 l    d  .sdata	00000000 .sdata
000158c0 l    d  .sbss	00000000 .sbss
000158d0 l    d  .bss	00000000 .bss
00000000 l    d  .startup	00000000 .startup
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 crtstuff.c
00014590 l     O .eh_frame	00000000 __EH_FRAME_BEGIN__
00015044 l     O .jcr	00000000 __JCR_LIST__
0001004c l     F .text	00000000 deregister_tm_clones
00010080 l     F .text	00000000 register_tm_clones
000100c0 l     F .text	00000000 __do_global_dtors_aux
000158d0 l     O .bss	00000001 completed.3082
0001458c l     O .fini_array	00000000 __do_global_dtors_aux_fini_array_entry
00010104 l     F .text	00000000 frame_dummy
000158d4 l     O .bss	00000018 object.3087
00014584 l     O .init_array	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 syscalls.c
000158ec l     O .bss	00000004 heap_end.1982
00000000 l    df *ABS*	00000000 htif.c
000106f4 l     F .text	00000068 htif_tohost
0001075c l     F .text	00000044 htif_fromhost
00000000 l    df *ABS*	00000000 riscv_counters.c
00000000 l    df *ABS*	00000000 ns16550.c
000158a8 l     O .sdata	00000004 pio
000108e4 l     F .text	000000b0 ns16550_init
00000000 l    df *ABS*	00000000 towers_main.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 impure.c
00015050 l     O .data	00000440 impure_data
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
000136c8 l     F .text	00000008 __fp_unlock
000136dc l     F .text	0000018c __sinit.part.1
0001386c l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 crtstuff.c
00015040 l     O .eh_frame	00000000 __FRAME_END__
00015044 l     O .jcr	00000000 __JCR_END__
00000000 l    df *ABS*	00000000 
00014590 l       .fini_array	00000000 __fini_array_end
0001458c l       .fini_array	00000000 __fini_array_start
0001458c l       .init_array	00000000 __init_array_end
00014584 l       .init_array	00000000 __preinit_array_end
00014584 l       .init_array	00000000 __init_array_start
00014584 l       .init_array	00000000 __preinit_array_start
00011b74 g     F .text	000000b0 _puts_r
00011100 g     F .text	000004d0 .hidden __divdi3
00015050 g       .data	00000000 _fdata
000142f0 g     F .text	00000068 __sseek
000139fc g     F .text	00000010 __sinit
00013874 g     F .text	00000070 __sfmoreglue
00010ae0 g     F .text	00000084 list_push
00012cdc g     F .text	00000004 __malloc_unlock
00012bb8 g     F .text	00000120 memmove
000139ec g     F .text	00000010 _cleanup
00010848 g     F .text	00000034 read_cycle
00010474 g     F .text	00000024 times
00010b64 g     F .text	00000084 list_pop
00015918 g     O .bss	00000004 errno
00014270 g     F .text	00000008 __seofread
00014584 g       .rodata	00000000 _etext
000160a0 g       *ABS*	00000000 _gp
00010188 g     F .text	00000034 execve
00010218 g     F .text	00000020 getpid
00010cdc g     F .text	0000006c towers_clear
00012a98 g     F .text	00000120 memcpy
00015898 g     O .data	00000000 .hidden __TMC_END__
000136d0 g     F .text	0000000c _cleanup_r
00011c24 g     F .text	0000000c puts
00010994 g     F .text	00000034 ns16550_rxready
00000000  w      *UND*	00000000 malloc
00010238 g     F .text	00000024 isatty
00010654 g     F .text	000000a0 sleep
000158d0 g       .bss	00000000 _bss_start
000158cc g     O .sbss	00000004 __malloc_top_pad
00010a08 g     F .text	0000004c ns16550_txchar
000158a0 g     O .sdata	00000000 .hidden __dso_handle
000107a0 g     F .text	00000040 htif_putc
00011db4 g     F .text	00000498 __sfvwrite_r
00014364 g     F .text	000000f0 _fclose_r
000136a8 g     F .text	00000020 fflush
000158c8 g     O .sbss	00000004 __malloc_max_sbrked_mem
00010e14 g     F .text	00000054 towers_solve
000102bc g     F .text	0000002c lseek
000158ac g     O .sdata	00000004 _global_impure_ptr
00012ce0 g     F .text	00000588 _realloc_r
00011ad4 g     F .text	000000a0 __libc_init_array
00013a1c g     F .text	00000010 __fp_lock_all
0001087c g     F .text	00000034 read_time
00010048 g       .text	00000000 _init
00011a74 g     F .text	00000060 __libc_fini_array
000104f0 g     F .text	0000006c write
000158a4 g     O .sdata	00000004 environ
000101e4 g     F .text	00000034 fstat
0001025c g     F .text	00000030 kill
00000000  w      *UND*	00000000 __deregister_frame_info
00000000  w      *UND*	00000000 _ITM_registerTMCloneTable
00013a0c g     F .text	00000000 __sfp_lock_acquire
000129c4 g     F .text	000000d4 memchr
00013b3c g     F .text	000002dc _free_r
000104c4 g     F .text	0000002c wait
00010e68 g     F .text	00000108 towers_verify
00010000 g       .text	00000000 _ftext
000158b4 g     O .sdata	00000004 __malloc_sbrk_base
00010000 g       .text	00000000 _start
00010a88 g     F .text	00000028 list_getSize
00010314 g     F .text	000000bc read
00011cc0 g     F .text	000000f4 __register_exitproc
000108b0 g     F .text	00000034 read_instret
000158f0 g     O .bss	00000028 __malloc_current_mallinfo
00010498 g     F .text	0000002c unlink
000101bc g     F .text	00000028 fork
00013268 g     F .text	00000154 __swsetup_r
000138e4 g     F .text	00000108 __sfp
00015490 g     O .data	00000408 __malloc_av_
00013a18 g     F .text	00000004 __sinit_lock_release
000141f4 g     F .text	0000007c __sread
000158c0 g     O .sbss	00000004 __env
00012cd8 g     F .text	00000004 __malloc_lock
00000000  w      *UND*	00000000 _ITM_deregisterTMCloneTable
000103d0 g     F .text	00000070 sbrk
0001364c g     F .text	0000005c _fflush_r
0001055c g     F .text	000000f8 gettimeofday
00014118 g       .text	00000000 memset
00010f70 g     F .text	00000190 main
000158c4 g     O .sbss	00000004 __malloc_max_total_mem
0001435c g     F .text	00000008 __sclose
00014454 g     F .text	0000000c fclose
0001224c g     F .text	00000778 _malloc_r
00013e18 g     F .text	000000b0 _fwalk
00010d48 g     F .text	000000cc towers_solve_h
00013a3c g     F .text	00000100 _malloc_trim_r
00010ab0 g     F .text	00000030 list_init
00010048 g       .text	00000000 _fini
0001447c g     O .rodata	00000100 .hidden __clz_tab
00011a60 g     F .text	00000014 atexit
000158b0 g     O .sdata	00000004 _impure_ptr
000133bc g     F .text	00000290 __sflush_r
00013a2c g     F .text	00000010 __fp_unlock_all
00010440 g     F .text	00000034 stat
00000200 g       .startup	00000000 _reset
00015898 g       .data	00000000 _edata
00010c2c g     F .text	000000b0 towers_init
00015960 g       .bss	00000000 _end
00014278 g     F .text	00000078 __swrite
000158b8 g     O .sdata	00000004 __malloc_trim_threshold
0001028c g     F .text	00000030 link
00010150 g     F .text	00000014 exit
000107e0 g     F .text	00000068 htif_getc
00013ec8 g     F .text	000000c0 _fwalk_reent
00013a10 g     F .text	00000004 __sfp_lock_release
000115d0 g     F .text	00000490 .hidden __moddi3
0001591c g     O .bss	00000008 g_nodeFreeList
00015924 g     O .bss	00000038 g_nodePool
00013f88 g     F .text	00000190 __smakebuf_r
00010be8 g     F .text	00000044 list_clear
00011c30 g     F .text	00000090 strlen
000102e8 g     F .text	0000002c open
00010a54 g     F .text	00000034 ns16550_flush
000109c8 g     F .text	00000040 ns16550_rxchar
00000000  w      *UND*	00000000 _Jv_RegisterClasses
000158c0 g       .sbss	00000000 _fbss
00000000  w      *UND*	00000000 __register_frame_info
00010164 g     F .text	00000024 close
00013a14 g     F .text	00000004 __sinit_lock_acquire



Disassembly of section .text:

00010000 <_ftext>:
   10000:	00006197          	auipc	gp,0x6
   10004:	0a018193          	addi	gp,gp,160 # 160a0 <_gp>
   10008:	00006297          	auipc	t0,0x6
   1000c:	8b828293          	addi	t0,t0,-1864 # 158c0 <__env>
   10010:	00006317          	auipc	t1,0x6
   10014:	95030313          	addi	t1,t1,-1712 # 15960 <_end>
   10018:	0002a023          	sw	zero,0(t0)
   1001c:	00428293          	addi	t0,t0,4
   10020:	fe62ece3          	bltu	t0,t1,10018 <_ftext+0x18>
   10024:	00002517          	auipc	a0,0x2
   10028:	a5050513          	addi	a0,a0,-1456 # 11a74 <__libc_fini_array>
   1002c:	235010ef          	jal	11a60 <atexit>
   10030:	2a5010ef          	jal	11ad4 <__libc_init_array>
   10034:	00012503          	lw	a0,0(sp)
   10038:	00410593          	addi	a1,sp,4
   1003c:	00000613          	li	a2,0
   10040:	731000ef          	jal	10f70 <main>
   10044:	10c0006f          	j	10150 <exit>

00010048 <_fini>:
   10048:	00008067          	ret

0001004c <deregister_tm_clones>:
   1004c:	00016537          	lui	a0,0x16
   10050:	000167b7          	lui	a5,0x16
   10054:	89850713          	addi	a4,a0,-1896 # 15898 <__TMC_END__>
   10058:	89b78793          	addi	a5,a5,-1893 # 1589b <__TMC_END__+0x3>
   1005c:	40e787b3          	sub	a5,a5,a4
   10060:	00600713          	li	a4,6
   10064:	00f77c63          	bleu	a5,a4,1007c <deregister_tm_clones+0x30>
   10068:	00000293          	li	t0,0
   1006c:	00028863          	beqz	t0,1007c <deregister_tm_clones+0x30>
   10070:	89850513          	addi	a0,a0,-1896
   10074:	00028313          	mv	t1,t0
   10078:	00030067          	jr	t1
   1007c:	00008067          	ret

00010080 <register_tm_clones>:
   10080:	00016537          	lui	a0,0x16
   10084:	000167b7          	lui	a5,0x16
   10088:	89850593          	addi	a1,a0,-1896 # 15898 <__TMC_END__>
   1008c:	89878793          	addi	a5,a5,-1896 # 15898 <__TMC_END__>
   10090:	40b787b3          	sub	a5,a5,a1
   10094:	4027d793          	srai	a5,a5,0x2
   10098:	01f7d593          	srli	a1,a5,0x1f
   1009c:	00f585b3          	add	a1,a1,a5
   100a0:	4015d593          	srai	a1,a1,0x1
   100a4:	00058c63          	beqz	a1,100bc <register_tm_clones+0x3c>
   100a8:	00000293          	li	t0,0
   100ac:	00028863          	beqz	t0,100bc <register_tm_clones+0x3c>
   100b0:	89850513          	addi	a0,a0,-1896
   100b4:	00028313          	mv	t1,t0
   100b8:	00030067          	jr	t1
   100bc:	00008067          	ret

000100c0 <__do_global_dtors_aux>:
   100c0:	ff010113          	addi	sp,sp,-16
   100c4:	00812423          	sw	s0,8(sp)
   100c8:	8301c783          	lbu	a5,-2000(gp) # 158d0 <_bss_start>
   100cc:	00112623          	sw	ra,12(sp)
   100d0:	02079263          	bnez	a5,100f4 <__do_global_dtors_aux+0x34>
   100d4:	f79ff0ef          	jal	1004c <deregister_tm_clones>
   100d8:	00000793          	li	a5,0
   100dc:	00078863          	beqz	a5,100ec <__do_global_dtors_aux+0x2c>
   100e0:	00014537          	lui	a0,0x14
   100e4:	59050513          	addi	a0,a0,1424 # 14590 <__fini_array_end>
   100e8:	f19ef0ef          	jal	0 <_reset-0x200>
   100ec:	00100793          	li	a5,1
   100f0:	82f18823          	sb	a5,-2000(gp) # 158d0 <_bss_start>
   100f4:	00c12083          	lw	ra,12(sp)
   100f8:	00812403          	lw	s0,8(sp)
   100fc:	01010113          	addi	sp,sp,16
   10100:	00008067          	ret

00010104 <frame_dummy>:
   10104:	ff010113          	addi	sp,sp,-16
   10108:	00000793          	li	a5,0
   1010c:	00112623          	sw	ra,12(sp)
   10110:	00078a63          	beqz	a5,10124 <frame_dummy+0x20>
   10114:	00014537          	lui	a0,0x14
   10118:	83418593          	addi	a1,gp,-1996 # 158d4 <object.3087>
   1011c:	59050513          	addi	a0,a0,1424 # 14590 <__fini_array_end>
   10120:	ee1ef0ef          	jal	0 <_reset-0x200>
   10124:	00015537          	lui	a0,0x15
   10128:	04450513          	addi	a0,a0,68 # 15044 <__JCR_END__>
   1012c:	00052783          	lw	a5,0(a0)
   10130:	00079863          	bnez	a5,10140 <frame_dummy+0x3c>
   10134:	00c12083          	lw	ra,12(sp)
   10138:	01010113          	addi	sp,sp,16
   1013c:	f45ff06f          	j	10080 <register_tm_clones>
   10140:	00000793          	li	a5,0
   10144:	fe0788e3          	beqz	a5,10134 <frame_dummy+0x30>
   10148:	000780e7          	jalr	a5
   1014c:	fe9ff06f          	j	10134 <frame_dummy+0x30>

00010150 <exit>:
register char * stack_ptr asm ("sp");

#undef errno
int errno;

void exit (int status) {
   10150:	fe010113          	addi	sp,sp,-32
   10154:	00812e23          	sw	s0,28(sp)
   10158:	02010413          	addi	s0,sp,32
   1015c:	fea42623          	sw	a0,-20(s0)
  while (1)
    ;
   10160:	0000006f          	j	10160 <exit+0x10>

00010164 <close>:
}

int close(int file) {
   10164:	fe010113          	addi	sp,sp,-32
   10168:	00812e23          	sw	s0,28(sp)
   1016c:	02010413          	addi	s0,sp,32
   10170:	fea42623          	sw	a0,-20(s0)
  return -1;
   10174:	fff00793          	li	a5,-1
}
   10178:	00078513          	mv	a0,a5
   1017c:	01c12403          	lw	s0,28(sp)
   10180:	02010113          	addi	sp,sp,32
   10184:	00008067          	ret

00010188 <execve>:

char *__env[1] = { 0 };
char **environ = __env;

int execve(char *name, char **argv, char **env) {
   10188:	fe010113          	addi	sp,sp,-32
   1018c:	00812e23          	sw	s0,28(sp)
   10190:	02010413          	addi	s0,sp,32
   10194:	fea42623          	sw	a0,-20(s0)
   10198:	feb42423          	sw	a1,-24(s0)
   1019c:	fec42223          	sw	a2,-28(s0)
  errno = ENOMEM;
   101a0:	00c00713          	li	a4,12
   101a4:	86e1ac23          	sw	a4,-1928(gp) # 15918 <errno>
  return -1;
   101a8:	fff00793          	li	a5,-1
}
   101ac:	00078513          	mv	a0,a5
   101b0:	01c12403          	lw	s0,28(sp)
   101b4:	02010113          	addi	sp,sp,32
   101b8:	00008067          	ret

000101bc <fork>:

int fork(void) {
   101bc:	ff010113          	addi	sp,sp,-16
   101c0:	00812623          	sw	s0,12(sp)
   101c4:	01010413          	addi	s0,sp,16
  errno = EAGAIN;
   101c8:	00b00713          	li	a4,11
   101cc:	86e1ac23          	sw	a4,-1928(gp) # 15918 <errno>
  return -1;
   101d0:	fff00793          	li	a5,-1
}
   101d4:	00078513          	mv	a0,a5
   101d8:	00c12403          	lw	s0,12(sp)
   101dc:	01010113          	addi	sp,sp,16
   101e0:	00008067          	ret

000101e4 <fstat>:

int fstat(int file, struct stat *st) {
   101e4:	fe010113          	addi	sp,sp,-32
   101e8:	00812e23          	sw	s0,28(sp)
   101ec:	02010413          	addi	s0,sp,32
   101f0:	fea42623          	sw	a0,-20(s0)
   101f4:	feb42423          	sw	a1,-24(s0)
  st->st_mode = S_IFCHR;
   101f8:	fe842783          	lw	a5,-24(s0)
   101fc:	00002737          	lui	a4,0x2
   10200:	00e7a823          	sw	a4,16(a5)
  return 0;
   10204:	00000793          	li	a5,0
}
   10208:	00078513          	mv	a0,a5
   1020c:	01c12403          	lw	s0,28(sp)
   10210:	02010113          	addi	sp,sp,32
   10214:	00008067          	ret

00010218 <getpid>:

int getpid(void) {
   10218:	ff010113          	addi	sp,sp,-16
   1021c:	00812623          	sw	s0,12(sp)
   10220:	01010413          	addi	s0,sp,16
  return 1;
   10224:	00100793          	li	a5,1
}
   10228:	00078513          	mv	a0,a5
   1022c:	00c12403          	lw	s0,12(sp)
   10230:	01010113          	addi	sp,sp,16
   10234:	00008067          	ret

00010238 <isatty>:

int isatty(int file) {
   10238:	fe010113          	addi	sp,sp,-32
   1023c:	00812e23          	sw	s0,28(sp)
   10240:	02010413          	addi	s0,sp,32
   10244:	fea42623          	sw	a0,-20(s0)
  return 1;
   10248:	00100793          	li	a5,1
}
   1024c:	00078513          	mv	a0,a5
   10250:	01c12403          	lw	s0,28(sp)
   10254:	02010113          	addi	sp,sp,32
   10258:	00008067          	ret

0001025c <kill>:

int kill(int pid, int sig) {
   1025c:	fe010113          	addi	sp,sp,-32
   10260:	00812e23          	sw	s0,28(sp)
   10264:	02010413          	addi	s0,sp,32
   10268:	fea42623          	sw	a0,-20(s0)
   1026c:	feb42423          	sw	a1,-24(s0)
  errno = EINVAL;
   10270:	01600713          	li	a4,22
   10274:	86e1ac23          	sw	a4,-1928(gp) # 15918 <errno>
  return -1;
   10278:	fff00793          	li	a5,-1
}
   1027c:	00078513          	mv	a0,a5
   10280:	01c12403          	lw	s0,28(sp)
   10284:	02010113          	addi	sp,sp,32
   10288:	00008067          	ret

0001028c <link>:

int link(char *old, char *new) {
   1028c:	fe010113          	addi	sp,sp,-32
   10290:	00812e23          	sw	s0,28(sp)
   10294:	02010413          	addi	s0,sp,32
   10298:	fea42623          	sw	a0,-20(s0)
   1029c:	feb42423          	sw	a1,-24(s0)
  errno = EMLINK;
   102a0:	01f00713          	li	a4,31
   102a4:	86e1ac23          	sw	a4,-1928(gp) # 15918 <errno>
  return -1;
   102a8:	fff00793          	li	a5,-1
}
   102ac:	00078513          	mv	a0,a5
   102b0:	01c12403          	lw	s0,28(sp)
   102b4:	02010113          	addi	sp,sp,32
   102b8:	00008067          	ret

000102bc <lseek>:

int lseek(int file, int ptr, int dir) {
   102bc:	fe010113          	addi	sp,sp,-32
   102c0:	00812e23          	sw	s0,28(sp)
   102c4:	02010413          	addi	s0,sp,32
   102c8:	fea42623          	sw	a0,-20(s0)
   102cc:	feb42423          	sw	a1,-24(s0)
   102d0:	fec42223          	sw	a2,-28(s0)
  return 0;
   102d4:	00000793          	li	a5,0
}
   102d8:	00078513          	mv	a0,a5
   102dc:	01c12403          	lw	s0,28(sp)
   102e0:	02010113          	addi	sp,sp,32
   102e4:	00008067          	ret

000102e8 <open>:

int open(const char *name, int flags, int mode) {
   102e8:	fe010113          	addi	sp,sp,-32
   102ec:	00812e23          	sw	s0,28(sp)
   102f0:	02010413          	addi	s0,sp,32
   102f4:	fea42623          	sw	a0,-20(s0)
   102f8:	feb42423          	sw	a1,-24(s0)
   102fc:	fec42223          	sw	a2,-28(s0)
  return -1;
   10300:	fff00793          	li	a5,-1
}
   10304:	00078513          	mv	a0,a5
   10308:	01c12403          	lw	s0,28(sp)
   1030c:	02010113          	addi	sp,sp,32
   10310:	00008067          	ret

00010314 <read>:

int read(int file, char *ptr, int len) {
   10314:	fd010113          	addi	sp,sp,-48
   10318:	02112623          	sw	ra,44(sp)
   1031c:	02812423          	sw	s0,40(sp)
   10320:	02912223          	sw	s1,36(sp)
   10324:	03010413          	addi	s0,sp,48
   10328:	fca42e23          	sw	a0,-36(s0)
   1032c:	fcb42c23          	sw	a1,-40(s0)
   10330:	fcc42a23          	sw	a2,-44(s0)
  int todo;
  if(len == 0)
   10334:	fd442783          	lw	a5,-44(s0)
   10338:	00079663          	bnez	a5,10344 <read+0x30>
    return 0;
   1033c:	00000793          	li	a5,0
   10340:	0780006f          	j	103b8 <read+0xa4>
    // note: this is always blocking
    *ptr++ = htif_getc();
  }
#endif
#ifdef CONSOLE_UART
  *ptr++ = ns16550_rxchar();
   10344:	fd842483          	lw	s1,-40(s0)
   10348:	00148793          	addi	a5,s1,1
   1034c:	fcf42c23          	sw	a5,-40(s0)
   10350:	678000ef          	jal	109c8 <ns16550_rxchar>
   10354:	00050793          	mv	a5,a0
   10358:	0ff7f793          	andi	a5,a5,255
   1035c:	00f48023          	sb	a5,0(s1)
  for(todo = 1; todo < len; todo++) {
   10360:	00100793          	li	a5,1
   10364:	fef42623          	sw	a5,-20(s0)
   10368:	0380006f          	j	103a0 <read+0x8c>
    if (!ns16550_rxready())
   1036c:	628000ef          	jal	10994 <ns16550_rxready>
   10370:	00050793          	mv	a5,a0
   10374:	02078e63          	beqz	a5,103b0 <read+0x9c>
      break;
    *ptr++ = ns16550_rxchar();
   10378:	fd842483          	lw	s1,-40(s0)
   1037c:	00148793          	addi	a5,s1,1
   10380:	fcf42c23          	sw	a5,-40(s0)
   10384:	644000ef          	jal	109c8 <ns16550_rxchar>
   10388:	00050793          	mv	a5,a0
   1038c:	0ff7f793          	andi	a5,a5,255
   10390:	00f48023          	sb	a5,0(s1)
    *ptr++ = htif_getc();
  }
#endif
#ifdef CONSOLE_UART
  *ptr++ = ns16550_rxchar();
  for(todo = 1; todo < len; todo++) {
   10394:	fec42783          	lw	a5,-20(s0)
   10398:	00178793          	addi	a5,a5,1
   1039c:	fef42623          	sw	a5,-20(s0)
   103a0:	fec42703          	lw	a4,-20(s0)
   103a4:	fd442783          	lw	a5,-44(s0)
   103a8:	fcf742e3          	blt	a4,a5,1036c <read+0x58>
   103ac:	0080006f          	j	103b4 <read+0xa0>
    if (!ns16550_rxready())
      break;
   103b0:	00000013          	nop
    *ptr++ = ns16550_rxchar();
  }
#endif
  return todo;
   103b4:	fec42783          	lw	a5,-20(s0)
}
   103b8:	00078513          	mv	a0,a5
   103bc:	02c12083          	lw	ra,44(sp)
   103c0:	02812403          	lw	s0,40(sp)
   103c4:	02412483          	lw	s1,36(sp)
   103c8:	03010113          	addi	sp,sp,48
   103cc:	00008067          	ret

000103d0 <sbrk>:

caddr_t sbrk(int incr) {
   103d0:	fd010113          	addi	sp,sp,-48
   103d4:	02812623          	sw	s0,44(sp)
   103d8:	03010413          	addi	s0,sp,48
   103dc:	fca42e23          	sw	a0,-36(s0)
  extern char _end;		/* Defined by the linker */
  static char *heap_end;
  char *prev_heap_end;

  if (heap_end == 0) {
   103e0:	84c1a783          	lw	a5,-1972(gp) # 158ec <heap_end.1982>
   103e4:	00079663          	bnez	a5,103f0 <sbrk+0x20>
    heap_end = &_end;
   103e8:	8c018713          	addi	a4,gp,-1856 # 15960 <_end>
   103ec:	84e1a623          	sw	a4,-1972(gp) # 158ec <heap_end.1982>
  }
  prev_heap_end = heap_end;
   103f0:	84c1a783          	lw	a5,-1972(gp) # 158ec <heap_end.1982>
   103f4:	fef42623          	sw	a5,-20(s0)
  if (heap_end + incr > stack_ptr) {
   103f8:	84c1a703          	lw	a4,-1972(gp) # 158ec <heap_end.1982>
   103fc:	fdc42783          	lw	a5,-36(s0)
   10400:	00f707b3          	add	a5,a4,a5
   10404:	00010713          	mv	a4,sp
   10408:	00f77a63          	bleu	a5,a4,1041c <sbrk+0x4c>
    errno = ENOMEM;
   1040c:	00c00713          	li	a4,12
   10410:	86e1ac23          	sw	a4,-1928(gp) # 15918 <errno>
    return (caddr_t) -1;
   10414:	fff00793          	li	a5,-1
   10418:	0180006f          	j	10430 <sbrk+0x60>
  }

  heap_end += incr;
   1041c:	84c1a703          	lw	a4,-1972(gp) # 158ec <heap_end.1982>
   10420:	fdc42783          	lw	a5,-36(s0)
   10424:	00f70733          	add	a4,a4,a5
   10428:	84e1a623          	sw	a4,-1972(gp) # 158ec <heap_end.1982>
  return (caddr_t) prev_heap_end;
   1042c:	fec42783          	lw	a5,-20(s0)
}
   10430:	00078513          	mv	a0,a5
   10434:	02c12403          	lw	s0,44(sp)
   10438:	03010113          	addi	sp,sp,48
   1043c:	00008067          	ret

00010440 <stat>:

int stat(const char *file, struct stat *st) {
   10440:	fe010113          	addi	sp,sp,-32
   10444:	00812e23          	sw	s0,28(sp)
   10448:	02010413          	addi	s0,sp,32
   1044c:	fea42623          	sw	a0,-20(s0)
   10450:	feb42423          	sw	a1,-24(s0)
  st->st_mode = S_IFCHR;
   10454:	fe842783          	lw	a5,-24(s0)
   10458:	00002737          	lui	a4,0x2
   1045c:	00e7a823          	sw	a4,16(a5)
  return 0;
   10460:	00000793          	li	a5,0
}
   10464:	00078513          	mv	a0,a5
   10468:	01c12403          	lw	s0,28(sp)
   1046c:	02010113          	addi	sp,sp,32
   10470:	00008067          	ret

00010474 <times>:

clock_t times(struct tms *buf) {
   10474:	fe010113          	addi	sp,sp,-32
   10478:	00812e23          	sw	s0,28(sp)
   1047c:	02010413          	addi	s0,sp,32
   10480:	fea42623          	sw	a0,-20(s0)
  return -1;
   10484:	fff00793          	li	a5,-1
}
   10488:	00078513          	mv	a0,a5
   1048c:	01c12403          	lw	s0,28(sp)
   10490:	02010113          	addi	sp,sp,32
   10494:	00008067          	ret

00010498 <unlink>:

int unlink(char *name) {
   10498:	fe010113          	addi	sp,sp,-32
   1049c:	00812e23          	sw	s0,28(sp)
   104a0:	02010413          	addi	s0,sp,32
   104a4:	fea42623          	sw	a0,-20(s0)
  errno = ENOENT;
   104a8:	00200713          	li	a4,2
   104ac:	86e1ac23          	sw	a4,-1928(gp) # 15918 <errno>
  return -1;
   104b0:	fff00793          	li	a5,-1
}
   104b4:	00078513          	mv	a0,a5
   104b8:	01c12403          	lw	s0,28(sp)
   104bc:	02010113          	addi	sp,sp,32
   104c0:	00008067          	ret

000104c4 <wait>:

int wait(int *status) {
   104c4:	fe010113          	addi	sp,sp,-32
   104c8:	00812e23          	sw	s0,28(sp)
   104cc:	02010413          	addi	s0,sp,32
   104d0:	fea42623          	sw	a0,-20(s0)
  errno = ECHILD;
   104d4:	00a00713          	li	a4,10
   104d8:	86e1ac23          	sw	a4,-1928(gp) # 15918 <errno>
  return -1;
   104dc:	fff00793          	li	a5,-1
}
   104e0:	00078513          	mv	a0,a5
   104e4:	01c12403          	lw	s0,28(sp)
   104e8:	02010113          	addi	sp,sp,32
   104ec:	00008067          	ret

000104f0 <write>:

int write(int file, char *ptr, int len) {
   104f0:	fd010113          	addi	sp,sp,-48
   104f4:	02112623          	sw	ra,44(sp)
   104f8:	02812423          	sw	s0,40(sp)
   104fc:	03010413          	addi	s0,sp,48
   10500:	fca42e23          	sw	a0,-36(s0)
   10504:	fcb42c23          	sw	a1,-40(s0)
   10508:	fcc42a23          	sw	a2,-44(s0)
  for (todo = 0; todo < len; todo++) {
    htif_putc (*ptr++);
  }
#endif
#ifdef CONSOLE_UART
  for (todo = 0; todo < len; todo++) {
   1050c:	fe042623          	sw	zero,-20(s0)
   10510:	0280006f          	j	10538 <write+0x48>
    ns16550_txchar (*ptr++);
   10514:	fd842783          	lw	a5,-40(s0)
   10518:	00178713          	addi	a4,a5,1
   1051c:	fce42c23          	sw	a4,-40(s0)
   10520:	0007c783          	lbu	a5,0(a5)
   10524:	00078513          	mv	a0,a5
   10528:	4e0000ef          	jal	10a08 <ns16550_txchar>
  for (todo = 0; todo < len; todo++) {
    htif_putc (*ptr++);
  }
#endif
#ifdef CONSOLE_UART
  for (todo = 0; todo < len; todo++) {
   1052c:	fec42783          	lw	a5,-20(s0)
   10530:	00178793          	addi	a5,a5,1
   10534:	fef42623          	sw	a5,-20(s0)
   10538:	fec42703          	lw	a4,-20(s0)
   1053c:	fd442783          	lw	a5,-44(s0)
   10540:	fcf74ae3          	blt	a4,a5,10514 <write+0x24>
    ns16550_txchar (*ptr++);
  }
#endif
  return len;
   10544:	fd442783          	lw	a5,-44(s0)
}
   10548:	00078513          	mv	a0,a5
   1054c:	02c12083          	lw	ra,44(sp)
   10550:	02812403          	lw	s0,40(sp)
   10554:	03010113          	addi	sp,sp,48
   10558:	00008067          	ret

0001055c <gettimeofday>:

#define CLOCK_PERIOD  (10000000)

int gettimeofday(struct timeval *ptimeval, void *ptimezone)
{
   1055c:	fd010113          	addi	sp,sp,-48
   10560:	02112623          	sw	ra,44(sp)
   10564:	02812423          	sw	s0,40(sp)
   10568:	03010413          	addi	s0,sp,48
   1056c:	fca42e23          	sw	a0,-36(s0)
   10570:	fcb42c23          	sw	a1,-40(s0)
    if (ptimeval)
   10574:	fdc42583          	lw	a1,-36(s0)
   10578:	0c058263          	beqz	a1,1063c <gettimeofday+0xe0>
#ifdef __riscv64
	asm ("rdtime %0" : "=r" (tv));
#else
	unsigned int tvh;
	unsigned int tvl;
	asm ("rdtime %0;"
   1057c:	c0102573          	rdtime	a0
   10580:	c81025f3          	rdtimeh	a1
   10584:	fea42623          	sw	a0,-20(s0)
   10588:	feb42423          	sw	a1,-24(s0)
	    "rdtimeh %1 " : "=r" (tvl), "=r" (tvh));
	tv = ((long long)tvh) << 32 | tvl;
   1058c:	fe842583          	lw	a1,-24(s0)
   10590:	00058813          	mv	a6,a1
   10594:	00000893          	li	a7,0
   10598:	00081793          	slli	a5,a6,0x0
   1059c:	00000713          	li	a4,0
   105a0:	fec42583          	lw	a1,-20(s0)
   105a4:	00058613          	mv	a2,a1
   105a8:	00000693          	li	a3,0
   105ac:	00c765b3          	or	a1,a4,a2
   105b0:	feb42023          	sw	a1,-32(s0)
   105b4:	00d7e7b3          	or	a5,a5,a3
   105b8:	fef42223          	sw	a5,-28(s0)
#endif
	ptimeval->tv_sec = tv / CLOCK_PERIOD;
   105bc:	fe042703          	lw	a4,-32(s0)
   105c0:	fe442783          	lw	a5,-28(s0)
   105c4:	00989637          	lui	a2,0x989
   105c8:	68060613          	addi	a2,a2,1664 # 989680 <_gp+0x9735e0>
   105cc:	00000693          	li	a3,0
   105d0:	00070513          	mv	a0,a4
   105d4:	00078593          	mv	a1,a5
   105d8:	329000ef          	jal	11100 <__divdi3>
   105dc:	00050713          	mv	a4,a0
   105e0:	00058793          	mv	a5,a1
   105e4:	fdc42683          	lw	a3,-36(s0)
   105e8:	00e6a023          	sw	a4,0(a3)
   105ec:	00f6a223          	sw	a5,4(a3)
	ptimeval->tv_usec = tv % CLOCK_PERIOD / (CLOCK_PERIOD / 1000000);
   105f0:	fe042703          	lw	a4,-32(s0)
   105f4:	fe442783          	lw	a5,-28(s0)
   105f8:	00989637          	lui	a2,0x989
   105fc:	68060613          	addi	a2,a2,1664 # 989680 <_gp+0x9735e0>
   10600:	00000693          	li	a3,0
   10604:	00070513          	mv	a0,a4
   10608:	00078593          	mv	a1,a5
   1060c:	7c5000ef          	jal	115d0 <__moddi3>
   10610:	00050713          	mv	a4,a0
   10614:	00058793          	mv	a5,a1
   10618:	00a00613          	li	a2,10
   1061c:	00000693          	li	a3,0
   10620:	00070513          	mv	a0,a4
   10624:	00078593          	mv	a1,a5
   10628:	2d9000ef          	jal	11100 <__divdi3>
   1062c:	00050713          	mv	a4,a0
   10630:	00058793          	mv	a5,a1
   10634:	fdc42783          	lw	a5,-36(s0)
   10638:	00e7a423          	sw	a4,8(a5)
    }

    return 0;
   1063c:	00000793          	li	a5,0
}
   10640:	00078513          	mv	a0,a5
   10644:	02c12083          	lw	ra,44(sp)
   10648:	02812403          	lw	s0,40(sp)
   1064c:	03010113          	addi	sp,sp,48
   10650:	00008067          	ret

00010654 <sleep>:

unsigned int sleep(unsigned int seconds)
{
   10654:	fd010113          	addi	sp,sp,-48
   10658:	02112623          	sw	ra,44(sp)
   1065c:	02812423          	sw	s0,40(sp)
   10660:	03212223          	sw	s2,36(sp)
   10664:	03312023          	sw	s3,32(sp)
   10668:	03010413          	addi	s0,sp,48
   1066c:	fca42e23          	sw	a0,-36(s0)
    struct timeval tv;
    gettimeofday(&tv, NULL);
   10670:	fe040793          	addi	a5,s0,-32
   10674:	00000593          	li	a1,0
   10678:	00078513          	mv	a0,a5
   1067c:	ee1ff0ef          	jal	1055c <gettimeofday>
    seconds += tv.tv_sec;
   10680:	fe042703          	lw	a4,-32(s0)
   10684:	fe442783          	lw	a5,-28(s0)
   10688:	fdc42783          	lw	a5,-36(s0)
   1068c:	00e787b3          	add	a5,a5,a4
   10690:	fcf42e23          	sw	a5,-36(s0)

    while (tv.tv_sec < seconds)
   10694:	0140006f          	j	106a8 <sleep+0x54>
	gettimeofday(&tv, NULL);
   10698:	fe040793          	addi	a5,s0,-32
   1069c:	00000593          	li	a1,0
   106a0:	00078513          	mv	a0,a5
   106a4:	eb9ff0ef          	jal	1055c <gettimeofday>
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    seconds += tv.tv_sec;

    while (tv.tv_sec < seconds)
   106a8:	fe042703          	lw	a4,-32(s0)
   106ac:	fe442783          	lw	a5,-28(s0)
   106b0:	fdc42683          	lw	a3,-36(s0)
   106b4:	00068913          	mv	s2,a3
   106b8:	00000993          	li	s3,0
   106bc:	00078693          	mv	a3,a5
   106c0:	fd36ece3          	bltu	a3,s3,10698 <sleep+0x44>
   106c4:	00078693          	mv	a3,a5
   106c8:	00d99663          	bne	s3,a3,106d4 <sleep+0x80>
   106cc:	00070793          	mv	a5,a4
   106d0:	fd27e4e3          	bltu	a5,s2,10698 <sleep+0x44>
	gettimeofday(&tv, NULL);

    return 0;
   106d4:	00000793          	li	a5,0
}
   106d8:	00078513          	mv	a0,a5
   106dc:	02c12083          	lw	ra,44(sp)
   106e0:	02812403          	lw	s0,40(sp)
   106e4:	02412903          	lw	s2,36(sp)
   106e8:	02012983          	lw	s3,32(sp)
   106ec:	03010113          	addi	sp,sp,48
   106f0:	00008067          	ret

000106f4 <htif_tohost>:
#define HTIF_CMD_WRITE      (0x01UL)
#define HTIF_CMD_IDENTITY   (0xFFUL)

static inline void htif_tohost(unsigned long dev,
	unsigned long cmd, unsigned long data)
{
   106f4:	fd010113          	addi	sp,sp,-48
   106f8:	02812623          	sw	s0,44(sp)
   106fc:	03010413          	addi	s0,sp,48
   10700:	fca42e23          	sw	a0,-36(s0)
   10704:	fcb42c23          	sw	a1,-40(s0)
   10708:	fcc42a23          	sw	a2,-44(s0)
	unsigned long packet;
	packet = (dev << HTIF_DEV_SHIFT) | (cmd << HTIF_CMD_SHIFT) | data;
   1070c:	fdc42783          	lw	a5,-36(s0)
   10710:	01879713          	slli	a4,a5,0x18
   10714:	fd842783          	lw	a5,-40(s0)
   10718:	01079793          	slli	a5,a5,0x10
   1071c:	00f76733          	or	a4,a4,a5
   10720:	fd442783          	lw	a5,-44(s0)
   10724:	00f767b3          	or	a5,a4,a5
   10728:	fef42623          	sw	a5,-20(s0)
	while (csr_swap(mtohost, packet) != 0);
   1072c:	00000013          	nop
   10730:	fec42783          	lw	a5,-20(s0)
   10734:	fef42423          	sw	a5,-24(s0)
   10738:	fe842783          	lw	a5,-24(s0)
   1073c:	780797f3          	csrrw	a5,mtohost,a5
   10740:	fef42423          	sw	a5,-24(s0)
   10744:	fe842783          	lw	a5,-24(s0)
   10748:	fe0794e3          	bnez	a5,10730 <htif_tohost+0x3c>
}
   1074c:	00000013          	nop
   10750:	02c12403          	lw	s0,44(sp)
   10754:	03010113          	addi	sp,sp,48
   10758:	00008067          	ret

0001075c <htif_fromhost>:

static inline unsigned long htif_fromhost(void)
{
   1075c:	fe010113          	addi	sp,sp,-32
   10760:	00812e23          	sw	s0,28(sp)
   10764:	02010413          	addi	s0,sp,32
	unsigned long data;
	while ((data = csr_swap(mfromhost, 0)) == 0);
   10768:	00000013          	nop
   1076c:	fe042623          	sw	zero,-20(s0)
   10770:	fec42783          	lw	a5,-20(s0)
   10774:	781797f3          	csrrw	a5,mfromhost,a5
   10778:	fef42623          	sw	a5,-20(s0)
   1077c:	fec42783          	lw	a5,-20(s0)
   10780:	fef42423          	sw	a5,-24(s0)
   10784:	fe842783          	lw	a5,-24(s0)
   10788:	fe0782e3          	beqz	a5,1076c <htif_fromhost+0x10>
	return data;
   1078c:	fe842783          	lw	a5,-24(s0)
}
   10790:	00078513          	mv	a0,a5
   10794:	01c12403          	lw	s0,28(sp)
   10798:	02010113          	addi	sp,sp,32
   1079c:	00008067          	ret

000107a0 <htif_putc>:

#define HTIF_DEV_CONSOLE        (1U)

void htif_putc(char c)
{
   107a0:	fe010113          	addi	sp,sp,-32
   107a4:	00112e23          	sw	ra,28(sp)
   107a8:	00812c23          	sw	s0,24(sp)
   107ac:	02010413          	addi	s0,sp,32
   107b0:	00050793          	mv	a5,a0
   107b4:	fef407a3          	sb	a5,-17(s0)
    htif_tohost(HTIF_DEV_CONSOLE, HTIF_CMD_WRITE, c);
   107b8:	fef44783          	lbu	a5,-17(s0)
   107bc:	00078613          	mv	a2,a5
   107c0:	00100593          	li	a1,1
   107c4:	00100513          	li	a0,1
   107c8:	f2dff0ef          	jal	106f4 <htif_tohost>
}
   107cc:	00000013          	nop
   107d0:	01c12083          	lw	ra,28(sp)
   107d4:	01812403          	lw	s0,24(sp)
   107d8:	02010113          	addi	sp,sp,32
   107dc:	00008067          	ret

000107e0 <htif_getc>:

char htif_getc(void)
{
   107e0:	fe010113          	addi	sp,sp,-32
   107e4:	00112e23          	sw	ra,28(sp)
   107e8:	00812c23          	sw	s0,24(sp)
   107ec:	02010413          	addi	s0,sp,32
    htif_tohost(HTIF_DEV_CONSOLE, HTIF_CMD_READ, 0);
   107f0:	00000613          	li	a2,0
   107f4:	00000593          	li	a1,0
   107f8:	00100513          	li	a0,1
   107fc:	ef9ff0ef          	jal	106f4 <htif_tohost>

    // poll interrupt
    unsigned long mip = csr_read(mip);
   10800:	344027f3          	csrr	a5,mip
   10804:	00078093          	mv	ra,a5
   10808:	00008793          	mv	a5,ra
   1080c:	fef42623          	sw	a5,-20(s0)
    while (!(mip & 0x40000000))
   10810:	00000013          	nop
   10814:	fec42703          	lw	a4,-20(s0)
   10818:	400007b7          	lui	a5,0x40000
   1081c:	00f777b3          	and	a5,a4,a5
   10820:	fe078ae3          	beqz	a5,10814 <htif_getc+0x34>
	;  // nothing

    unsigned long data = htif_fromhost();
   10824:	f39ff0ef          	jal	1075c <htif_fromhost>
   10828:	fea42423          	sw	a0,-24(s0)
    return data;
   1082c:	fe842783          	lw	a5,-24(s0)
   10830:	0ff7f793          	andi	a5,a5,255
}
   10834:	00078513          	mv	a0,a5
   10838:	01c12083          	lw	ra,28(sp)
   1083c:	01812403          	lw	s0,24(sp)
   10840:	02010113          	addi	sp,sp,32
   10844:	00008067          	ret

00010848 <read_cycle>:
// The following are interfaces to inline RISC-V assembly instructions
//     RDCYCLE, RDTIME, RDINSTRET
// For all of them, the result is left in v0 (= x2) per calling convention

uint64_t  read_cycle (void)
{
   10848:	fe010113          	addi	sp,sp,-32
   1084c:	00812e23          	sw	s0,28(sp)
   10850:	02010413          	addi	s0,sp,32
    uint64_t result;

    asm volatile ("RDCYCLE %0" : "=r" (result));
   10854:	c0002773          	rdcycle	a4
   10858:	fee42423          	sw	a4,-24(s0)
   1085c:	fef42623          	sw	a5,-20(s0)
    return result;
   10860:	fe842703          	lw	a4,-24(s0)
   10864:	fec42783          	lw	a5,-20(s0)
}
   10868:	00070513          	mv	a0,a4
   1086c:	00078593          	mv	a1,a5
   10870:	01c12403          	lw	s0,28(sp)
   10874:	02010113          	addi	sp,sp,32
   10878:	00008067          	ret

0001087c <read_time>:

uint64_t  read_time (void)
{
   1087c:	fe010113          	addi	sp,sp,-32
   10880:	00812e23          	sw	s0,28(sp)
   10884:	02010413          	addi	s0,sp,32
    uint64_t result;

    asm volatile ("RDTIME %0" : "=r" (result));
   10888:	c0102773          	rdtime	a4
   1088c:	fee42423          	sw	a4,-24(s0)
   10890:	fef42623          	sw	a5,-20(s0)
    return result;
   10894:	fe842703          	lw	a4,-24(s0)
   10898:	fec42783          	lw	a5,-20(s0)
}
   1089c:	00070513          	mv	a0,a4
   108a0:	00078593          	mv	a1,a5
   108a4:	01c12403          	lw	s0,28(sp)
   108a8:	02010113          	addi	sp,sp,32
   108ac:	00008067          	ret

000108b0 <read_instret>:

uint64_t  read_instret (void)
{
   108b0:	fe010113          	addi	sp,sp,-32
   108b4:	00812e23          	sw	s0,28(sp)
   108b8:	02010413          	addi	s0,sp,32
    uint64_t result;

    asm volatile ("RDINSTRET %0" : "=r" (result));
   108bc:	c0202773          	rdinstret	a4
   108c0:	fee42423          	sw	a4,-24(s0)
   108c4:	fef42623          	sw	a5,-20(s0)
    return result;
   108c8:	fe842703          	lw	a4,-24(s0)
   108cc:	fec42783          	lw	a5,-20(s0)
}
   108d0:	00070513          	mv	a0,a4
   108d4:	00078593          	mv	a1,a5
   108d8:	01c12403          	lw	s0,28(sp)
   108dc:	02010113          	addi	sp,sp,32
   108e0:	00008067          	ret

000108e4 <ns16550_init>:
static struct ns16550_pio * pio = (void*)NS16550_BASE;

#ifdef CONSOLE_UART
__attribute__ ((constructor))
static int ns16550_init(void)
{
   108e4:	fe010113          	addi	sp,sp,-32
   108e8:	00812e23          	sw	s0,28(sp)
   108ec:	02010413          	addi	s0,sp,32
  uint32_t divisor;

  pio->ier = 0;
   108f0:	8081a783          	lw	a5,-2040(gp) # 158a8 <pio>
   108f4:	00078223          	sb	zero,4(a5) # 40000004 <_gp+0x3ffe9f64>

  divisor = NS16550_CLOCK_RATE / (16 * DEFAULT_BAUDRATE);
   108f8:	01a00793          	li	a5,26
   108fc:	fef42623          	sw	a5,-20(s0)
  pio->lcr |= LCR_DLAB;
   10900:	8081a783          	lw	a5,-2040(gp) # 158a8 <pio>
   10904:	8081a703          	lw	a4,-2040(gp) # 158a8 <pio>
   10908:	00c74703          	lbu	a4,12(a4) # 200c <_reset+0x1e0c>
   1090c:	0ff77713          	andi	a4,a4,255
   10910:	f8076713          	ori	a4,a4,-128
   10914:	0ff77713          	andi	a4,a4,255
   10918:	00e78623          	sb	a4,12(a5)
  pio->dll = divisor & 0xff;
   1091c:	8081a783          	lw	a5,-2040(gp) # 158a8 <pio>
   10920:	fec42703          	lw	a4,-20(s0)
   10924:	0ff77713          	andi	a4,a4,255
   10928:	00e78023          	sb	a4,0(a5)
  pio->dlm = (divisor >> 8) & 0xff;
   1092c:	8081a783          	lw	a5,-2040(gp) # 158a8 <pio>
   10930:	fec42703          	lw	a4,-20(s0)
   10934:	00875713          	srli	a4,a4,0x8
   10938:	0ff77713          	andi	a4,a4,255
   1093c:	00e78223          	sb	a4,4(a5)
  pio->lcr &= ~LCR_DLAB;
   10940:	8081a783          	lw	a5,-2040(gp) # 158a8 <pio>
   10944:	8081a703          	lw	a4,-2040(gp) # 158a8 <pio>
   10948:	00c74703          	lbu	a4,12(a4)
   1094c:	0ff77713          	andi	a4,a4,255
   10950:	07f77713          	andi	a4,a4,127
   10954:	0ff77713          	andi	a4,a4,255
   10958:	00e78623          	sb	a4,12(a5)

  pio->lcr = LCR_WLS8;
   1095c:	8081a783          	lw	a5,-2040(gp) # 158a8 <pio>
   10960:	00300713          	li	a4,3
   10964:	00e78623          	sb	a4,12(a5)
  pio->fcr = FCR_FE;
   10968:	8081a783          	lw	a5,-2040(gp) # 158a8 <pio>
   1096c:	00100713          	li	a4,1
   10970:	00e78423          	sb	a4,8(a5)
  pio->mcr = MCR_RTS;
   10974:	8081a783          	lw	a5,-2040(gp) # 158a8 <pio>
   10978:	00200713          	li	a4,2
   1097c:	00e78823          	sb	a4,16(a5)

  return 0;
   10980:	00000793          	li	a5,0
}
   10984:	00078513          	mv	a0,a5
   10988:	01c12403          	lw	s0,28(sp)
   1098c:	02010113          	addi	sp,sp,32
   10990:	00008067          	ret

00010994 <ns16550_rxready>:
#endif


int ns16550_rxready(void)
{
   10994:	ff010113          	addi	sp,sp,-16
   10998:	00812623          	sw	s0,12(sp)
   1099c:	01010413          	addi	s0,sp,16
  return (pio->lsr & LSR_DR) != 0;
   109a0:	8081a783          	lw	a5,-2040(gp) # 158a8 <pio>
   109a4:	0147c783          	lbu	a5,20(a5)
   109a8:	0ff7f793          	andi	a5,a5,255
   109ac:	0017f793          	andi	a5,a5,1
   109b0:	00f037b3          	snez	a5,a5
   109b4:	0ff7f793          	andi	a5,a5,255
}
   109b8:	00078513          	mv	a0,a5
   109bc:	00c12403          	lw	s0,12(sp)
   109c0:	01010113          	addi	sp,sp,16
   109c4:	00008067          	ret

000109c8 <ns16550_rxchar>:


int ns16550_rxchar(void)
{
   109c8:	ff010113          	addi	sp,sp,-16
   109cc:	00812623          	sw	s0,12(sp)
   109d0:	01010413          	addi	s0,sp,16
  while ((pio->lsr & LSR_DR) == 0)
   109d4:	00000013          	nop
   109d8:	8081a783          	lw	a5,-2040(gp) # 158a8 <pio>
   109dc:	0147c783          	lbu	a5,20(a5)
   109e0:	0ff7f793          	andi	a5,a5,255
   109e4:	0017f793          	andi	a5,a5,1
   109e8:	fe0788e3          	beqz	a5,109d8 <ns16550_rxchar+0x10>
    ;  // nothing

  return pio->rbr;
   109ec:	8081a783          	lw	a5,-2040(gp) # 158a8 <pio>
   109f0:	0007c783          	lbu	a5,0(a5)
   109f4:	0ff7f793          	andi	a5,a5,255
}
   109f8:	00078513          	mv	a0,a5
   109fc:	00c12403          	lw	s0,12(sp)
   10a00:	01010113          	addi	sp,sp,16
   10a04:	00008067          	ret

00010a08 <ns16550_txchar>:


int ns16550_txchar(int c)
{
   10a08:	fe010113          	addi	sp,sp,-32
   10a0c:	00812e23          	sw	s0,28(sp)
   10a10:	02010413          	addi	s0,sp,32
   10a14:	fea42623          	sw	a0,-20(s0)
  while ((pio->lsr & LSR_THRE) == 0)
   10a18:	00000013          	nop
   10a1c:	8081a783          	lw	a5,-2040(gp) # 158a8 <pio>
   10a20:	0147c783          	lbu	a5,20(a5)
   10a24:	0ff7f793          	andi	a5,a5,255
   10a28:	0207f793          	andi	a5,a5,32
   10a2c:	fe0788e3          	beqz	a5,10a1c <ns16550_txchar+0x14>
    ;  // nothing

  pio->thr = c;
   10a30:	8081a783          	lw	a5,-2040(gp) # 158a8 <pio>
   10a34:	fec42703          	lw	a4,-20(s0)
   10a38:	0ff77713          	andi	a4,a4,255
   10a3c:	00e78023          	sb	a4,0(a5)

  return c;
   10a40:	fec42783          	lw	a5,-20(s0)
}
   10a44:	00078513          	mv	a0,a5
   10a48:	01c12403          	lw	s0,28(sp)
   10a4c:	02010113          	addi	sp,sp,32
   10a50:	00008067          	ret

00010a54 <ns16550_flush>:


void ns16550_flush(void)
{
   10a54:	ff010113          	addi	sp,sp,-16
   10a58:	00812623          	sw	s0,12(sp)
   10a5c:	01010413          	addi	s0,sp,16
  while ((pio->lsr & LSR_TEMT) == 0)
   10a60:	00000013          	nop
   10a64:	8081a783          	lw	a5,-2040(gp) # 158a8 <pio>
   10a68:	0147c783          	lbu	a5,20(a5)
   10a6c:	0ff7f793          	andi	a5,a5,255
   10a70:	0407f793          	andi	a5,a5,64
   10a74:	fe0788e3          	beqz	a5,10a64 <ns16550_flush+0x10>
    ;  // nothing
}
   10a78:	00000013          	nop
   10a7c:	00c12403          	lw	s0,12(sp)
   10a80:	01010113          	addi	sp,sp,16
   10a84:	00008067          	ret

00010a88 <list_getSize>:

struct List g_nodeFreeList;
struct Node g_nodePool[NUM_DISCS];

int list_getSize( struct List* list )
{
   10a88:	fe010113          	addi	sp,sp,-32
   10a8c:	00812e23          	sw	s0,28(sp)
   10a90:	02010413          	addi	s0,sp,32
   10a94:	fea42623          	sw	a0,-20(s0)
  return list->size;
   10a98:	fec42783          	lw	a5,-20(s0)
   10a9c:	0007a783          	lw	a5,0(a5)
}
   10aa0:	00078513          	mv	a0,a5
   10aa4:	01c12403          	lw	s0,28(sp)
   10aa8:	02010113          	addi	sp,sp,32
   10aac:	00008067          	ret

00010ab0 <list_init>:

void list_init( struct List* list )
{
   10ab0:	fe010113          	addi	sp,sp,-32
   10ab4:	00812e23          	sw	s0,28(sp)
   10ab8:	02010413          	addi	s0,sp,32
   10abc:	fea42623          	sw	a0,-20(s0)
  list->size = 0;
   10ac0:	fec42783          	lw	a5,-20(s0)
   10ac4:	0007a023          	sw	zero,0(a5)
  list->head = 0;
   10ac8:	fec42783          	lw	a5,-20(s0)
   10acc:	0007a223          	sw	zero,4(a5)
}
   10ad0:	00000013          	nop
   10ad4:	01c12403          	lw	s0,28(sp)
   10ad8:	02010113          	addi	sp,sp,32
   10adc:	00008067          	ret

00010ae0 <list_push>:

void list_push( struct List* list, int val )
{
   10ae0:	fd010113          	addi	sp,sp,-48
   10ae4:	02812623          	sw	s0,44(sp)
   10ae8:	03010413          	addi	s0,sp,48
   10aec:	fca42e23          	sw	a0,-36(s0)
   10af0:	fcb42c23          	sw	a1,-40(s0)
  struct Node* newNode;

  // Pop the next free node off the free list
  newNode = g_nodeFreeList.head;
   10af4:	87c18793          	addi	a5,gp,-1924 # 1591c <g_nodeFreeList>
   10af8:	0047a783          	lw	a5,4(a5)
   10afc:	fef42623          	sw	a5,-20(s0)
  g_nodeFreeList.head = g_nodeFreeList.head->next;
   10b00:	87c18793          	addi	a5,gp,-1924 # 1591c <g_nodeFreeList>
   10b04:	0047a783          	lw	a5,4(a5)
   10b08:	0047a703          	lw	a4,4(a5)
   10b0c:	87c18793          	addi	a5,gp,-1924 # 1591c <g_nodeFreeList>
   10b10:	00e7a223          	sw	a4,4(a5)

  // Push the new node onto the given list
  newNode->next = list->head;
   10b14:	fdc42783          	lw	a5,-36(s0)
   10b18:	0047a703          	lw	a4,4(a5)
   10b1c:	fec42783          	lw	a5,-20(s0)
   10b20:	00e7a223          	sw	a4,4(a5)
  list->head = newNode;
   10b24:	fdc42783          	lw	a5,-36(s0)
   10b28:	fec42703          	lw	a4,-20(s0)
   10b2c:	00e7a223          	sw	a4,4(a5)

  // Assign the value
  list->head->val = val;
   10b30:	fdc42783          	lw	a5,-36(s0)
   10b34:	0047a783          	lw	a5,4(a5)
   10b38:	fd842703          	lw	a4,-40(s0)
   10b3c:	00e7a023          	sw	a4,0(a5)

  // Increment size
  list->size++;
   10b40:	fdc42783          	lw	a5,-36(s0)
   10b44:	0007a783          	lw	a5,0(a5)
   10b48:	00178713          	addi	a4,a5,1
   10b4c:	fdc42783          	lw	a5,-36(s0)
   10b50:	00e7a023          	sw	a4,0(a5)

}
   10b54:	00000013          	nop
   10b58:	02c12403          	lw	s0,44(sp)
   10b5c:	03010113          	addi	sp,sp,48
   10b60:	00008067          	ret

00010b64 <list_pop>:

int list_pop( struct List* list )
{
   10b64:	fd010113          	addi	sp,sp,-48
   10b68:	02812623          	sw	s0,44(sp)
   10b6c:	03010413          	addi	s0,sp,48
   10b70:	fca42e23          	sw	a0,-36(s0)
  struct Node* freedNode;
  int val;

  // Get the value from the->head of given list
  val = list->head->val;
   10b74:	fdc42783          	lw	a5,-36(s0)
   10b78:	0047a783          	lw	a5,4(a5)
   10b7c:	0007a783          	lw	a5,0(a5)
   10b80:	fef42623          	sw	a5,-20(s0)
  
  // Pop the head node off the given list
  freedNode = list->head;
   10b84:	fdc42783          	lw	a5,-36(s0)
   10b88:	0047a783          	lw	a5,4(a5)
   10b8c:	fef42423          	sw	a5,-24(s0)
  list->head = list->head->next;
   10b90:	fdc42783          	lw	a5,-36(s0)
   10b94:	0047a783          	lw	a5,4(a5)
   10b98:	0047a703          	lw	a4,4(a5)
   10b9c:	fdc42783          	lw	a5,-36(s0)
   10ba0:	00e7a223          	sw	a4,4(a5)

  // Push the freed node onto the free list
  freedNode->next = g_nodeFreeList.head;
   10ba4:	87c18793          	addi	a5,gp,-1924 # 1591c <g_nodeFreeList>
   10ba8:	0047a703          	lw	a4,4(a5)
   10bac:	fe842783          	lw	a5,-24(s0)
   10bb0:	00e7a223          	sw	a4,4(a5)
  g_nodeFreeList.head = freedNode;
   10bb4:	87c18793          	addi	a5,gp,-1924 # 1591c <g_nodeFreeList>
   10bb8:	fe842703          	lw	a4,-24(s0)
   10bbc:	00e7a223          	sw	a4,4(a5)

  // Decrement size
  list->size--;
   10bc0:	fdc42783          	lw	a5,-36(s0)
   10bc4:	0007a783          	lw	a5,0(a5)
   10bc8:	fff78713          	addi	a4,a5,-1
   10bcc:	fdc42783          	lw	a5,-36(s0)
   10bd0:	00e7a023          	sw	a4,0(a5)

  return val;
   10bd4:	fec42783          	lw	a5,-20(s0)
}
   10bd8:	00078513          	mv	a0,a5
   10bdc:	02c12403          	lw	s0,44(sp)
   10be0:	03010113          	addi	sp,sp,48
   10be4:	00008067          	ret

00010be8 <list_clear>:

void list_clear( struct List* list )
{
   10be8:	fe010113          	addi	sp,sp,-32
   10bec:	00112e23          	sw	ra,28(sp)
   10bf0:	00812c23          	sw	s0,24(sp)
   10bf4:	02010413          	addi	s0,sp,32
   10bf8:	fea42623          	sw	a0,-20(s0)
  while ( list_getSize(list) > 0 )
   10bfc:	00c0006f          	j	10c08 <list_clear+0x20>
    list_pop(list);
   10c00:	fec42503          	lw	a0,-20(s0)
   10c04:	f61ff0ef          	jal	10b64 <list_pop>
  return val;
}

void list_clear( struct List* list )
{
  while ( list_getSize(list) > 0 )
   10c08:	fec42503          	lw	a0,-20(s0)
   10c0c:	e7dff0ef          	jal	10a88 <list_getSize>
   10c10:	00050793          	mv	a5,a0
   10c14:	fef046e3          	bgtz	a5,10c00 <list_clear+0x18>
    list_pop(list);
}
   10c18:	00000013          	nop
   10c1c:	01c12083          	lw	ra,28(sp)
   10c20:	01812403          	lw	s0,24(sp)
   10c24:	02010113          	addi	sp,sp,32
   10c28:	00008067          	ret

00010c2c <towers_init>:
  struct List pegB;
  struct List pegC;  
};

void towers_init( struct Towers* this, int n )
{
   10c2c:	fd010113          	addi	sp,sp,-48
   10c30:	02112623          	sw	ra,44(sp)
   10c34:	02812423          	sw	s0,40(sp)
   10c38:	03010413          	addi	s0,sp,48
   10c3c:	fca42e23          	sw	a0,-36(s0)
   10c40:	fcb42c23          	sw	a1,-40(s0)
  int i;

  this->numDiscs = n;
   10c44:	fdc42783          	lw	a5,-36(s0)
   10c48:	fd842703          	lw	a4,-40(s0)
   10c4c:	00e7a023          	sw	a4,0(a5)
  this->numMoves = 0;
   10c50:	fdc42783          	lw	a5,-36(s0)
   10c54:	0007a223          	sw	zero,4(a5)

  list_init( &(this->pegA) );
   10c58:	fdc42783          	lw	a5,-36(s0)
   10c5c:	00878793          	addi	a5,a5,8
   10c60:	00078513          	mv	a0,a5
   10c64:	e4dff0ef          	jal	10ab0 <list_init>
  list_init( &(this->pegB) );
   10c68:	fdc42783          	lw	a5,-36(s0)
   10c6c:	01078793          	addi	a5,a5,16
   10c70:	00078513          	mv	a0,a5
   10c74:	e3dff0ef          	jal	10ab0 <list_init>
  list_init( &(this->pegC) );
   10c78:	fdc42783          	lw	a5,-36(s0)
   10c7c:	01878793          	addi	a5,a5,24
   10c80:	00078513          	mv	a0,a5
   10c84:	e2dff0ef          	jal	10ab0 <list_init>

  for ( i = 0; i < n; i++ )
   10c88:	fe042623          	sw	zero,-20(s0)
   10c8c:	0300006f          	j	10cbc <towers_init+0x90>
    list_push( &(this->pegA), n-i );
   10c90:	fdc42783          	lw	a5,-36(s0)
   10c94:	00878693          	addi	a3,a5,8
   10c98:	fd842703          	lw	a4,-40(s0)
   10c9c:	fec42783          	lw	a5,-20(s0)
   10ca0:	40f707b3          	sub	a5,a4,a5
   10ca4:	00078593          	mv	a1,a5
   10ca8:	00068513          	mv	a0,a3
   10cac:	e35ff0ef          	jal	10ae0 <list_push>

  list_init( &(this->pegA) );
  list_init( &(this->pegB) );
  list_init( &(this->pegC) );

  for ( i = 0; i < n; i++ )
   10cb0:	fec42783          	lw	a5,-20(s0)
   10cb4:	00178793          	addi	a5,a5,1
   10cb8:	fef42623          	sw	a5,-20(s0)
   10cbc:	fec42703          	lw	a4,-20(s0)
   10cc0:	fd842783          	lw	a5,-40(s0)
   10cc4:	fcf746e3          	blt	a4,a5,10c90 <towers_init+0x64>
    list_push( &(this->pegA), n-i );

}
   10cc8:	00000013          	nop
   10ccc:	02c12083          	lw	ra,44(sp)
   10cd0:	02812403          	lw	s0,40(sp)
   10cd4:	03010113          	addi	sp,sp,48
   10cd8:	00008067          	ret

00010cdc <towers_clear>:

void towers_clear( struct Towers* this )
{
   10cdc:	fe010113          	addi	sp,sp,-32
   10ce0:	00112e23          	sw	ra,28(sp)
   10ce4:	00812c23          	sw	s0,24(sp)
   10ce8:	02010413          	addi	s0,sp,32
   10cec:	fea42623          	sw	a0,-20(s0)

  list_clear( &(this->pegA) );
   10cf0:	fec42783          	lw	a5,-20(s0)
   10cf4:	00878793          	addi	a5,a5,8
   10cf8:	00078513          	mv	a0,a5
   10cfc:	eedff0ef          	jal	10be8 <list_clear>
  list_clear( &(this->pegB) );
   10d00:	fec42783          	lw	a5,-20(s0)
   10d04:	01078793          	addi	a5,a5,16
   10d08:	00078513          	mv	a0,a5
   10d0c:	eddff0ef          	jal	10be8 <list_clear>
  list_clear( &(this->pegC) );
   10d10:	fec42783          	lw	a5,-20(s0)
   10d14:	01878793          	addi	a5,a5,24
   10d18:	00078513          	mv	a0,a5
   10d1c:	ecdff0ef          	jal	10be8 <list_clear>

  towers_init( this, this->numDiscs );
   10d20:	fec42783          	lw	a5,-20(s0)
   10d24:	0007a783          	lw	a5,0(a5)
   10d28:	00078593          	mv	a1,a5
   10d2c:	fec42503          	lw	a0,-20(s0)
   10d30:	efdff0ef          	jal	10c2c <towers_init>

}
   10d34:	00000013          	nop
   10d38:	01c12083          	lw	ra,28(sp)
   10d3c:	01812403          	lw	s0,24(sp)
   10d40:	02010113          	addi	sp,sp,32
   10d44:	00008067          	ret

00010d48 <towers_solve_h>:

void towers_solve_h( struct Towers* this, int n,
                     struct List* startPeg, 
                     struct List* tempPeg, 
                     struct List* destPeg ) 
{ 
   10d48:	fc010113          	addi	sp,sp,-64
   10d4c:	02112e23          	sw	ra,60(sp)
   10d50:	02812c23          	sw	s0,56(sp)
   10d54:	04010413          	addi	s0,sp,64
   10d58:	fca42e23          	sw	a0,-36(s0)
   10d5c:	fcb42c23          	sw	a1,-40(s0)
   10d60:	fcc42a23          	sw	a2,-44(s0)
   10d64:	fcd42823          	sw	a3,-48(s0)
   10d68:	fce42623          	sw	a4,-52(s0)
  int val;

  if ( n == 1 ) {
   10d6c:	fd842703          	lw	a4,-40(s0)
   10d70:	00100793          	li	a5,1
   10d74:	02f71a63          	bne	a4,a5,10da8 <towers_solve_h+0x60>
    val = list_pop(startPeg);
   10d78:	fd442503          	lw	a0,-44(s0)
   10d7c:	de9ff0ef          	jal	10b64 <list_pop>
   10d80:	fea42623          	sw	a0,-20(s0)
    list_push(destPeg,val);
   10d84:	fec42583          	lw	a1,-20(s0)
   10d88:	fcc42503          	lw	a0,-52(s0)
   10d8c:	d55ff0ef          	jal	10ae0 <list_push>
    this->numMoves++;
   10d90:	fdc42783          	lw	a5,-36(s0)
   10d94:	0047a783          	lw	a5,4(a5)
   10d98:	00178713          	addi	a4,a5,1
   10d9c:	fdc42783          	lw	a5,-36(s0)
   10da0:	00e7a223          	sw	a4,4(a5)
    towers_solve_h( this, n-1, startPeg, destPeg,  tempPeg );
    towers_solve_h( this, 1,   startPeg, tempPeg,  destPeg );
    towers_solve_h( this, n-1, tempPeg,  startPeg, destPeg );
  }

}
   10da4:	05c0006f          	j	10e00 <towers_solve_h+0xb8>
    val = list_pop(startPeg);
    list_push(destPeg,val);
    this->numMoves++;
  }
  else {
    towers_solve_h( this, n-1, startPeg, destPeg,  tempPeg );
   10da8:	fd842783          	lw	a5,-40(s0)
   10dac:	fff78793          	addi	a5,a5,-1
   10db0:	fd042703          	lw	a4,-48(s0)
   10db4:	fcc42683          	lw	a3,-52(s0)
   10db8:	fd442603          	lw	a2,-44(s0)
   10dbc:	00078593          	mv	a1,a5
   10dc0:	fdc42503          	lw	a0,-36(s0)
   10dc4:	f85ff0ef          	jal	10d48 <towers_solve_h>
    towers_solve_h( this, 1,   startPeg, tempPeg,  destPeg );
   10dc8:	fcc42703          	lw	a4,-52(s0)
   10dcc:	fd042683          	lw	a3,-48(s0)
   10dd0:	fd442603          	lw	a2,-44(s0)
   10dd4:	00100593          	li	a1,1
   10dd8:	fdc42503          	lw	a0,-36(s0)
   10ddc:	f6dff0ef          	jal	10d48 <towers_solve_h>
    towers_solve_h( this, n-1, tempPeg,  startPeg, destPeg );
   10de0:	fd842783          	lw	a5,-40(s0)
   10de4:	fff78793          	addi	a5,a5,-1
   10de8:	fcc42703          	lw	a4,-52(s0)
   10dec:	fd442683          	lw	a3,-44(s0)
   10df0:	fd042603          	lw	a2,-48(s0)
   10df4:	00078593          	mv	a1,a5
   10df8:	fdc42503          	lw	a0,-36(s0)
   10dfc:	f4dff0ef          	jal	10d48 <towers_solve_h>
  }

}
   10e00:	00000013          	nop
   10e04:	03c12083          	lw	ra,60(sp)
   10e08:	03812403          	lw	s0,56(sp)
   10e0c:	04010113          	addi	sp,sp,64
   10e10:	00008067          	ret

00010e14 <towers_solve>:

void towers_solve( struct Towers* this )
{
   10e14:	fe010113          	addi	sp,sp,-32
   10e18:	00112e23          	sw	ra,28(sp)
   10e1c:	00812c23          	sw	s0,24(sp)
   10e20:	02010413          	addi	s0,sp,32
   10e24:	fea42623          	sw	a0,-20(s0)
  towers_solve_h( this, this->numDiscs, &(this->pegA), &(this->pegB), &(this->pegC) );
   10e28:	fec42783          	lw	a5,-20(s0)
   10e2c:	0007a583          	lw	a1,0(a5)
   10e30:	fec42783          	lw	a5,-20(s0)
   10e34:	00878613          	addi	a2,a5,8
   10e38:	fec42783          	lw	a5,-20(s0)
   10e3c:	01078693          	addi	a3,a5,16
   10e40:	fec42783          	lw	a5,-20(s0)
   10e44:	01878793          	addi	a5,a5,24
   10e48:	00078713          	mv	a4,a5
   10e4c:	fec42503          	lw	a0,-20(s0)
   10e50:	ef9ff0ef          	jal	10d48 <towers_solve_h>
}
   10e54:	00000013          	nop
   10e58:	01c12083          	lw	ra,28(sp)
   10e5c:	01812403          	lw	s0,24(sp)
   10e60:	02010113          	addi	sp,sp,32
   10e64:	00008067          	ret

00010e68 <towers_verify>:

int towers_verify( struct Towers* this )
{
   10e68:	fd010113          	addi	sp,sp,-48
   10e6c:	02112623          	sw	ra,44(sp)
   10e70:	02812423          	sw	s0,40(sp)
   10e74:	03010413          	addi	s0,sp,48
   10e78:	fca42e23          	sw	a0,-36(s0)
  struct Node* ptr;
  int numDiscs = 0;
   10e7c:	fe042423          	sw	zero,-24(s0)

  if ( list_getSize(&this->pegA) != 0 ) {
   10e80:	fdc42783          	lw	a5,-36(s0)
   10e84:	00878793          	addi	a5,a5,8
   10e88:	00078513          	mv	a0,a5
   10e8c:	bfdff0ef          	jal	10a88 <list_getSize>
   10e90:	00050793          	mv	a5,a0
   10e94:	00078663          	beqz	a5,10ea0 <towers_verify+0x38>
    return 2;
   10e98:	00200793          	li	a5,2
   10e9c:	0c00006f          	j	10f5c <towers_verify+0xf4>
  }

  if ( list_getSize(&this->pegB) != 0 ) {
   10ea0:	fdc42783          	lw	a5,-36(s0)
   10ea4:	01078793          	addi	a5,a5,16
   10ea8:	00078513          	mv	a0,a5
   10eac:	bddff0ef          	jal	10a88 <list_getSize>
   10eb0:	00050793          	mv	a5,a0
   10eb4:	00078663          	beqz	a5,10ec0 <towers_verify+0x58>
    return 3;
   10eb8:	00300793          	li	a5,3
   10ebc:	0a00006f          	j	10f5c <towers_verify+0xf4>
  }

  if ( list_getSize(&this->pegC) != this->numDiscs ) {
   10ec0:	fdc42783          	lw	a5,-36(s0)
   10ec4:	01878793          	addi	a5,a5,24
   10ec8:	00078513          	mv	a0,a5
   10ecc:	bbdff0ef          	jal	10a88 <list_getSize>
   10ed0:	00050713          	mv	a4,a0
   10ed4:	fdc42783          	lw	a5,-36(s0)
   10ed8:	0007a783          	lw	a5,0(a5)
   10edc:	00f70663          	beq	a4,a5,10ee8 <towers_verify+0x80>
    return 4;
   10ee0:	00400793          	li	a5,4
   10ee4:	0780006f          	j	10f5c <towers_verify+0xf4>
  }

  for ( ptr = this->pegC.head; ptr != 0; ptr = ptr->next ) {
   10ee8:	fdc42783          	lw	a5,-36(s0)
   10eec:	01c7a783          	lw	a5,28(a5)
   10ef0:	fef42623          	sw	a5,-20(s0)
   10ef4:	0340006f          	j	10f28 <towers_verify+0xc0>
    numDiscs++;
   10ef8:	fe842783          	lw	a5,-24(s0)
   10efc:	00178793          	addi	a5,a5,1
   10f00:	fef42423          	sw	a5,-24(s0)
    if ( ptr->val != numDiscs ) {
   10f04:	fec42783          	lw	a5,-20(s0)
   10f08:	0007a703          	lw	a4,0(a5)
   10f0c:	fe842783          	lw	a5,-24(s0)
   10f10:	00f70663          	beq	a4,a5,10f1c <towers_verify+0xb4>
      return 5;
   10f14:	00500793          	li	a5,5
   10f18:	0440006f          	j	10f5c <towers_verify+0xf4>

  if ( list_getSize(&this->pegC) != this->numDiscs ) {
    return 4;
  }

  for ( ptr = this->pegC.head; ptr != 0; ptr = ptr->next ) {
   10f1c:	fec42783          	lw	a5,-20(s0)
   10f20:	0047a783          	lw	a5,4(a5)
   10f24:	fef42623          	sw	a5,-20(s0)
   10f28:	fec42783          	lw	a5,-20(s0)
   10f2c:	fc0796e3          	bnez	a5,10ef8 <towers_verify+0x90>
    if ( ptr->val != numDiscs ) {
      return 5;
    }
  }
  
  if ( this->numMoves != ((1 << this->numDiscs) - 1) ) {
   10f30:	fdc42783          	lw	a5,-36(s0)
   10f34:	0047a703          	lw	a4,4(a5)
   10f38:	fdc42783          	lw	a5,-36(s0)
   10f3c:	0007a783          	lw	a5,0(a5)
   10f40:	00100693          	li	a3,1
   10f44:	00f697b3          	sll	a5,a3,a5
   10f48:	fff78793          	addi	a5,a5,-1
   10f4c:	00f70663          	beq	a4,a5,10f58 <towers_verify+0xf0>
    return 6;
   10f50:	00600793          	li	a5,6
   10f54:	0080006f          	j	10f5c <towers_verify+0xf4>
  }

  return 1;
   10f58:	00100793          	li	a5,1
}
   10f5c:	00078513          	mv	a0,a5
   10f60:	02c12083          	lw	ra,44(sp)
   10f64:	02812403          	lw	s0,40(sp)
   10f68:	03010113          	addi	sp,sp,48
   10f6c:	00008067          	ret

00010f70 <main>:

//--------------------------------------------------------------------------
// Main

int main( int argc, char* argv[] )
{
   10f70:	f9010113          	addi	sp,sp,-112
   10f74:	06112623          	sw	ra,108(sp)
   10f78:	06812423          	sw	s0,104(sp)
   10f7c:	07010413          	addi	s0,sp,112
   10f80:	f8a42e23          	sw	a0,-100(s0)
   10f84:	f8b42c23          	sw	a1,-104(s0)
    int i;
    uint64_t c0, i0, c1, i1;

    // Initialize free list 

    list_init( &g_nodeFreeList );
   10f88:	87c18513          	addi	a0,gp,-1924 # 1591c <g_nodeFreeList>
   10f8c:	b25ff0ef          	jal	10ab0 <list_init>
    g_nodeFreeList.head = &(g_nodePool[0]);
   10f90:	87c18793          	addi	a5,gp,-1924 # 1591c <g_nodeFreeList>
   10f94:	88418713          	addi	a4,gp,-1916 # 15924 <g_nodePool>
   10f98:	00e7a223          	sw	a4,4(a5)
    g_nodeFreeList.size = NUM_DISCS;
   10f9c:	00700713          	li	a4,7
   10fa0:	86e1ae23          	sw	a4,-1924(gp) # 1591c <g_nodeFreeList>
    g_nodePool[NUM_DISCS-1].next = 0;
   10fa4:	88418793          	addi	a5,gp,-1916 # 15924 <g_nodePool>
   10fa8:	0207aa23          	sw	zero,52(a5)
    g_nodePool[NUM_DISCS-1].val = 99;
   10fac:	88418793          	addi	a5,gp,-1916 # 15924 <g_nodePool>
   10fb0:	06300713          	li	a4,99
   10fb4:	02e7a823          	sw	a4,48(a5)
    for ( i = 0; i < (NUM_DISCS-1); i++ ) {
   10fb8:	fe042623          	sw	zero,-20(s0)
   10fbc:	0500006f          	j	1100c <main+0x9c>
	g_nodePool[i].next = &(g_nodePool[i+1]);
   10fc0:	fec42783          	lw	a5,-20(s0)
   10fc4:	00178793          	addi	a5,a5,1
   10fc8:	00379713          	slli	a4,a5,0x3
   10fcc:	88418793          	addi	a5,gp,-1916 # 15924 <g_nodePool>
   10fd0:	00f70733          	add	a4,a4,a5
   10fd4:	fec42783          	lw	a5,-20(s0)
   10fd8:	88418693          	addi	a3,gp,-1916 # 15924 <g_nodePool>
   10fdc:	00379793          	slli	a5,a5,0x3
   10fe0:	00f687b3          	add	a5,a3,a5
   10fe4:	00e7a223          	sw	a4,4(a5)
	g_nodePool[i].val = i;
   10fe8:	fec42703          	lw	a4,-20(s0)
   10fec:	00371713          	slli	a4,a4,0x3
   10ff0:	88418793          	addi	a5,gp,-1916 # 15924 <g_nodePool>
   10ff4:	00f707b3          	add	a5,a4,a5
   10ff8:	fec42703          	lw	a4,-20(s0)
   10ffc:	00e7a023          	sw	a4,0(a5)
    list_init( &g_nodeFreeList );
    g_nodeFreeList.head = &(g_nodePool[0]);
    g_nodeFreeList.size = NUM_DISCS;
    g_nodePool[NUM_DISCS-1].next = 0;
    g_nodePool[NUM_DISCS-1].val = 99;
    for ( i = 0; i < (NUM_DISCS-1); i++ ) {
   11000:	fec42783          	lw	a5,-20(s0)
   11004:	00178793          	addi	a5,a5,1
   11008:	fef42623          	sw	a5,-20(s0)
   1100c:	fec42703          	lw	a4,-20(s0)
   11010:	00500793          	li	a5,5
   11014:	fae7d6e3          	ble	a4,a5,10fc0 <main+0x50>
	g_nodePool[i].next = &(g_nodePool[i+1]);
	g_nodePool[i].val = i;
    }

    towers_init( &towers, NUM_DISCS );
   11018:	fa840793          	addi	a5,s0,-88
   1101c:	00700593          	li	a1,7
   11020:	00078513          	mv	a0,a5
   11024:	c09ff0ef          	jal	10c2c <towers_init>

    // Solve it

    towers_clear( &towers );
   11028:	fa840793          	addi	a5,s0,-88
   1102c:	00078513          	mv	a0,a5
   11030:	cadff0ef          	jal	10cdc <towers_clear>

    c0 = read_cycle ();
   11034:	815ff0ef          	jal	10848 <read_cycle>
   11038:	fea42023          	sw	a0,-32(s0)
   1103c:	feb42223          	sw	a1,-28(s0)
    i0 = read_instret ();
   11040:	871ff0ef          	jal	108b0 <read_instret>
   11044:	fca42c23          	sw	a0,-40(s0)
   11048:	fcb42e23          	sw	a1,-36(s0)

    towers_solve( &towers );
   1104c:	fa840793          	addi	a5,s0,-88
   11050:	00078513          	mv	a0,a5
   11054:	dc1ff0ef          	jal	10e14 <towers_solve>

    c1 = read_cycle () - c0;
   11058:	ff0ff0ef          	jal	10848 <read_cycle>
   1105c:	00050613          	mv	a2,a0
   11060:	00058693          	mv	a3,a1
   11064:	fe042503          	lw	a0,-32(s0)
   11068:	fe442583          	lw	a1,-28(s0)
   1106c:	40a60733          	sub	a4,a2,a0
   11070:	00e63833          	sltu	a6,a2,a4
   11074:	40b687b3          	sub	a5,a3,a1
   11078:	410786b3          	sub	a3,a5,a6
   1107c:	00068793          	mv	a5,a3
   11080:	fce42823          	sw	a4,-48(s0)
   11084:	fcf42a23          	sw	a5,-44(s0)
    i1 = read_instret () - i0;
   11088:	829ff0ef          	jal	108b0 <read_instret>
   1108c:	00050613          	mv	a2,a0
   11090:	00058693          	mv	a3,a1
   11094:	fd842503          	lw	a0,-40(s0)
   11098:	fdc42583          	lw	a1,-36(s0)
   1109c:	40a60733          	sub	a4,a2,a0
   110a0:	00e63833          	sltu	a6,a2,a4
   110a4:	40b687b3          	sub	a5,a3,a1
   110a8:	410786b3          	sub	a3,a5,a6
   110ac:	00068793          	mv	a5,a3
   110b0:	fce42423          	sw	a4,-56(s0)
   110b4:	fcf42623          	sw	a5,-52(s0)

    // Check the results
    if (towers_verify( &towers ))
   110b8:	fa840793          	addi	a5,s0,-88
   110bc:	00078513          	mv	a0,a5
   110c0:	da9ff0ef          	jal	10e68 <towers_verify>
   110c4:	00050793          	mv	a5,a0
   110c8:	00078a63          	beqz	a5,110dc <main+0x16c>
	printf ("Verify = ok\n");
   110cc:	000147b7          	lui	a5,0x14
   110d0:	46078513          	addi	a0,a5,1120 # 14460 <fclose+0xc>
   110d4:	351000ef          	jal	11c24 <puts>
   110d8:	0100006f          	j	110e8 <main+0x178>
    else
	printf ("Verify = not ok\n");
   110dc:	000147b7          	lui	a5,0x14
   110e0:	46c78513          	addi	a0,a5,1132 # 1446c <fclose+0x18>
   110e4:	341000ef          	jal	11c24 <puts>

    return 0;
   110e8:	00000793          	li	a5,0
}
   110ec:	00078513          	mv	a0,a5
   110f0:	06c12083          	lw	ra,108(sp)
   110f4:	06812403          	lw	s0,104(sp)
   110f8:	07010113          	addi	sp,sp,112
   110fc:	00008067          	ret

00011100 <__divdi3>:
  Wtype c = 0;
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
   11100:	2605ce63          	bltz	a1,1137c <__divdi3+0x27c>
   11104:	00050313          	mv	t1,a0
   11108:	00058793          	mv	a5,a1

#ifdef L_divdi3
DWtype
__divdi3 (DWtype u, DWtype v)
{
  Wtype c = 0;
   1110c:	00000893          	li	a7,0
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
   11110:	2406ca63          	bltz	a3,11364 <__divdi3+0x264>
  DWunion rr;
  UWtype d0, d1, n0, n1, n2;
  UWtype q0, q1;
  UWtype b, bm;

  d0 = dd.s.low;
   11114:	00060293          	mv	t0,a2
  d1 = dd.s.high;
  n0 = nn.s.low;
   11118:	00030393          	mv	t2,t1
  n1 = nn.s.high;
   1111c:	00078593          	mv	a1,a5
	}
    }

#else /* UDIV_NEEDS_NORMALIZATION */

  if (d1 == 0)
   11120:	0e069e63          	bnez	a3,1121c <__divdi3+0x11c>
    {
      if (d0 > n1)
   11124:	16c7f263          	bleu	a2,a5,11288 <__divdi3+0x188>
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   11128:	00010737          	lui	a4,0x10
   1112c:	26e66c63          	bltu	a2,a4,113a4 <__divdi3+0x2a4>
   11130:	01000737          	lui	a4,0x1000
   11134:	00e63733          	sltu	a4,a2,a4
   11138:	00174713          	xori	a4,a4,1
   1113c:	40e00733          	neg	a4,a4
   11140:	00877713          	andi	a4,a4,8
   11144:	01070713          	addi	a4,a4,16 # 1000010 <_gp+0xfe9f70>
   11148:	000146b7          	lui	a3,0x14
   1114c:	00e65533          	srl	a0,a2,a4
   11150:	47c68693          	addi	a3,a3,1148 # 1447c <__clz_tab>
   11154:	00d506b3          	add	a3,a0,a3
   11158:	0006c683          	lbu	a3,0(a3)
   1115c:	00e68733          	add	a4,a3,a4
   11160:	02000693          	li	a3,32
   11164:	40e686b3          	sub	a3,a3,a4

	  if (bm != 0)
   11168:	00068c63          	beqz	a3,11180 <__divdi3+0x80>
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   1116c:	00d797b3          	sll	a5,a5,a3
   11170:	00e35733          	srl	a4,t1,a4
	  if (bm != 0)
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
   11174:	00d612b3          	sll	t0,a2,a3
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   11178:	00f765b3          	or	a1,a4,a5
	      n0 = n0 << bm;
   1117c:	00d313b3          	sll	t2,t1,a3
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11180:	0102d613          	srli	a2,t0,0x10
   11184:	02c5d533          	divu	a0,a1,a2
   11188:	01029693          	slli	a3,t0,0x10
   1118c:	0106d693          	srli	a3,a3,0x10
   11190:	0103d713          	srli	a4,t2,0x10
   11194:	02c5f7b3          	remu	a5,a1,a2
   11198:	02a68833          	mul	a6,a3,a0
   1119c:	01079793          	slli	a5,a5,0x10
   111a0:	00f765b3          	or	a1,a4,a5
   111a4:	0105fc63          	bleu	a6,a1,111bc <__divdi3+0xbc>
   111a8:	005585b3          	add	a1,a1,t0
   111ac:	fff50793          	addi	a5,a0,-1
   111b0:	0055e463          	bltu	a1,t0,111b8 <__divdi3+0xb8>
   111b4:	4105e263          	bltu	a1,a6,115b8 <__divdi3+0x4b8>
   111b8:	00078513          	mv	a0,a5
   111bc:	410585b3          	sub	a1,a1,a6
   111c0:	02c5d7b3          	divu	a5,a1,a2
   111c4:	01039393          	slli	t2,t2,0x10
   111c8:	0103d393          	srli	t2,t2,0x10
   111cc:	02c5f5b3          	remu	a1,a1,a2
   111d0:	02f686b3          	mul	a3,a3,a5
   111d4:	01059593          	slli	a1,a1,0x10
   111d8:	00b3e5b3          	or	a1,t2,a1
   111dc:	00d5fe63          	bleu	a3,a1,111f8 <__divdi3+0xf8>
   111e0:	00b285b3          	add	a1,t0,a1
   111e4:	fff78713          	addi	a4,a5,-1
   111e8:	0055e663          	bltu	a1,t0,111f4 <__divdi3+0xf4>
   111ec:	ffe78793          	addi	a5,a5,-2
   111f0:	00d5e463          	bltu	a1,a3,111f8 <__divdi3+0xf8>
   111f4:	00070793          	mv	a5,a4
   111f8:	01051513          	slli	a0,a0,0x10
   111fc:	00f56533          	or	a0,a0,a5
   11200:	00000593          	li	a1,0
  if (vv.s.high < 0)
    c = ~c,
    vv.ll = -vv.ll;

  w = __udivmoddi4 (uu.ll, vv.ll, (UDWtype *) 0);
  if (c)
   11204:	00088a63          	beqz	a7,11218 <__divdi3+0x118>
    w = -w;
   11208:	40a00533          	neg	a0,a0
   1120c:	00a037b3          	snez	a5,a0
   11210:	40b005b3          	neg	a1,a1
   11214:	40f585b3          	sub	a1,a1,a5

  return w;
}
   11218:	00008067          	ret
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
   1121c:	00d7f863          	bleu	a3,a5,1122c <__divdi3+0x12c>
   11220:	00000593          	li	a1,0
   11224:	00000513          	li	a0,0
   11228:	fddff06f          	j	11204 <__divdi3+0x104>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   1122c:	00010737          	lui	a4,0x10
   11230:	18e6e263          	bltu	a3,a4,113b4 <__divdi3+0x2b4>
   11234:	01000737          	lui	a4,0x1000
   11238:	00e6b733          	sltu	a4,a3,a4
   1123c:	00174713          	xori	a4,a4,1
   11240:	40e00733          	neg	a4,a4
   11244:	00877713          	andi	a4,a4,8
   11248:	01070713          	addi	a4,a4,16 # 1000010 <_gp+0xfe9f70>
   1124c:	000145b7          	lui	a1,0x14
   11250:	00e6d533          	srl	a0,a3,a4
   11254:	47c58593          	addi	a1,a1,1148 # 1447c <__clz_tab>
   11258:	00b505b3          	add	a1,a0,a1
   1125c:	0005c803          	lbu	a6,0(a1)
   11260:	02000293          	li	t0,32
   11264:	00e80833          	add	a6,a6,a4
   11268:	410282b3          	sub	t0,t0,a6
	  if (bm == 0)
   1126c:	14029c63          	bnez	t0,113c4 <__divdi3+0x2c4>

		 This special case is necessary, not an optimization.  */

	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
   11270:	00000593          	li	a1,0
   11274:	00100513          	li	a0,1
   11278:	f8f6e6e3          	bltu	a3,a5,11204 <__divdi3+0x104>
   1127c:	00c33533          	sltu	a0,t1,a2
   11280:	00154513          	xori	a0,a0,1
   11284:	f81ff06f          	j	11204 <__divdi3+0x104>
	}
      else
	{
	  /* qq = NN / 0d */

	  if (d0 == 0)
   11288:	00061663          	bnez	a2,11294 <__divdi3+0x194>
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
   1128c:	00100293          	li	t0,1
   11290:	02d2d2b3          	divu	t0,t0,a3

	  count_leading_zeros (bm, d0);
   11294:	00010737          	lui	a4,0x10
   11298:	0ee2ee63          	bltu	t0,a4,11394 <__divdi3+0x294>
   1129c:	01000737          	lui	a4,0x1000
   112a0:	00e2b733          	sltu	a4,t0,a4
   112a4:	00174713          	xori	a4,a4,1
   112a8:	40e00733          	neg	a4,a4
   112ac:	00877713          	andi	a4,a4,8
   112b0:	01070713          	addi	a4,a4,16 # 1000010 <_gp+0xfe9f70>
   112b4:	000146b7          	lui	a3,0x14
   112b8:	00e2d633          	srl	a2,t0,a4
   112bc:	47c68693          	addi	a3,a3,1148 # 1447c <__clz_tab>
   112c0:	00d606b3          	add	a3,a2,a3
   112c4:	0006c503          	lbu	a0,0(a3)
   112c8:	02000e13          	li	t3,32
   112cc:	00e50533          	add	a0,a0,a4
   112d0:	40ae0e33          	sub	t3,t3,a0

	  if (bm == 0)
   112d4:	1e0e1663          	bnez	t3,114c0 <__divdi3+0x3c0>
   112d8:	01029813          	slli	a6,t0,0x10
		 leading quotient digit q1 = 1).

		 This special case is necessary, not an optimization.
		 (Shifts counts of W_TYPE_SIZE are undefined.)  */

	      n1 -= d0;
   112dc:	405786b3          	sub	a3,a5,t0
   112e0:	0102d613          	srli	a2,t0,0x10
   112e4:	01085813          	srli	a6,a6,0x10
   112e8:	00100593          	li	a1,1
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   112ec:	0103d793          	srli	a5,t2,0x10
   112f0:	02c6d533          	divu	a0,a3,a2
   112f4:	02c6f6b3          	remu	a3,a3,a2
   112f8:	03050733          	mul	a4,a0,a6
   112fc:	01069693          	slli	a3,a3,0x10
   11300:	00d7e7b3          	or	a5,a5,a3
   11304:	00e7fc63          	bleu	a4,a5,1131c <__divdi3+0x21c>
   11308:	005787b3          	add	a5,a5,t0
   1130c:	fff50693          	addi	a3,a0,-1
   11310:	0057e463          	bltu	a5,t0,11318 <__divdi3+0x218>
   11314:	2ae7e863          	bltu	a5,a4,115c4 <__divdi3+0x4c4>
   11318:	00068513          	mv	a0,a3
   1131c:	40e78733          	sub	a4,a5,a4
   11320:	02c757b3          	divu	a5,a4,a2
   11324:	01039393          	slli	t2,t2,0x10
   11328:	0103d393          	srli	t2,t2,0x10
   1132c:	02c77733          	remu	a4,a4,a2
   11330:	03078833          	mul	a6,a5,a6
   11334:	01071713          	slli	a4,a4,0x10
   11338:	00e3e733          	or	a4,t2,a4
   1133c:	01077e63          	bleu	a6,a4,11358 <__divdi3+0x258>
   11340:	00e28733          	add	a4,t0,a4
   11344:	fff78693          	addi	a3,a5,-1
   11348:	00576663          	bltu	a4,t0,11354 <__divdi3+0x254>
   1134c:	ffe78793          	addi	a5,a5,-2
   11350:	01076463          	bltu	a4,a6,11358 <__divdi3+0x258>
   11354:	00068793          	mv	a5,a3
   11358:	01051513          	slli	a0,a0,0x10
   1135c:	00f56533          	or	a0,a0,a5
   11360:	ea5ff06f          	j	11204 <__divdi3+0x104>
  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    c = ~c,
    vv.ll = -vv.ll;
   11364:	40c00633          	neg	a2,a2
   11368:	00c03733          	snez	a4,a2
   1136c:	40d006b3          	neg	a3,a3

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    c = ~c,
   11370:	fff8c893          	not	a7,a7
    vv.ll = -vv.ll;
   11374:	40e686b3          	sub	a3,a3,a4
   11378:	d9dff06f          	j	11114 <__divdi3+0x14>
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
   1137c:	40a00333          	neg	t1,a0
   11380:	00603733          	snez	a4,t1
   11384:	40b007b3          	neg	a5,a1
   11388:	40e787b3          	sub	a5,a5,a4
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
   1138c:	fff00893          	li	a7,-1
   11390:	d81ff06f          	j	11110 <__divdi3+0x10>
	  /* qq = NN / 0d */

	  if (d0 == 0)
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */

	  count_leading_zeros (bm, d0);
   11394:	0ff00713          	li	a4,255
   11398:	00573733          	sltu	a4,a4,t0
   1139c:	00371713          	slli	a4,a4,0x3
   113a0:	f15ff06f          	j	112b4 <__divdi3+0x1b4>
    {
      if (d0 > n1)
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   113a4:	0ff00713          	li	a4,255
   113a8:	00c73733          	sltu	a4,a4,a2
   113ac:	00371713          	slli	a4,a4,0x3
   113b0:	d99ff06f          	j	11148 <__divdi3+0x48>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   113b4:	0ff00713          	li	a4,255
   113b8:	00d73733          	sltu	a4,a4,a3
   113bc:	00371713          	slli	a4,a4,0x3
   113c0:	e8dff06f          	j	1124c <__divdi3+0x14c>
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
   113c4:	01065733          	srl	a4,a2,a6
   113c8:	005696b3          	sll	a3,a3,t0
   113cc:	00e6e6b3          	or	a3,a3,a4
	      d0 = d0 << bm;
	      n2 = n1 >> b;
   113d0:	0107d5b3          	srl	a1,a5,a6
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   113d4:	0106de93          	srli	t4,a3,0x10
   113d8:	03d5de33          	divu	t3,a1,t4
   113dc:	01069393          	slli	t2,a3,0x10
   113e0:	0103d393          	srli	t2,t2,0x10
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   113e4:	005797b3          	sll	a5,a5,t0
   113e8:	01035833          	srl	a6,t1,a6
   113ec:	00f867b3          	or	a5,a6,a5
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   113f0:	0107d713          	srli	a4,a5,0x10
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
   113f4:	00561633          	sll	a2,a2,t0
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   113f8:	03d5f5b3          	remu	a1,a1,t4
   113fc:	03c38533          	mul	a0,t2,t3
   11400:	01059593          	slli	a1,a1,0x10
   11404:	00b76733          	or	a4,a4,a1
   11408:	00a77e63          	bleu	a0,a4,11424 <__divdi3+0x324>
   1140c:	00d70733          	add	a4,a4,a3
   11410:	fffe0593          	addi	a1,t3,-1
   11414:	18d76e63          	bltu	a4,a3,115b0 <__divdi3+0x4b0>
   11418:	18a77c63          	bleu	a0,a4,115b0 <__divdi3+0x4b0>
   1141c:	ffee0e13          	addi	t3,t3,-2
   11420:	00d70733          	add	a4,a4,a3
   11424:	40a70733          	sub	a4,a4,a0
   11428:	03d75833          	divu	a6,a4,t4
   1142c:	01079793          	slli	a5,a5,0x10
   11430:	0107d793          	srli	a5,a5,0x10
   11434:	03d77733          	remu	a4,a4,t4
   11438:	030385b3          	mul	a1,t2,a6
   1143c:	01071713          	slli	a4,a4,0x10
   11440:	00e7e7b3          	or	a5,a5,a4
   11444:	00b7fe63          	bleu	a1,a5,11460 <__divdi3+0x360>
   11448:	00d787b3          	add	a5,a5,a3
   1144c:	fff80713          	addi	a4,a6,-1
   11450:	14d7e863          	bltu	a5,a3,115a0 <__divdi3+0x4a0>
   11454:	14b7f663          	bleu	a1,a5,115a0 <__divdi3+0x4a0>
   11458:	ffe80813          	addi	a6,a6,-2
   1145c:	00d787b3          	add	a5,a5,a3
   11460:	010e1e13          	slli	t3,t3,0x10
	      umul_ppmm (m1, m0, q0, d0);
   11464:	000103b7          	lui	t2,0x10
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11468:	010e6533          	or	a0,t3,a6
	      umul_ppmm (m1, m0, q0, d0);
   1146c:	fff38713          	addi	a4,t2,-1 # ffff <_reset+0xfdff>
   11470:	00e576b3          	and	a3,a0,a4
   11474:	01055813          	srli	a6,a0,0x10
   11478:	00e67733          	and	a4,a2,a4
   1147c:	01065613          	srli	a2,a2,0x10
   11480:	02e68e33          	mul	t3,a3,a4
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11484:	40b787b3          	sub	a5,a5,a1
   11488:	02c686b3          	mul	a3,a3,a2
	      umul_ppmm (m1, m0, q0, d0);
   1148c:	010e5593          	srli	a1,t3,0x10
   11490:	02e80733          	mul	a4,a6,a4
   11494:	00e686b3          	add	a3,a3,a4
   11498:	00d586b3          	add	a3,a1,a3
   1149c:	02c80633          	mul	a2,a6,a2
   114a0:	00e6f463          	bleu	a4,a3,114a8 <__divdi3+0x3a8>
   114a4:	00760633          	add	a2,a2,t2
   114a8:	0106d813          	srli	a6,a3,0x10
   114ac:	00c80633          	add	a2,a6,a2

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   114b0:	0cc7ee63          	bltu	a5,a2,1158c <__divdi3+0x48c>
   114b4:	0ac78c63          	beq	a5,a2,1156c <__divdi3+0x46c>
		{
		  q0--;
   114b8:	00000593          	li	a1,0
   114bc:	d49ff06f          	j	11204 <__divdi3+0x104>
	    {
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
   114c0:	01c292b3          	sll	t0,t0,t3
	      n2 = n1 >> b;
   114c4:	00a7d833          	srl	a6,a5,a0
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   114c8:	0102d713          	srli	a4,t0,0x10
   114cc:	02e85eb3          	divu	t4,a6,a4
   114d0:	01029f13          	slli	t5,t0,0x10

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   114d4:	01c796b3          	sll	a3,a5,t3
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   114d8:	010f5f13          	srli	t5,t5,0x10

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   114dc:	00a35533          	srl	a0,t1,a0
   114e0:	00d56533          	or	a0,a0,a3
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   114e4:	01055613          	srli	a2,a0,0x10
	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;
   114e8:	01c313b3          	sll	t2,t1,t3

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   114ec:	02e87833          	remu	a6,a6,a4
   114f0:	03df06b3          	mul	a3,t5,t4
   114f4:	01081813          	slli	a6,a6,0x10
   114f8:	01066633          	or	a2,a2,a6
   114fc:	00d67e63          	bleu	a3,a2,11518 <__divdi3+0x418>
   11500:	00560633          	add	a2,a2,t0
   11504:	fffe8793          	addi	a5,t4,-1
   11508:	0a566063          	bltu	a2,t0,115a8 <__divdi3+0x4a8>
   1150c:	08d67e63          	bleu	a3,a2,115a8 <__divdi3+0x4a8>
   11510:	ffee8e93          	addi	t4,t4,-2
   11514:	00560633          	add	a2,a2,t0
   11518:	40d60633          	sub	a2,a2,a3
   1151c:	02e655b3          	divu	a1,a2,a4
   11520:	01051513          	slli	a0,a0,0x10
   11524:	01055513          	srli	a0,a0,0x10
   11528:	02e67633          	remu	a2,a2,a4
   1152c:	02bf07b3          	mul	a5,t5,a1
   11530:	01061613          	slli	a2,a2,0x10
   11534:	00c566b3          	or	a3,a0,a2
   11538:	00f6fe63          	bleu	a5,a3,11554 <__divdi3+0x454>
   1153c:	005686b3          	add	a3,a3,t0
   11540:	fff58613          	addi	a2,a1,-1
   11544:	0456ea63          	bltu	a3,t0,11598 <__divdi3+0x498>
   11548:	04f6f863          	bleu	a5,a3,11598 <__divdi3+0x498>
   1154c:	ffe58593          	addi	a1,a1,-2
   11550:	005686b3          	add	a3,a3,t0
   11554:	010e9e93          	slli	t4,t4,0x10
   11558:	40f686b3          	sub	a3,a3,a5
   1155c:	00bee5b3          	or	a1,t4,a1
   11560:	000f0813          	mv	a6,t5
   11564:	00070613          	mv	a2,a4
   11568:	d85ff06f          	j	112ec <__divdi3+0x1ec>
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   1156c:	000107b7          	lui	a5,0x10
   11570:	fff78793          	addi	a5,a5,-1 # ffff <_reset+0xfdff>
   11574:	00f6f6b3          	and	a3,a3,a5
   11578:	01069693          	slli	a3,a3,0x10
   1157c:	00fe77b3          	and	a5,t3,a5
   11580:	00531333          	sll	t1,t1,t0
   11584:	00f687b3          	add	a5,a3,a5
   11588:	f2f378e3          	bleu	a5,t1,114b8 <__divdi3+0x3b8>
   1158c:	fff50513          	addi	a0,a0,-1
		{
		  q0--;
   11590:	00000593          	li	a1,0
   11594:	c71ff06f          	j	11204 <__divdi3+0x104>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11598:	00060593          	mv	a1,a2
   1159c:	fb9ff06f          	j	11554 <__divdi3+0x454>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   115a0:	00070813          	mv	a6,a4
   115a4:	ebdff06f          	j	11460 <__divdi3+0x360>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   115a8:	00078e93          	mv	t4,a5
   115ac:	f6dff06f          	j	11518 <__divdi3+0x418>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   115b0:	00058e13          	mv	t3,a1
   115b4:	e71ff06f          	j	11424 <__divdi3+0x324>
	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
	      n0 = n0 << bm;
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   115b8:	ffe50513          	addi	a0,a0,-2
   115bc:	005585b3          	add	a1,a1,t0
   115c0:	bfdff06f          	j	111bc <__divdi3+0xbc>
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   115c4:	ffe50513          	addi	a0,a0,-2
   115c8:	005787b3          	add	a5,a5,t0
   115cc:	d51ff06f          	j	1131c <__divdi3+0x21c>

000115d0 <__moddi3>:

#ifdef L_moddi3
DWtype
__moddi3 (DWtype u, DWtype v)
{
  Wtype c = 0;
   115d0:	00000813          	li	a6,0
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
   115d4:	1605c863          	bltz	a1,11744 <__moddi3+0x174>
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
   115d8:	1806c263          	bltz	a3,1175c <__moddi3+0x18c>
  DWunion rr;
  UWtype d0, d1, n0, n1, n2;
  UWtype q0, q1;
  UWtype b, bm;

  d0 = dd.s.low;
   115dc:	00060893          	mv	a7,a2
  d1 = dd.s.high;
  n0 = nn.s.low;
   115e0:	00050313          	mv	t1,a0
  n1 = nn.s.high;
   115e4:	00058393          	mv	t2,a1
	}
    }

#else /* UDIV_NEEDS_NORMALIZATION */

  if (d1 == 0)
   115e8:	0e069663          	bnez	a3,116d4 <__moddi3+0x104>
    {
      if (d0 > n1)
   115ec:	18c5f263          	bleu	a2,a1,11770 <__moddi3+0x1a0>
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   115f0:	000107b7          	lui	a5,0x10
   115f4:	24f66063          	bltu	a2,a5,11834 <__moddi3+0x264>
   115f8:	010002b7          	lui	t0,0x1000
   115fc:	005632b3          	sltu	t0,a2,t0
   11600:	0012c293          	xori	t0,t0,1
   11604:	405002b3          	neg	t0,t0
   11608:	0082f293          	andi	t0,t0,8
   1160c:	01028293          	addi	t0,t0,16 # 1000010 <_gp+0xfe9f70>
   11610:	000147b7          	lui	a5,0x14
   11614:	00565733          	srl	a4,a2,t0
   11618:	47c78793          	addi	a5,a5,1148 # 1447c <__clz_tab>
   1161c:	00f707b3          	add	a5,a4,a5
   11620:	0007c783          	lbu	a5,0(a5)
   11624:	005787b3          	add	a5,a5,t0
   11628:	02000293          	li	t0,32
   1162c:	40f282b3          	sub	t0,t0,a5

	  if (bm != 0)
   11630:	00028c63          	beqz	t0,11648 <__moddi3+0x78>
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   11634:	005595b3          	sll	a1,a1,t0
   11638:	00f557b3          	srl	a5,a0,a5
	  if (bm != 0)
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
   1163c:	005618b3          	sll	a7,a2,t0
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   11640:	00b7e3b3          	or	t2,a5,a1
	      n0 = n0 << bm;
   11644:	00551333          	sll	t1,a0,t0
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11648:	0108de13          	srli	t3,a7,0x10
   1164c:	03c3d633          	divu	a2,t2,t3
   11650:	01089693          	slli	a3,a7,0x10
   11654:	0106d693          	srli	a3,a3,0x10
   11658:	01035713          	srli	a4,t1,0x10
   1165c:	03c3f5b3          	remu	a1,t2,t3
   11660:	02c68633          	mul	a2,a3,a2
   11664:	01059593          	slli	a1,a1,0x10
   11668:	00b76733          	or	a4,a4,a1
   1166c:	00c77863          	bleu	a2,a4,1167c <__moddi3+0xac>
   11670:	01170733          	add	a4,a4,a7
   11674:	01176463          	bltu	a4,a7,1167c <__moddi3+0xac>
   11678:	3cc76863          	bltu	a4,a2,11a48 <__moddi3+0x478>
   1167c:	40c70733          	sub	a4,a4,a2
   11680:	03c757b3          	divu	a5,a4,t3
   11684:	01031313          	slli	t1,t1,0x10
   11688:	01035313          	srli	t1,t1,0x10
   1168c:	03c77733          	remu	a4,a4,t3
   11690:	02f68533          	mul	a0,a3,a5
   11694:	01071713          	slli	a4,a4,0x10
   11698:	00e367b3          	or	a5,t1,a4
   1169c:	00a7fa63          	bleu	a0,a5,116b0 <__moddi3+0xe0>
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   116a0:	011787b3          	add	a5,a5,a7
   116a4:	0117e663          	bltu	a5,a7,116b0 <__moddi3+0xe0>
   116a8:	00a7f463          	bleu	a0,a5,116b0 <__moddi3+0xe0>
   116ac:	011787b3          	add	a5,a5,a7
   116b0:	40a787b3          	sub	a5,a5,a0
	  /* Remainder in n0 >> bm.  */
	}

      if (rp != 0)
	{
	  rr.s.low = n0 >> bm;
   116b4:	0057d533          	srl	a0,a5,t0
	  rr.s.high = 0;
	  *rp = rr.ll;
   116b8:	00000593          	li	a1,0
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    vv.ll = -vv.ll;

  (void) __udivmoddi4 (uu.ll, vv.ll, (UDWtype*)&w);
  if (c)
   116bc:	00080a63          	beqz	a6,116d0 <__moddi3+0x100>
    w = -w;
   116c0:	40a00533          	neg	a0,a0
   116c4:	00a037b3          	snez	a5,a0
   116c8:	40b005b3          	neg	a1,a1
   116cc:	40f585b3          	sub	a1,a1,a5

  return w;
}
   116d0:	00008067          	ret
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
   116d4:	fed5e4e3          	bltu	a1,a3,116bc <__moddi3+0xec>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   116d8:	000107b7          	lui	a5,0x10
   116dc:	16f6e463          	bltu	a3,a5,11844 <__moddi3+0x274>
   116e0:	010008b7          	lui	a7,0x1000
   116e4:	0116b8b3          	sltu	a7,a3,a7
   116e8:	0018c893          	xori	a7,a7,1
   116ec:	411008b3          	neg	a7,a7
   116f0:	0088f893          	andi	a7,a7,8
   116f4:	01088893          	addi	a7,a7,16 # 1000010 <_gp+0xfe9f70>
   116f8:	000147b7          	lui	a5,0x14
   116fc:	0116d733          	srl	a4,a3,a7
   11700:	47c78793          	addi	a5,a5,1148 # 1447c <__clz_tab>
   11704:	00f707b3          	add	a5,a4,a5
   11708:	0007ce83          	lbu	t4,0(a5)
   1170c:	02000e13          	li	t3,32
   11710:	011e8eb3          	add	t4,t4,a7
   11714:	41de0e33          	sub	t3,t3,t4
	  if (bm == 0)
   11718:	1c0e1863          	bnez	t3,118e8 <__moddi3+0x318>

		 This special case is necessary, not an optimization.  */

	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
   1171c:	00b6e663          	bltu	a3,a1,11728 <__moddi3+0x158>
   11720:	00050793          	mv	a5,a0
   11724:	00c56a63          	bltu	a0,a2,11738 <__moddi3+0x168>
		{
		  q0 = 1;
		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
   11728:	40c507b3          	sub	a5,a0,a2
   1172c:	40d585b3          	sub	a1,a1,a3
   11730:	00f53533          	sltu	a0,a0,a5
   11734:	40a583b3          	sub	t2,a1,a0

	      if (rp != 0)
		{
		  rr.s.low = n0;
		  rr.s.high = n1;
		  *rp = rr.ll;
   11738:	00078513          	mv	a0,a5
   1173c:	00038593          	mv	a1,t2
   11740:	f7dff06f          	j	116bc <__moddi3+0xec>
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
   11744:	40a00533          	neg	a0,a0
   11748:	00a037b3          	snez	a5,a0
   1174c:	40b00733          	neg	a4,a1
   11750:	40f705b3          	sub	a1,a4,a5
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
   11754:	fff00813          	li	a6,-1
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
   11758:	e806d2e3          	bgez	a3,115dc <__moddi3+0xc>
    vv.ll = -vv.ll;
   1175c:	40c00633          	neg	a2,a2
   11760:	00c037b3          	snez	a5,a2
   11764:	40d006b3          	neg	a3,a3
   11768:	40f686b3          	sub	a3,a3,a5
   1176c:	e71ff06f          	j	115dc <__moddi3+0xc>
	}
      else
	{
	  /* qq = NN / 0d */

	  if (d0 == 0)
   11770:	00061663          	bnez	a2,1177c <__moddi3+0x1ac>
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
   11774:	00100893          	li	a7,1
   11778:	02d8d8b3          	divu	a7,a7,a3

	  count_leading_zeros (bm, d0);
   1177c:	000107b7          	lui	a5,0x10
   11780:	0af8e263          	bltu	a7,a5,11824 <__moddi3+0x254>
   11784:	010007b7          	lui	a5,0x1000
   11788:	00f8b7b3          	sltu	a5,a7,a5
   1178c:	0017c793          	xori	a5,a5,1
   11790:	40f007b3          	neg	a5,a5
   11794:	0087f793          	andi	a5,a5,8
   11798:	01078793          	addi	a5,a5,16 # 1000010 <_gp+0xfe9f70>
   1179c:	00014737          	lui	a4,0x14
   117a0:	00f8d6b3          	srl	a3,a7,a5
   117a4:	47c70713          	addi	a4,a4,1148 # 1447c <__clz_tab>
   117a8:	00e68733          	add	a4,a3,a4
   117ac:	00074703          	lbu	a4,0(a4)
   117b0:	02000293          	li	t0,32
   117b4:	00f707b3          	add	a5,a4,a5
   117b8:	40f282b3          	sub	t0,t0,a5

	  if (bm == 0)
   117bc:	08029c63          	bnez	t0,11854 <__moddi3+0x284>
   117c0:	01089793          	slli	a5,a7,0x10
		 leading quotient digit q1 = 1).

		 This special case is necessary, not an optimization.
		 (Shifts counts of W_TYPE_SIZE are undefined.)  */

	      n1 -= d0;
   117c4:	411585b3          	sub	a1,a1,a7
   117c8:	0108d693          	srli	a3,a7,0x10
   117cc:	0107d793          	srli	a5,a5,0x10
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   117d0:	01035713          	srli	a4,t1,0x10
   117d4:	02d5d633          	divu	a2,a1,a3
   117d8:	02d5f5b3          	remu	a1,a1,a3
   117dc:	02f60633          	mul	a2,a2,a5
   117e0:	01059593          	slli	a1,a1,0x10
   117e4:	00b76733          	or	a4,a4,a1
   117e8:	00c77a63          	bleu	a2,a4,117fc <__moddi3+0x22c>
   117ec:	01170733          	add	a4,a4,a7
   117f0:	01176663          	bltu	a4,a7,117fc <__moddi3+0x22c>
   117f4:	00c77463          	bleu	a2,a4,117fc <__moddi3+0x22c>
   117f8:	01170733          	add	a4,a4,a7
   117fc:	40c70733          	sub	a4,a4,a2
   11800:	02d75633          	divu	a2,a4,a3
   11804:	01031313          	slli	t1,t1,0x10
   11808:	01035313          	srli	t1,t1,0x10
   1180c:	02d77733          	remu	a4,a4,a3
   11810:	02f60533          	mul	a0,a2,a5
   11814:	01071713          	slli	a4,a4,0x10
   11818:	00e367b3          	or	a5,t1,a4
   1181c:	e8a7fae3          	bleu	a0,a5,116b0 <__moddi3+0xe0>
   11820:	e81ff06f          	j	116a0 <__moddi3+0xd0>
	  /* qq = NN / 0d */

	  if (d0 == 0)
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */

	  count_leading_zeros (bm, d0);
   11824:	0ff00793          	li	a5,255
   11828:	0117b7b3          	sltu	a5,a5,a7
   1182c:	00379793          	slli	a5,a5,0x3
   11830:	f6dff06f          	j	1179c <__moddi3+0x1cc>
    {
      if (d0 > n1)
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   11834:	0ff00293          	li	t0,255
   11838:	00c2b2b3          	sltu	t0,t0,a2
   1183c:	00329293          	slli	t0,t0,0x3
   11840:	dd1ff06f          	j	11610 <__moddi3+0x40>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   11844:	0ff00893          	li	a7,255
   11848:	00d8b8b3          	sltu	a7,a7,a3
   1184c:	00389893          	slli	a7,a7,0x3
   11850:	ea9ff06f          	j	116f8 <__moddi3+0x128>
	    {
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
   11854:	005898b3          	sll	a7,a7,t0
	      n2 = n1 >> b;
   11858:	00f5de33          	srl	t3,a1,a5
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   1185c:	0108d713          	srli	a4,a7,0x10
   11860:	02ee5633          	divu	a2,t3,a4
   11864:	01089393          	slli	t2,a7,0x10

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   11868:	005595b3          	sll	a1,a1,t0
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   1186c:	0103d393          	srli	t2,t2,0x10

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   11870:	00f557b3          	srl	a5,a0,a5
   11874:	00b7e7b3          	or	a5,a5,a1
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11878:	0107d693          	srli	a3,a5,0x10
	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;
   1187c:	00551333          	sll	t1,a0,t0

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   11880:	02ee7e33          	remu	t3,t3,a4
   11884:	02c385b3          	mul	a1,t2,a2
   11888:	010e1e13          	slli	t3,t3,0x10
   1188c:	01c6e633          	or	a2,a3,t3
   11890:	00b67a63          	bleu	a1,a2,118a4 <__moddi3+0x2d4>
   11894:	01160633          	add	a2,a2,a7
   11898:	01166663          	bltu	a2,a7,118a4 <__moddi3+0x2d4>
   1189c:	00b67463          	bleu	a1,a2,118a4 <__moddi3+0x2d4>
   118a0:	01160633          	add	a2,a2,a7
   118a4:	40b60633          	sub	a2,a2,a1
   118a8:	02e655b3          	divu	a1,a2,a4
   118ac:	01079793          	slli	a5,a5,0x10
   118b0:	0107d793          	srli	a5,a5,0x10
   118b4:	02e67633          	remu	a2,a2,a4
   118b8:	02b385b3          	mul	a1,t2,a1
   118bc:	01061613          	slli	a2,a2,0x10
   118c0:	00c7e6b3          	or	a3,a5,a2
   118c4:	00b6fa63          	bleu	a1,a3,118d8 <__moddi3+0x308>
   118c8:	011686b3          	add	a3,a3,a7
   118cc:	0116e663          	bltu	a3,a7,118d8 <__moddi3+0x308>
   118d0:	00b6f463          	bleu	a1,a3,118d8 <__moddi3+0x308>
   118d4:	011686b3          	add	a3,a3,a7
   118d8:	40b685b3          	sub	a1,a3,a1
   118dc:	00038793          	mv	a5,t2
   118e0:	00070693          	mv	a3,a4
   118e4:	eedff06f          	j	117d0 <__moddi3+0x200>
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
   118e8:	01c696b3          	sll	a3,a3,t3
   118ec:	01d653b3          	srl	t2,a2,t4
   118f0:	0076e3b3          	or	t2,a3,t2
	      d0 = d0 << bm;
	      n2 = n1 >> b;
   118f4:	01d5d333          	srl	t1,a1,t4
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   118f8:	0103d893          	srli	a7,t2,0x10
   118fc:	031357b3          	divu	a5,t1,a7
   11900:	01039713          	slli	a4,t2,0x10
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   11904:	01c596b3          	sll	a3,a1,t3
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11908:	01075713          	srli	a4,a4,0x10
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   1190c:	01d555b3          	srl	a1,a0,t4
   11910:	00d5e6b3          	or	a3,a1,a3
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11914:	0106d293          	srli	t0,a3,0x10
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
   11918:	01c61633          	sll	a2,a2,t3
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;
   1191c:	01c51533          	sll	a0,a0,t3

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11920:	03137333          	remu	t1,t1,a7
   11924:	02f705b3          	mul	a1,a4,a5
   11928:	01031313          	slli	t1,t1,0x10
   1192c:	0062e2b3          	or	t0,t0,t1
   11930:	00b2fe63          	bleu	a1,t0,1194c <__moddi3+0x37c>
   11934:	007282b3          	add	t0,t0,t2
   11938:	fff78313          	addi	t1,a5,-1
   1193c:	1072e263          	bltu	t0,t2,11a40 <__moddi3+0x470>
   11940:	10b2f063          	bleu	a1,t0,11a40 <__moddi3+0x470>
   11944:	ffe78793          	addi	a5,a5,-2
   11948:	007282b3          	add	t0,t0,t2
   1194c:	40b282b3          	sub	t0,t0,a1
   11950:	0312d333          	divu	t1,t0,a7
   11954:	01069693          	slli	a3,a3,0x10
   11958:	0106d693          	srli	a3,a3,0x10
   1195c:	0312f2b3          	remu	t0,t0,a7
   11960:	02670733          	mul	a4,a4,t1
   11964:	01029893          	slli	a7,t0,0x10
   11968:	0116e8b3          	or	a7,a3,a7
   1196c:	00e8fe63          	bleu	a4,a7,11988 <__moddi3+0x3b8>
   11970:	007888b3          	add	a7,a7,t2
   11974:	fff30693          	addi	a3,t1,-1
   11978:	0c78e063          	bltu	a7,t2,11a38 <__moddi3+0x468>
   1197c:	0ae8fe63          	bleu	a4,a7,11a38 <__moddi3+0x468>
   11980:	ffe30313          	addi	t1,t1,-2
   11984:	007888b3          	add	a7,a7,t2
   11988:	01079793          	slli	a5,a5,0x10
	      umul_ppmm (m1, m0, q0, d0);
   1198c:	00010fb7          	lui	t6,0x10
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11990:	0067e333          	or	t1,a5,t1
	      umul_ppmm (m1, m0, q0, d0);
   11994:	ffff8793          	addi	a5,t6,-1 # ffff <_reset+0xfdff>
   11998:	00f376b3          	and	a3,t1,a5
   1199c:	01065593          	srli	a1,a2,0x10
   119a0:	01035313          	srli	t1,t1,0x10
   119a4:	00f677b3          	and	a5,a2,a5
   119a8:	02f68f33          	mul	t5,a3,a5
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   119ac:	40e88733          	sub	a4,a7,a4
	      umul_ppmm (m1, m0, q0, d0);
   119b0:	02f307b3          	mul	a5,t1,a5
   119b4:	010f5293          	srli	t0,t5,0x10
   119b8:	02b686b3          	mul	a3,a3,a1
   119bc:	00f686b3          	add	a3,a3,a5
   119c0:	00d288b3          	add	a7,t0,a3
   119c4:	02b30333          	mul	t1,t1,a1
   119c8:	00f8f463          	bleu	a5,a7,119d0 <__moddi3+0x400>
   119cc:	01f30333          	add	t1,t1,t6
   119d0:	000106b7          	lui	a3,0x10
   119d4:	fff68793          	addi	a5,a3,-1 # ffff <_reset+0xfdff>
   119d8:	0108d693          	srli	a3,a7,0x10
   119dc:	00f8f8b3          	and	a7,a7,a5
   119e0:	01089293          	slli	t0,a7,0x10
   119e4:	00668333          	add	t1,a3,t1
   119e8:	00ff78b3          	and	a7,t5,a5
   119ec:	011288b3          	add	a7,t0,a7

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   119f0:	00676a63          	bltu	a4,t1,11a04 <__moddi3+0x434>
   119f4:	04670e63          	beq	a4,t1,11a50 <__moddi3+0x480>
   119f8:	40670733          	sub	a4,a4,t1
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);
   119fc:	00088793          	mv	a5,a7
   11a00:	0180006f          	j	11a18 <__moddi3+0x448>

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
		{
		  q0--;
		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
   11a04:	40c887b3          	sub	a5,a7,a2
   11a08:	40730333          	sub	t1,t1,t2
   11a0c:	00f8b8b3          	sltu	a7,a7,a5
   11a10:	411308b3          	sub	a7,t1,a7
   11a14:	41170733          	sub	a4,a4,a7
	      q1 = 0;

	      /* Remainder in (n1n0 - m1m0) >> bm.  */
	      if (rp != 0)
		{
		  sub_ddmmss (n1, n0, n1, n0, m1, m0);
   11a18:	40f507b3          	sub	a5,a0,a5
   11a1c:	00f53533          	sltu	a0,a0,a5
   11a20:	40a70733          	sub	a4,a4,a0
		  rr.s.low = (n1 << b) | (n0 >> bm);
   11a24:	01d71533          	sll	a0,a4,t4
   11a28:	01c7d7b3          	srl	a5,a5,t3
		  rr.s.high = n1 >> bm;
		  *rp = rr.ll;
   11a2c:	00f56533          	or	a0,a0,a5
   11a30:	01c755b3          	srl	a1,a4,t3
   11a34:	c89ff06f          	j	116bc <__moddi3+0xec>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   11a38:	00068313          	mv	t1,a3
   11a3c:	f4dff06f          	j	11988 <__moddi3+0x3b8>
   11a40:	00030793          	mv	a5,t1
   11a44:	f09ff06f          	j	1194c <__moddi3+0x37c>
	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
	      n0 = n0 << bm;
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   11a48:	01170733          	add	a4,a4,a7
   11a4c:	c31ff06f          	j	1167c <__moddi3+0xac>
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   11a50:	fb156ae3          	bltu	a0,a7,11a04 <__moddi3+0x434>
   11a54:	00088793          	mv	a5,a7
   11a58:	00000713          	li	a4,0
   11a5c:	fbdff06f          	j	11a18 <__moddi3+0x448>

00011a60 <atexit>:
int
_DEFUN (atexit,
	(fn),
	_VOID _EXFNPTR(fn, (_VOID)))
{
  return __register_exitproc (__et_atexit, fn, NULL, NULL);
   11a60:	00050593          	mv	a1,a0
   11a64:	00000693          	li	a3,0
   11a68:	00000613          	li	a2,0
   11a6c:	00000513          	li	a0,0
   11a70:	2500006f          	j	11cc0 <__register_exitproc>

00011a74 <__libc_fini_array>:
extern void _fini (void);

/* Run all the cleanup routines.  */
void
__libc_fini_array (void)
{
   11a74:	ff010113          	addi	sp,sp,-16
   11a78:	00812423          	sw	s0,8(sp)
   11a7c:	00912223          	sw	s1,4(sp)
  size_t count;
  size_t i;
  
  count = __fini_array_end - __fini_array_start;
   11a80:	00014437          	lui	s0,0x14
   11a84:	000144b7          	lui	s1,0x14
   11a88:	58c48493          	addi	s1,s1,1420 # 1458c <__init_array_end>
   11a8c:	59040413          	addi	s0,s0,1424 # 14590 <__fini_array_end>
   11a90:	40940433          	sub	s0,s0,s1
   11a94:	40245413          	srai	s0,s0,0x2
   11a98:	00241793          	slli	a5,s0,0x2
   11a9c:	ffc78793          	addi	a5,a5,-4
extern void _fini (void);

/* Run all the cleanup routines.  */
void
__libc_fini_array (void)
{
   11aa0:	00112623          	sw	ra,12(sp)
   11aa4:	009784b3          	add	s1,a5,s1
  size_t count;
  size_t i;
  
  count = __fini_array_end - __fini_array_start;
  for (i = count; i > 0; i--)
   11aa8:	00040c63          	beqz	s0,11ac0 <__libc_fini_array+0x4c>
    __fini_array_start[i-1] ();
   11aac:	0004a783          	lw	a5,0(s1)
   11ab0:	fff40413          	addi	s0,s0,-1
   11ab4:	ffc48493          	addi	s1,s1,-4
   11ab8:	000780e7          	jalr	a5
{
  size_t count;
  size_t i;
  
  count = __fini_array_end - __fini_array_start;
  for (i = count; i > 0; i--)
   11abc:	fe0418e3          	bnez	s0,11aac <__libc_fini_array+0x38>
    __fini_array_start[i-1] ();

  _fini ();
}
   11ac0:	00c12083          	lw	ra,12(sp)
   11ac4:	00812403          	lw	s0,8(sp)
   11ac8:	00412483          	lw	s1,4(sp)
   11acc:	01010113          	addi	sp,sp,16
  
  count = __fini_array_end - __fini_array_start;
  for (i = count; i > 0; i--)
    __fini_array_start[i-1] ();

  _fini ();
   11ad0:	d78fe06f          	j	10048 <_fini>

00011ad4 <__libc_init_array>:
extern void _init (void);

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
   11ad4:	ff010113          	addi	sp,sp,-16
   11ad8:	00812423          	sw	s0,8(sp)
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
   11adc:	000147b7          	lui	a5,0x14
   11ae0:	00014437          	lui	s0,0x14
extern void _init (void);

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
   11ae4:	01212023          	sw	s2,0(sp)
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
   11ae8:	58478793          	addi	a5,a5,1412 # 14584 <_etext>
   11aec:	58440913          	addi	s2,s0,1412 # 14584 <_etext>
   11af0:	41278933          	sub	s2,a5,s2
   11af4:	40295913          	srai	s2,s2,0x2
extern void _init (void);

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
   11af8:	00912223          	sw	s1,4(sp)
   11afc:	00112623          	sw	ra,12(sp)
   11b00:	58440413          	addi	s0,s0,1412
   11b04:	00000493          	li	s1,0
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
   11b08:	00090c63          	beqz	s2,11b20 <__libc_init_array+0x4c>
    __preinit_array_start[i] ();
   11b0c:	00042783          	lw	a5,0(s0)
{
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
   11b10:	00148493          	addi	s1,s1,1
   11b14:	00440413          	addi	s0,s0,4
    __preinit_array_start[i] ();
   11b18:	000780e7          	jalr	a5
{
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
   11b1c:	fe9918e3          	bne	s2,s1,11b0c <__libc_init_array+0x38>
    __preinit_array_start[i] ();

  _init ();

  count = __init_array_end - __init_array_start;
   11b20:	00014437          	lui	s0,0x14

  count = __preinit_array_end - __preinit_array_start;
  for (i = 0; i < count; i++)
    __preinit_array_start[i] ();

  _init ();
   11b24:	d24fe0ef          	jal	10048 <_fini>

  count = __init_array_end - __init_array_start;
   11b28:	000147b7          	lui	a5,0x14
   11b2c:	58440913          	addi	s2,s0,1412 # 14584 <_etext>
   11b30:	58c78793          	addi	a5,a5,1420 # 1458c <__init_array_end>
   11b34:	41278933          	sub	s2,a5,s2
   11b38:	40295913          	srai	s2,s2,0x2
   11b3c:	58440413          	addi	s0,s0,1412
  for (i = 0; i < count; i++)
   11b40:	00000493          	li	s1,0
   11b44:	00090c63          	beqz	s2,11b5c <__libc_init_array+0x88>
    __init_array_start[i] ();
   11b48:	00042783          	lw	a5,0(s0)
    __preinit_array_start[i] ();

  _init ();

  count = __init_array_end - __init_array_start;
  for (i = 0; i < count; i++)
   11b4c:	00148493          	addi	s1,s1,1
   11b50:	00440413          	addi	s0,s0,4
    __init_array_start[i] ();
   11b54:	000780e7          	jalr	a5
    __preinit_array_start[i] ();

  _init ();

  count = __init_array_end - __init_array_start;
  for (i = 0; i < count; i++)
   11b58:	fe9918e3          	bne	s2,s1,11b48 <__libc_init_array+0x74>
    __init_array_start[i] ();
}
   11b5c:	00c12083          	lw	ra,12(sp)
   11b60:	00812403          	lw	s0,8(sp)
   11b64:	00412483          	lw	s1,4(sp)
   11b68:	00012903          	lw	s2,0(sp)
   11b6c:	01010113          	addi	sp,sp,16
   11b70:	00008067          	ret

00011b74 <_puts_r>:

int
_DEFUN(_puts_r, (ptr, s),
       struct _reent *ptr _AND
       _CONST char * s)
{
   11b74:	fd010113          	addi	sp,sp,-48
   11b78:	02812423          	sw	s0,40(sp)
   11b7c:	00050413          	mv	s0,a0
#ifdef _FVWRITE_IN_STREAMIO
  int result;
  size_t c = strlen (s);
   11b80:	00058513          	mv	a0,a1

int
_DEFUN(_puts_r, (ptr, s),
       struct _reent *ptr _AND
       _CONST char * s)
{
   11b84:	02912223          	sw	s1,36(sp)
   11b88:	02112623          	sw	ra,44(sp)
   11b8c:	00058493          	mv	s1,a1
#ifdef _FVWRITE_IN_STREAMIO
  int result;
  size_t c = strlen (s);
   11b90:	0a0000ef          	jal	11c30 <strlen>
  uio.uio_resid = c + 1;
  uio.uio_iov = &iov[0];
  uio.uio_iovcnt = 2;

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
   11b94:	00842583          	lw	a1,8(s0)
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
  iov[0].iov_len = c;
  iov[1].iov_base = "\n";
   11b98:	00014737          	lui	a4,0x14
   11b9c:	57c70713          	addi	a4,a4,1404 # 1457c <__clz_tab+0x100>
  uio.uio_iovcnt = 2;

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
   11ba0:	00c59683          	lh	a3,12(a1)
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
  iov[0].iov_len = c;
  iov[1].iov_base = "\n";
   11ba4:	00e12c23          	sw	a4,24(sp)
  iov[1].iov_len = 1;
   11ba8:	00100713          	li	a4,1
   11bac:	00e12e23          	sw	a4,28(sp)
  uio.uio_resid = c + 1;
  uio.uio_iov = &iov[0];
   11bb0:	01010713          	addi	a4,sp,16

  iov[0].iov_base = s;
  iov[0].iov_len = c;
  iov[1].iov_base = "\n";
  iov[1].iov_len = 1;
  uio.uio_resid = c + 1;
   11bb4:	00150613          	addi	a2,a0,1
  uio.uio_iov = &iov[0];
   11bb8:	00e12223          	sw	a4,4(sp)
  uio.uio_iovcnt = 2;

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
   11bbc:	01269793          	slli	a5,a3,0x12
  iov[0].iov_len = c;
  iov[1].iov_base = "\n";
  iov[1].iov_len = 1;
  uio.uio_resid = c + 1;
  uio.uio_iov = &iov[0];
  uio.uio_iovcnt = 2;
   11bc0:	00200713          	li	a4,2
  size_t c = strlen (s);
  struct __suio uio;
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
   11bc4:	00912823          	sw	s1,16(sp)
  iov[0].iov_len = c;
   11bc8:	00a12a23          	sw	a0,20(sp)
  iov[1].iov_base = "\n";
  iov[1].iov_len = 1;
  uio.uio_resid = c + 1;
   11bcc:	00c12623          	sw	a2,12(sp)
  uio.uio_iov = &iov[0];
  uio.uio_iovcnt = 2;
   11bd0:	00e12423          	sw	a4,8(sp)

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
   11bd4:	0207c263          	bltz	a5,11bf8 <_puts_r+0x84>
  uio.uio_iov = &iov[0];
  uio.uio_iovcnt = 2;

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  _newlib_flockfile_start (fp);
   11bd8:	0685a783          	lw	a5,104(a1)
  ORIENT (fp, -1);
   11bdc:	ffffe737          	lui	a4,0xffffe
   11be0:	00002637          	lui	a2,0x2
   11be4:	fff70713          	addi	a4,a4,-1 # ffffdfff <_gp+0xfffe7f5f>
   11be8:	00c6e6b3          	or	a3,a3,a2
   11bec:	00e7f733          	and	a4,a5,a4
   11bf0:	00d59623          	sh	a3,12(a1)
   11bf4:	06e5a423          	sw	a4,104(a1)
  result = (__sfvwrite_r (ptr, fp, &uio) ? EOF : '\n');
   11bf8:	00410613          	addi	a2,sp,4
   11bfc:	00040513          	mv	a0,s0
   11c00:	1b4000ef          	jal	11db4 <__sfvwrite_r>

err:
  _newlib_flockfile_end (fp);
  return result;
#endif
}
   11c04:	02c12083          	lw	ra,44(sp)

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
  result = (__sfvwrite_r (ptr, fp, &uio) ? EOF : '\n');
   11c08:	00a03533          	snez	a0,a0
   11c0c:	40a00533          	neg	a0,a0

err:
  _newlib_flockfile_end (fp);
  return result;
#endif
}
   11c10:	00a56513          	ori	a0,a0,10
   11c14:	02812403          	lw	s0,40(sp)
   11c18:	02412483          	lw	s1,36(sp)
   11c1c:	03010113          	addi	sp,sp,48
   11c20:	00008067          	ret

00011c24 <puts>:

int
_DEFUN(puts, (s),
       char _CONST * s)
{
  return _puts_r (_REENT, s);
   11c24:	00050593          	mv	a1,a0
   11c28:	8101a503          	lw	a0,-2032(gp) # 158b0 <_impure_ptr>
   11c2c:	f49ff06f          	j	11b74 <_puts_r>

00011c30 <strlen>:
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  while (*str++)
    ;
  return str - start - 1;
#else
  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
   11c30:	00357793          	andi	a5,a0,3
   11c34:	00050593          	mv	a1,a0
   11c38:	04079a63          	bnez	a5,11c8c <strlen+0x5c>
    if (!ch)
      return str - start - 1;
  } while ((uintptr_t)str & (sizeof(long)-1));

  unsigned long* ls = (unsigned long*)str;
  while (!__libc_detect_null(*ls++))
   11c3c:	7f7f86b7          	lui	a3,0x7f7f8
   11c40:	f7f68693          	addi	a3,a3,-129 # 7f7f7f7f <_gp+0x7f7e1edf>
   11c44:	fff00613          	li	a2,-1
   11c48:	00450513          	addi	a0,a0,4
   11c4c:	ffc52783          	lw	a5,-4(a0)
   11c50:	00d7f733          	and	a4,a5,a3
   11c54:	00d70733          	add	a4,a4,a3
   11c58:	00d7e7b3          	or	a5,a5,a3
   11c5c:	00f767b3          	or	a5,a4,a5
   11c60:	fec784e3          	beq	a5,a2,11c48 <strlen+0x18>

  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
   11c64:	ffc54703          	lbu	a4,-4(a0)
  while (!__libc_detect_null(*ls++))
    ;
  asm volatile ("" : "+r"(ls)); /* prevent "optimization" */

  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);
   11c68:	40b507b3          	sub	a5,a0,a1

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
   11c6c:	ffd54683          	lbu	a3,-3(a0)
   11c70:	ffe54603          	lbu	a2,-2(a0)
  if (c0 == 0)            return ret + 0 - sl;
   11c74:	02070e63          	beqz	a4,11cb0 <strlen+0x80>
  if (c1 == 0)            return ret + 1 - sl;
   11c78:	02068863          	beqz	a3,11ca8 <strlen+0x78>
  if (c2 == 0)            return ret + 2 - sl;
  if (sl == 4 || c3 == 0) return ret + 3 - sl;
   11c7c:	fff78513          	addi	a0,a5,-1
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
  if (c1 == 0)            return ret + 1 - sl;
  if (c2 == 0)            return ret + 2 - sl;
   11c80:	02060c63          	beqz	a2,11cb8 <strlen+0x88>
  if (c0 == 0)            return ret + 4 - sl;
  if (c1 == 0)            return ret + 5 - sl;
  if (c2 == 0)            return ret + 6 - sl;
                          return ret + 7 - sl;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   11c84:	00008067          	ret
  {
    char ch = *str;
    str++;
    if (!ch)
      return str - start - 1;
  } while ((uintptr_t)str & (sizeof(long)-1));
   11c88:	fa070ae3          	beqz	a4,11c3c <strlen+0xc>
    ;
  return str - start - 1;
#else
  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
  {
    char ch = *str;
   11c8c:	00054783          	lbu	a5,0(a0)
    str++;
   11c90:	00150513          	addi	a0,a0,1
    if (!ch)
      return str - start - 1;
  } while ((uintptr_t)str & (sizeof(long)-1));
   11c94:	00357713          	andi	a4,a0,3
#else
  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
  {
    char ch = *str;
    str++;
    if (!ch)
   11c98:	fe0798e3          	bnez	a5,11c88 <strlen+0x58>
      return str - start - 1;
   11c9c:	40b50533          	sub	a0,a0,a1
   11ca0:	fff50513          	addi	a0,a0,-1
   11ca4:	00008067          	ret
  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
  if (c1 == 0)            return ret + 1 - sl;
   11ca8:	ffd78513          	addi	a0,a5,-3
   11cac:	00008067          	ret

  str = (const char*)ls;
  size_t ret = str - start, sl = sizeof(long);

  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
  if (c0 == 0)            return ret + 0 - sl;
   11cb0:	ffc78513          	addi	a0,a5,-4
   11cb4:	00008067          	ret
  if (c1 == 0)            return ret + 1 - sl;
  if (c2 == 0)            return ret + 2 - sl;
   11cb8:	ffe78513          	addi	a0,a5,-2
  if (c0 == 0)            return ret + 4 - sl;
  if (c1 == 0)            return ret + 5 - sl;
  if (c2 == 0)            return ret + 6 - sl;
                          return ret + 7 - sl;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   11cbc:	00008067          	ret

00011cc0 <__register_exitproc>:
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
   11cc0:	fe010113          	addi	sp,sp,-32
   11cc4:	00812c23          	sw	s0,24(sp)

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
   11cc8:	80c1a403          	lw	s0,-2036(gp) # 158ac <_global_impure_ptr>
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
   11ccc:	00912a23          	sw	s1,20(sp)
   11cd0:	00050493          	mv	s1,a0

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
   11cd4:	14842503          	lw	a0,328(s0)
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
   11cd8:	00112e23          	sw	ra,28(sp)
#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
  if (p == NULL)
   11cdc:	0c050263          	beqz	a0,11da0 <__register_exitproc+0xe0>
    _GLOBAL_ATEXIT = p = _GLOBAL_ATEXIT0;
  if (p->_ind >= _ATEXIT_SIZE)
   11ce0:	00452783          	lw	a5,4(a0)
   11ce4:	01f00713          	li	a4,31
   11ce8:	00178813          	addi	a6,a5,1
   11cec:	04f75863          	ble	a5,a4,11d3c <__register_exitproc+0x7c>
#ifndef _ATEXIT_DYNAMIC_ALLOC
      return -1;
#else
      /* Don't dynamically allocate the atexit array if malloc is not
	 available.  */
      if (!malloc)
   11cf0:	00000793          	li	a5,0
   11cf4:	0a078c63          	beqz	a5,11dac <__register_exitproc+0xec>
	return -1;

      p = (struct _atexit *) malloc (sizeof *p);
   11cf8:	19000513          	li	a0,400
   11cfc:	00b12623          	sw	a1,12(sp)
   11d00:	00c12423          	sw	a2,8(sp)
   11d04:	00d12223          	sw	a3,4(sp)
   11d08:	af8ee0ef          	jal	0 <_reset-0x200>
      if (p == NULL)
   11d0c:	00c12583          	lw	a1,12(sp)
   11d10:	00812603          	lw	a2,8(sp)
   11d14:	00412683          	lw	a3,4(sp)
   11d18:	08050a63          	beqz	a0,11dac <__register_exitproc+0xec>
	  __lock_release_recursive(__atexit_lock);
#endif
	  return -1;
	}
      p->_ind = 0;
      p->_next = _GLOBAL_ATEXIT;
   11d1c:	14842783          	lw	a5,328(s0)
      _GLOBAL_ATEXIT = p;
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
      p->_on_exit_args._is_cxa = 0;
   11d20:	00100813          	li	a6,1
#ifndef __SINGLE_THREAD__
	  __lock_release_recursive(__atexit_lock);
#endif
	  return -1;
	}
      p->_ind = 0;
   11d24:	00052223          	sw	zero,4(a0)
      p->_next = _GLOBAL_ATEXIT;
   11d28:	00f52023          	sw	a5,0(a0)
      _GLOBAL_ATEXIT = p;
   11d2c:	14a42423          	sw	a0,328(s0)
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
      p->_on_exit_args._is_cxa = 0;
   11d30:	00000793          	li	a5,0
	}
      p->_ind = 0;
      p->_next = _GLOBAL_ATEXIT;
      _GLOBAL_ATEXIT = p;
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
   11d34:	18052423          	sw	zero,392(a0)
      p->_on_exit_args._is_cxa = 0;
   11d38:	18052623          	sw	zero,396(a0)
   11d3c:	00279713          	slli	a4,a5,0x2
      p->_on_exit_args_ptr = NULL;
#endif
#endif
    }

  if (type != __et_atexit)
   11d40:	02049463          	bnez	s1,11d68 <__register_exitproc+0xa8>
      args->_fntypes |= (1 << p->_ind);
      args->_dso_handle[p->_ind] = d;
      if (type == __et_cxa)
	args->_is_cxa |= (1 << p->_ind);
    }
  p->_fns[p->_ind++] = fn;
   11d44:	00e50733          	add	a4,a0,a4
   11d48:	01052223          	sw	a6,4(a0)
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif
  return 0;
   11d4c:	00000513          	li	a0,0
      args->_fntypes |= (1 << p->_ind);
      args->_dso_handle[p->_ind] = d;
      if (type == __et_cxa)
	args->_is_cxa |= (1 << p->_ind);
    }
  p->_fns[p->_ind++] = fn;
   11d50:	00b72423          	sw	a1,8(a4)
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif
  return 0;
}
   11d54:	01c12083          	lw	ra,28(sp)
   11d58:	01812403          	lw	s0,24(sp)
   11d5c:	01412483          	lw	s1,20(sp)
   11d60:	02010113          	addi	sp,sp,32
   11d64:	00008067          	ret
   11d68:	00e502b3          	add	t0,a0,a4
	  p->_on_exit_args_ptr = args;
	}
#else
      args = &p->_on_exit_args;
#endif
      args->_fnargs[p->_ind] = arg;
   11d6c:	08c2a423          	sw	a2,136(t0)
      args->_fntypes |= (1 << p->_ind);
   11d70:	18852883          	lw	a7,392(a0)
   11d74:	00100613          	li	a2,1
   11d78:	00f617b3          	sll	a5,a2,a5
   11d7c:	00f8e633          	or	a2,a7,a5
   11d80:	18c52423          	sw	a2,392(a0)
      args->_dso_handle[p->_ind] = d;
   11d84:	10d2a423          	sw	a3,264(t0)
      if (type == __et_cxa)
   11d88:	00200693          	li	a3,2
   11d8c:	fad49ce3          	bne	s1,a3,11d44 <__register_exitproc+0x84>
	args->_is_cxa |= (1 << p->_ind);
   11d90:	18c52683          	lw	a3,396(a0)
   11d94:	00f6e7b3          	or	a5,a3,a5
   11d98:	18f52623          	sw	a5,396(a0)
   11d9c:	fa9ff06f          	j	11d44 <__register_exitproc+0x84>
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
  if (p == NULL)
    _GLOBAL_ATEXIT = p = _GLOBAL_ATEXIT0;
   11da0:	14c40513          	addi	a0,s0,332
   11da4:	14a42423          	sw	a0,328(s0)
   11da8:	f39ff06f          	j	11ce0 <__register_exitproc+0x20>
      return -1;
#else
      /* Don't dynamically allocate the atexit array if malloc is not
	 available.  */
      if (!malloc)
	return -1;
   11dac:	fff00513          	li	a0,-1
   11db0:	fa5ff06f          	j	11d54 <__register_exitproc+0x94>

00011db4 <__sfvwrite_r>:
  register struct __siov *iov;
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
   11db4:	00862783          	lw	a5,8(a2) # 2008 <_reset+0x1e08>
   11db8:	1a078e63          	beqz	a5,11f74 <__sfvwrite_r+0x1c0>
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   11dbc:	00c5d703          	lhu	a4,12(a1)
int
_DEFUN(__sfvwrite_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       register FILE *fp _AND
       register struct __suio *uio)
{
   11dc0:	fd010113          	addi	sp,sp,-48
   11dc4:	02812423          	sw	s0,40(sp)

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   11dc8:	00877793          	andi	a5,a4,8
int
_DEFUN(__sfvwrite_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       register FILE *fp _AND
       register struct __suio *uio)
{
   11dcc:	01412c23          	sw	s4,24(sp)
   11dd0:	01512a23          	sw	s5,20(sp)
   11dd4:	02112623          	sw	ra,44(sp)
   11dd8:	02912223          	sw	s1,36(sp)
   11ddc:	03212023          	sw	s2,32(sp)
   11de0:	01312e23          	sw	s3,28(sp)
   11de4:	01612823          	sw	s6,16(sp)
   11de8:	01712623          	sw	s7,12(sp)
   11dec:	01812423          	sw	s8,8(sp)
   11df0:	01912223          	sw	s9,4(sp)
   11df4:	01a12023          	sw	s10,0(sp)
   11df8:	00058413          	mv	s0,a1
   11dfc:	00050a93          	mv	s5,a0
   11e00:	00060a13          	mv	s4,a2

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   11e04:	0a078463          	beqz	a5,11eac <__sfvwrite_r+0xf8>
   11e08:	0105a783          	lw	a5,16(a1)
   11e0c:	0a078063          	beqz	a5,11eac <__sfvwrite_r+0xf8>
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   11e10:	00277793          	andi	a5,a4,2

  /* make sure we can write */
  if (cantwrite (ptr, fp))
    return EOF;

  iov = uio->uio_iov;
   11e14:	000a2483          	lw	s1,0(s4)
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   11e18:	0a078c63          	beqz	a5,11ed0 <__sfvwrite_r+0x11c>
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
   11e1c:	80000b37          	lui	s6,0x80000
   11e20:	00000993          	li	s3,0
   11e24:	00000913          	li	s2,0
   11e28:	c00b4b13          	xori	s6,s6,-1024
   11e2c:	00098613          	mv	a2,s3
   11e30:	000a8513          	mv	a0,s5
       * Unbuffered: Split buffer in the largest multiple of BUFSIZ < INT_MAX
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
   11e34:	12090863          	beqz	s2,11f64 <__sfvwrite_r+0x1b0>
	  w = fp->_write (ptr, fp->_cookie, p,
   11e38:	00090693          	mv	a3,s2
   11e3c:	012b7463          	bleu	s2,s6,11e44 <__sfvwrite_r+0x90>
   11e40:	000b0693          	mv	a3,s6
   11e44:	02442783          	lw	a5,36(s0)
   11e48:	01c42583          	lw	a1,28(s0)
   11e4c:	000780e7          	jalr	a5
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
	  if (w <= 0)
   11e50:	16a05863          	blez	a0,11fc0 <__sfvwrite_r+0x20c>
	    goto err;
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
   11e54:	008a2783          	lw	a5,8(s4)
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
	  if (w <= 0)
	    goto err;
	  p += w;
   11e58:	00a989b3          	add	s3,s3,a0
	  len -= w;
   11e5c:	40a90933          	sub	s2,s2,a0
	}
      while ((uio->uio_resid -= w) != 0);
   11e60:	40a78533          	sub	a0,a5,a0
   11e64:	00aa2423          	sw	a0,8(s4)
   11e68:	fc0512e3          	bnez	a0,11e2c <__sfvwrite_r+0x78>
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
    return 0;
   11e6c:	00000793          	li	a5,0
  return 0;

err:
  fp->_flags |= __SERR;
  return EOF;
}
   11e70:	02c12083          	lw	ra,44(sp)
   11e74:	00078513          	mv	a0,a5
   11e78:	02812403          	lw	s0,40(sp)
   11e7c:	02412483          	lw	s1,36(sp)
   11e80:	02012903          	lw	s2,32(sp)
   11e84:	01c12983          	lw	s3,28(sp)
   11e88:	01812a03          	lw	s4,24(sp)
   11e8c:	01412a83          	lw	s5,20(sp)
   11e90:	01012b03          	lw	s6,16(sp)
   11e94:	00c12b83          	lw	s7,12(sp)
   11e98:	00812c03          	lw	s8,8(sp)
   11e9c:	00412c83          	lw	s9,4(sp)
   11ea0:	00012d03          	lw	s10,0(sp)
   11ea4:	03010113          	addi	sp,sp,48
   11ea8:	00008067          	ret

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   11eac:	00040593          	mv	a1,s0
   11eb0:	000a8513          	mv	a0,s5
   11eb4:	3b4010ef          	jal	13268 <__swsetup_r>
    return EOF;
   11eb8:	fff00793          	li	a5,-1

  if ((len = uio->uio_resid) == 0)
    return 0;

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   11ebc:	fa051ae3          	bnez	a0,11e70 <__sfvwrite_r+0xbc>
   11ec0:	00c45703          	lhu	a4,12(s0)
    return EOF;

  iov = uio->uio_iov;
   11ec4:	000a2483          	lw	s1,0(s4)
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   11ec8:	00277793          	andi	a5,a4,2
   11ecc:	f40798e3          	bnez	a5,11e1c <__sfvwrite_r+0x68>
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
    }
  else if ((fp->_flags & __SLBF) == 0)
   11ed0:	00177793          	andi	a5,a4,1
   11ed4:	10079063          	bnez	a5,11fd4 <__sfvwrite_r+0x220>
		goto err;
	    }
	  else
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
   11ed8:	80000b37          	lui	s6,0x80000
   11edc:	00000b93          	li	s7,0
   11ee0:	00000913          	li	s2,0
   11ee4:	fffb4b13          	not	s6,s6
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
   11ee8:	06090663          	beqz	s2,11f54 <__sfvwrite_r+0x1a0>
	  w = fp->_w;
	  if (fp->_flags & __SSTR)
   11eec:	20077793          	andi	a5,a4,512
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
	  w = fp->_w;
   11ef0:	00842983          	lw	s3,8(s0)
	  if (fp->_flags & __SSTR)
   11ef4:	08078663          	beqz	a5,11f80 <__sfvwrite_r+0x1cc>
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
   11ef8:	23396e63          	bltu	s2,s3,12134 <__sfvwrite_r+0x380>
   11efc:	48077793          	andi	a5,a4,1152
   11f00:	26079463          	bnez	a5,12168 <__sfvwrite_r+0x3b4>
   11f04:	00042503          	lw	a0,0(s0)
   11f08:	00098c13          	mv	s8,s3
		  w = len;
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
	      COPY (w);		/* copy MIN(fp->_w,len), */
   11f0c:	000c0613          	mv	a2,s8
   11f10:	000b8593          	mv	a1,s7
   11f14:	4a5000ef          	jal	12bb8 <memmove>
	      fp->_w -= w;
   11f18:	00842783          	lw	a5,8(s0)
	      fp->_p += w;
   11f1c:	00042603          	lw	a2,0(s0)
   11f20:	00090513          	mv	a0,s2
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
	      COPY (w);		/* copy MIN(fp->_w,len), */
	      fp->_w -= w;
   11f24:	413789b3          	sub	s3,a5,s3
	      fp->_p += w;
   11f28:	01860633          	add	a2,a2,s8
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
	      COPY (w);		/* copy MIN(fp->_w,len), */
	      fp->_w -= w;
   11f2c:	01342423          	sw	s3,8(s0)
	      fp->_p += w;
   11f30:	00c42023          	sw	a2,0(s0)
		goto err;
	    }
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
   11f34:	008a2783          	lw	a5,8(s4)
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
	      w = fp->_write (ptr, fp->_cookie, p, w);
	      if (w <= 0)
		goto err;
	    }
	  p += w;
   11f38:	00ab8bb3          	add	s7,s7,a0
	  len -= w;
   11f3c:	40a90933          	sub	s2,s2,a0
	}
      while ((uio->uio_resid -= w) != 0);
   11f40:	40a789b3          	sub	s3,a5,a0
   11f44:	013a2423          	sw	s3,8(s4)
   11f48:	f20982e3          	beqz	s3,11e6c <__sfvwrite_r+0xb8>
   11f4c:	00c45703          	lhu	a4,12(s0)
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
   11f50:	f8091ee3          	bnez	s2,11eec <__sfvwrite_r+0x138>
   11f54:	0004ab83          	lw	s7,0(s1)
   11f58:	0044a903          	lw	s2,4(s1)
   11f5c:	00848493          	addi	s1,s1,8
   11f60:	f89ff06f          	j	11ee8 <__sfvwrite_r+0x134>
       * Unbuffered: Split buffer in the largest multiple of BUFSIZ < INT_MAX
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
   11f64:	0004a983          	lw	s3,0(s1)
   11f68:	0044a903          	lw	s2,4(s1)
   11f6c:	00848493          	addi	s1,s1,8
   11f70:	ebdff06f          	j	11e2c <__sfvwrite_r+0x78>
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
    return 0;
   11f74:	00000793          	li	a5,0
  return 0;

err:
  fp->_flags |= __SERR;
  return EOF;
}
   11f78:	00078513          	mv	a0,a5
   11f7c:	00008067          	ret
	      COPY (w);		/* copy MIN(fp->_w,len), */
	      fp->_w -= w;
	      fp->_p += w;
	      w = len;		/* but pretend copied all */
	    }
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
   11f80:	00042503          	lw	a0,0(s0)
   11f84:	01042783          	lw	a5,16(s0)
   11f88:	12a7ea63          	bltu	a5,a0,120bc <__sfvwrite_r+0x308>
   11f8c:	01442783          	lw	a5,20(s0)
   11f90:	12f96663          	bltu	s2,a5,120bc <__sfvwrite_r+0x308>
		goto err;
	    }
	  else
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
   11f94:	00090693          	mv	a3,s2
   11f98:	012b7463          	bleu	s2,s6,11fa0 <__sfvwrite_r+0x1ec>
   11f9c:	000b0693          	mv	a3,s6
   11fa0:	02f6c6b3          	div	a3,a3,a5
	      w = fp->_write (ptr, fp->_cookie, p, w);
   11fa4:	02442703          	lw	a4,36(s0)
   11fa8:	01c42583          	lw	a1,28(s0)
   11fac:	000b8613          	mv	a2,s7
   11fb0:	000a8513          	mv	a0,s5
   11fb4:	02f686b3          	mul	a3,a3,a5
   11fb8:	000700e7          	jalr	a4
	      if (w <= 0)
   11fbc:	f6a04ce3          	bgtz	a0,11f34 <__sfvwrite_r+0x180>
   11fc0:	00c41783          	lh	a5,12(s0)
      while ((uio->uio_resid -= w) != 0);
    }
  return 0;

err:
  fp->_flags |= __SERR;
   11fc4:	0407e793          	ori	a5,a5,64
   11fc8:	00f41623          	sh	a5,12(s0)
  return EOF;
   11fcc:	fff00793          	li	a5,-1
   11fd0:	ea1ff06f          	j	11e70 <__sfvwrite_r+0xbc>
   11fd4:	00000993          	li	s3,0
   11fd8:	00000c13          	li	s8,0
   11fdc:	00000d13          	li	s10,0
   11fe0:	00000913          	li	s2,0
       */
      nlknown = 0;
      nldist = 0;
      do
	{
	  GETIOV (nlknown = 0);
   11fe4:	06090c63          	beqz	s2,1205c <__sfvwrite_r+0x2a8>
	  if (!nlknown)
   11fe8:	140c0e63          	beqz	s8,12144 <__sfvwrite_r+0x390>
	    {
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
	      nlknown = 1;
	    }
	  s = MIN (len, nldist);
   11fec:	00098b93          	mv	s7,s3
   11ff0:	01397463          	bleu	s3,s2,11ff8 <__sfvwrite_r+0x244>
   11ff4:	00090b93          	mv	s7,s2
	  w = fp->_w + fp->_bf._size;
	  if (fp->_p > fp->_bf._base && s > w)
   11ff8:	00042503          	lw	a0,0(s0)
   11ffc:	01042783          	lw	a5,16(s0)
	    {
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
	      nlknown = 1;
	    }
	  s = MIN (len, nldist);
   12000:	000b8b13          	mv	s6,s7
	  w = fp->_w + fp->_bf._size;
   12004:	01442683          	lw	a3,20(s0)
	  if (fp->_p > fp->_bf._base && s > w)
   12008:	00a7f863          	bleu	a0,a5,12018 <__sfvwrite_r+0x264>
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
	      nlknown = 1;
	    }
	  s = MIN (len, nldist);
	  w = fp->_w + fp->_bf._size;
   1200c:	00842c83          	lw	s9,8(s0)
   12010:	01968cb3          	add	s9,a3,s9
	  if (fp->_p > fp->_bf._base && s > w)
   12014:	057cce63          	blt	s9,s7,12070 <__sfvwrite_r+0x2bc>
	      /* fp->_w -= w; */
	      fp->_p += w;
	      if (_fflush_r (ptr, fp))
		goto err;
	    }
	  else if (s >= (w = fp->_bf._size))
   12018:	0edbca63          	blt	s7,a3,1210c <__sfvwrite_r+0x358>
	    {
	      w = fp->_write (ptr, fp->_cookie, p, w);
   1201c:	02442783          	lw	a5,36(s0)
   12020:	01c42583          	lw	a1,28(s0)
   12024:	000d0613          	mv	a2,s10
   12028:	000a8513          	mv	a0,s5
   1202c:	000780e7          	jalr	a5
   12030:	00050b13          	mv	s6,a0
	      if (w <= 0)
   12034:	f8a056e3          	blez	a0,11fc0 <__sfvwrite_r+0x20c>
	      w = s;
	      COPY (w);
	      fp->_w -= w;
	      fp->_p += w;
	    }
	  if ((nldist -= w) == 0)
   12038:	416989b3          	sub	s3,s3,s6
   1203c:	06098463          	beqz	s3,120a4 <__sfvwrite_r+0x2f0>
	      nlknown = 0;
	    }
	  p += w;
	  len -= w;
	}
      while ((uio->uio_resid -= w) != 0);
   12040:	008a2783          	lw	a5,8(s4)
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
		goto err;
	      nlknown = 0;
	    }
	  p += w;
   12044:	016d0d33          	add	s10,s10,s6
	  len -= w;
   12048:	41690933          	sub	s2,s2,s6
	}
      while ((uio->uio_resid -= w) != 0);
   1204c:	41678b33          	sub	s6,a5,s6
   12050:	016a2423          	sw	s6,8(s4)
   12054:	e00b0ce3          	beqz	s6,11e6c <__sfvwrite_r+0xb8>
       */
      nlknown = 0;
      nldist = 0;
      do
	{
	  GETIOV (nlknown = 0);
   12058:	f80918e3          	bnez	s2,11fe8 <__sfvwrite_r+0x234>
   1205c:	0004ad03          	lw	s10,0(s1)
   12060:	0044a903          	lw	s2,4(s1)
   12064:	00000c13          	li	s8,0
   12068:	00848493          	addi	s1,s1,8
   1206c:	f79ff06f          	j	11fe4 <__sfvwrite_r+0x230>
	    }
	  s = MIN (len, nldist);
	  w = fp->_w + fp->_bf._size;
	  if (fp->_p > fp->_bf._base && s > w)
	    {
	      COPY (w);
   12070:	000d0593          	mv	a1,s10
   12074:	000c8613          	mv	a2,s9
   12078:	341000ef          	jal	12bb8 <memmove>
	      /* fp->_w -= w; */
	      fp->_p += w;
   1207c:	00042783          	lw	a5,0(s0)
	      if (_fflush_r (ptr, fp))
   12080:	00040593          	mv	a1,s0
   12084:	000a8513          	mv	a0,s5
	  w = fp->_w + fp->_bf._size;
	  if (fp->_p > fp->_bf._base && s > w)
	    {
	      COPY (w);
	      /* fp->_w -= w; */
	      fp->_p += w;
   12088:	019787b3          	add	a5,a5,s9
   1208c:	00f42023          	sw	a5,0(s0)
	      if (_fflush_r (ptr, fp))
   12090:	5bc010ef          	jal	1364c <_fflush_r>
   12094:	f20516e3          	bnez	a0,11fc0 <__sfvwrite_r+0x20c>
   12098:	000c8b13          	mv	s6,s9
	      w = s;
	      COPY (w);
	      fp->_w -= w;
	      fp->_p += w;
	    }
	  if ((nldist -= w) == 0)
   1209c:	416989b3          	sub	s3,s3,s6
   120a0:	fa0990e3          	bnez	s3,12040 <__sfvwrite_r+0x28c>
	    {
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
   120a4:	00040593          	mv	a1,s0
   120a8:	000a8513          	mv	a0,s5
   120ac:	5a0010ef          	jal	1364c <_fflush_r>
   120b0:	f00518e3          	bnez	a0,11fc0 <__sfvwrite_r+0x20c>
		goto err;
	      nlknown = 0;
   120b4:	00000c13          	li	s8,0
   120b8:	f89ff06f          	j	12040 <__sfvwrite_r+0x28c>
	      w = len;		/* but pretend copied all */
	    }
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
   120bc:	01397463          	bleu	s3,s2,120c4 <__sfvwrite_r+0x310>
   120c0:	00090993          	mv	s3,s2
	      COPY (w);
   120c4:	00098613          	mv	a2,s3
   120c8:	000b8593          	mv	a1,s7
   120cc:	2ed000ef          	jal	12bb8 <memmove>
	      fp->_w -= w;
   120d0:	00842783          	lw	a5,8(s0)
	      fp->_p += w;
   120d4:	00042703          	lw	a4,0(s0)
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
	      COPY (w);
	      fp->_w -= w;
   120d8:	413787b3          	sub	a5,a5,s3
	      fp->_p += w;
   120dc:	01370733          	add	a4,a4,s3
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
	      COPY (w);
	      fp->_w -= w;
   120e0:	00f42423          	sw	a5,8(s0)
	      fp->_p += w;
   120e4:	00e42023          	sw	a4,0(s0)
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
   120e8:	00078663          	beqz	a5,120f4 <__sfvwrite_r+0x340>
   120ec:	00098513          	mv	a0,s3
   120f0:	e45ff06f          	j	11f34 <__sfvwrite_r+0x180>
   120f4:	00040593          	mv	a1,s0
   120f8:	000a8513          	mv	a0,s5
   120fc:	550010ef          	jal	1364c <_fflush_r>
   12100:	ec0510e3          	bnez	a0,11fc0 <__sfvwrite_r+0x20c>
   12104:	00098513          	mv	a0,s3
   12108:	e2dff06f          	j	11f34 <__sfvwrite_r+0x180>
		goto err;
	    }
	  else
	    {
	      w = s;
	      COPY (w);
   1210c:	000b8613          	mv	a2,s7
   12110:	000d0593          	mv	a1,s10
   12114:	2a5000ef          	jal	12bb8 <memmove>
	      fp->_w -= w;
   12118:	00842703          	lw	a4,8(s0)
	      fp->_p += w;
   1211c:	00042783          	lw	a5,0(s0)
	    }
	  else
	    {
	      w = s;
	      COPY (w);
	      fp->_w -= w;
   12120:	41770733          	sub	a4,a4,s7
	      fp->_p += w;
   12124:	01778bb3          	add	s7,a5,s7
	    }
	  else
	    {
	      w = s;
	      COPY (w);
	      fp->_w -= w;
   12128:	00e42423          	sw	a4,8(s0)
	      fp->_p += w;
   1212c:	01742023          	sw	s7,0(s0)
   12130:	f09ff06f          	j	12038 <__sfvwrite_r+0x284>
   12134:	00042503          	lw	a0,0(s0)
		  fp->_bf._size = newsize;
		  w = len;
		  fp->_w = newsize - curpos;
		}
	      if (len < w)
		w = len;
   12138:	00090993          	mv	s3,s2
   1213c:	00090c13          	mv	s8,s2
   12140:	dcdff06f          	j	11f0c <__sfvwrite_r+0x158>
      do
	{
	  GETIOV (nlknown = 0);
	  if (!nlknown)
	    {
	      nl = memchr ((_PTR) p, '\n', len);
   12144:	00090613          	mv	a2,s2
   12148:	00a00593          	li	a1,10
   1214c:	000d0513          	mv	a0,s10
   12150:	075000ef          	jal	129c4 <memchr>
	      nldist = nl ? nl + 1 - p : len + 1;
   12154:	0c050e63          	beqz	a0,12230 <__sfvwrite_r+0x47c>
   12158:	00150513          	addi	a0,a0,1
   1215c:	41a509b3          	sub	s3,a0,s10
	      nlknown = 1;
   12160:	00100c13          	li	s8,1
   12164:	e89ff06f          	j	11fec <__sfvwrite_r+0x238>
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   12168:	01442983          	lw	s3,20(s0)
	  if (fp->_flags & __SSTR)
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
   1216c:	01042583          	lw	a1,16(s0)
   12170:	00042c03          	lw	s8,0(s0)
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   12174:	00199793          	slli	a5,s3,0x1
   12178:	013789b3          	add	s3,a5,s3
   1217c:	01f9d793          	srli	a5,s3,0x1f
	  if (fp->_flags & __SSTR)
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
   12180:	40bc0c33          	sub	s8,s8,a1
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   12184:	013789b3          	add	s3,a5,s3
		  if (newsize < curpos + len + 1)
   12188:	001c0793          	addi	a5,s8,1
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   1218c:	4019d993          	srai	s3,s3,0x1
		  if (newsize < curpos + len + 1)
   12190:	012787b3          	add	a5,a5,s2
   12194:	00098613          	mv	a2,s3
   12198:	00f9f663          	bleu	a5,s3,121a4 <__sfvwrite_r+0x3f0>
		    newsize = curpos + len + 1;
   1219c:	00078993          	mv	s3,a5
   121a0:	00078613          	mv	a2,a5
		  if (fp->_flags & __SOPT)
   121a4:	40077713          	andi	a4,a4,1024
   121a8:	04070c63          	beqz	a4,12200 <__sfvwrite_r+0x44c>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
   121ac:	00060593          	mv	a1,a2
   121b0:	000a8513          	mv	a0,s5
   121b4:	098000ef          	jal	1224c <_malloc_r>
   121b8:	00050c93          	mv	s9,a0
		      if (!str)
   121bc:	08050063          	beqz	a0,1223c <__sfvwrite_r+0x488>
			{
			  ptr->_errno = ENOMEM;
			  goto err;
			}
		      memcpy (str, fp->_bf._base, curpos);
   121c0:	01042583          	lw	a1,16(s0)
   121c4:	000c0613          	mv	a2,s8
   121c8:	0d1000ef          	jal	12a98 <memcpy>
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
   121cc:	00c45783          	lhu	a5,12(s0)
   121d0:	b7f7f793          	andi	a5,a5,-1153
   121d4:	0807e793          	ori	a5,a5,128
   121d8:	00f41623          	sh	a5,12(s0)
			  ptr->_errno = ENOMEM;
			  goto err;
			}
		    }
		  fp->_bf._base = str;
		  fp->_p = str + curpos;
   121dc:	018c8533          	add	a0,s9,s8
		  fp->_bf._size = newsize;
		  w = len;
		  fp->_w = newsize - curpos;
   121e0:	41898c33          	sub	s8,s3,s8
			  goto err;
			}
		    }
		  fp->_bf._base = str;
		  fp->_p = str + curpos;
		  fp->_bf._size = newsize;
   121e4:	01342a23          	sw	s3,20(s0)
		  w = len;
		  fp->_w = newsize - curpos;
   121e8:	01842423          	sw	s8,8(s0)
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
			  goto err;
			}
		    }
		  fp->_bf._base = str;
   121ec:	01942823          	sw	s9,16(s0)
		  fp->_p = str + curpos;
   121f0:	00a42023          	sw	a0,0(s0)
		  fp->_bf._size = newsize;
		  w = len;
   121f4:	00090993          	mv	s3,s2
   121f8:	00090c13          	mv	s8,s2
   121fc:	d11ff06f          	j	11f0c <__sfvwrite_r+0x158>
		      memcpy (str, fp->_bf._base, curpos);
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
		    }
		  else
		    {
		      str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
   12200:	000a8513          	mv	a0,s5
   12204:	2dd000ef          	jal	12ce0 <_realloc_r>
   12208:	00050c93          	mv	s9,a0
							 newsize);
		      if (!str)
   1220c:	fc0518e3          	bnez	a0,121dc <__sfvwrite_r+0x428>
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
   12210:	01042583          	lw	a1,16(s0)
   12214:	000a8513          	mv	a0,s5
   12218:	125010ef          	jal	13b3c <_free_r>
			  fp->_flags &=  ~__SMBF;
   1221c:	00c41783          	lh	a5,12(s0)
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
   12220:	00c00713          	li	a4,12
   12224:	00eaa023          	sw	a4,0(s5)
		      if (!str)
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
			  fp->_flags &=  ~__SMBF;
   12228:	f7f7f793          	andi	a5,a5,-129
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
			  goto err;
   1222c:	d99ff06f          	j	11fc4 <__sfvwrite_r+0x210>
	{
	  GETIOV (nlknown = 0);
	  if (!nlknown)
	    {
	      nl = memchr ((_PTR) p, '\n', len);
	      nldist = nl ? nl + 1 - p : len + 1;
   12230:	00190993          	addi	s3,s2,1
	      nlknown = 1;
   12234:	00100c13          	li	s8,1
   12238:	db5ff06f          	j	11fec <__sfvwrite_r+0x238>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
		      if (!str)
			{
			  ptr->_errno = ENOMEM;
   1223c:	00c00793          	li	a5,12
   12240:	00faa023          	sw	a5,0(s5)
   12244:	00c41783          	lh	a5,12(s0)
			  goto err;
   12248:	d7dff06f          	j	11fc4 <__sfvwrite_r+0x210>

0001224c <_malloc_r>:
#if __STD_C
Void_t* mALLOc(RARG size_t bytes)
#else
Void_t* mALLOc(RARG bytes) RDECL size_t bytes;
#endif
{
   1224c:	fd010113          	addi	sp,sp,-48
   12250:	02912223          	sw	s1,36(sp)
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
   12254:	01600793          	li	a5,22
   12258:	00b58493          	addi	s1,a1,11
#if __STD_C
Void_t* mALLOc(RARG size_t bytes)
#else
Void_t* mALLOc(RARG bytes) RDECL size_t bytes;
#endif
{
   1225c:	01312e23          	sw	s3,28(sp)
   12260:	02112623          	sw	ra,44(sp)
   12264:	02812423          	sw	s0,40(sp)
   12268:	03212023          	sw	s2,32(sp)
   1226c:	01412c23          	sw	s4,24(sp)
   12270:	01512a23          	sw	s5,20(sp)
   12274:	01612823          	sw	s6,16(sp)
   12278:	01712623          	sw	s7,12(sp)
   1227c:	01812423          	sw	s8,8(sp)
   12280:	01912223          	sw	s9,4(sp)
   12284:	00050993          	mv	s3,a0
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
   12288:	1a97fc63          	bleu	s1,a5,12440 <_malloc_r+0x1f4>
   1228c:	ff84f493          	andi	s1,s1,-8

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   12290:	2404c463          	bltz	s1,124d8 <_malloc_r+0x28c>
   12294:	24b4e263          	bltu	s1,a1,124d8 <_malloc_r+0x28c>
  {
    RERRNO = ENOMEM;
    return 0;
  }

  MALLOC_LOCK;
   12298:	241000ef          	jal	12cd8 <__malloc_lock>

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
   1229c:	1f700793          	li	a5,503
   122a0:	7097fa63          	bleu	s1,a5,129b4 <_malloc_r+0x768>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   122a4:	0094d793          	srli	a5,s1,0x9
   122a8:	08000693          	li	a3,128
   122ac:	04000513          	li	a0,64
   122b0:	03f00593          	li	a1,63
   122b4:	22079a63          	bnez	a5,124e8 <_malloc_r+0x29c>
    bin = bin_at(idx);
   122b8:	00015937          	lui	s2,0x15
   122bc:	49090913          	addi	s2,s2,1168 # 15490 <__malloc_av_>
   122c0:	00269693          	slli	a3,a3,0x2
   122c4:	00d906b3          	add	a3,s2,a3

    for (victim = last(bin); victim != bin; victim = victim->bk)
   122c8:	0046a403          	lw	s0,4(a3)

  }
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);
   122cc:	ff868693          	addi	a3,a3,-8

    for (victim = last(bin); victim != bin; victim = victim->bk)
   122d0:	22868a63          	beq	a3,s0,12504 <_malloc_r+0x2b8>
    {
      victim_size = chunksize(victim);
   122d4:	00442783          	lw	a5,4(s0)
      remainder_size = long_sub_size_t(victim_size, nb);
      
      if (remainder_size >= (long)MINSIZE) /* too big */
   122d8:	00f00613          	li	a2,15
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
    {
      victim_size = chunksize(victim);
   122dc:	ffc7f793          	andi	a5,a5,-4
      remainder_size = long_sub_size_t(victim_size, nb);
   122e0:	40978733          	sub	a4,a5,s1
      
      if (remainder_size >= (long)MINSIZE) /* too big */
   122e4:	02e64063          	blt	a2,a4,12304 <_malloc_r+0xb8>
      {
        --idx; /* adjust to rescan below after checking last remainder */
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
   122e8:	22075263          	bgez	a4,1250c <_malloc_r+0x2c0>
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
   122ec:	00c42403          	lw	s0,12(s0)
   122f0:	20868a63          	beq	a3,s0,12504 <_malloc_r+0x2b8>
    {
      victim_size = chunksize(victim);
   122f4:	00442783          	lw	a5,4(s0)
   122f8:	ffc7f793          	andi	a5,a5,-4
      remainder_size = long_sub_size_t(victim_size, nb);
   122fc:	40978733          	sub	a4,a5,s1
      
      if (remainder_size >= (long)MINSIZE) /* too big */
   12300:	fee654e3          	ble	a4,a2,122e8 <_malloc_r+0x9c>
      {
        --idx; /* adjust to rescan below after checking last remainder */
        break;   
   12304:	00058693          	mv	a3,a1

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
   12308:	01092403          	lw	s0,16(s2)
   1230c:	00890813          	addi	a6,s2,8
   12310:	4b040263          	beq	s0,a6,127b4 <_malloc_r+0x568>
  {
    victim_size = chunksize(victim);
   12314:	00442783          	lw	a5,4(s0)
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
   12318:	00f00613          	li	a2,15

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
  {
    victim_size = chunksize(victim);
   1231c:	ffc7f793          	andi	a5,a5,-4
    remainder_size = long_sub_size_t(victim_size, nb);
   12320:	40978733          	sub	a4,a5,s1

    if (remainder_size >= (long)MINSIZE) /* re-split */
   12324:	44e64a63          	blt	a2,a4,12778 <_malloc_r+0x52c>
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
      return chunk2mem(victim);
    }

    clear_last_remainder;
   12328:	01092a23          	sw	a6,20(s2)
   1232c:	01092823          	sw	a6,16(s2)

    if (remainder_size >= 0)  /* exhaust */
   12330:	20075663          	bgez	a4,1253c <_malloc_r+0x2f0>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   12334:	1ff00713          	li	a4,511
   12338:	3cf76e63          	bltu	a4,a5,12714 <_malloc_r+0x4c8>
   1233c:	0037d793          	srli	a5,a5,0x3
   12340:	00178613          	addi	a2,a5,1
   12344:	00361613          	slli	a2,a2,0x3
   12348:	00492703          	lw	a4,4(s2)
   1234c:	00c90633          	add	a2,s2,a2
   12350:	00062503          	lw	a0,0(a2)
   12354:	4027d793          	srai	a5,a5,0x2
   12358:	00100593          	li	a1,1
   1235c:	00f597b3          	sll	a5,a1,a5
   12360:	00e7e7b3          	or	a5,a5,a4
   12364:	ff860713          	addi	a4,a2,-8
   12368:	00e42623          	sw	a4,12(s0)
   1236c:	00a42423          	sw	a0,8(s0)
   12370:	00f92223          	sw	a5,4(s2)
   12374:	00862023          	sw	s0,0(a2)
   12378:	00852623          	sw	s0,12(a0)
  /* 
     If there are any possibly nonempty big-enough blocks, 
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks)  
   1237c:	4026d713          	srai	a4,a3,0x2
   12380:	00100613          	li	a2,1
   12384:	00e61633          	sll	a2,a2,a4
   12388:	1cc7ea63          	bltu	a5,a2,1255c <_malloc_r+0x310>
  {

    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
   1238c:	00f67733          	and	a4,a2,a5
   12390:	02071463          	bnez	a4,123b8 <_malloc_r+0x16c>
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
   12394:	00161613          	slli	a2,a2,0x1
    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
   12398:	ffc6f693          	andi	a3,a3,-4
      block <<= 1;
      while ((block & binblocks) == 0)
   1239c:	00f67733          	and	a4,a2,a5
    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
   123a0:	00468693          	addi	a3,a3,4
      block <<= 1;
      while ((block & binblocks) == 0)
   123a4:	00071a63          	bnez	a4,123b8 <_malloc_r+0x16c>
      {
        idx += BINBLOCKWIDTH;
        block <<= 1;
   123a8:	00161613          	slli	a2,a2,0x1
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
   123ac:	00f67733          	and	a4,a2,a5
      {
        idx += BINBLOCKWIDTH;
   123b0:	00468693          	addi	a3,a3,4
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
   123b4:	fe070ae3          	beqz	a4,123a8 <_malloc_r+0x15c>
        for (victim = last(bin); victim != bin; victim = victim->bk)
        {
          victim_size = chunksize(victim);
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
   123b8:	00f00513          	li	a0,15
      
    /* For each possibly nonempty block ... */
    for (;;)  
    {
      startidx = idx;          /* (track incomplete blocks) */
      q = bin = bin_at(idx);
   123bc:	00369893          	slli	a7,a3,0x3
   123c0:	012888b3          	add	a7,a7,s2
   123c4:	00088593          	mv	a1,a7
   123c8:	00068293          	mv	t0,a3
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
   123cc:	00c5a403          	lw	s0,12(a1)
   123d0:	00859a63          	bne	a1,s0,123e4 <_malloc_r+0x198>
   123d4:	3e80006f          	j	127bc <_malloc_r+0x570>
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
   123d8:	40075463          	bgez	a4,127e0 <_malloc_r+0x594>
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
   123dc:	00c42403          	lw	s0,12(s0)
   123e0:	3c858e63          	beq	a1,s0,127bc <_malloc_r+0x570>
        {
          victim_size = chunksize(victim);
   123e4:	00442783          	lw	a5,4(s0)
   123e8:	ffc7f793          	andi	a5,a5,-4
          remainder_size = long_sub_size_t(victim_size, nb);
   123ec:	40978733          	sub	a4,a5,s1

          if (remainder_size >= (long)MINSIZE) /* split */
   123f0:	fee554e3          	ble	a4,a0,123d8 <_malloc_r+0x18c>
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
   123f4:	00c42683          	lw	a3,12(s0)
   123f8:	00842603          	lw	a2,8(s0)
          victim_size = chunksize(victim);
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
   123fc:	009407b3          	add	a5,s0,s1
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
            link_last_remainder(remainder);
            set_head(remainder, remainder_size | PREV_INUSE);
   12400:	00176893          	ori	a7,a4,1
            set_foot(remainder, remainder_size);
   12404:	00e785b3          	add	a1,a5,a4
          remainder_size = long_sub_size_t(victim_size, nb);

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
   12408:	0014e493          	ori	s1,s1,1
   1240c:	00942223          	sw	s1,4(s0)
            unlink(victim, bck, fwd);
            link_last_remainder(remainder);
            set_head(remainder, remainder_size | PREV_INUSE);
            set_foot(remainder, remainder_size);
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   12410:	00098513          	mv	a0,s3

          if (remainder_size >= (long)MINSIZE) /* split */
          {
            remainder = chunk_at_offset(victim, nb);
            set_head(victim, nb | PREV_INUSE);
            unlink(victim, bck, fwd);
   12414:	00d62623          	sw	a3,12(a2)
   12418:	00c6a423          	sw	a2,8(a3)
            link_last_remainder(remainder);
   1241c:	00f92a23          	sw	a5,20(s2)
   12420:	00f92823          	sw	a5,16(s2)
   12424:	0107a623          	sw	a6,12(a5)
   12428:	0107a423          	sw	a6,8(a5)
            set_head(remainder, remainder_size | PREV_INUSE);
   1242c:	0117a223          	sw	a7,4(a5)
            set_foot(remainder, remainder_size);
   12430:	00e5a023          	sw	a4,0(a1)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   12434:	0a9000ef          	jal	12cdc <__malloc_unlock>
            return chunk2mem(victim);
   12438:	00840513          	addi	a0,s0,8
   1243c:	0680006f          	j	124a4 <_malloc_r+0x258>
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   12440:	01000493          	li	s1,16
   12444:	08b4ea63          	bltu	s1,a1,124d8 <_malloc_r+0x28c>
  {
    RERRNO = ENOMEM;
    return 0;
  }

  MALLOC_LOCK;
   12448:	091000ef          	jal	12cd8 <__malloc_lock>
   1244c:	00600793          	li	a5,6
   12450:	00200693          	li	a3,2
  {
    idx = smallbin_index(nb); 

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
   12454:	00015937          	lui	s2,0x15
   12458:	49090913          	addi	s2,s2,1168 # 15490 <__malloc_av_>
   1245c:	00279793          	slli	a5,a5,0x2
   12460:	00f907b3          	add	a5,s2,a5
    victim = last(q);
   12464:	0047a403          	lw	s0,4(a5)

#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
   12468:	ff878713          	addi	a4,a5,-8
   1246c:	36e40263          	beq	s0,a4,127d0 <_malloc_r+0x584>
      victim = last(q);
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
   12470:	00442783          	lw	a5,4(s0)
      unlink(victim, bck, fwd);
   12474:	00c42683          	lw	a3,12(s0)
   12478:	00842603          	lw	a2,8(s0)
      victim = last(q);
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
   1247c:	ffc7f793          	andi	a5,a5,-4
      unlink(victim, bck, fwd);
      set_inuse_bit_at_offset(victim, victim_size);
   12480:	00f407b3          	add	a5,s0,a5
   12484:	0047a703          	lw	a4,4(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   12488:	00098513          	mv	a0,s3
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
      unlink(victim, bck, fwd);
   1248c:	00d62623          	sw	a3,12(a2)
      set_inuse_bit_at_offset(victim, victim_size);
   12490:	00176713          	ori	a4,a4,1
    }
#endif
    if (victim != q)
    {
      victim_size = chunksize(victim);
      unlink(victim, bck, fwd);
   12494:	00c6a423          	sw	a2,8(a3)
      set_inuse_bit_at_offset(victim, victim_size);
   12498:	00e7a223          	sw	a4,4(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   1249c:	041000ef          	jal	12cdc <__malloc_unlock>
      return chunk2mem(victim);
   124a0:	00840513          	addi	a0,s0,8
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
  return chunk2mem(victim);

#endif /* MALLOC_PROVIDED */
}
   124a4:	02c12083          	lw	ra,44(sp)
   124a8:	02812403          	lw	s0,40(sp)
   124ac:	02412483          	lw	s1,36(sp)
   124b0:	02012903          	lw	s2,32(sp)
   124b4:	01c12983          	lw	s3,28(sp)
   124b8:	01812a03          	lw	s4,24(sp)
   124bc:	01412a83          	lw	s5,20(sp)
   124c0:	01012b03          	lw	s6,16(sp)
   124c4:	00c12b83          	lw	s7,12(sp)
   124c8:	00812c03          	lw	s8,8(sp)
   124cc:	00412c83          	lw	s9,4(sp)
   124d0:	03010113          	addi	sp,sp,48
   124d4:	00008067          	ret
  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
  {
    RERRNO = ENOMEM;
   124d8:	00c00793          	li	a5,12
   124dc:	00f9a023          	sw	a5,0(s3)
    return 0;
   124e0:	00000513          	li	a0,0
   124e4:	fc1ff06f          	j	124a4 <_malloc_r+0x258>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   124e8:	00400713          	li	a4,4
   124ec:	20f76263          	bltu	a4,a5,126f0 <_malloc_r+0x4a4>
   124f0:	0064d593          	srli	a1,s1,0x6
   124f4:	03958513          	addi	a0,a1,57
   124f8:	00151693          	slli	a3,a0,0x1
   124fc:	03858593          	addi	a1,a1,56
   12500:	db9ff06f          	j	122b8 <_malloc_r+0x6c>
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
   12504:	00050693          	mv	a3,a0
   12508:	e01ff06f          	j	12308 <_malloc_r+0xbc>
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
        set_inuse_bit_at_offset(victim, victim_size);
   1250c:	00f407b3          	add	a5,s0,a5
   12510:	0047a703          	lw	a4,4(a5)
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
   12514:	00c42683          	lw	a3,12(s0)
   12518:	00842603          	lw	a2,8(s0)
        set_inuse_bit_at_offset(victim, victim_size);
   1251c:	00176713          	ori	a4,a4,1
        check_malloced_chunk(victim, nb);
	MALLOC_UNLOCK;
   12520:	00098513          	mv	a0,s3
        break;   
      }

      else if (remainder_size >= 0) /* exact fit */
      {
        unlink(victim, bck, fwd);
   12524:	00d62623          	sw	a3,12(a2)
   12528:	00c6a423          	sw	a2,8(a3)
        set_inuse_bit_at_offset(victim, victim_size);
   1252c:	00e7a223          	sw	a4,4(a5)
        check_malloced_chunk(victim, nb);
	MALLOC_UNLOCK;
   12530:	7ac000ef          	jal	12cdc <__malloc_unlock>
        return chunk2mem(victim);
   12534:	00840513          	addi	a0,s0,8
   12538:	f6dff06f          	j	124a4 <_malloc_r+0x258>

    clear_last_remainder;

    if (remainder_size >= 0)  /* exhaust */
    {
      set_inuse_bit_at_offset(victim, victim_size);
   1253c:	00f407b3          	add	a5,s0,a5
   12540:	0047a703          	lw	a4,4(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   12544:	00098513          	mv	a0,s3

    clear_last_remainder;

    if (remainder_size >= 0)  /* exhaust */
    {
      set_inuse_bit_at_offset(victim, victim_size);
   12548:	00176713          	ori	a4,a4,1
   1254c:	00e7a223          	sw	a4,4(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   12550:	78c000ef          	jal	12cdc <__malloc_unlock>
      return chunk2mem(victim);
   12554:	00840513          	addi	a0,s0,8
   12558:	f4dff06f          	j	124a4 <_malloc_r+0x258>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  remainder_size = long_sub_size_t(chunksize(top), nb);
   1255c:	00892403          	lw	s0,8(s2)
   12560:	00442a03          	lw	s4,4(s0)
   12564:	ffca7a93          	andi	s5,s4,-4
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   12568:	009ae863          	bltu	s5,s1,12578 <_malloc_r+0x32c>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  remainder_size = long_sub_size_t(chunksize(top), nb);
   1256c:	409a87b3          	sub	a5,s5,s1
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   12570:	00f00713          	li	a4,15
   12574:	14f74a63          	blt	a4,a5,126c8 <_malloc_r+0x47c>
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
   12578:	82c1a703          	lw	a4,-2004(gp) # 158cc <__malloc_top_pad>

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
   1257c:	8141a683          	lw	a3,-2028(gp) # 158b4 <__malloc_sbrk_base>
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
   12580:	00e48733          	add	a4,s1,a4

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
   12584:	fff00793          	li	a5,-1
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
   12588:	01540b33          	add	s6,s0,s5

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
   1258c:	01070a13          	addi	s4,a4,16

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
   12590:	00f68c63          	beq	a3,a5,125a8 <_malloc_r+0x35c>
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
   12594:	000016b7          	lui	a3,0x1
   12598:	00f68a13          	addi	s4,a3,15 # 100f <_reset+0xe0f>
   1259c:	014706b3          	add	a3,a4,s4
   125a0:	fffff737          	lui	a4,0xfffff
   125a4:	00e6fa33          	and	s4,a3,a4

  brk = (char*)(MORECORE (sbrk_size));
   125a8:	000a0513          	mv	a0,s4
   125ac:	e25fd0ef          	jal	103d0 <sbrk>

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
   125b0:	fff00793          	li	a5,-1
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));
   125b4:	00050b93          	mv	s7,a0

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
   125b8:	28f50063          	beq	a0,a5,12838 <_malloc_r+0x5ec>
   125bc:	27656c63          	bltu	a0,s6,12834 <_malloc_r+0x5e8>
      (brk < old_end && old_top != initial_top))
    return;

  sbrked_mem += sbrk_size;
   125c0:	85018c13          	addi	s8,gp,-1968 # 158f0 <__malloc_current_mallinfo>
   125c4:	000c2703          	lw	a4,0(s8)
   125c8:	00ea0733          	add	a4,s4,a4
   125cc:	00ec2023          	sw	a4,0(s8)

  if (brk == old_end /* can just add bytes to current top, unless
   125d0:	357b0c63          	beq	s6,s7,12928 <_malloc_r+0x6dc>
    top_size = sbrk_size + old_top_size;
    set_head(top, top_size | PREV_INUSE);
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
   125d4:	8141a683          	lw	a3,-2028(gp) # 158b4 <__malloc_sbrk_base>
   125d8:	fff00793          	li	a5,-1
   125dc:	36f68a63          	beq	a3,a5,12950 <_malloc_r+0x704>
      sbrk_base = brk;
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
   125e0:	416b8b33          	sub	s6,s7,s6
   125e4:	00eb0733          	add	a4,s6,a4
   125e8:	00ec2023          	sw	a4,0(s8)

    /* Guarantee alignment of first new chunk made from this space */
    front_misalign = (POINTER_UINT)chunk2mem(brk) & MALLOC_ALIGN_MASK;
   125ec:	007bf713          	andi	a4,s7,7
    if (front_misalign > 0) 
   125f0:	000017b7          	lui	a5,0x1
   125f4:	00070a63          	beqz	a4,12608 <_malloc_r+0x3bc>
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
      brk += correction;
   125f8:	40eb8bb3          	sub	s7,s7,a4
   125fc:	00878793          	addi	a5,a5,8 # 1008 <_reset+0xe08>
   12600:	008b8b93          	addi	s7,s7,8
   12604:	40e787b3          	sub	a5,a5,a4
    }
    else
      correction = 0;

    /* Guarantee the next brk will be at a page boundary */
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));
   12608:	00001737          	lui	a4,0x1
   1260c:	fff70713          	addi	a4,a4,-1 # fff <_reset+0xdff>
   12610:	014b8a33          	add	s4,s7,s4
   12614:	00ea7a33          	and	s4,s4,a4
   12618:	41478a33          	sub	s4,a5,s4

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
   1261c:	000a0513          	mv	a0,s4
   12620:	db1fd0ef          	jal	103d0 <sbrk>
    if (new_brk == (char*)(MORECORE_FAILURE))
   12624:	fff00793          	li	a5,-1
   12628:	30f50e63          	beq	a0,a5,12944 <_malloc_r+0x6f8>
   1262c:	417507b3          	sub	a5,a0,s7
   12630:	014787b3          	add	a5,a5,s4
   12634:	0017e793          	ori	a5,a5,1
	correction = 0;
	correction_failed = 1;
	new_brk = brk;
      }

    sbrked_mem += correction;
   12638:	000c2703          	lw	a4,0(s8)

    top = (mchunkptr)brk;
   1263c:	01792423          	sw	s7,8(s2)
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);
   12640:	00fba223          	sw	a5,4(s7)
	correction = 0;
	correction_failed = 1;
	new_brk = brk;
      }

    sbrked_mem += correction;
   12644:	00ea0733          	add	a4,s4,a4
   12648:	00ec2023          	sw	a4,0(s8)

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);

    if (old_top != initial_top)
   1264c:	03240c63          	beq	s0,s2,12684 <_malloc_r+0x438>

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE) 
   12650:	00f00613          	li	a2,15
   12654:	29567263          	bleu	s5,a2,128d8 <_malloc_r+0x68c>
        return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
   12658:	00442683          	lw	a3,4(s0)
        set_head(top, PREV_INUSE); /* will force null return from malloc */
        return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
   1265c:	ff4a8793          	addi	a5,s5,-12
   12660:	ff87f793          	andi	a5,a5,-8
      set_head_size(old_top, old_top_size);
   12664:	0016f693          	andi	a3,a3,1
      chunk_at_offset(old_top, old_top_size          )->size =
   12668:	00f405b3          	add	a1,s0,a5
   1266c:	00500513          	li	a0,5
        return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
   12670:	00f6e6b3          	or	a3,a3,a5
   12674:	00d42223          	sw	a3,4(s0)
      chunk_at_offset(old_top, old_top_size          )->size =
   12678:	00a5a223          	sw	a0,4(a1)
        SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
   1267c:	00a5a423          	sw	a0,8(a1)
        SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE) 
   12680:	2cf66c63          	bltu	a2,a5,12958 <_malloc_r+0x70c>
        fREe(RCALL chunk2mem(old_top));
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem) 
   12684:	8281a683          	lw	a3,-2008(gp) # 158c8 <__malloc_max_sbrked_mem>
   12688:	00e6f463          	bleu	a4,a3,12690 <_malloc_r+0x444>
    max_sbrked_mem = sbrked_mem;
   1268c:	82e1a423          	sw	a4,-2008(gp) # 158c8 <__malloc_max_sbrked_mem>
#if HAVE_MMAP
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem) 
    max_total_mem = mmapped_mem + sbrked_mem;
#else
  if ((unsigned long)(sbrked_mem) > (unsigned long)max_total_mem) 
   12690:	8241a683          	lw	a3,-2012(gp) # 158c4 <__malloc_max_total_mem>
   12694:	00892403          	lw	s0,8(s2)
   12698:	00e6f463          	bleu	a4,a3,126a0 <_malloc_r+0x454>
    max_total_mem = sbrked_mem;
   1269c:	82e1a223          	sw	a4,-2012(gp) # 158c4 <__malloc_max_total_mem>
   126a0:	00442703          	lw	a4,4(s0)
   126a4:	ffc77713          	andi	a4,a4,-4
    }
#endif

    /* Try to extend */
    malloc_extend_top(RCALL nb);
    remainder_size = long_sub_size_t(chunksize(top), nb);
   126a8:	409707b3          	sub	a5,a4,s1
    if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   126ac:	00976663          	bltu	a4,s1,126b8 <_malloc_r+0x46c>
   126b0:	00f00713          	li	a4,15
   126b4:	00f74a63          	blt	a4,a5,126c8 <_malloc_r+0x47c>
    {
      MALLOC_UNLOCK;
   126b8:	00098513          	mv	a0,s3
   126bc:	620000ef          	jal	12cdc <__malloc_unlock>
      return 0; /* propagate failure */
   126c0:	00000513          	li	a0,0
   126c4:	de1ff06f          	j	124a4 <_malloc_r+0x258>
    }
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
   126c8:	00940733          	add	a4,s0,s1
  set_head(top, remainder_size | PREV_INUSE);
   126cc:	0017e793          	ori	a5,a5,1
      return 0; /* propagate failure */
    }
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
   126d0:	0014e493          	ori	s1,s1,1
   126d4:	00942223          	sw	s1,4(s0)
  top = chunk_at_offset(victim, nb);
  set_head(top, remainder_size | PREV_INUSE);
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
   126d8:	00098513          	mv	a0,s3
    }
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
   126dc:	00e92423          	sw	a4,8(s2)
  set_head(top, remainder_size | PREV_INUSE);
   126e0:	00f72223          	sw	a5,4(a4)
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
   126e4:	5f8000ef          	jal	12cdc <__malloc_unlock>
  return chunk2mem(victim);
   126e8:	00840513          	addi	a0,s0,8
   126ec:	db9ff06f          	j	124a4 <_malloc_r+0x258>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   126f0:	01400713          	li	a4,20
   126f4:	10f77e63          	bleu	a5,a4,12810 <_malloc_r+0x5c4>
   126f8:	05400713          	li	a4,84
   126fc:	1af76063          	bltu	a4,a5,1289c <_malloc_r+0x650>
   12700:	00c4d593          	srli	a1,s1,0xc
   12704:	06f58513          	addi	a0,a1,111
   12708:	00151693          	slli	a3,a0,0x1
   1270c:	06e58593          	addi	a1,a1,110
   12710:	ba9ff06f          	j	122b8 <_malloc_r+0x6c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   12714:	0097d713          	srli	a4,a5,0x9
   12718:	00400613          	li	a2,4
   1271c:	10e67263          	bleu	a4,a2,12820 <_malloc_r+0x5d4>
   12720:	01400613          	li	a2,20
   12724:	1ee66463          	bltu	a2,a4,1290c <_malloc_r+0x6c0>
   12728:	05c70593          	addi	a1,a4,92
   1272c:	05b70613          	addi	a2,a4,91
   12730:	00159593          	slli	a1,a1,0x1
   12734:	00259593          	slli	a1,a1,0x2
   12738:	00b905b3          	add	a1,s2,a1
   1273c:	0005a703          	lw	a4,0(a1)
   12740:	ff858593          	addi	a1,a1,-8
   12744:	16e58a63          	beq	a1,a4,128b8 <_malloc_r+0x66c>
   12748:	00472603          	lw	a2,4(a4)
   1274c:	ffc67613          	andi	a2,a2,-4
   12750:	00c7f663          	bleu	a2,a5,1275c <_malloc_r+0x510>
   12754:	00872703          	lw	a4,8(a4)
   12758:	fee598e3          	bne	a1,a4,12748 <_malloc_r+0x4fc>
   1275c:	00c72583          	lw	a1,12(a4)
   12760:	00492783          	lw	a5,4(s2)
   12764:	00b42623          	sw	a1,12(s0)
   12768:	00e42423          	sw	a4,8(s0)
   1276c:	0085a423          	sw	s0,8(a1)
   12770:	00872623          	sw	s0,12(a4)
   12774:	c09ff06f          	j	1237c <_malloc_r+0x130>
    victim_size = chunksize(victim);
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
   12778:	009407b3          	add	a5,s0,s1
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
   1277c:	00176613          	ori	a2,a4,1
      set_foot(remainder, remainder_size);
   12780:	00e786b3          	add	a3,a5,a4
    remainder_size = long_sub_size_t(victim_size, nb);

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
   12784:	0014e493          	ori	s1,s1,1
   12788:	00942223          	sw	s1,4(s0)
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
      set_foot(remainder, remainder_size);
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   1278c:	00098513          	mv	a0,s3

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
   12790:	00f92a23          	sw	a5,20(s2)
   12794:	00f92823          	sw	a5,16(s2)
   12798:	0107a623          	sw	a6,12(a5)
   1279c:	0107a423          	sw	a6,8(a5)
      set_head(remainder, remainder_size | PREV_INUSE);
   127a0:	00c7a223          	sw	a2,4(a5)
      set_foot(remainder, remainder_size);
   127a4:	00e6a023          	sw	a4,0(a3)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   127a8:	534000ef          	jal	12cdc <__malloc_unlock>
      return chunk2mem(victim);
   127ac:	00840513          	addi	a0,s0,8
   127b0:	cf5ff06f          	j	124a4 <_malloc_r+0x258>
   127b4:	00492783          	lw	a5,4(s2)
   127b8:	bc5ff06f          	j	1237c <_malloc_r+0x130>
         {
           bin = next_bin(bin);
           ++idx;
         }
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
   127bc:	00128293          	addi	t0,t0,1
   127c0:	0032f793          	andi	a5,t0,3
            return chunk2mem(victim);
          }

        }

       bin = next_bin(bin);
   127c4:	00858593          	addi	a1,a1,8
         {
           bin = next_bin(bin);
           ++idx;
         }
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
   127c8:	c00792e3          	bnez	a5,123cc <_malloc_r+0x180>
   127cc:	0880006f          	j	12854 <_malloc_r+0x608>
#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
    {
      q = next_bin(q);
      victim = last(q);
   127d0:	00c7a403          	lw	s0,12(a5)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
      return chunk2mem(victim);
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
   127d4:	00268693          	addi	a3,a3,2
    {
      q = next_bin(q);
      victim = last(q);
    }
#endif
    if (victim != q)
   127d8:	b28788e3          	beq	a5,s0,12308 <_malloc_r+0xbc>
   127dc:	c95ff06f          	j	12470 <_malloc_r+0x224>
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
   127e0:	00f407b3          	add	a5,s0,a5
   127e4:	0047a703          	lw	a4,4(a5)
            unlink(victim, bck, fwd);
   127e8:	00c42683          	lw	a3,12(s0)
   127ec:	00842603          	lw	a2,8(s0)
            return chunk2mem(victim);
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
   127f0:	00176713          	ori	a4,a4,1
   127f4:	00e7a223          	sw	a4,4(a5)
            unlink(victim, bck, fwd);
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   127f8:	00098513          	mv	a0,s3
          }

          else if (remainder_size >= 0)  /* take */
          {
            set_inuse_bit_at_offset(victim, victim_size);
            unlink(victim, bck, fwd);
   127fc:	00d62623          	sw	a3,12(a2)
   12800:	00c6a423          	sw	a2,8(a3)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   12804:	4d8000ef          	jal	12cdc <__malloc_unlock>
            return chunk2mem(victim);
   12808:	00840513          	addi	a0,s0,8
   1280c:	c99ff06f          	j	124a4 <_malloc_r+0x258>
   12810:	05c78513          	addi	a0,a5,92
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   12814:	05b78593          	addi	a1,a5,91
   12818:	00151693          	slli	a3,a0,0x1
   1281c:	a9dff06f          	j	122b8 <_malloc_r+0x6c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   12820:	0067d613          	srli	a2,a5,0x6
   12824:	03960593          	addi	a1,a2,57
   12828:	00159593          	slli	a1,a1,0x1
   1282c:	03860613          	addi	a2,a2,56
   12830:	f05ff06f          	j	12734 <_malloc_r+0x4e8>

  brk = (char*)(MORECORE (sbrk_size));

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
      (brk < old_end && old_top != initial_top))
   12834:	d92406e3          	beq	s0,s2,125c0 <_malloc_r+0x374>
   12838:	00892403          	lw	s0,8(s2)
   1283c:	00442703          	lw	a4,4(s0)
   12840:	ffc77713          	andi	a4,a4,-4
   12844:	e65ff06f          	j	126a8 <_malloc_r+0x45c>
          binblocks &= ~block;
          break;
        }
        --startidx;
       q = prev_bin(q);
      } while (first(q) == q);
   12848:	0088a783          	lw	a5,8(a7)
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
        {
          binblocks &= ~block;
          break;
        }
        --startidx;
   1284c:	fff68693          	addi	a3,a3,-1
       q = prev_bin(q);
      } while (first(q) == q);
   12850:	14f89e63          	bne	a7,a5,129ac <_malloc_r+0x760>

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
   12854:	0036f793          	andi	a5,a3,3
        {
          binblocks &= ~block;
          break;
        }
        --startidx;
       q = prev_bin(q);
   12858:	ff888893          	addi	a7,a7,-8

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
   1285c:	fe0796e3          	bnez	a5,12848 <_malloc_r+0x5fc>
        {
          binblocks &= ~block;
   12860:	00492783          	lw	a5,4(s2)
   12864:	fff64713          	not	a4,a2
   12868:	00f777b3          	and	a5,a4,a5
   1286c:	00f92223          	sw	a5,4(s2)
       q = prev_bin(q);
      } while (first(q) == q);

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
   12870:	00161613          	slli	a2,a2,0x1
   12874:	cec7e4e3          	bltu	a5,a2,1255c <_malloc_r+0x310>
   12878:	ce0602e3          	beqz	a2,1255c <_malloc_r+0x310>
      {
        while ((block & binblocks) == 0)
   1287c:	00f67733          	and	a4,a2,a5
   12880:	00028693          	mv	a3,t0
   12884:	b2071ce3          	bnez	a4,123bc <_malloc_r+0x170>
        {
          idx += BINBLOCKWIDTH;
          block <<= 1;
   12888:	00161613          	slli	a2,a2,0x1

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
   1288c:	00f67733          	and	a4,a2,a5
        {
          idx += BINBLOCKWIDTH;
   12890:	00468693          	addi	a3,a3,4

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
   12894:	fe070ae3          	beqz	a4,12888 <_malloc_r+0x63c>
   12898:	b25ff06f          	j	123bc <_malloc_r+0x170>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   1289c:	15400713          	li	a4,340
   128a0:	04f76263          	bltu	a4,a5,128e4 <_malloc_r+0x698>
   128a4:	00f4d593          	srli	a1,s1,0xf
   128a8:	07858513          	addi	a0,a1,120
   128ac:	00151693          	slli	a3,a0,0x1
   128b0:	07758593          	addi	a1,a1,119
   128b4:	a05ff06f          	j	122b8 <_malloc_r+0x6c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   128b8:	00492703          	lw	a4,4(s2)
   128bc:	40265613          	srai	a2,a2,0x2
   128c0:	00100793          	li	a5,1
   128c4:	00c797b3          	sll	a5,a5,a2
   128c8:	00e7e7b3          	or	a5,a5,a4
   128cc:	00f92223          	sw	a5,4(s2)
   128d0:	00058713          	mv	a4,a1
   128d4:	e91ff06f          	j	12764 <_malloc_r+0x518>
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE) 
      {
        set_head(top, PREV_INUSE); /* will force null return from malloc */
   128d8:	00100793          	li	a5,1
   128dc:	00fba223          	sw	a5,4(s7)
   128e0:	dd9ff06f          	j	126b8 <_malloc_r+0x46c>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
   128e4:	55400713          	li	a4,1364
   128e8:	0fe00693          	li	a3,254
   128ec:	07f00513          	li	a0,127
   128f0:	07e00593          	li	a1,126
   128f4:	9cf762e3          	bltu	a4,a5,122b8 <_malloc_r+0x6c>
   128f8:	0124d593          	srli	a1,s1,0x12
   128fc:	07d58513          	addi	a0,a1,125
   12900:	00151693          	slli	a3,a0,0x1
   12904:	07c58593          	addi	a1,a1,124
   12908:	9b1ff06f          	j	122b8 <_malloc_r+0x6c>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   1290c:	05400613          	li	a2,84
   12910:	04e66e63          	bltu	a2,a4,1296c <_malloc_r+0x720>
   12914:	00c7d613          	srli	a2,a5,0xc
   12918:	06f60593          	addi	a1,a2,111
   1291c:	00159593          	slli	a1,a1,0x1
   12920:	06e60613          	addi	a2,a2,110
   12924:	e11ff06f          	j	12734 <_malloc_r+0x4e8>

  sbrked_mem += sbrk_size;

  if (brk == old_end /* can just add bytes to current top, unless
			previous correction failed */
      && ((POINTER_UINT)old_end & (pagesz - 1)) == 0)
   12928:	014b1793          	slli	a5,s6,0x14
   1292c:	ca0794e3          	bnez	a5,125d4 <_malloc_r+0x388>
  {
    top_size = sbrk_size + old_top_size;
    set_head(top, top_size | PREV_INUSE);
   12930:	00892783          	lw	a5,8(s2)
   12934:	014a8a33          	add	s4,s5,s4
   12938:	001a6a13          	ori	s4,s4,1
   1293c:	0147a223          	sw	s4,4(a5)
   12940:	d45ff06f          	j	12684 <_malloc_r+0x438>
    /* Guarantee the next brk will be at a page boundary */
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE))
   12944:	00100793          	li	a5,1
      {
	correction = 0;
   12948:	00000a13          	li	s4,0
   1294c:	cedff06f          	j	12638 <_malloc_r+0x3ec>
    set_head(top, top_size | PREV_INUSE);
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
      sbrk_base = brk;
   12950:	8171aa23          	sw	s7,-2028(gp) # 158b4 <__malloc_sbrk_base>
   12954:	c99ff06f          	j	125ec <_malloc_r+0x3a0>
        SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
        SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE) 
        fREe(RCALL chunk2mem(old_top));
   12958:	00840593          	addi	a1,s0,8
   1295c:	00098513          	mv	a0,s3
   12960:	1dc010ef          	jal	13b3c <_free_r>
   12964:	000c2703          	lw	a4,0(s8)
   12968:	d1dff06f          	j	12684 <_malloc_r+0x438>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   1296c:	15400613          	li	a2,340
   12970:	00e66c63          	bltu	a2,a4,12988 <_malloc_r+0x73c>
   12974:	00f7d613          	srli	a2,a5,0xf
   12978:	07860593          	addi	a1,a2,120
   1297c:	00159593          	slli	a1,a1,0x1
   12980:	07760613          	addi	a2,a2,119
   12984:	db1ff06f          	j	12734 <_malloc_r+0x4e8>
   12988:	55400513          	li	a0,1364
   1298c:	0fe00593          	li	a1,254
   12990:	07e00613          	li	a2,126
   12994:	dae560e3          	bltu	a0,a4,12734 <_malloc_r+0x4e8>
   12998:	0127d613          	srli	a2,a5,0x12
   1299c:	07d60593          	addi	a1,a2,125
   129a0:	00159593          	slli	a1,a1,0x1
   129a4:	07c60613          	addi	a2,a2,124
   129a8:	d8dff06f          	j	12734 <_malloc_r+0x4e8>
   129ac:	00492783          	lw	a5,4(s2)
   129b0:	ec1ff06f          	j	12870 <_malloc_r+0x624>
   129b4:	0034d693          	srli	a3,s1,0x3
   129b8:	00168793          	addi	a5,a3,1
   129bc:	00179793          	slli	a5,a5,0x1
   129c0:	a95ff06f          	j	12454 <_malloc_r+0x208>

000129c4 <memchr>:
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   129c4:	00357793          	andi	a5,a0,3
	_CONST _PTR src_void _AND
	int c _AND
	size_t length)
{
  _CONST unsigned char *src = (_CONST unsigned char *) src_void;
  unsigned char d = c;
   129c8:	0ff5f693          	andi	a3,a1,255
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   129cc:	0c078063          	beqz	a5,12a8c <memchr+0xc8>
    {
      if (!length--)
   129d0:	fff60793          	addi	a5,a2,-1
   129d4:	06060063          	beqz	a2,12a34 <memchr+0x70>
        return NULL;
      if (*src == d)
   129d8:	00054703          	lbu	a4,0(a0)
   129dc:	00d71c63          	bne	a4,a3,129f4 <memchr+0x30>
   129e0:	0b40006f          	j	12a94 <memchr+0xd0>
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
    {
      if (!length--)
   129e4:	04078863          	beqz	a5,12a34 <memchr+0x70>
        return NULL;
      if (*src == d)
   129e8:	00054703          	lbu	a4,0(a0)
   129ec:	fff78793          	addi	a5,a5,-1
   129f0:	04d70463          	beq	a4,a3,12a38 <memchr+0x74>
        return (void *) src;
      src++;
   129f4:	00150513          	addi	a0,a0,1
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   129f8:	00357713          	andi	a4,a0,3
   129fc:	fe0714e3          	bnez	a4,129e4 <memchr+0x20>
      if (*src == d)
        return (void *) src;
      src++;
    }

  if (!TOO_SMALL (length))
   12a00:	00300813          	li	a6,3
   12a04:	02f86c63          	bltu	a6,a5,12a3c <memchr+0x78>
      src = (unsigned char *) asrc;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
   12a08:	02078663          	beqz	a5,12a34 <memchr+0x70>
    {
      if (*src == d)
   12a0c:	00054703          	lbu	a4,0(a0)
   12a10:	02d70463          	beq	a4,a3,12a38 <memchr+0x74>
   12a14:	00150713          	addi	a4,a0,1
   12a18:	00f507b3          	add	a5,a0,a5
   12a1c:	0100006f          	j	12a2c <memchr+0x68>
   12a20:	00170713          	addi	a4,a4,1
   12a24:	fff74603          	lbu	a2,-1(a4)
   12a28:	00d60863          	beq	a2,a3,12a38 <memchr+0x74>
        return (void *) src;
      src++;
   12a2c:	00070513          	mv	a0,a4
      src = (unsigned char *) asrc;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
   12a30:	fee798e3          	bne	a5,a4,12a20 <memchr+0x5c>
  unsigned int i;

  while (UNALIGNED (src))
    {
      if (!length--)
        return NULL;
   12a34:	00000513          	li	a0,0
        return (void *) src;
      src++;
    }

  return NULL;
}
   12a38:	00008067          	ret
   12a3c:	0ff5f593          	andi	a1,a1,255
         contain the search character, which is detected by XORing
         the word-sized segment with a word-sized block of the search
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
      mask = d << 8 | d;
   12a40:	00859713          	slli	a4,a1,0x8
   12a44:	00b765b3          	or	a1,a4,a1
      mask = mask << 16 | mask;
   12a48:	01059713          	slli	a4,a1,0x10
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
        {
          if (DETECTCHAR (*asrc, mask))
   12a4c:	feff02b7          	lui	t0,0xfeff0
   12a50:	808088b7          	lui	a7,0x80808
         the word-sized segment with a word-sized block of the search
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
      mask = d << 8 | d;
      mask = mask << 16 | mask;
   12a54:	00e5e5b3          	or	a1,a1,a4
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
        {
          if (DETECTCHAR (*asrc, mask))
   12a58:	eff28293          	addi	t0,t0,-257 # fefefeff <_gp+0xfefd9e5f>
   12a5c:	08088893          	addi	a7,a7,128 # 80808080 <_gp+0x807f1fe0>
   12a60:	00052703          	lw	a4,0(a0)
   12a64:	00e5c733          	xor	a4,a1,a4
   12a68:	00570633          	add	a2,a4,t0
   12a6c:	fff74713          	not	a4,a4
   12a70:	00e67733          	and	a4,a2,a4
   12a74:	01177733          	and	a4,a4,a7
   12a78:	f8071ae3          	bnez	a4,12a0c <memchr+0x48>
            break;
          length -= LBLOCKSIZE;
   12a7c:	ffc78793          	addi	a5,a5,-4
          asrc++;
   12a80:	00450513          	addi	a0,a0,4
      mask = d << 8 | d;
      mask = mask << 16 | mask;
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
   12a84:	fcf86ee3          	bltu	a6,a5,12a60 <memchr+0x9c>
   12a88:	f81ff06f          	j	12a08 <memchr+0x44>
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
   12a8c:	00060793          	mv	a5,a2
   12a90:	f71ff06f          	j	12a00 <memchr+0x3c>
   12a94:	00008067          	ret

00012a98 <memcpy>:

  char* a = (char*)aa;
  const char* b = (const char*)bb;
  char* end = a+n;
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
   12a98:	00a5c7b3          	xor	a5,a1,a0
   12a9c:	0037f793          	andi	a5,a5,3
    *(a-1) = tt; \
  }

  char* a = (char*)aa;
  const char* b = (const char*)bb;
  char* end = a+n;
   12aa0:	00c508b3          	add	a7,a0,a2
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
   12aa4:	0e079263          	bnez	a5,12b88 <memcpy+0xf0>
   12aa8:	00300793          	li	a5,3
   12aac:	0ec7fe63          	bleu	a2,a5,12ba8 <memcpy+0x110>
      while (a < end)
        BODY(a, b, char);
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
   12ab0:	00357793          	andi	a5,a0,3
   12ab4:	04079a63          	bnez	a5,12b08 <memcpy+0x70>
    while ((uintptr_t)a & msk)
      BODY(a, b, char);

  long* la = (long*)a;
  const long* lb = (const long*)b;
  long* lend = (long*)((uintptr_t)end & ~msk);
   12ab8:	ffc8f813          	andi	a6,a7,-4

  if (__builtin_expect(la < lend-8, 0))
   12abc:	fe080793          	addi	a5,a6,-32
   12ac0:	00050713          	mv	a4,a0
   12ac4:	06f56663          	bltu	a0,a5,12b30 <memcpy+0x98>
      *la++ = b7;
      *la++ = b8;
    }
  }

  while (la < lend)
   12ac8:	00058693          	mv	a3,a1
   12acc:	00070793          	mv	a5,a4
   12ad0:	03077863          	bleu	a6,a4,12b00 <memcpy+0x68>
    BODY(la, lb, long);
   12ad4:	0006a603          	lw	a2,0(a3)
   12ad8:	00478793          	addi	a5,a5,4
   12adc:	00468693          	addi	a3,a3,4
   12ae0:	fec7ae23          	sw	a2,-4(a5)
      *la++ = b7;
      *la++ = b8;
    }
  }

  while (la < lend)
   12ae4:	ff07e8e3          	bltu	a5,a6,12ad4 <memcpy+0x3c>
   12ae8:	fff74793          	not	a5,a4
   12aec:	01078833          	add	a6,a5,a6
   12af0:	ffc87813          	andi	a6,a6,-4
   12af4:	00480813          	addi	a6,a6,4
   12af8:	01070733          	add	a4,a4,a6
   12afc:	010585b3          	add	a1,a1,a6
    BODY(la, lb, long);

  a = (char*)la;
  b = (const char*)lb;
  if (__builtin_expect(a < end, 0))
   12b00:	09176863          	bltu	a4,a7,12b90 <memcpy+0xf8>
    goto small;
  return aa;
}
   12b04:	00008067          	ret
   12b08:	00050713          	mv	a4,a0
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
    while ((uintptr_t)a & msk)
      BODY(a, b, char);
   12b0c:	0005c683          	lbu	a3,0(a1)
   12b10:	00170713          	addi	a4,a4,1
        BODY(a, b, char);
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
    while ((uintptr_t)a & msk)
   12b14:	00377793          	andi	a5,a4,3
      BODY(a, b, char);
   12b18:	00158593          	addi	a1,a1,1
   12b1c:	fed70fa3          	sb	a3,-1(a4)
        BODY(a, b, char);
    return aa;
  }

  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
    while ((uintptr_t)a & msk)
   12b20:	fe0796e3          	bnez	a5,12b0c <memcpy+0x74>
      BODY(a, b, char);

  long* la = (long*)a;
  const long* lb = (const long*)b;
  long* lend = (long*)((uintptr_t)end & ~msk);
   12b24:	ffc8f813          	andi	a6,a7,-4

  if (__builtin_expect(la < lend-8, 0))
   12b28:	fe080793          	addi	a5,a6,-32
   12b2c:	f8f77ee3          	bleu	a5,a4,12ac8 <memcpy+0x30>
  {
    while (la < lend-8)
    {
      long b0 = *lb++;
   12b30:	0005af83          	lw	t6,0(a1)
      long b1 = *lb++;
   12b34:	0045af03          	lw	t5,4(a1)
      long b2 = *lb++;
   12b38:	0085ae83          	lw	t4,8(a1)
      long b3 = *lb++;
   12b3c:	00c5ae03          	lw	t3,12(a1)
      long b4 = *lb++;
   12b40:	0105a383          	lw	t2,16(a1)
      long b5 = *lb++;
   12b44:	0145a303          	lw	t1,20(a1)
      long b6 = *lb++;
   12b48:	0185a283          	lw	t0,24(a1)
      long b7 = *lb++;
   12b4c:	01c5a603          	lw	a2,28(a1)
   12b50:	02458593          	addi	a1,a1,36
   12b54:	02470713          	addi	a4,a4,36
      long b8 = *lb++;
   12b58:	ffc5a683          	lw	a3,-4(a1)
      *la++ = b0;
   12b5c:	fdf72e23          	sw	t6,-36(a4)
      *la++ = b1;
   12b60:	ffe72023          	sw	t5,-32(a4)
      *la++ = b2;
   12b64:	ffd72223          	sw	t4,-28(a4)
      *la++ = b3;
   12b68:	ffc72423          	sw	t3,-24(a4)
      *la++ = b4;
   12b6c:	fe772623          	sw	t2,-20(a4)
      *la++ = b5;
   12b70:	fe672823          	sw	t1,-16(a4)
      *la++ = b6;
   12b74:	fe572a23          	sw	t0,-12(a4)
      *la++ = b7;
   12b78:	fec72c23          	sw	a2,-8(a4)
      *la++ = b8;
   12b7c:	fed72e23          	sw	a3,-4(a4)
  const long* lb = (const long*)b;
  long* lend = (long*)((uintptr_t)end & ~msk);

  if (__builtin_expect(la < lend-8, 0))
  {
    while (la < lend-8)
   12b80:	faf768e3          	bltu	a4,a5,12b30 <memcpy+0x98>
   12b84:	f45ff06f          	j	12ac8 <memcpy+0x30>
  char* end = a+n;
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
  {
small:
    if (__builtin_expect(a < end, 1))
   12b88:	00050713          	mv	a4,a0
   12b8c:	03157463          	bleu	a7,a0,12bb4 <memcpy+0x11c>
      while (a < end)
        BODY(a, b, char);
   12b90:	0005c783          	lbu	a5,0(a1)
   12b94:	00170713          	addi	a4,a4,1
   12b98:	00158593          	addi	a1,a1,1
   12b9c:	fef70fa3          	sb	a5,-1(a4)
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
  {
small:
    if (__builtin_expect(a < end, 1))
      while (a < end)
   12ba0:	ff1768e3          	bltu	a4,a7,12b90 <memcpy+0xf8>
   12ba4:	00008067          	ret
   12ba8:	00050713          	mv	a4,a0
  char* end = a+n;
  uintptr_t msk = sizeof(long)-1;
  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
  {
small:
    if (__builtin_expect(a < end, 1))
   12bac:	ff1562e3          	bltu	a0,a7,12b90 <memcpy+0xf8>
   12bb0:	f55ff06f          	j	12b04 <memcpy+0x6c>
   12bb4:	00008067          	ret

00012bb8 <memmove>:
  char *dst = dst_void;
  _CONST char *src = src_void;
  long *aligned_dst;
  _CONST long *aligned_src;

  if (src < dst && dst < src + length)
   12bb8:	02a5f863          	bleu	a0,a1,12be8 <memmove+0x30>
   12bbc:	00c58733          	add	a4,a1,a2
   12bc0:	02e57463          	bleu	a4,a0,12be8 <memmove+0x30>
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
      dst += length;
   12bc4:	00c507b3          	add	a5,a0,a2
   12bc8:	40c785b3          	sub	a1,a5,a2
      while (length--)
   12bcc:	0e060263          	beqz	a2,12cb0 <memmove+0xf8>
	{
	  *--dst = *--src;
   12bd0:	fff70713          	addi	a4,a4,-1
   12bd4:	00074683          	lbu	a3,0(a4)
   12bd8:	fff78793          	addi	a5,a5,-1
   12bdc:	00d78023          	sb	a3,0(a5)
  if (src < dst && dst < src + length)
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
      dst += length;
      while (length--)
   12be0:	fef598e3          	bne	a1,a5,12bd0 <memmove+0x18>
   12be4:	00008067          	ret
  else
    {
      /* Use optimizing algorithm for a non-destructive copy to closely 
         match memcpy. If the size is small or either SRC or DST is unaligned,
         then punt into the byte copy loop.  This should be rare.  */
      if (!TOO_SMALL(length) && !UNALIGNED (src, dst))
   12be8:	00f00893          	li	a7,15
   12bec:	0cc8f463          	bleu	a2,a7,12cb4 <memmove+0xfc>
   12bf0:	00a5e7b3          	or	a5,a1,a0
   12bf4:	0037f793          	andi	a5,a5,3
   12bf8:	0c079463          	bnez	a5,12cc0 <memmove+0x108>
   12bfc:	00058713          	mv	a4,a1
   12c00:	00050793          	mv	a5,a0
   12c04:	00060693          	mv	a3,a2
          aligned_src = (long*)src;

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
            {
              *aligned_dst++ = *aligned_src++;
   12c08:	00072803          	lw	a6,0(a4)
   12c0c:	01078793          	addi	a5,a5,16
   12c10:	01070713          	addi	a4,a4,16
   12c14:	ff07a823          	sw	a6,-16(a5)
              *aligned_dst++ = *aligned_src++;
   12c18:	ff472803          	lw	a6,-12(a4)
              *aligned_dst++ = *aligned_src++;
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
   12c1c:	ff068693          	addi	a3,a3,-16

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
            {
              *aligned_dst++ = *aligned_src++;
              *aligned_dst++ = *aligned_src++;
   12c20:	ff07aa23          	sw	a6,-12(a5)
              *aligned_dst++ = *aligned_src++;
   12c24:	ff872803          	lw	a6,-8(a4)
   12c28:	ff07ac23          	sw	a6,-8(a5)
              *aligned_dst++ = *aligned_src++;
   12c2c:	ffc72803          	lw	a6,-4(a4)
   12c30:	ff07ae23          	sw	a6,-4(a5)
        {
          aligned_dst = (long*)dst;
          aligned_src = (long*)src;

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
   12c34:	fcd8eae3          	bltu	a7,a3,12c08 <memmove+0x50>
   12c38:	ff060713          	addi	a4,a2,-16
   12c3c:	ff077713          	andi	a4,a4,-16
   12c40:	01070713          	addi	a4,a4,16
   12c44:	00f67313          	andi	t1,a2,15
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   12c48:	00300293          	li	t0,3
   12c4c:	00e507b3          	add	a5,a0,a4
   12c50:	00e585b3          	add	a1,a1,a4
   12c54:	0662fc63          	bleu	t1,t0,12ccc <memmove+0x114>
   12c58:	00058813          	mv	a6,a1
   12c5c:	00078693          	mv	a3,a5
   12c60:	00030713          	mv	a4,t1
            {
              *aligned_dst++ = *aligned_src++;
   12c64:	00480813          	addi	a6,a6,4
   12c68:	ffc82883          	lw	a7,-4(a6)
   12c6c:	00468693          	addi	a3,a3,4
              length -= LITTLEBLOCKSIZE;
   12c70:	ffc70713          	addi	a4,a4,-4
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
            {
              *aligned_dst++ = *aligned_src++;
   12c74:	ff16ae23          	sw	a7,-4(a3)
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   12c78:	fee2e6e3          	bltu	t0,a4,12c64 <memmove+0xac>
   12c7c:	ffc30713          	addi	a4,t1,-4
   12c80:	ffc77713          	andi	a4,a4,-4
   12c84:	00470713          	addi	a4,a4,4
   12c88:	00367613          	andi	a2,a2,3
   12c8c:	00e787b3          	add	a5,a5,a4
   12c90:	00e585b3          	add	a1,a1,a4
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   12c94:	02060a63          	beqz	a2,12cc8 <memmove+0x110>
   12c98:	00c78633          	add	a2,a5,a2
        {
          *dst++ = *src++;
   12c9c:	00158593          	addi	a1,a1,1
   12ca0:	fff5c703          	lbu	a4,-1(a1)
   12ca4:	00178793          	addi	a5,a5,1
   12ca8:	fee78fa3          	sb	a4,-1(a5)
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   12cac:	fec798e3          	bne	a5,a2,12c9c <memmove+0xe4>
        }
    }

  return dst_void;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   12cb0:	00008067          	ret
   12cb4:	00050793          	mv	a5,a0
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   12cb8:	fe0610e3          	bnez	a2,12c98 <memmove+0xe0>
   12cbc:	00c0006f          	j	12cc8 <memmove+0x110>
   12cc0:	00050793          	mv	a5,a0
   12cc4:	fd5ff06f          	j	12c98 <memmove+0xe0>
   12cc8:	00008067          	ret
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   12ccc:	00030613          	mv	a2,t1
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   12cd0:	fc0614e3          	bnez	a2,12c98 <memmove+0xe0>
   12cd4:	ff5ff06f          	j	12cc8 <memmove+0x110>

00012cd8 <__malloc_lock>:
   12cd8:	00008067          	ret

00012cdc <__malloc_unlock>:
}

void
__malloc_unlock (ptr)
     struct _reent *ptr;
{
   12cdc:	00008067          	ret

00012ce0 <_realloc_r>:
#if __STD_C
Void_t* rEALLOc(RARG Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(RARG oldmem, bytes) RDECL Void_t* oldmem; size_t bytes;
#endif
{
   12ce0:	fd010113          	addi	sp,sp,-48
   12ce4:	01312e23          	sw	s3,28(sp)
   12ce8:	02112623          	sw	ra,44(sp)
   12cec:	02812423          	sw	s0,40(sp)
   12cf0:	02912223          	sw	s1,36(sp)
   12cf4:	03212023          	sw	s2,32(sp)
   12cf8:	01412c23          	sw	s4,24(sp)
   12cfc:	01512a23          	sw	s5,20(sp)
   12d00:	01612823          	sw	s6,16(sp)
   12d04:	01712623          	sw	s7,12(sp)
   12d08:	01812423          	sw	s8,8(sp)
   12d0c:	01912223          	sw	s9,4(sp)
   12d10:	00060993          	mv	s3,a2
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
   12d14:	1c058863          	beqz	a1,12ee4 <_realloc_r+0x204>
   12d18:	00058a13          	mv	s4,a1
   12d1c:	00050493          	mv	s1,a0

  MALLOC_LOCK;
   12d20:	fb9ff0ef          	jal	12cd8 <__malloc_lock>

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
   12d24:	ffca2783          	lw	a5,-4(s4)


  nb = request2size(bytes);
   12d28:	00b98713          	addi	a4,s3,11
   12d2c:	01600693          	li	a3,22
  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);

  MALLOC_LOCK;

  newp    = oldp    = mem2chunk(oldmem);
   12d30:	ff8a0b13          	addi	s6,s4,-8
  newsize = oldsize = chunksize(oldp);
   12d34:	ffc7fa93          	andi	s5,a5,-4


  nb = request2size(bytes);
   12d38:	0ce6f263          	bleu	a4,a3,12dfc <_realloc_r+0x11c>
   12d3c:	ff877913          	andi	s2,a4,-8

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   12d40:	00090713          	mv	a4,s2
   12d44:	14094c63          	bltz	s2,12e9c <_realloc_r+0x1bc>
   12d48:	15396a63          	bltu	s2,s3,12e9c <_realloc_r+0x1bc>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
   12d4c:	0aeade63          	ble	a4,s5,12e08 <_realloc_r+0x128>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next)) 
   12d50:	00015c37          	lui	s8,0x15
   12d54:	490c0c13          	addi	s8,s8,1168 # 15490 <__malloc_av_>
   12d58:	008c2683          	lw	a3,8(s8)
  if ((long)(oldsize) < (long)(nb))  
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
   12d5c:	015b0533          	add	a0,s6,s5
    if (next == top || !inuse(next)) 
   12d60:	30d50263          	beq	a0,a3,13064 <_realloc_r+0x384>
   12d64:	00452683          	lw	a3,4(a0)
   12d68:	ffe6f613          	andi	a2,a3,-2
   12d6c:	00c50633          	add	a2,a0,a2
   12d70:	00462603          	lw	a2,4(a2)
   12d74:	00167613          	andi	a2,a2,1
   12d78:	0e060e63          	beqz	a2,12e74 <_realloc_r+0x194>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   12d7c:	0017f793          	andi	a5,a5,1
   12d80:	26078463          	beqz	a5,12fe8 <_realloc_r+0x308>
      }
    }

    /* Must allocate */

    newmem = mALLOc (RCALL bytes);
   12d84:	00098593          	mv	a1,s3
   12d88:	00048513          	mv	a0,s1
   12d8c:	cc0ff0ef          	jal	1224c <_malloc_r>
   12d90:	00050413          	mv	s0,a0

    if (newmem == 0)  /* propagate failure */
   12d94:	4a050463          	beqz	a0,1323c <_realloc_r+0x55c>
    }

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
   12d98:	ffca2783          	lw	a5,-4(s4)
   12d9c:	ff850693          	addi	a3,a0,-8
   12da0:	ffe7f713          	andi	a4,a5,-2
   12da4:	00eb0733          	add	a4,s6,a4
   12da8:	42e68463          	beq	a3,a4,131d0 <_realloc_r+0x4f0>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12dac:	ffca8613          	addi	a2,s5,-4
   12db0:	02400793          	li	a5,36
   12db4:	3cc7ea63          	bltu	a5,a2,13188 <_realloc_r+0x4a8>
   12db8:	01300713          	li	a4,19
   12dbc:	36c76a63          	bltu	a4,a2,13130 <_realloc_r+0x450>
   12dc0:	00050793          	mv	a5,a0
   12dc4:	000a0713          	mv	a4,s4
   12dc8:	00072683          	lw	a3,0(a4)
   12dcc:	00d7a023          	sw	a3,0(a5)
   12dd0:	00472683          	lw	a3,4(a4)
   12dd4:	00d7a223          	sw	a3,4(a5)
   12dd8:	00872703          	lw	a4,8(a4)
   12ddc:	00e7a423          	sw	a4,8(a5)
    fREe(RCALL oldmem);
   12de0:	000a0593          	mv	a1,s4
   12de4:	00048513          	mv	a0,s1
   12de8:	555000ef          	jal	13b3c <_free_r>
    MALLOC_UNLOCK;
   12dec:	00048513          	mv	a0,s1
   12df0:	eedff0ef          	jal	12cdc <__malloc_unlock>
    return newmem;
   12df4:	00040513          	mv	a0,s0
   12df8:	0480006f          	j	12e40 <_realloc_r+0x160>


  nb = request2size(bytes);

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   12dfc:	01000713          	li	a4,16

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);


  nb = request2size(bytes);
   12e00:	00070913          	mv	s2,a4
   12e04:	f45ff06f          	j	12d48 <_realloc_r+0x68>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
   12e08:	000a0993          	mv	s3,s4
  }


 split:  /* split off extra room in old or expanded chunk */

  remainder_size = long_sub_size_t(newsize, nb);
   12e0c:	412a86b3          	sub	a3,s5,s2

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
   12e10:	00f00713          	li	a4,15
   12e14:	08d76c63          	bltu	a4,a3,12eac <_realloc_r+0x1cc>
    set_inuse_bit_at_offset(remainder, remainder_size);
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
  }
  else
  {
    set_head_size(newp, newsize);
   12e18:	0017f793          	andi	a5,a5,1
   12e1c:	0157e7b3          	or	a5,a5,s5
   12e20:	00fb2223          	sw	a5,4(s6) # 80000004 <_gp+0x7ffe9f64>
    set_inuse_bit_at_offset(newp, newsize);
   12e24:	015b0633          	add	a2,s6,s5
   12e28:	00462783          	lw	a5,4(a2)
   12e2c:	0017e793          	ori	a5,a5,1
   12e30:	00f62223          	sw	a5,4(a2)
  }

  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
   12e34:	00048513          	mv	a0,s1
   12e38:	ea5ff0ef          	jal	12cdc <__malloc_unlock>
  return chunk2mem(newp);
   12e3c:	00098513          	mv	a0,s3

#endif /* MALLOC_PROVIDED */
}
   12e40:	02c12083          	lw	ra,44(sp)
   12e44:	02812403          	lw	s0,40(sp)
   12e48:	02412483          	lw	s1,36(sp)
   12e4c:	02012903          	lw	s2,32(sp)
   12e50:	01c12983          	lw	s3,28(sp)
   12e54:	01812a03          	lw	s4,24(sp)
   12e58:	01412a83          	lw	s5,20(sp)
   12e5c:	01012b03          	lw	s6,16(sp)
   12e60:	00c12b83          	lw	s7,12(sp)
   12e64:	00812c03          	lw	s8,8(sp)
   12e68:	00412c83          	lw	s9,4(sp)
   12e6c:	03010113          	addi	sp,sp,48
   12e70:	00008067          	ret
          return chunk2mem(oldp);
        }
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
   12e74:	ffc6f693          	andi	a3,a3,-4
   12e78:	015686b3          	add	a3,a3,s5
   12e7c:	0ae6c063          	blt	a3,a4,12f1c <_realloc_r+0x23c>
      { 
        unlink(next, bck, fwd);
   12e80:	00c52703          	lw	a4,12(a0)
   12e84:	00852603          	lw	a2,8(a0)
        newsize  += nextsize;
        goto split;
   12e88:	000a0993          	mv	s3,s4

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
      { 
        unlink(next, bck, fwd);
        newsize  += nextsize;
   12e8c:	00068a93          	mv	s5,a3
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
      { 
        unlink(next, bck, fwd);
   12e90:	00e62623          	sw	a4,12(a2)
   12e94:	00c72423          	sw	a2,8(a4)
        newsize  += nextsize;
        goto split;
   12e98:	f75ff06f          	j	12e0c <_realloc_r+0x12c>
  nb = request2size(bytes);

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
  {
    RERRNO = ENOMEM;
   12e9c:	00c00793          	li	a5,12
   12ea0:	00f4a023          	sw	a5,0(s1)
    return 0;
   12ea4:	00000513          	li	a0,0
   12ea8:	f99ff06f          	j	12e40 <_realloc_r+0x160>
  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
   12eac:	0017f713          	andi	a4,a5,1

  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
   12eb0:	012b05b3          	add	a1,s6,s2
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
   12eb4:	0016e793          	ori	a5,a3,1
  remainder_size = long_sub_size_t(newsize, nb);

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
   12eb8:	01276733          	or	a4,a4,s2
   12ebc:	00eb2223          	sw	a4,4(s6)
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
   12ec0:	00d586b3          	add	a3,a1,a3

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
   12ec4:	00f5a223          	sw	a5,4(a1)
    set_inuse_bit_at_offset(remainder, remainder_size);
   12ec8:	0046a783          	lw	a5,4(a3)
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
   12ecc:	00858593          	addi	a1,a1,8
   12ed0:	00048513          	mv	a0,s1
  if (remainder_size >= (long)MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
   12ed4:	0017e793          	ori	a5,a5,1
   12ed8:	00f6a223          	sw	a5,4(a3)
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
   12edc:	461000ef          	jal	13b3c <_free_r>
   12ee0:	f55ff06f          	j	12e34 <_realloc_r+0x154>
  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
  return chunk2mem(newp);

#endif /* MALLOC_PROVIDED */
}
   12ee4:	02c12083          	lw	ra,44(sp)
   12ee8:	02812403          	lw	s0,40(sp)
   12eec:	02412483          	lw	s1,36(sp)
   12ef0:	02012903          	lw	s2,32(sp)
   12ef4:	01c12983          	lw	s3,28(sp)
   12ef8:	01812a03          	lw	s4,24(sp)
   12efc:	01412a83          	lw	s5,20(sp)
   12f00:	01012b03          	lw	s6,16(sp)
   12f04:	00c12b83          	lw	s7,12(sp)
   12f08:	00812c03          	lw	s8,8(sp)
   12f0c:	00412c83          	lw	s9,4(sp)
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
   12f10:	00060593          	mv	a1,a2
  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
  return chunk2mem(newp);

#endif /* MALLOC_PROVIDED */
}
   12f14:	03010113          	addi	sp,sp,48
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
   12f18:	b34ff06f          	j	1224c <_malloc_r>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   12f1c:	0017f793          	andi	a5,a5,1
   12f20:	e60792e3          	bnez	a5,12d84 <_realloc_r+0xa4>
    {
      prev = prev_chunk(oldp);
   12f24:	ff8a2b83          	lw	s7,-8(s4)
   12f28:	417b0bb3          	sub	s7,s6,s7
      prevsize = chunksize(prev);
   12f2c:	004ba783          	lw	a5,4(s7)
   12f30:	ffc7f793          	andi	a5,a5,-4
            return newmem;
          }
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
   12f34:	00f68433          	add	s0,a3,a5
   12f38:	0ce44063          	blt	s0,a4,12ff8 <_realloc_r+0x318>
        {
          unlink(next, bck, fwd);
   12f3c:	00c52783          	lw	a5,12(a0)
   12f40:	00852703          	lw	a4,8(a0)
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12f44:	ffca8613          	addi	a2,s5,-4
        {
          unlink(next, bck, fwd);
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
   12f48:	008b8993          	addi	s3,s7,8
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
        {
          unlink(next, bck, fwd);
   12f4c:	00f72623          	sw	a5,12(a4)
   12f50:	00e7a423          	sw	a4,8(a5)
          unlink(prev, bck, fwd);
   12f54:	008ba703          	lw	a4,8(s7)
   12f58:	00cba783          	lw	a5,12(s7)
   12f5c:	00f72623          	sw	a5,12(a4)
   12f60:	00e7a423          	sw	a4,8(a5)
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12f64:	02400793          	li	a5,36
   12f68:	22c7e663          	bltu	a5,a2,13194 <_realloc_r+0x4b4>
   12f6c:	01300713          	li	a4,19
   12f70:	00098793          	mv	a5,s3
   12f74:	04c77663          	bleu	a2,a4,12fc0 <_realloc_r+0x2e0>
   12f78:	000a2783          	lw	a5,0(s4)
   12f7c:	00fba423          	sw	a5,8(s7)
   12f80:	004a2783          	lw	a5,4(s4)
   12f84:	00fba623          	sw	a5,12(s7)
   12f88:	01b00793          	li	a5,27
   12f8c:	24c7fc63          	bleu	a2,a5,131e4 <_realloc_r+0x504>
   12f90:	008a2783          	lw	a5,8(s4)
   12f94:	00fba823          	sw	a5,16(s7)
   12f98:	00ca2783          	lw	a5,12(s4)
   12f9c:	00fbaa23          	sw	a5,20(s7)
   12fa0:	02400793          	li	a5,36
   12fa4:	0af61a63          	bne	a2,a5,13058 <_realloc_r+0x378>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12fa8:	010a2703          	lw	a4,16(s4)
   12fac:	020b8793          	addi	a5,s7,32
   12fb0:	018a0a13          	addi	s4,s4,24
   12fb4:	00ebac23          	sw	a4,24(s7)
   12fb8:	ffca2703          	lw	a4,-4(s4)
   12fbc:	00ebae23          	sw	a4,28(s7)
   12fc0:	000a2703          	lw	a4,0(s4)
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
   12fc4:	00040a93          	mv	s5,s0
   12fc8:	000b8b13          	mv	s6,s7
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   12fcc:	00e7a023          	sw	a4,0(a5)
   12fd0:	004a2703          	lw	a4,4(s4)
   12fd4:	00e7a223          	sw	a4,4(a5)
   12fd8:	008a2703          	lw	a4,8(s4)
   12fdc:	00e7a423          	sw	a4,8(a5)
   12fe0:	004ba783          	lw	a5,4(s7)
   12fe4:	e29ff06f          	j	12e0c <_realloc_r+0x12c>

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
    {
      prev = prev_chunk(oldp);
   12fe8:	ff8a2b83          	lw	s7,-8(s4)
   12fec:	417b0bb3          	sub	s7,s6,s7
      prevsize = chunksize(prev);
   12ff0:	004ba783          	lw	a5,4(s7)
   12ff4:	ffc7f793          	andi	a5,a5,-4
          goto split;
        }
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
   12ff8:	00fa8433          	add	s0,s5,a5
   12ffc:	d8e444e3          	blt	s0,a4,12d84 <_realloc_r+0xa4>
      {
        unlink(prev, bck, fwd);
   13000:	00cba783          	lw	a5,12(s7)
   13004:	008ba703          	lw	a4,8(s7)
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   13008:	ffca8613          	addi	a2,s5,-4
   1300c:	02400693          	li	a3,36
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
   13010:	00f72623          	sw	a5,12(a4)
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
   13014:	008b8993          	addi	s3,s7,8
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
   13018:	00e7a423          	sw	a4,8(a5)
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1301c:	16c6ec63          	bltu	a3,a2,13194 <_realloc_r+0x4b4>
   13020:	01300713          	li	a4,19
   13024:	00098793          	mv	a5,s3
   13028:	f8c77ce3          	bleu	a2,a4,12fc0 <_realloc_r+0x2e0>
   1302c:	000a2783          	lw	a5,0(s4)
   13030:	00fba423          	sw	a5,8(s7)
   13034:	004a2783          	lw	a5,4(s4)
   13038:	00fba623          	sw	a5,12(s7)
   1303c:	01b00793          	li	a5,27
   13040:	1ac7f263          	bleu	a2,a5,131e4 <_realloc_r+0x504>
   13044:	008a2783          	lw	a5,8(s4)
   13048:	00fba823          	sw	a5,16(s7)
   1304c:	00ca2783          	lw	a5,12(s4)
   13050:	00fbaa23          	sw	a5,20(s7)
   13054:	f4d60ae3          	beq	a2,a3,12fa8 <_realloc_r+0x2c8>
   13058:	018b8793          	addi	a5,s7,24
   1305c:	010a0a13          	addi	s4,s4,16
   13060:	f61ff06f          	j	12fc0 <_realloc_r+0x2e0>
      nextsize = chunksize(next);

      /* Forward into top only if a remainder */
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
   13064:	00452683          	lw	a3,4(a0)
   13068:	01090613          	addi	a2,s2,16
   1306c:	ffc6f693          	andi	a3,a3,-4
   13070:	015686b3          	add	a3,a3,s5
   13074:	0ec6d063          	ble	a2,a3,13154 <_realloc_r+0x474>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   13078:	0017f793          	andi	a5,a5,1
   1307c:	d00794e3          	bnez	a5,12d84 <_realloc_r+0xa4>
    {
      prev = prev_chunk(oldp);
   13080:	ff8a2b83          	lw	s7,-8(s4)
   13084:	417b0bb3          	sub	s7,s6,s7
      prevsize = chunksize(prev);
   13088:	004ba783          	lw	a5,4(s7)
   1308c:	ffc7f793          	andi	a5,a5,-4
      if (next != 0)
      {
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
   13090:	00d78cb3          	add	s9,a5,a3
   13094:	f6ccc2e3          	blt	s9,a2,12ff8 <_realloc_r+0x318>
          {
            unlink(prev, bck, fwd);
   13098:	00cba783          	lw	a5,12(s7)
   1309c:	008ba703          	lw	a4,8(s7)
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   130a0:	ffca8613          	addi	a2,s5,-4
   130a4:	02400693          	li	a3,36
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
          {
            unlink(prev, bck, fwd);
   130a8:	00f72623          	sw	a5,12(a4)
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
   130ac:	008b8413          	addi	s0,s7,8
        /* into top */
        if (next == top)
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
          {
            unlink(prev, bck, fwd);
   130b0:	00e7a423          	sw	a4,8(a5)
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   130b4:	14c6ec63          	bltu	a3,a2,1320c <_realloc_r+0x52c>
   130b8:	01300713          	li	a4,19
   130bc:	00040793          	mv	a5,s0
   130c0:	02c77263          	bleu	a2,a4,130e4 <_realloc_r+0x404>
   130c4:	000a2783          	lw	a5,0(s4)
   130c8:	00fba423          	sw	a5,8(s7)
   130cc:	004a2783          	lw	a5,4(s4)
   130d0:	00fba623          	sw	a5,12(s7)
   130d4:	01b00793          	li	a5,27
   130d8:	14c7e263          	bltu	a5,a2,1321c <_realloc_r+0x53c>
   130dc:	010b8793          	addi	a5,s7,16
   130e0:	008a0a13          	addi	s4,s4,8
   130e4:	000a2703          	lw	a4,0(s4)
   130e8:	00e7a023          	sw	a4,0(a5)
   130ec:	004a2703          	lw	a4,4(s4)
   130f0:	00e7a223          	sw	a4,4(a5)
   130f4:	008a2703          	lw	a4,8(s4)
   130f8:	00e7a423          	sw	a4,8(a5)
            top = chunk_at_offset(newp, nb);
            set_head(top, (newsize - nb) | PREV_INUSE);
   130fc:	412c86b3          	sub	a3,s9,s2
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
   13100:	012b87b3          	add	a5,s7,s2
            set_head(top, (newsize - nb) | PREV_INUSE);
   13104:	0016e693          	ori	a3,a3,1
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
   13108:	00fc2423          	sw	a5,8(s8)
            set_head(top, (newsize - nb) | PREV_INUSE);
   1310c:	00d7a223          	sw	a3,4(a5)
            set_head_size(newp, nb);
   13110:	004ba703          	lw	a4,4(s7)
	    MALLOC_UNLOCK;
   13114:	00048513          	mv	a0,s1
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
            top = chunk_at_offset(newp, nb);
            set_head(top, (newsize - nb) | PREV_INUSE);
            set_head_size(newp, nb);
   13118:	00177713          	andi	a4,a4,1
   1311c:	01276733          	or	a4,a4,s2
   13120:	00eba223          	sw	a4,4(s7)
	    MALLOC_UNLOCK;
   13124:	bb9ff0ef          	jal	12cdc <__malloc_unlock>
            return newmem;
   13128:	00040513          	mv	a0,s0
   1312c:	d15ff06f          	j	12e40 <_realloc_r+0x160>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   13130:	000a2703          	lw	a4,0(s4)
   13134:	00e52023          	sw	a4,0(a0)
   13138:	004a2703          	lw	a4,4(s4)
   1313c:	00e52223          	sw	a4,4(a0)
   13140:	01b00713          	li	a4,27
   13144:	06c76663          	bltu	a4,a2,131b0 <_realloc_r+0x4d0>
   13148:	00850793          	addi	a5,a0,8
   1314c:	008a0713          	addi	a4,s4,8
   13150:	c79ff06f          	j	12dc8 <_realloc_r+0xe8>
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
          set_head(top, (newsize - nb) | PREV_INUSE);
   13154:	412686b3          	sub	a3,a3,s2
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
   13158:	012b0b33          	add	s6,s6,s2
          set_head(top, (newsize - nb) | PREV_INUSE);
   1315c:	0016e693          	ori	a3,a3,1
      if (next == top)
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
   13160:	016c2423          	sw	s6,8(s8)
          set_head(top, (newsize - nb) | PREV_INUSE);
   13164:	00db2223          	sw	a3,4(s6)
          set_head_size(oldp, nb);
   13168:	ffca2703          	lw	a4,-4(s4)
	  MALLOC_UNLOCK;
   1316c:	00048513          	mv	a0,s1
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
        {
          newsize += nextsize;
          top = chunk_at_offset(oldp, nb);
          set_head(top, (newsize - nb) | PREV_INUSE);
          set_head_size(oldp, nb);
   13170:	00177713          	andi	a4,a4,1
   13174:	01276733          	or	a4,a4,s2
   13178:	feea2e23          	sw	a4,-4(s4)
	  MALLOC_UNLOCK;
   1317c:	b61ff0ef          	jal	12cdc <__malloc_unlock>
          return chunk2mem(oldp);
   13180:	000a0513          	mv	a0,s4
   13184:	cbdff06f          	j	12e40 <_realloc_r+0x160>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   13188:	000a0593          	mv	a1,s4
   1318c:	a2dff0ef          	jal	12bb8 <memmove>
   13190:	c51ff06f          	j	12de0 <_realloc_r+0x100>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   13194:	000a0593          	mv	a1,s4
   13198:	00098513          	mv	a0,s3
   1319c:	a1dff0ef          	jal	12bb8 <memmove>
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
   131a0:	00040a93          	mv	s5,s0
   131a4:	004ba783          	lw	a5,4(s7)
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   131a8:	000b8b13          	mv	s6,s7
   131ac:	c61ff06f          	j	12e0c <_realloc_r+0x12c>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   131b0:	008a2703          	lw	a4,8(s4)
   131b4:	00e52423          	sw	a4,8(a0)
   131b8:	00ca2703          	lw	a4,12(s4)
   131bc:	00e52623          	sw	a4,12(a0)
   131c0:	02f60863          	beq	a2,a5,131f0 <_realloc_r+0x510>
   131c4:	01050793          	addi	a5,a0,16
   131c8:	010a0713          	addi	a4,s4,16
   131cc:	bfdff06f          	j	12dc8 <_realloc_r+0xe8>
    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
    {
      newsize += chunksize(newp);
   131d0:	ffc52703          	lw	a4,-4(a0)
      newp = oldp;
      goto split;
   131d4:	000a0993          	mv	s3,s4
    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
    {
      newsize += chunksize(newp);
   131d8:	ffc77713          	andi	a4,a4,-4
   131dc:	00ea8ab3          	add	s5,s5,a4
      newp = oldp;
      goto split;
   131e0:	c2dff06f          	j	12e0c <_realloc_r+0x12c>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   131e4:	010b8793          	addi	a5,s7,16
   131e8:	008a0a13          	addi	s4,s4,8
   131ec:	dd5ff06f          	j	12fc0 <_realloc_r+0x2e0>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   131f0:	010a2683          	lw	a3,16(s4)
   131f4:	01850793          	addi	a5,a0,24
   131f8:	018a0713          	addi	a4,s4,24
   131fc:	00d52823          	sw	a3,16(a0)
   13200:	014a2683          	lw	a3,20(s4)
   13204:	00d52a23          	sw	a3,20(a0)
   13208:	bc1ff06f          	j	12dc8 <_realloc_r+0xe8>
          {
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1320c:	000a0593          	mv	a1,s4
   13210:	00040513          	mv	a0,s0
   13214:	9a5ff0ef          	jal	12bb8 <memmove>
   13218:	ee5ff06f          	j	130fc <_realloc_r+0x41c>
   1321c:	008a2783          	lw	a5,8(s4)
   13220:	00fba823          	sw	a5,16(s7)
   13224:	00ca2783          	lw	a5,12(s4)
   13228:	00fbaa23          	sw	a5,20(s7)
   1322c:	02d60063          	beq	a2,a3,1324c <_realloc_r+0x56c>
   13230:	018b8793          	addi	a5,s7,24
   13234:	010a0a13          	addi	s4,s4,16
   13238:	eadff06f          	j	130e4 <_realloc_r+0x404>

    newmem = mALLOc (RCALL bytes);

    if (newmem == 0)  /* propagate failure */
    {
      MALLOC_UNLOCK;
   1323c:	00048513          	mv	a0,s1
   13240:	a9dff0ef          	jal	12cdc <__malloc_unlock>
      return 0;
   13244:	00000513          	li	a0,0
   13248:	bf9ff06f          	j	12e40 <_realloc_r+0x160>
          {
            unlink(prev, bck, fwd);
            newp = prev;
            newsize += prevsize + nextsize;
            newmem = chunk2mem(newp);
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1324c:	010a2703          	lw	a4,16(s4)
   13250:	020b8793          	addi	a5,s7,32
   13254:	018a0a13          	addi	s4,s4,24
   13258:	00ebac23          	sw	a4,24(s7)
   1325c:	ffca2703          	lw	a4,-4(s4)
   13260:	00ebae23          	sw	a4,28(s7)
   13264:	e81ff06f          	j	130e4 <_realloc_r+0x404>

00013268 <__swsetup_r>:
       struct _reent *ptr _AND
       register FILE * fp)
{
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   13268:	8101a783          	lw	a5,-2032(gp) # 158b0 <_impure_ptr>

int
_DEFUN(__swsetup_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   1326c:	ff010113          	addi	sp,sp,-16
   13270:	00812423          	sw	s0,8(sp)
   13274:	00912223          	sw	s1,4(sp)
   13278:	00112623          	sw	ra,12(sp)
   1327c:	00050493          	mv	s1,a0
   13280:	00058413          	mv	s0,a1
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   13284:	00078663          	beqz	a5,13290 <__swsetup_r+0x28>
   13288:	0387a703          	lw	a4,56(a5)
   1328c:	0c070c63          	beqz	a4,13364 <__swsetup_r+0xfc>

  /*
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
   13290:	00c41703          	lh	a4,12(s0)
   13294:	01071793          	slli	a5,a4,0x10
   13298:	0107d793          	srli	a5,a5,0x10
   1329c:	0087f693          	andi	a3,a5,8
   132a0:	04068263          	beqz	a3,132e4 <__swsetup_r+0x7c>
   132a4:	01042683          	lw	a3,16(s0)
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
   132a8:	06068263          	beqz	a3,1330c <__swsetup_r+0xa4>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
    __smakebuf_r (ptr, fp);

  if (fp->_flags & __SLBF)
   132ac:	0017f713          	andi	a4,a5,1
   132b0:	08071063          	bnez	a4,13330 <__swsetup_r+0xc8>
       */
      fp->_w = 0;
      fp->_lbfsize = -fp->_bf._size;
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;
   132b4:	0027f793          	andi	a5,a5,2
   132b8:	00000713          	li	a4,0
   132bc:	00079463          	bnez	a5,132c4 <__swsetup_r+0x5c>
   132c0:	01442703          	lw	a4,20(s0)
   132c4:	00e42423          	sw	a4,8(s0)
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
      return EOF;
    }
  return 0;
   132c8:	00000513          	li	a0,0
      fp->_lbfsize = -fp->_bf._size;
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;

  if (!fp->_bf._base && (fp->_flags & __SMBF))
   132cc:	06068e63          	beqz	a3,13348 <__swsetup_r+0xe0>
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
      return EOF;
    }
  return 0;
}
   132d0:	00c12083          	lw	ra,12(sp)
   132d4:	00812403          	lw	s0,8(sp)
   132d8:	00412483          	lw	s1,4(sp)
   132dc:	01010113          	addi	sp,sp,16
   132e0:	00008067          	ret
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
   132e4:	0107f693          	andi	a3,a5,16
   132e8:	0a068e63          	beqz	a3,133a4 <__swsetup_r+0x13c>
        {
	  ptr->_errno = EBADF;
	  fp->_flags |= __SERR;
	  return EOF;
        }
      if (fp->_flags & __SRD)
   132ec:	0047f793          	andi	a5,a5,4
   132f0:	08079063          	bnez	a5,13370 <__swsetup_r+0x108>
   132f4:	01042683          	lw	a3,16(s0)
	    FREEUB (ptr, fp);
	  fp->_flags &= ~(__SRD | __SEOF);
	  fp->_r = 0;
	  fp->_p = fp->_bf._base;
	}
      fp->_flags |= __SWR;
   132f8:	00876793          	ori	a5,a4,8
   132fc:	00f41623          	sh	a5,12(s0)
   13300:	01079793          	slli	a5,a5,0x10
   13304:	0107d793          	srli	a5,a5,0x10
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
   13308:	fa0692e3          	bnez	a3,132ac <__swsetup_r+0x44>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
   1330c:	2807f713          	andi	a4,a5,640
   13310:	20000613          	li	a2,512
   13314:	f8c70ce3          	beq	a4,a2,132ac <__swsetup_r+0x44>
    __smakebuf_r (ptr, fp);
   13318:	00040593          	mv	a1,s0
   1331c:	00048513          	mv	a0,s1
   13320:	469000ef          	jal	13f88 <__smakebuf_r>
   13324:	00c45783          	lhu	a5,12(s0)
   13328:	01042683          	lw	a3,16(s0)
   1332c:	f81ff06f          	j	132ac <__swsetup_r+0x44>
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
      fp->_lbfsize = -fp->_bf._size;
   13330:	01442783          	lw	a5,20(s0)
      /*
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
   13334:	00042423          	sw	zero,8(s0)
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
      return EOF;
    }
  return 0;
   13338:	00000513          	li	a0,0
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
      fp->_lbfsize = -fp->_bf._size;
   1333c:	40f007b3          	neg	a5,a5
   13340:	00f42c23          	sw	a5,24(s0)
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;

  if (!fp->_bf._base && (fp->_flags & __SMBF))
   13344:	f80696e3          	bnez	a3,132d0 <__swsetup_r+0x68>
   13348:	00c41783          	lh	a5,12(s0)
   1334c:	0807f713          	andi	a4,a5,128
   13350:	f80700e3          	beqz	a4,132d0 <__swsetup_r+0x68>
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
   13354:	0407e793          	ori	a5,a5,64
   13358:	00f41623          	sh	a5,12(s0)
      return EOF;
   1335c:	fff00513          	li	a0,-1
   13360:	f71ff06f          	j	132d0 <__swsetup_r+0x68>
       struct _reent *ptr _AND
       register FILE * fp)
{
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   13364:	00078513          	mv	a0,a5
   13368:	694000ef          	jal	139fc <__sinit>
   1336c:	f25ff06f          	j	13290 <__swsetup_r+0x28>
	  return EOF;
        }
      if (fp->_flags & __SRD)
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
   13370:	03042583          	lw	a1,48(s0)
   13374:	00058e63          	beqz	a1,13390 <__swsetup_r+0x128>
	    FREEUB (ptr, fp);
   13378:	04040793          	addi	a5,s0,64
   1337c:	00f58863          	beq	a1,a5,1338c <__swsetup_r+0x124>
   13380:	00048513          	mv	a0,s1
   13384:	7b8000ef          	jal	13b3c <_free_r>
   13388:	00c41703          	lh	a4,12(s0)
   1338c:	02042823          	sw	zero,48(s0)
	  fp->_flags &= ~(__SRD | __SEOF);
	  fp->_r = 0;
	  fp->_p = fp->_bf._base;
   13390:	01042683          	lw	a3,16(s0)
      if (fp->_flags & __SRD)
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
	    FREEUB (ptr, fp);
	  fp->_flags &= ~(__SRD | __SEOF);
   13394:	fdb77713          	andi	a4,a4,-37
	  fp->_r = 0;
   13398:	00042223          	sw	zero,4(s0)
	  fp->_p = fp->_bf._base;
   1339c:	00d42023          	sw	a3,0(s0)
   133a0:	f59ff06f          	j	132f8 <__swsetup_r+0x90>
  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
        {
	  ptr->_errno = EBADF;
	  fp->_flags |= __SERR;
   133a4:	04076713          	ori	a4,a4,64

  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
        {
	  ptr->_errno = EBADF;
   133a8:	00900793          	li	a5,9
   133ac:	00f4a023          	sw	a5,0(s1)
	  fp->_flags |= __SERR;
	  return EOF;
   133b0:	fff00513          	li	a0,-1
  if ((fp->_flags & __SWR) == 0)
    {
      if ((fp->_flags & __SRW) == 0)
        {
	  ptr->_errno = EBADF;
	  fp->_flags |= __SERR;
   133b4:	00e41623          	sh	a4,12(s0)
	  return EOF;
   133b8:	f19ff06f          	j	132d0 <__swsetup_r+0x68>

000133bc <__sflush_r>:
  register unsigned char *p;
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
   133bc:	00c59683          	lh	a3,12(a1)
   directly from __srefill. */
int
_DEFUN(__sflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   133c0:	fe010113          	addi	sp,sp,-32
   133c4:	00812c23          	sw	s0,24(sp)
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
  if ((flags & __SWR) == 0)
   133c8:	01069713          	slli	a4,a3,0x10
   133cc:	01075713          	srli	a4,a4,0x10
   133d0:	00877793          	andi	a5,a4,8
   directly from __srefill. */
int
_DEFUN(__sflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   133d4:	01312623          	sw	s3,12(sp)
   133d8:	00112e23          	sw	ra,28(sp)
   133dc:	00912a23          	sw	s1,20(sp)
   133e0:	01212823          	sw	s2,16(sp)
   133e4:	00058413          	mv	s0,a1
   133e8:	00050993          	mv	s3,a0
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
  if ((flags & __SWR) == 0)
   133ec:	10079a63          	bnez	a5,13500 <__sflush_r+0x144>
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
   133f0:	000017b7          	lui	a5,0x1
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   133f4:	0045a703          	lw	a4,4(a1)
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
   133f8:	80078793          	addi	a5,a5,-2048 # 800 <_reset+0x600>
   133fc:	00f6e7b3          	or	a5,a3,a5
   13400:	00f59623          	sh	a5,12(a1)
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   13404:	1ce05663          	blez	a4,135d0 <__sflush_r+0x214>
   13408:	02842803          	lw	a6,40(s0)
   1340c:	0c080a63          	beqz	a6,134e0 <__sflush_r+0x124>
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
	  ptr->_errno = 0;
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
   13410:	01079793          	slli	a5,a5,0x10
   13414:	0107d793          	srli	a5,a5,0x10
   13418:	01379693          	slli	a3,a5,0x13
#endif

	  /* Save last errno and set errno to 0, so we can check if a device
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
   1341c:	0009a483          	lw	s1,0(s3)
	  ptr->_errno = 0;
   13420:	0009a023          	sw	zero,0(s3)
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
   13424:	1a06dc63          	bgez	a3,135dc <__sflush_r+0x220>
	    curoff = fp->_offset;
   13428:	05042603          	lw	a2,80(s0)
   1342c:	05442683          	lw	a3,84(s0)
		  else
		    fp->_flags |= __SERR;
		  return result;
		}
            }
          if (fp->_flags & __SRD)
   13430:	0047f793          	andi	a5,a5,4
   13434:	04078263          	beqz	a5,13478 <__sflush_r+0xbc>
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
   13438:	00442503          	lw	a0,4(s0)
              if (HASUB (fp))
   1343c:	03042703          	lw	a4,48(s0)
            }
          if (fp->_flags & __SRD)
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
   13440:	40a607b3          	sub	a5,a2,a0
   13444:	41f55513          	srai	a0,a0,0x1f
   13448:	00f635b3          	sltu	a1,a2,a5
   1344c:	40a686b3          	sub	a3,a3,a0
   13450:	00078613          	mv	a2,a5
   13454:	40b686b3          	sub	a3,a3,a1
              if (HASUB (fp))
   13458:	02070063          	beqz	a4,13478 <__sflush_r+0xbc>
                curoff -= fp->_ur;
   1345c:	03c42503          	lw	a0,60(s0)
   13460:	40a787b3          	sub	a5,a5,a0
   13464:	41f55513          	srai	a0,a0,0x1f
   13468:	00f63733          	sltu	a4,a2,a5
   1346c:	40a686b3          	sub	a3,a3,a0
   13470:	00078613          	mv	a2,a5
   13474:	40e686b3          	sub	a3,a3,a4
#ifdef __LARGE64_FILES
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
   13478:	01c42583          	lw	a1,28(s0)
   1347c:	00000713          	li	a4,0
   13480:	00098513          	mv	a0,s3
   13484:	000800e7          	jalr	a6
	  if (curoff != -1 || ptr->_errno == 0
   13488:	fff00793          	li	a5,-1
   1348c:	0ef50063          	beq	a0,a5,1356c <__sflush_r+0x1b0>
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   13490:	00c45683          	lhu	a3,12(s0)
   13494:	fffff7b7          	lui	a5,0xfffff
   13498:	7ff78793          	addi	a5,a5,2047 # fffff7ff <_gp+0xfffe975f>
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   1349c:	01042703          	lw	a4,16(s0)
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   134a0:	00f6f7b3          	and	a5,a3,a5
   134a4:	01079793          	slli	a5,a5,0x10
   134a8:	4107d793          	srai	a5,a5,0x10
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   134ac:	00e42023          	sw	a4,0(s0)
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   134b0:	01379713          	slli	a4,a5,0x13
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   134b4:	00f41623          	sh	a5,12(s0)
#endif
	      fp->_r = 0;
   134b8:	00042223          	sw	zero,4(s0)
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   134bc:	10074463          	bltz	a4,135c4 <__sflush_r+0x208>
		fp->_offset = curoff;
	      ptr->_errno = tmp_errno;
	      if (HASUB (fp))
   134c0:	03042583          	lw	a1,48(s0)
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
		fp->_offset = curoff;
	      ptr->_errno = tmp_errno;
   134c4:	0099a023          	sw	s1,0(s3)
	      if (HASUB (fp))
   134c8:	00058c63          	beqz	a1,134e0 <__sflush_r+0x124>
		FREEUB (ptr, fp);
   134cc:	04040793          	addi	a5,s0,64
   134d0:	00f58663          	beq	a1,a5,134dc <__sflush_r+0x120>
   134d4:	00098513          	mv	a0,s3
   134d8:	664000ef          	jal	13b3c <_free_r>
   134dc:	02042823          	sw	zero,48(s0)
	    {
	      fp->_flags |= __SERR;
	      return EOF;
	    }
	}
      return 0;
   134e0:	00000513          	li	a0,0
	}
      p += t;
      n -= t;
    }
  return 0;
}
   134e4:	01c12083          	lw	ra,28(sp)
   134e8:	01812403          	lw	s0,24(sp)
   134ec:	01412483          	lw	s1,20(sp)
   134f0:	01012903          	lw	s2,16(sp)
   134f4:	00c12983          	lw	s3,12(sp)
   134f8:	02010113          	addi	sp,sp,32
   134fc:	00008067          	ret
	      return EOF;
	    }
	}
      return 0;
    }
  if ((p = fp->_bf._base) == NULL)
   13500:	0105a903          	lw	s2,16(a1)
   13504:	fc090ee3          	beqz	s2,134e0 <__sflush_r+0x124>
    {
      /* Nothing to flush.  */
      return 0;
    }
  n = fp->_p - p;		/* write this much */
   13508:	0005a483          	lw	s1,0(a1)
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
   1350c:	00377713          	andi	a4,a4,3
  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
   13510:	0125a023          	sw	s2,0(a1)
  if ((p = fp->_bf._base) == NULL)
    {
      /* Nothing to flush.  */
      return 0;
    }
  n = fp->_p - p;		/* write this much */
   13514:	412484b3          	sub	s1,s1,s2
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
   13518:	00000793          	li	a5,0
   1351c:	00071463          	bnez	a4,13524 <__sflush_r+0x168>
   13520:	0145a783          	lw	a5,20(a1)
   13524:	00f42423          	sw	a5,8(s0)

  while (n > 0)
   13528:	00904863          	bgtz	s1,13538 <__sflush_r+0x17c>
   1352c:	fb5ff06f          	j	134e0 <__sflush_r+0x124>
      if (t <= 0)
	{
          fp->_flags |= __SERR;
          return EOF;
	}
      p += t;
   13530:	00a90933          	add	s2,s2,a0
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
   13534:	fa9056e3          	blez	s1,134e0 <__sflush_r+0x124>
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
   13538:	02442783          	lw	a5,36(s0)
   1353c:	01c42583          	lw	a1,28(s0)
   13540:	00048693          	mv	a3,s1
   13544:	00090613          	mv	a2,s2
   13548:	00098513          	mv	a0,s3
   1354c:	000780e7          	jalr	a5
	{
          fp->_flags |= __SERR;
          return EOF;
	}
      p += t;
      n -= t;
   13550:	40a484b3          	sub	s1,s1,a0
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
      if (t <= 0)
   13554:	fca04ee3          	bgtz	a0,13530 <__sflush_r+0x174>
	{
          fp->_flags |= __SERR;
   13558:	00c45783          	lhu	a5,12(s0)
          return EOF;
   1355c:	fff00513          	li	a0,-1
  while (n > 0)
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
      if (t <= 0)
	{
          fp->_flags |= __SERR;
   13560:	0407e793          	ori	a5,a5,64
   13564:	00f41623          	sh	a5,12(s0)
          return EOF;
   13568:	f7dff06f          	j	134e4 <__sflush_r+0x128>
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
	  if (curoff != -1 || ptr->_errno == 0
   1356c:	f2a592e3          	bne	a1,a0,13490 <__sflush_r+0xd4>
   13570:	0009a703          	lw	a4,0(s3)
   13574:	01d00793          	li	a5,29
   13578:	fee7e0e3          	bltu	a5,a4,13558 <__sflush_r+0x19c>
   1357c:	204007b7          	lui	a5,0x20400
   13580:	00178793          	addi	a5,a5,1 # 20400001 <_gp+0x203e9f61>
   13584:	00e7d7b3          	srl	a5,a5,a4
   13588:	0017f793          	andi	a5,a5,1
   1358c:	fc0786e3          	beqz	a5,13558 <__sflush_r+0x19c>
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   13590:	00c45603          	lhu	a2,12(s0)
   13594:	fffff7b7          	lui	a5,0xfffff
   13598:	7ff78793          	addi	a5,a5,2047 # fffff7ff <_gp+0xfffe975f>
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   1359c:	01042683          	lw	a3,16(s0)
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   135a0:	00f677b3          	and	a5,a2,a5
   135a4:	01079793          	slli	a5,a5,0x10
   135a8:	4107d793          	srai	a5,a5,0x10
#endif
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
   135ac:	00d42023          	sw	a3,0(s0)
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   135b0:	01379693          	slli	a3,a5,0x13
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   135b4:	00f41623          	sh	a5,12(s0)
#endif
	      fp->_r = 0;
   135b8:	00042223          	sw	zero,4(s0)
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   135bc:	f006d2e3          	bgez	a3,134c0 <__sflush_r+0x104>
   135c0:	f00710e3          	bnez	a4,134c0 <__sflush_r+0x104>
		fp->_offset = curoff;
   135c4:	04a42823          	sw	a0,80(s0)
   135c8:	04b42a23          	sw	a1,84(s0)
   135cc:	ef5ff06f          	j	134c0 <__sflush_r+0x104>
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   135d0:	03c5a703          	lw	a4,60(a1)
   135d4:	e2e04ae3          	bgtz	a4,13408 <__sflush_r+0x4c>
   135d8:	f09ff06f          	j	134e0 <__sflush_r+0x124>
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
   135dc:	01c42583          	lw	a1,28(s0)
   135e0:	00000613          	li	a2,0
   135e4:	00000693          	li	a3,0
   135e8:	00100713          	li	a4,1
   135ec:	00098513          	mv	a0,s3
   135f0:	000800e7          	jalr	a6
	      if (curoff == -1L && ptr->_errno != 0)
   135f4:	fff00793          	li	a5,-1
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
   135f8:	00050613          	mv	a2,a0
   135fc:	00058693          	mv	a3,a1
	      if (curoff == -1L && ptr->_errno != 0)
   13600:	00f50863          	beq	a0,a5,13610 <__sflush_r+0x254>
   13604:	00c45783          	lhu	a5,12(s0)
   13608:	02842803          	lw	a6,40(s0)
   1360c:	e25ff06f          	j	13430 <__sflush_r+0x74>
   13610:	fea59ae3          	bne	a1,a0,13604 <__sflush_r+0x248>
   13614:	0009a783          	lw	a5,0(s3)
   13618:	fe0786e3          	beqz	a5,13604 <__sflush_r+0x248>
		{
		  int result = EOF;
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
   1361c:	01d00713          	li	a4,29
   13620:	00e78663          	beq	a5,a4,1362c <__sflush_r+0x270>
   13624:	01600713          	li	a4,22
   13628:	00e79863          	bne	a5,a4,13638 <__sflush_r+0x27c>
		    {
		      result = 0;
		      ptr->_errno = tmp_errno;
   1362c:	0099a023          	sw	s1,0(s3)
	      if (curoff == -1L && ptr->_errno != 0)
		{
		  int result = EOF;
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
		    {
		      result = 0;
   13630:	00000513          	li	a0,0
		      ptr->_errno = tmp_errno;
   13634:	eb1ff06f          	j	134e4 <__sflush_r+0x128>
		    }
		  else
		    fp->_flags |= __SERR;
   13638:	00c45783          	lhu	a5,12(s0)
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
	      if (curoff == -1L && ptr->_errno != 0)
		{
		  int result = EOF;
   1363c:	00058513          	mv	a0,a1
		    {
		      result = 0;
		      ptr->_errno = tmp_errno;
		    }
		  else
		    fp->_flags |= __SERR;
   13640:	0407e793          	ori	a5,a5,64
   13644:	00f41623          	sh	a5,12(s0)
   13648:	e9dff06f          	j	134e4 <__sflush_r+0x128>

0001364c <_fflush_r>:

int
_DEFUN(_fflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   1364c:	fe010113          	addi	sp,sp,-32
   13650:	00812c23          	sw	s0,24(sp)
   13654:	00112e23          	sw	ra,28(sp)
   13658:	00050413          	mv	s0,a0
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
   1365c:	00050663          	beqz	a0,13668 <_fflush_r+0x1c>
   13660:	03852783          	lw	a5,56(a0)
   13664:	02078a63          	beqz	a5,13698 <_fflush_r+0x4c>

  if (!fp->_flags)
   13668:	00c59783          	lh	a5,12(a1)
   1366c:	00079c63          	bnez	a5,13684 <_fflush_r+0x38>

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
  _newlib_flockfile_end (fp);
  return ret;
}
   13670:	01c12083          	lw	ra,28(sp)
   13674:	00000513          	li	a0,0
   13678:	01812403          	lw	s0,24(sp)
   1367c:	02010113          	addi	sp,sp,32
   13680:	00008067          	ret

  if (!fp->_flags)
    return 0;

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
   13684:	00040513          	mv	a0,s0
  _newlib_flockfile_end (fp);
  return ret;
}
   13688:	01c12083          	lw	ra,28(sp)
   1368c:	01812403          	lw	s0,24(sp)
   13690:	02010113          	addi	sp,sp,32

  if (!fp->_flags)
    return 0;

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
   13694:	d29ff06f          	j	133bc <__sflush_r>
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
   13698:	00b12623          	sw	a1,12(sp)
   1369c:	360000ef          	jal	139fc <__sinit>
   136a0:	00c12583          	lw	a1,12(sp)
   136a4:	fc5ff06f          	j	13668 <_fflush_r+0x1c>

000136a8 <fflush>:
#ifndef _REENT_ONLY

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
   136a8:	00050593          	mv	a1,a0
  if (fp == NULL)
   136ac:	00050663          	beqz	a0,136b8 <fflush+0x10>
    return _fwalk_reent (_GLOBAL_REENT, _fflush_r);

  return _fflush_r (_REENT, fp);
   136b0:	8101a503          	lw	a0,-2032(gp) # 158b0 <_impure_ptr>
   136b4:	f99ff06f          	j	1364c <_fflush_r>
int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
  if (fp == NULL)
    return _fwalk_reent (_GLOBAL_REENT, _fflush_r);
   136b8:	80c1a503          	lw	a0,-2036(gp) # 158ac <_global_impure_ptr>
   136bc:	000135b7          	lui	a1,0x13
   136c0:	64c58593          	addi	a1,a1,1612 # 1364c <_fflush_r>
   136c4:	0050006f          	j	13ec8 <_fwalk_reent>

000136c8 <__fp_unlock>:
       FILE * ptr)
{
  _funlockfile (ptr);

  return 0;
}
   136c8:	00000513          	li	a0,0
   136cc:	00008067          	ret

000136d0 <_cleanup_r>:
  cleanup_func = _fflush_r;
#else
  cleanup_func = _fclose_r;
#endif
#endif
  _CAST_VOID _fwalk_reent (ptr, cleanup_func);
   136d0:	000145b7          	lui	a1,0x14
   136d4:	36458593          	addi	a1,a1,868 # 14364 <_fclose_r>
   136d8:	7f00006f          	j	13ec8 <_fwalk_reent>

000136dc <__sinit.part.1>:
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   136dc:	fe010113          	addi	sp,sp,-32
      __sinit_lock_release ();
      return;
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
   136e0:	000137b7          	lui	a5,0x13
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   136e4:	00812c23          	sw	s0,24(sp)
      __sinit_lock_release ();
      return;
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
   136e8:	6d078793          	addi	a5,a5,1744 # 136d0 <_cleanup_r>
  s->_stdin = __sfp(s);
  s->_stdout = __sfp(s);
  s->_stderr = __sfp(s);
#endif

  std (s->_stdin,  __SRD, 0, s);
   136ec:	00452403          	lw	s0,4(a0)
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   136f0:	00112e23          	sw	ra,28(sp)
   136f4:	00912a23          	sw	s1,20(sp)
   136f8:	01212823          	sw	s2,16(sp)
   136fc:	01312623          	sw	s3,12(sp)
   13700:	01412423          	sw	s4,8(sp)
   13704:	01512223          	sw	s5,4(sp)
   13708:	01612023          	sw	s6,0(sp)
      __sinit_lock_release ();
      return;
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
   1370c:	02f52e23          	sw	a5,60(a0)

  s->__sglue._next = NULL;
#ifndef _REENT_SMALL
  s->__sglue._niobs = 3;
   13710:	00300793          	li	a5,3
   13714:	2ef52223          	sw	a5,740(a0)
  s->__sglue._iobs = &s->__sf[0];
   13718:	2f050713          	addi	a4,a0,752
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   1371c:	00400793          	li	a5,4
  s->__cleanup = _cleanup_r;	/* conservative */

  s->__sglue._next = NULL;
#ifndef _REENT_SMALL
  s->__sglue._niobs = 3;
  s->__sglue._iobs = &s->__sf[0];
   13720:	2ee52423          	sw	a4,744(a0)
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */

  s->__sglue._next = NULL;
   13724:	2e052023          	sw	zero,736(a0)
/*
 * __sinit() is called whenever stdio's internal variables must be set up.
 */

_VOID
_DEFUN(__sinit, (s),
   13728:	00050913          	mv	s2,a0
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   1372c:	00f41623          	sh	a5,12(s0)
  ptr->_flags2 = 0;
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   13730:	00800613          	li	a2,8
   13734:	00000593          	li	a1,0
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
  ptr->_p = 0;
   13738:	00042023          	sw	zero,0(s0)
  ptr->_r = 0;
   1373c:	00042223          	sw	zero,4(s0)
  ptr->_w = 0;
   13740:	00042423          	sw	zero,8(s0)
  ptr->_flags = flags;
  ptr->_flags2 = 0;
   13744:	06042423          	sw	zero,104(s0)
  ptr->_file = file;
   13748:	00041723          	sh	zero,14(s0)
  ptr->_bf._base = 0;
   1374c:	00042823          	sw	zero,16(s0)
  ptr->_bf._size = 0;
   13750:	00042a23          	sw	zero,20(s0)
  ptr->_lbfsize = 0;
   13754:	00042c23          	sw	zero,24(s0)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   13758:	06040513          	addi	a0,s0,96
   1375c:	1bd000ef          	jal	14118 <memset>
     requires both stdin and stdout to be line-buffered, but tradition
     leaves stdin alone on systems without fcntl.  */
#ifdef HAVE_FCNTL
  std (s->_stdout, __SWR, 1, s);
#else
  std (s->_stdout, __SWR | __SLBF, 1, s);
   13760:	00892483          	lw	s1,8(s2)
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   13764:	00014b37          	lui	s6,0x14
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   13768:	00014ab7          	lui	s5,0x14
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   1376c:	00014a37          	lui	s4,0x14
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   13770:	000149b7          	lui	s3,0x14
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   13774:	1f4b0b13          	addi	s6,s6,500 # 141f4 <__sread>
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   13778:	278a8a93          	addi	s5,s5,632 # 14278 <__swrite>
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   1377c:	2f0a0a13          	addi	s4,s4,752 # 142f0 <__sseek>
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   13780:	35c98993          	addi	s3,s3,860 # 1435c <__sclose>
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   13784:	00900793          	li	a5,9
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   13788:	03642023          	sw	s6,32(s0)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   1378c:	03542223          	sw	s5,36(s0)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   13790:	03442423          	sw	s4,40(s0)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   13794:	03342623          	sw	s3,44(s0)
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
   13798:	00842e23          	sw	s0,28(s0)
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   1379c:	00f49623          	sh	a5,12(s1)
  ptr->_flags2 = 0;
  ptr->_file = file;
   137a0:	00100793          	li	a5,1
   137a4:	00f49723          	sh	a5,14(s1)
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   137a8:	00800613          	li	a2,8
   137ac:	00000593          	li	a1,0
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
  ptr->_p = 0;
   137b0:	0004a023          	sw	zero,0(s1)
  ptr->_r = 0;
   137b4:	0004a223          	sw	zero,4(s1)
  ptr->_w = 0;
   137b8:	0004a423          	sw	zero,8(s1)
  ptr->_flags = flags;
  ptr->_flags2 = 0;
   137bc:	0604a423          	sw	zero,104(s1)
  ptr->_file = file;
  ptr->_bf._base = 0;
   137c0:	0004a823          	sw	zero,16(s1)
  ptr->_bf._size = 0;
   137c4:	0004aa23          	sw	zero,20(s1)
  ptr->_lbfsize = 0;
   137c8:	0004ac23          	sw	zero,24(s1)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   137cc:	06048513          	addi	a0,s1,96
   137d0:	149000ef          	jal	14118 <memset>
  std (s->_stdout, __SWR | __SLBF, 1, s);
#endif

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);
   137d4:	00c92403          	lw	s0,12(s2)
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   137d8:	01200793          	li	a5,18
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   137dc:	0364a023          	sw	s6,32(s1)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   137e0:	0354a223          	sw	s5,36(s1)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   137e4:	0344a423          	sw	s4,40(s1)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   137e8:	0334a623          	sw	s3,44(s1)
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
   137ec:	0094ae23          	sw	s1,28(s1)
            struct _reent *data)
{
  ptr->_p = 0;
  ptr->_r = 0;
  ptr->_w = 0;
  ptr->_flags = flags;
   137f0:	00f41623          	sh	a5,12(s0)
  ptr->_flags2 = 0;
  ptr->_file = file;
   137f4:	00200793          	li	a5,2
   137f8:	00f41723          	sh	a5,14(s0)
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
  ptr->_p = 0;
   137fc:	00042023          	sw	zero,0(s0)
  ptr->_r = 0;
   13800:	00042223          	sw	zero,4(s0)
  ptr->_w = 0;
   13804:	00042423          	sw	zero,8(s0)
  ptr->_flags = flags;
  ptr->_flags2 = 0;
   13808:	06042423          	sw	zero,104(s0)
  ptr->_file = file;
  ptr->_bf._base = 0;
   1380c:	00042823          	sw	zero,16(s0)
  ptr->_bf._size = 0;
   13810:	00042a23          	sw	zero,20(s0)
  ptr->_lbfsize = 0;
   13814:	00042c23          	sw	zero,24(s0)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   13818:	06040513          	addi	a0,s0,96
   1381c:	00800613          	li	a2,8
   13820:	00000593          	li	a1,0
   13824:	0f5000ef          	jal	14118 <memset>
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;

  __sinit_lock_release ();
}
   13828:	01c12083          	lw	ra,28(sp)

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;
   1382c:	00100793          	li	a5,1
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
  ptr->_read = __sread;
   13830:	03642023          	sw	s6,32(s0)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   13834:	03542223          	sw	s5,36(s0)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   13838:	03442423          	sw	s4,40(s0)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   1383c:	03342623          	sw	s3,44(s0)
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  ptr->_cookie = ptr;
   13840:	00842e23          	sw	s0,28(s0)
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;

  __sinit_lock_release ();
}
   13844:	01412483          	lw	s1,20(sp)

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);

  s->__sdidinit = 1;
   13848:	02f92c23          	sw	a5,56(s2)

  __sinit_lock_release ();
}
   1384c:	01812403          	lw	s0,24(sp)
   13850:	01012903          	lw	s2,16(sp)
   13854:	00c12983          	lw	s3,12(sp)
   13858:	00812a03          	lw	s4,8(sp)
   1385c:	00412a83          	lw	s5,4(sp)
   13860:	00012b03          	lw	s6,0(sp)
   13864:	02010113          	addi	sp,sp,32
   13868:	00008067          	ret

0001386c <__fp_lock>:
   1386c:	00000513          	li	a0,0
   13870:	00008067          	ret

00013874 <__sfmoreglue>:

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   13874:	ff010113          	addi	sp,sp,-16
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
   13878:	fff58793          	addi	a5,a1,-1

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   1387c:	00812423          	sw	s0,8(sp)
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
   13880:	00479413          	slli	s0,a5,0x4
   13884:	00779793          	slli	a5,a5,0x7
   13888:	40878433          	sub	s0,a5,s0

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   1388c:	01212023          	sw	s2,0(sp)
   13890:	00058913          	mv	s2,a1
  struct glue_with_file *g;

  g = (struct glue_with_file *)
   13894:	08040593          	addi	a1,s0,128

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   13898:	00912223          	sw	s1,4(sp)
   1389c:	00112623          	sw	ra,12(sp)
  struct glue_with_file *g;

  g = (struct glue_with_file *)
   138a0:	9adfe0ef          	jal	1224c <_malloc_r>
   138a4:	00050493          	mv	s1,a0
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  if (g == NULL)
   138a8:	02050063          	beqz	a0,138c8 <__sfmoreglue+0x54>
    return NULL;
  g->glue._next = NULL;
  g->glue._niobs = n;
  g->glue._iobs = &g->file;
   138ac:	01050513          	addi	a0,a0,16

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  if (g == NULL)
    return NULL;
  g->glue._next = NULL;
   138b0:	0004a023          	sw	zero,0(s1)
  g->glue._niobs = n;
   138b4:	0124a223          	sw	s2,4(s1)
  g->glue._iobs = &g->file;
   138b8:	00a4a423          	sw	a0,8(s1)
  memset (&g->file, 0, n * sizeof (FILE));
   138bc:	07040613          	addi	a2,s0,112
   138c0:	00000593          	li	a1,0
   138c4:	055000ef          	jal	14118 <memset>
  return &g->glue;
}
   138c8:	00c12083          	lw	ra,12(sp)
   138cc:	00048513          	mv	a0,s1
   138d0:	00812403          	lw	s0,8(sp)
   138d4:	00412483          	lw	s1,4(sp)
   138d8:	00012903          	lw	s2,0(sp)
   138dc:	01010113          	addi	sp,sp,16
   138e0:	00008067          	ret

000138e4 <__sfp>:
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
   138e4:	fe010113          	addi	sp,sp,-32
   138e8:	01212823          	sw	s2,16(sp)
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
   138ec:	80c1a903          	lw	s2,-2036(gp) # 158ac <_global_impure_ptr>
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
   138f0:	01312623          	sw	s3,12(sp)
   138f4:	00112e23          	sw	ra,28(sp)
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
   138f8:	03892783          	lw	a5,56(s2)
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
   138fc:	00812c23          	sw	s0,24(sp)
   13900:	00912a23          	sw	s1,20(sp)
   13904:	00050993          	mv	s3,a0
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
   13908:	00079663          	bnez	a5,13914 <__sfp+0x30>
   1390c:	00090513          	mv	a0,s2
   13910:	dcdff0ef          	jal	136dc <__sinit.part.1>
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
   13914:	2e090913          	addi	s2,s2,736
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   13918:	fff00493          	li	s1,-1
   1391c:	00492783          	lw	a5,4(s2)
   13920:	00892403          	lw	s0,8(s2)
   13924:	fff78793          	addi	a5,a5,-1
   13928:	0007da63          	bgez	a5,1393c <__sfp+0x58>
   1392c:	0840006f          	j	139b0 <__sfp+0xcc>
   13930:	fff78793          	addi	a5,a5,-1
   13934:	07040413          	addi	s0,s0,112
   13938:	06978c63          	beq	a5,s1,139b0 <__sfp+0xcc>
	if (fp->_flags == 0)
   1393c:	00c41703          	lh	a4,12(s0)
   13940:	fe0718e3          	bnez	a4,13930 <__sfp+0x4c>
  _newlib_sfp_lock_exit ();
  d->_errno = ENOMEM;
  return NULL;

found:
  fp->_file = -1;		/* no file */
   13944:	fff00793          	li	a5,-1
   13948:	00f41723          	sh	a5,14(s0)
  fp->_flags = 1;		/* reserve this slot; caller sets real flags */
   1394c:	00100793          	li	a5,1
   13950:	00f41623          	sh	a5,12(s0)
  fp->_flags2 = 0;
   13954:	06042423          	sw	zero,104(s0)
#ifndef __SINGLE_THREAD__
  __lock_init_recursive (fp->_lock);
#endif
  _newlib_sfp_lock_end ();

  fp->_p = NULL;		/* no current pointer */
   13958:	00042023          	sw	zero,0(s0)
  fp->_w = 0;			/* nothing to read or write */
   1395c:	00042423          	sw	zero,8(s0)
  fp->_r = 0;
   13960:	00042223          	sw	zero,4(s0)
  fp->_bf._base = NULL;		/* no buffer */
   13964:	00042823          	sw	zero,16(s0)
  fp->_bf._size = 0;
   13968:	00042a23          	sw	zero,20(s0)
  fp->_lbfsize = 0;		/* not line buffered */
   1396c:	00042c23          	sw	zero,24(s0)
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
   13970:	00800613          	li	a2,8
   13974:	00000593          	li	a1,0
   13978:	06040513          	addi	a0,s0,96
   1397c:	79c000ef          	jal	14118 <memset>
  /* fp->_cookie = <any>; */	/* caller sets cookie, _read/_write etc */
  fp->_ub._base = NULL;		/* no ungetc buffer */
   13980:	02042823          	sw	zero,48(s0)
  fp->_ub._size = 0;
   13984:	02042a23          	sw	zero,52(s0)
  fp->_lb._base = NULL;		/* no line buffer */
   13988:	04042223          	sw	zero,68(s0)
  fp->_lb._size = 0;
   1398c:	04042423          	sw	zero,72(s0)

  return fp;
   13990:	00040513          	mv	a0,s0
}
   13994:	01c12083          	lw	ra,28(sp)
   13998:	01812403          	lw	s0,24(sp)
   1399c:	01412483          	lw	s1,20(sp)
   139a0:	01012903          	lw	s2,16(sp)
   139a4:	00c12983          	lw	s3,12(sp)
   139a8:	02010113          	addi	sp,sp,32
   139ac:	00008067          	ret
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
   139b0:	00092783          	lw	a5,0(s2)
   139b4:	00078663          	beqz	a5,139c0 <__sfp+0xdc>
   139b8:	00078913          	mv	s2,a5
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
    }
   139bc:	f61ff06f          	j	1391c <__sfp+0x38>
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
   139c0:	00400593          	li	a1,4
   139c4:	00098513          	mv	a0,s3
   139c8:	eadff0ef          	jal	13874 <__sfmoreglue>
   139cc:	00a92023          	sw	a0,0(s2)
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
   139d0:	00050663          	beqz	a0,139dc <__sfp+0xf8>
   139d4:	00050913          	mv	s2,a0
   139d8:	f45ff06f          	j	1391c <__sfp+0x38>
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
    }
  _newlib_sfp_lock_exit ();
  d->_errno = ENOMEM;
   139dc:	00c00793          	li	a5,12
   139e0:	00f9a023          	sw	a5,0(s3)
  return NULL;
   139e4:	00000513          	li	a0,0
   139e8:	fadff06f          	j	13994 <__sfp+0xb0>

000139ec <_cleanup>:
  cleanup_func = _fflush_r;
#else
  cleanup_func = _fclose_r;
#endif
#endif
  _CAST_VOID _fwalk_reent (ptr, cleanup_func);
   139ec:	80c1a503          	lw	a0,-2036(gp) # 158ac <_global_impure_ptr>
   139f0:	000145b7          	lui	a1,0x14
   139f4:	36458593          	addi	a1,a1,868 # 14364 <_fclose_r>
   139f8:	4d00006f          	j	13ec8 <_fwalk_reent>

000139fc <__sinit>:
_DEFUN(__sinit, (s),
       struct _reent *s)
{
  __sinit_lock_acquire ();

  if (s->__sdidinit)
   139fc:	03852783          	lw	a5,56(a0)
   13a00:	00078463          	beqz	a5,13a08 <__sinit+0xc>
   13a04:	00008067          	ret
   13a08:	cd5ff06f          	j	136dc <__sinit.part.1>

00013a0c <__sfp_lock_acquire>:
   13a0c:	00008067          	ret

00013a10 <__sfp_lock_release>:
   13a10:	00008067          	ret

00013a14 <__sinit_lock_acquire>:
   13a14:	00008067          	ret

00013a18 <__sinit_lock_release>:
  __lock_acquire_recursive (__sinit_lock);
}

_VOID
_DEFUN_VOID(__sinit_lock_release)
{
   13a18:	00008067          	ret

00013a1c <__fp_lock_all>:
_VOID
_DEFUN_VOID(__fp_lock_all)
{
  __sfp_lock_acquire ();

  _CAST_VOID _fwalk (_REENT, __fp_lock);
   13a1c:	8101a503          	lw	a0,-2032(gp) # 158b0 <_impure_ptr>
   13a20:	000145b7          	lui	a1,0x14
   13a24:	86c58593          	addi	a1,a1,-1940 # 1386c <__fp_lock>
   13a28:	3f00006f          	j	13e18 <_fwalk>

00013a2c <__fp_unlock_all>:
}

_VOID
_DEFUN_VOID(__fp_unlock_all)
{
  _CAST_VOID _fwalk (_REENT, __fp_unlock);
   13a2c:	8101a503          	lw	a0,-2032(gp) # 158b0 <_impure_ptr>
   13a30:	000135b7          	lui	a1,0x13
   13a34:	6c858593          	addi	a1,a1,1736 # 136c8 <__fp_unlock>
   13a38:	3e00006f          	j	13e18 <_fwalk>

00013a3c <_malloc_trim_r>:
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
   13a3c:	fe010113          	addi	sp,sp,-32
   13a40:	01212823          	sw	s2,16(sp)

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;

  top_size = chunksize(top);
   13a44:	00015937          	lui	s2,0x15
   13a48:	49090913          	addi	s2,s2,1168 # 15490 <__malloc_av_>
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
   13a4c:	00812c23          	sw	s0,24(sp)
   13a50:	00912a23          	sw	s1,20(sp)
   13a54:	00058413          	mv	s0,a1
   13a58:	01312623          	sw	s3,12(sp)
   13a5c:	00112e23          	sw	ra,28(sp)
   13a60:	00050993          	mv	s3,a0
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;
   13a64:	a74ff0ef          	jal	12cd8 <__malloc_lock>

  top_size = chunksize(top);
   13a68:	00892703          	lw	a4,8(s2)
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
   13a6c:	000017b7          	lui	a5,0x1
   13a70:	fef78593          	addi	a1,a5,-17 # fef <_reset+0xdef>

  unsigned long pagesz = malloc_getpagesize;

  MALLOC_LOCK;

  top_size = chunksize(top);
   13a74:	00472483          	lw	s1,4(a4)
   13a78:	ffc4f493          	andi	s1,s1,-4
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
   13a7c:	40848433          	sub	s0,s1,s0
   13a80:	00b40433          	add	s0,s0,a1
   13a84:	00c45413          	srli	s0,s0,0xc
   13a88:	fff40413          	addi	s0,s0,-1
   13a8c:	00c41413          	slli	s0,s0,0xc

  if (extra < (long)pagesz)  /* Not enough memory to release */
   13a90:	00f44c63          	blt	s0,a5,13aa8 <_malloc_trim_r+0x6c>
  }

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
   13a94:	00000513          	li	a0,0
   13a98:	939fc0ef          	jal	103d0 <sbrk>
    if (current_brk != (char*)(top) + top_size)
   13a9c:	00892783          	lw	a5,8(s2)
   13aa0:	009787b3          	add	a5,a5,s1
   13aa4:	02f50663          	beq	a0,a5,13ad0 <_malloc_trim_r+0x94>
  top_size = chunksize(top);
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;

  if (extra < (long)pagesz)  /* Not enough memory to release */
  {
    MALLOC_UNLOCK;
   13aa8:	00098513          	mv	a0,s3
   13aac:	a30ff0ef          	jal	12cdc <__malloc_unlock>
    return 0;
   13ab0:	00000513          	li	a0,0
	MALLOC_UNLOCK;
        return 1;
      }
    }
  }
}
   13ab4:	01c12083          	lw	ra,28(sp)
   13ab8:	01812403          	lw	s0,24(sp)
   13abc:	01412483          	lw	s1,20(sp)
   13ac0:	01012903          	lw	s2,16(sp)
   13ac4:	00c12983          	lw	s3,12(sp)
   13ac8:	02010113          	addi	sp,sp,32
   13acc:	00008067          	ret
      return 0;     /* Apparently we don't own memory; must fail */
    }

    else
    {
      new_brk = (char*)(MORECORE (-extra));
   13ad0:	40800533          	neg	a0,s0
   13ad4:	8fdfc0ef          	jal	103d0 <sbrk>
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
   13ad8:	fff00793          	li	a5,-1
   13adc:	02f50863          	beq	a0,a5,13b0c <_malloc_trim_r+0xd0>

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
        sbrked_mem -= extra;
   13ae0:	8501a783          	lw	a5,-1968(gp) # 158f0 <__malloc_current_mallinfo>
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
   13ae4:	00892683          	lw	a3,8(s2)
   13ae8:	408484b3          	sub	s1,s1,s0
   13aec:	0014e493          	ori	s1,s1,1
        sbrked_mem -= extra;
   13af0:	40878433          	sub	s0,a5,s0
        check_chunk(top);
	MALLOC_UNLOCK;
   13af4:	00098513          	mv	a0,s3
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
   13af8:	0096a223          	sw	s1,4(a3)
        sbrked_mem -= extra;
   13afc:	8481a823          	sw	s0,-1968(gp) # 158f0 <__malloc_current_mallinfo>
        check_chunk(top);
	MALLOC_UNLOCK;
   13b00:	9dcff0ef          	jal	12cdc <__malloc_unlock>
        return 1;
   13b04:	00100513          	li	a0,1
   13b08:	fadff06f          	j	13ab4 <_malloc_trim_r+0x78>
      new_brk = (char*)(MORECORE (-extra));
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
   13b0c:	00000513          	li	a0,0
   13b10:	8c1fc0ef          	jal	103d0 <sbrk>
        top_size = current_brk - (char*)top;
   13b14:	00892703          	lw	a4,8(s2)
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
   13b18:	00f00693          	li	a3,15
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
        top_size = current_brk - (char*)top;
   13b1c:	40e507b3          	sub	a5,a0,a4
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
   13b20:	f8f6d4e3          	ble	a5,a3,13aa8 <_malloc_trim_r+0x6c>
        {
          sbrked_mem = current_brk - sbrk_base;
   13b24:	8141a683          	lw	a3,-2028(gp) # 158b4 <__malloc_sbrk_base>
          set_head(top, top_size | PREV_INUSE);
   13b28:	0017e793          	ori	a5,a5,1
   13b2c:	00f72223          	sw	a5,4(a4)
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
        top_size = current_brk - (char*)top;
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
        {
          sbrked_mem = current_brk - sbrk_base;
   13b30:	40d50533          	sub	a0,a0,a3
   13b34:	84a1a823          	sw	a0,-1968(gp) # 158f0 <__malloc_current_mallinfo>
   13b38:	f71ff06f          	j	13aa8 <_malloc_trim_r+0x6c>

00013b3c <_free_r>:
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
   13b3c:	0e058e63          	beqz	a1,13c38 <_free_r+0xfc>
#if __STD_C
void fREe(RARG Void_t* mem)
#else
void fREe(RARG mem) RDECL Void_t* mem;
#endif
{
   13b40:	ff010113          	addi	sp,sp,-16
   13b44:	00812423          	sw	s0,8(sp)
   13b48:	00058413          	mv	s0,a1
   13b4c:	00912223          	sw	s1,4(sp)
   13b50:	00112623          	sw	ra,12(sp)
   13b54:	00050493          	mv	s1,a0
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
    return;

  MALLOC_LOCK;
   13b58:	980ff0ef          	jal	12cd8 <__malloc_lock>

  p = mem2chunk(mem);
  hd = p->size;
   13b5c:	ffc42503          	lw	a0,-4(s0)
  if (mem == 0)                              /* free(0) has no effect */
    return;

  MALLOC_LOCK;

  p = mem2chunk(mem);
   13b60:	ff840613          	addi	a2,s0,-8
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
   13b64:	000155b7          	lui	a1,0x15
  }
#endif
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
   13b68:	ffe57793          	andi	a5,a0,-2
  next = chunk_at_offset(p, sz);
   13b6c:	00f606b3          	add	a3,a2,a5
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
   13b70:	49058593          	addi	a1,a1,1168 # 15490 <__malloc_av_>
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
   13b74:	0046a703          	lw	a4,4(a3)
  
  if (next == top)                            /* merge with top */
   13b78:	0085a803          	lw	a6,8(a1)
  {
    sz += nextsz;

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
   13b7c:	00157513          	andi	a0,a0,1
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
   13b80:	ffc77713          	andi	a4,a4,-4
  
  if (next == top)                            /* merge with top */
   13b84:	15068463          	beq	a3,a6,13ccc <_free_r+0x190>
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
    return;
  }

  set_head(next, nextsz);                    /* clear inuse bit */
   13b88:	00e6a223          	sw	a4,4(a3)

  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
   13b8c:	02051663          	bnez	a0,13bb8 <_free_r+0x7c>
  {
    prevsz = p->prev_size;
   13b90:	ff842503          	lw	a0,-8(s0)
    p = chunk_at_offset(p, -prevsz);
   13b94:	40a60633          	sub	a2,a2,a0
    sz += prevsz;
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
   13b98:	00862803          	lw	a6,8(a2)

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
  {
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -prevsz);
    sz += prevsz;
   13b9c:	00a787b3          	add	a5,a5,a0
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
   13ba0:	00015537          	lui	a0,0x15
   13ba4:	49850513          	addi	a0,a0,1176 # 15498 <__malloc_av_+0x8>
   13ba8:	16a80663          	beq	a6,a0,13d14 <_free_r+0x1d8>
      islr = 1;
    else
      unlink(p, bck, fwd);
   13bac:	00c62503          	lw	a0,12(a2)
   13bb0:	00a82623          	sw	a0,12(a6)
   13bb4:	01052423          	sw	a6,8(a0)
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
   13bb8:	00e68533          	add	a0,a3,a4
   13bbc:	00452503          	lw	a0,4(a0)
   13bc0:	00157513          	andi	a0,a0,1
   13bc4:	0c050a63          	beqz	a0,13c98 <_free_r+0x15c>
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   13bc8:	0017e693          	ori	a3,a5,1
  set_foot(p, sz);
   13bcc:	00f60733          	add	a4,a2,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   13bd0:	00d62223          	sw	a3,4(a2)
  set_foot(p, sz);
   13bd4:	00f72023          	sw	a5,0(a4)
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   13bd8:	1ff00713          	li	a4,511
   13bdc:	06f76063          	bltu	a4,a5,13c3c <_free_r+0x100>
   13be0:	0037d793          	srli	a5,a5,0x3
   13be4:	00178713          	addi	a4,a5,1
   13be8:	00371713          	slli	a4,a4,0x3
   13bec:	0045a683          	lw	a3,4(a1)
   13bf0:	00e58733          	add	a4,a1,a4
   13bf4:	00072803          	lw	a6,0(a4)
   13bf8:	4027d793          	srai	a5,a5,0x2
   13bfc:	00100513          	li	a0,1
   13c00:	00f517b3          	sll	a5,a0,a5
   13c04:	00d7e7b3          	or	a5,a5,a3
   13c08:	ff870693          	addi	a3,a4,-8
   13c0c:	00d62623          	sw	a3,12(a2)
   13c10:	01062423          	sw	a6,8(a2)
   13c14:	00f5a223          	sw	a5,4(a1)
   13c18:	00c72023          	sw	a2,0(a4)
   13c1c:	00c82623          	sw	a2,12(a6)

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
   13c20:	00048513          	mv	a0,s1
    frontlink(p, sz, idx, bck, fwd);  

  MALLOC_UNLOCK;

#endif /* MALLOC_PROVIDED */
}
   13c24:	00c12083          	lw	ra,12(sp)
   13c28:	00812403          	lw	s0,8(sp)
   13c2c:	00412483          	lw	s1,4(sp)
   13c30:	01010113          	addi	sp,sp,16

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
      malloc_trim(RCALL top_pad); 
    MALLOC_UNLOCK;
   13c34:	8a8ff06f          	j	12cdc <__malloc_unlock>
   13c38:	00008067          	ret


  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   13c3c:	0097d713          	srli	a4,a5,0x9
   13c40:	00400693          	li	a3,4
   13c44:	10e6e463          	bltu	a3,a4,13d4c <_free_r+0x210>
   13c48:	0067d713          	srli	a4,a5,0x6
   13c4c:	03970513          	addi	a0,a4,57
   13c50:	03870693          	addi	a3,a4,56
   13c54:	00151513          	slli	a0,a0,0x1
   13c58:	00251513          	slli	a0,a0,0x2
   13c5c:	00a58533          	add	a0,a1,a0
   13c60:	00052703          	lw	a4,0(a0)
   13c64:	ff850513          	addi	a0,a0,-8
   13c68:	0ee50e63          	beq	a0,a4,13d64 <_free_r+0x228>
   13c6c:	00472683          	lw	a3,4(a4)
   13c70:	ffc6f693          	andi	a3,a3,-4
   13c74:	00d7f663          	bleu	a3,a5,13c80 <_free_r+0x144>
   13c78:	00872703          	lw	a4,8(a4)
   13c7c:	fee518e3          	bne	a0,a4,13c6c <_free_r+0x130>
   13c80:	00c72503          	lw	a0,12(a4)
   13c84:	00a62623          	sw	a0,12(a2)
   13c88:	00e62423          	sw	a4,8(a2)
   13c8c:	00c52423          	sw	a2,8(a0)
   13c90:	00c72623          	sw	a2,12(a4)
   13c94:	f8dff06f          	j	13c20 <_free_r+0xe4>
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
   13c98:	0086a503          	lw	a0,8(a3)
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
   13c9c:	00e787b3          	add	a5,a5,a4
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
   13ca0:	00015737          	lui	a4,0x15
   13ca4:	49870713          	addi	a4,a4,1176 # 15498 <__malloc_av_+0x8>
   13ca8:	0ce50e63          	beq	a0,a4,13d84 <_free_r+0x248>
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   13cac:	00c6a803          	lw	a6,12(a3)
  }


  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
   13cb0:	00f60733          	add	a4,a2,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   13cb4:	0017e693          	ori	a3,a5,1
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   13cb8:	01052623          	sw	a6,12(a0)
   13cbc:	00a82423          	sw	a0,8(a6)
  }


  set_head(p, sz | PREV_INUSE);
   13cc0:	00d62223          	sw	a3,4(a2)
  set_foot(p, sz);
   13cc4:	00f72023          	sw	a5,0(a4)
   13cc8:	f11ff06f          	j	13bd8 <_free_r+0x9c>
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
  
  if (next == top)                            /* merge with top */
  {
    sz += nextsz;
   13ccc:	00e787b3          	add	a5,a5,a4

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
   13cd0:	02051063          	bnez	a0,13cf0 <_free_r+0x1b4>
    {
      prevsz = p->prev_size;
   13cd4:	ff842503          	lw	a0,-8(s0)
      p = chunk_at_offset(p, -prevsz);
   13cd8:	40a60633          	sub	a2,a2,a0
      sz += prevsz;
      unlink(p, bck, fwd);
   13cdc:	00c62703          	lw	a4,12(a2)
   13ce0:	00862683          	lw	a3,8(a2)

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
    {
      prevsz = p->prev_size;
      p = chunk_at_offset(p, -prevsz);
      sz += prevsz;
   13ce4:	00a787b3          	add	a5,a5,a0
      unlink(p, bck, fwd);
   13ce8:	00e6a623          	sw	a4,12(a3)
   13cec:	00d72423          	sw	a3,8(a4)
    }

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
   13cf0:	8181a703          	lw	a4,-2024(gp) # 158b8 <__malloc_trim_threshold>
      p = chunk_at_offset(p, -prevsz);
      sz += prevsz;
      unlink(p, bck, fwd);
    }

    set_head(p, sz | PREV_INUSE);
   13cf4:	0017e693          	ori	a3,a5,1
   13cf8:	00d62223          	sw	a3,4(a2)
    top = p;
   13cfc:	00c5a423          	sw	a2,8(a1)
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
   13d00:	f2e7e0e3          	bltu	a5,a4,13c20 <_free_r+0xe4>
      malloc_trim(RCALL top_pad); 
   13d04:	82c1a583          	lw	a1,-2004(gp) # 158cc <__malloc_top_pad>
   13d08:	00048513          	mv	a0,s1
   13d0c:	d31ff0ef          	jal	13a3c <_malloc_trim_r>
   13d10:	f11ff06f          	j	13c20 <_free_r+0xe4>
      islr = 1;
    else
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
   13d14:	00e685b3          	add	a1,a3,a4
   13d18:	0045a583          	lw	a1,4(a1)
   13d1c:	0015f593          	andi	a1,a1,1
   13d20:	0e059263          	bnez	a1,13e04 <_free_r+0x2c8>
   13d24:	0086a583          	lw	a1,8(a3)
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   13d28:	00c6a683          	lw	a3,12(a3)
      unlink(p, bck, fwd);
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
   13d2c:	00f707b3          	add	a5,a4,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   13d30:	0017e513          	ori	a0,a5,1
  set_foot(p, sz);
   13d34:	00f60733          	add	a4,a2,a5
    {
      islr = 1;
      link_last_remainder(p);   
    }
    else
      unlink(next, bck, fwd);
   13d38:	00d5a623          	sw	a3,12(a1)
   13d3c:	00b6a423          	sw	a1,8(a3)
  }


  set_head(p, sz | PREV_INUSE);
   13d40:	00a62223          	sw	a0,4(a2)
  set_foot(p, sz);
   13d44:	00f72023          	sw	a5,0(a4)
   13d48:	ed9ff06f          	j	13c20 <_free_r+0xe4>
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   13d4c:	01400693          	li	a3,20
   13d50:	04e6ec63          	bltu	a3,a4,13da8 <_free_r+0x26c>
   13d54:	05c70513          	addi	a0,a4,92
   13d58:	05b70693          	addi	a3,a4,91
   13d5c:	00151513          	slli	a0,a0,0x1
   13d60:	ef9ff06f          	j	13c58 <_free_r+0x11c>
   13d64:	0045a783          	lw	a5,4(a1)
   13d68:	4026d713          	srai	a4,a3,0x2
   13d6c:	00100693          	li	a3,1
   13d70:	00e69733          	sll	a4,a3,a4
   13d74:	00f76733          	or	a4,a4,a5
   13d78:	00e5a223          	sw	a4,4(a1)
   13d7c:	00050713          	mv	a4,a0
   13d80:	f05ff06f          	j	13c84 <_free_r+0x148>
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   13d84:	0017e693          	ori	a3,a5,1
  set_foot(p, sz);
   13d88:	00f60733          	add	a4,a2,a5
    sz += nextsz;
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
    {
      islr = 1;
      link_last_remainder(p);   
   13d8c:	00c5aa23          	sw	a2,20(a1)
   13d90:	00c5a823          	sw	a2,16(a1)
   13d94:	00a62623          	sw	a0,12(a2)
   13d98:	00a62423          	sw	a0,8(a2)
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   13d9c:	00d62223          	sw	a3,4(a2)
  set_foot(p, sz);
   13da0:	00f72023          	sw	a5,0(a4)
   13da4:	e7dff06f          	j	13c20 <_free_r+0xe4>
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);  
   13da8:	05400693          	li	a3,84
   13dac:	00e6ec63          	bltu	a3,a4,13dc4 <_free_r+0x288>
   13db0:	00c7d713          	srli	a4,a5,0xc
   13db4:	06f70513          	addi	a0,a4,111
   13db8:	06e70693          	addi	a3,a4,110
   13dbc:	00151513          	slli	a0,a0,0x1
   13dc0:	e99ff06f          	j	13c58 <_free_r+0x11c>
   13dc4:	15400693          	li	a3,340
   13dc8:	00e6ec63          	bltu	a3,a4,13de0 <_free_r+0x2a4>
   13dcc:	00f7d713          	srli	a4,a5,0xf
   13dd0:	07870513          	addi	a0,a4,120
   13dd4:	07770693          	addi	a3,a4,119
   13dd8:	00151513          	slli	a0,a0,0x1
   13ddc:	e7dff06f          	j	13c58 <_free_r+0x11c>
   13de0:	55400813          	li	a6,1364
   13de4:	0fe00513          	li	a0,254
   13de8:	07e00693          	li	a3,126
   13dec:	e6e866e3          	bltu	a6,a4,13c58 <_free_r+0x11c>
   13df0:	0127d713          	srli	a4,a5,0x12
   13df4:	07d70513          	addi	a0,a4,125
   13df8:	07c70693          	addi	a3,a4,124
   13dfc:	00151513          	slli	a0,a0,0x1
   13e00:	e59ff06f          	j	13c58 <_free_r+0x11c>
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   13e04:	0017e693          	ori	a3,a5,1
  set_foot(p, sz);
   13e08:	00f60733          	add	a4,a2,a5
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
   13e0c:	00d62223          	sw	a3,4(a2)
  set_foot(p, sz);
   13e10:	00f72023          	sw	a5,0(a4)
   13e14:	e0dff06f          	j	13c20 <_free_r+0xe4>

00013e18 <_fwalk>:

int
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
   13e18:	fe010113          	addi	sp,sp,-32
   13e1c:	01512223          	sw	s5,4(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   13e20:	2e050a93          	addi	s5,a0,736

int
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
   13e24:	00112e23          	sw	ra,28(sp)
   13e28:	00812c23          	sw	s0,24(sp)
   13e2c:	00912a23          	sw	s1,20(sp)
   13e30:	01212823          	sw	s2,16(sp)
   13e34:	01312623          	sw	s3,12(sp)
   13e38:	01412423          	sw	s4,8(sp)
   13e3c:	01612023          	sw	s6,0(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   13e40:	080a8063          	beqz	s5,13ec0 <_fwalk+0xa8>
   13e44:	00058b13          	mv	s6,a1
   13e48:	00000a13          	li	s4,0
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   13e4c:	00100993          	li	s3,1
   13e50:	fff00913          	li	s2,-1
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   13e54:	004aa483          	lw	s1,4(s5)
   13e58:	008aa403          	lw	s0,8(s5)
   13e5c:	fff48493          	addi	s1,s1,-1
   13e60:	0204c663          	bltz	s1,13e8c <_fwalk+0x74>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   13e64:	00c45783          	lhu	a5,12(s0)
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   13e68:	fff48493          	addi	s1,s1,-1
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   13e6c:	00f9fc63          	bleu	a5,s3,13e84 <_fwalk+0x6c>
   13e70:	00e41783          	lh	a5,14(s0)
	ret |= (*function) (fp);
   13e74:	00040513          	mv	a0,s0
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   13e78:	01278663          	beq	a5,s2,13e84 <_fwalk+0x6c>
	ret |= (*function) (fp);
   13e7c:	000b00e7          	jalr	s6
   13e80:	00aa6a33          	or	s4,s4,a0
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   13e84:	07040413          	addi	s0,s0,112
   13e88:	fd249ee3          	bne	s1,s2,13e64 <_fwalk+0x4c>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   13e8c:	000aaa83          	lw	s5,0(s5)
   13e90:	fc0a92e3          	bnez	s5,13e54 <_fwalk+0x3c>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*function) (fp);

  return ret;
}
   13e94:	01c12083          	lw	ra,28(sp)
   13e98:	000a0513          	mv	a0,s4
   13e9c:	01812403          	lw	s0,24(sp)
   13ea0:	01412483          	lw	s1,20(sp)
   13ea4:	01012903          	lw	s2,16(sp)
   13ea8:	00c12983          	lw	s3,12(sp)
   13eac:	00812a03          	lw	s4,8(sp)
   13eb0:	00412a83          	lw	s5,4(sp)
   13eb4:	00012b03          	lw	s6,0(sp)
   13eb8:	02010113          	addi	sp,sp,32
   13ebc:	00008067          	ret
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
  register FILE *fp;
  register int n, ret = 0;
   13ec0:	00000a13          	li	s4,0
   13ec4:	fd1ff06f          	j	13e94 <_fwalk+0x7c>

00013ec8 <_fwalk_reent>:
   I/O function (e.g. _fclose_r).  */
int
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
   13ec8:	fd010113          	addi	sp,sp,-48
   13ecc:	01612823          	sw	s6,16(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   13ed0:	2e050b13          	addi	s6,a0,736
   I/O function (e.g. _fclose_r).  */
int
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
   13ed4:	02112623          	sw	ra,44(sp)
   13ed8:	02812423          	sw	s0,40(sp)
   13edc:	02912223          	sw	s1,36(sp)
   13ee0:	03212023          	sw	s2,32(sp)
   13ee4:	01312e23          	sw	s3,28(sp)
   13ee8:	01412c23          	sw	s4,24(sp)
   13eec:	01512a23          	sw	s5,20(sp)
   13ef0:	01712623          	sw	s7,12(sp)
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   13ef4:	080b0663          	beqz	s6,13f80 <_fwalk_reent+0xb8>
   13ef8:	00058b93          	mv	s7,a1
   13efc:	00050a93          	mv	s5,a0
   13f00:	00000a13          	li	s4,0
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   13f04:	00100993          	li	s3,1
   13f08:	fff00913          	li	s2,-1
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   13f0c:	004b2483          	lw	s1,4(s6)
   13f10:	008b2403          	lw	s0,8(s6)
   13f14:	fff48493          	addi	s1,s1,-1
   13f18:	0204c863          	bltz	s1,13f48 <_fwalk_reent+0x80>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   13f1c:	00c45783          	lhu	a5,12(s0)
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   13f20:	fff48493          	addi	s1,s1,-1
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   13f24:	00f9fe63          	bleu	a5,s3,13f40 <_fwalk_reent+0x78>
   13f28:	00e41783          	lh	a5,14(s0)
	ret |= (*reent_function) (ptr, fp);
   13f2c:	00040593          	mv	a1,s0
   13f30:	000a8513          	mv	a0,s5
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   13f34:	01278663          	beq	a5,s2,13f40 <_fwalk_reent+0x78>
	ret |= (*reent_function) (ptr, fp);
   13f38:	000b80e7          	jalr	s7
   13f3c:	00aa6a33          	or	s4,s4,a0
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   13f40:	07040413          	addi	s0,s0,112
   13f44:	fd249ce3          	bne	s1,s2,13f1c <_fwalk_reent+0x54>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   13f48:	000b2b03          	lw	s6,0(s6)
   13f4c:	fc0b10e3          	bnez	s6,13f0c <_fwalk_reent+0x44>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*reent_function) (ptr, fp);

  return ret;
}
   13f50:	02c12083          	lw	ra,44(sp)
   13f54:	000a0513          	mv	a0,s4
   13f58:	02812403          	lw	s0,40(sp)
   13f5c:	02412483          	lw	s1,36(sp)
   13f60:	02012903          	lw	s2,32(sp)
   13f64:	01c12983          	lw	s3,28(sp)
   13f68:	01812a03          	lw	s4,24(sp)
   13f6c:	01412a83          	lw	s5,20(sp)
   13f70:	01012b03          	lw	s6,16(sp)
   13f74:	00c12b83          	lw	s7,12(sp)
   13f78:	03010113          	addi	sp,sp,48
   13f7c:	00008067          	ret
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
  register FILE *fp;
  register int n, ret = 0;
   13f80:	00000a13          	li	s4,0
   13f84:	fcdff06f          	j	13f50 <_fwalk_reent+0x88>

00013f88 <__smakebuf_r>:
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
   13f88:	00c59783          	lh	a5,12(a1)

_VOID
_DEFUN(__smakebuf_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE *fp)
{
   13f8c:	f7010113          	addi	sp,sp,-144
   13f90:	08912223          	sw	s1,132(sp)
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
   13f94:	01079493          	slli	s1,a5,0x10
   13f98:	0104d493          	srli	s1,s1,0x10
   13f9c:	0024f713          	andi	a4,s1,2

_VOID
_DEFUN(__smakebuf_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE *fp)
{
   13fa0:	08112623          	sw	ra,140(sp)
   13fa4:	08812423          	sw	s0,136(sp)
   13fa8:	09212023          	sw	s2,128(sp)
   13fac:	07312e23          	sw	s3,124(sp)
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
   13fb0:	0e071063          	bnez	a4,14090 <__smakebuf_r+0x108>
   13fb4:	00050913          	mv	s2,a0
      return;
    }
#ifdef __USE_INTERNAL_STAT64
  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
   13fb8:	00e59503          	lh	a0,14(a1)
   13fbc:	00058413          	mv	s0,a1
   13fc0:	04054c63          	bltz	a0,14018 <__smakebuf_r+0x90>
   13fc4:	00010593          	mv	a1,sp
   13fc8:	a1cfc0ef          	jal	101e4 <fstat>
   13fcc:	04054063          	bltz	a0,1400c <__smakebuf_r+0x84>
      fp->_flags |= __SNPT;
#endif
    }
  else
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
   13fd0:	01012703          	lw	a4,16(sp)
   13fd4:	0000f7b7          	lui	a5,0xf
   13fd8:	ffffe9b7          	lui	s3,0xffffe
   13fdc:	00f777b3          	and	a5,a4,a5
   13fe0:	013789b3          	add	s3,a5,s3
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
   13fe4:	00008737          	lui	a4,0x8
      fp->_flags |= __SNPT;
#endif
    }
  else
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
   13fe8:	0019b993          	seqz	s3,s3
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
   13fec:	0ae78e63          	beq	a5,a4,140a8 <__smakebuf_r+0x120>
#else
	  fp->_blksize = 1024;
#endif
	}
      else
	fp->_flags |= __SNPT;
   13ff0:	00c45703          	lhu	a4,12(s0)
   13ff4:	000017b7          	lui	a5,0x1
   13ff8:	80078793          	addi	a5,a5,-2048 # 800 <_reset+0x600>
   13ffc:	00f767b3          	or	a5,a4,a5
   14000:	00f41623          	sh	a5,12(s0)
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
#ifdef HAVE_BLKSIZE
      size = st.st_blksize <= 0 ? BUFSIZ : st.st_blksize;
#else
      size = BUFSIZ;
   14004:	40000493          	li	s1,1024
   14008:	0340006f          	j	1403c <__smakebuf_r+0xb4>
   1400c:	00c41783          	lh	a5,12(s0)
   14010:	01079493          	slli	s1,a5,0x10
   14014:	0104d493          	srli	s1,s1,0x10
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   14018:	01849493          	slli	s1,s1,0x18
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   1401c:	00001737          	lui	a4,0x1
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   14020:	41f4d493          	srai	s1,s1,0x1f
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   14024:	80070713          	addi	a4,a4,-2048 # 800 <_reset+0x600>
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   14028:	c404f493          	andi	s1,s1,-960
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   1402c:	00e7e7b3          	or	a5,a5,a4
      couldbetty = 0;
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
        size = _DEFAULT_ASPRINTF_BUFSIZE;
      else
        size = BUFSIZ;
   14030:	40048493          	addi	s1,s1,1024
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   14034:	00f41623          	sh	a5,12(s0)
  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
#endif
    {
      couldbetty = 0;
   14038:	00000993          	li	s3,0
	}
      else
	fp->_flags |= __SNPT;
#endif
    }
  if ((p = _malloc_r (ptr, size)) == NULL)
   1403c:	00048593          	mv	a1,s1
   14040:	00090513          	mv	a0,s2
   14044:	a08fe0ef          	jal	1224c <_malloc_r>
   14048:	0a050263          	beqz	a0,140ec <__smakebuf_r+0x164>
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
      fp->_flags |= __SMBF;
   1404c:	00c45783          	lhu	a5,12(s0)
	  fp->_bf._size = 1;
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
   14050:	00013737          	lui	a4,0x13
   14054:	6d070713          	addi	a4,a4,1744 # 136d0 <_cleanup_r>
      fp->_flags |= __SMBF;
   14058:	0807e793          	ori	a5,a5,128
	  fp->_bf._size = 1;
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
   1405c:	02e92e23          	sw	a4,60(s2)
      fp->_flags |= __SMBF;
   14060:	00f41623          	sh	a5,12(s0)
      fp->_bf._base = fp->_p = (unsigned char *) p;
   14064:	00a42023          	sw	a0,0(s0)
   14068:	00a42823          	sw	a0,16(s0)
      fp->_bf._size = size;
   1406c:	00942a23          	sw	s1,20(s0)
      if (couldbetty && _isatty_r (ptr, fp->_file))
   14070:	06099063          	bnez	s3,140d0 <__smakebuf_r+0x148>
	fp->_flags |= __SLBF;
    }
}
   14074:	08c12083          	lw	ra,140(sp)
   14078:	08812403          	lw	s0,136(sp)
   1407c:	08412483          	lw	s1,132(sp)
   14080:	08012903          	lw	s2,128(sp)
   14084:	07c12983          	lw	s3,124(sp)
   14088:	09010113          	addi	sp,sp,144
   1408c:	00008067          	ret
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
    {
      fp->_bf._base = fp->_p = fp->_nbuf;
   14090:	04358793          	addi	a5,a1,67
   14094:	00f5a023          	sw	a5,0(a1)
   14098:	00f5a823          	sw	a5,16(a1)
      fp->_bf._size = 1;
   1409c:	00100793          	li	a5,1
   140a0:	00f5aa23          	sw	a5,20(a1)
   140a4:	fd1ff06f          	j	14074 <__smakebuf_r+0xec>
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
   140a8:	02842703          	lw	a4,40(s0)
   140ac:	000147b7          	lui	a5,0x14
   140b0:	2f078793          	addi	a5,a5,752 # 142f0 <__sseek>
   140b4:	f2f71ee3          	bne	a4,a5,13ff0 <__smakebuf_r+0x68>
	{
	  fp->_flags |= __SOPT;
   140b8:	00c45783          	lhu	a5,12(s0)
#ifdef HAVE_BLKSIZE
	  fp->_blksize = st.st_blksize;
#else
	  fp->_blksize = 1024;
   140bc:	40000493          	li	s1,1024
   140c0:	04942623          	sw	s1,76(s0)
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
	{
	  fp->_flags |= __SOPT;
   140c4:	0097e7b3          	or	a5,a5,s1
   140c8:	00f41623          	sh	a5,12(s0)
#ifdef HAVE_BLKSIZE
	  fp->_blksize = st.st_blksize;
#else
	  fp->_blksize = 1024;
   140cc:	f71ff06f          	j	1403c <__smakebuf_r+0xb4>
    {
      ptr->__cleanup = _cleanup_r;
      fp->_flags |= __SMBF;
      fp->_bf._base = fp->_p = (unsigned char *) p;
      fp->_bf._size = size;
      if (couldbetty && _isatty_r (ptr, fp->_file))
   140d0:	00e41503          	lh	a0,14(s0)
   140d4:	964fc0ef          	jal	10238 <isatty>
   140d8:	f8050ee3          	beqz	a0,14074 <__smakebuf_r+0xec>
	fp->_flags |= __SLBF;
   140dc:	00c45783          	lhu	a5,12(s0)
   140e0:	0017e793          	ori	a5,a5,1
   140e4:	00f41623          	sh	a5,12(s0)
   140e8:	f8dff06f          	j	14074 <__smakebuf_r+0xec>
	fp->_flags |= __SNPT;
#endif
    }
  if ((p = _malloc_r (ptr, size)) == NULL)
    {
      if (!(fp->_flags & __SSTR))
   140ec:	00c41783          	lh	a5,12(s0)
   140f0:	2007f713          	andi	a4,a5,512
   140f4:	f80710e3          	bnez	a4,14074 <__smakebuf_r+0xec>
	{
	  fp->_flags |= __SNBF;
   140f8:	0027e793          	ori	a5,a5,2
	  fp->_bf._base = fp->_p = fp->_nbuf;
   140fc:	04340713          	addi	a4,s0,67
    }
  if ((p = _malloc_r (ptr, size)) == NULL)
    {
      if (!(fp->_flags & __SSTR))
	{
	  fp->_flags |= __SNBF;
   14100:	00f41623          	sh	a5,12(s0)
	  fp->_bf._base = fp->_p = fp->_nbuf;
	  fp->_bf._size = 1;
   14104:	00100793          	li	a5,1
  if ((p = _malloc_r (ptr, size)) == NULL)
    {
      if (!(fp->_flags & __SSTR))
	{
	  fp->_flags |= __SNBF;
	  fp->_bf._base = fp->_p = fp->_nbuf;
   14108:	00e42023          	sw	a4,0(s0)
   1410c:	00e42823          	sw	a4,16(s0)
	  fp->_bf._size = 1;
   14110:	00f42a23          	sw	a5,20(s0)
   14114:	f61ff06f          	j	14074 <__smakebuf_r+0xec>

00014118 <memset>:
   14118:	00f00813          	li	a6,15
   1411c:	00050713          	mv	a4,a0
   14120:	02c87e63          	bleu	a2,a6,1415c <memset+0x44>
   14124:	00f77793          	andi	a5,a4,15
   14128:	0a079063          	bnez	a5,141c8 <memset+0xb0>
   1412c:	08059263          	bnez	a1,141b0 <memset+0x98>
   14130:	ff067693          	andi	a3,a2,-16
   14134:	00f67613          	andi	a2,a2,15
   14138:	00e686b3          	add	a3,a3,a4
   1413c:	00b72023          	sw	a1,0(a4)
   14140:	00b72223          	sw	a1,4(a4)
   14144:	00b72423          	sw	a1,8(a4)
   14148:	00b72623          	sw	a1,12(a4)
   1414c:	01070713          	addi	a4,a4,16
   14150:	fed766e3          	bltu	a4,a3,1413c <memset+0x24>
   14154:	00061463          	bnez	a2,1415c <memset+0x44>
   14158:	00008067          	ret
   1415c:	40c806b3          	sub	a3,a6,a2
   14160:	00269693          	slli	a3,a3,0x2
   14164:	00000297          	auipc	t0,0x0
   14168:	005686b3          	add	a3,a3,t0
   1416c:	00c68067          	jr	a3,12
   14170:	00b70723          	sb	a1,14(a4)
   14174:	00b706a3          	sb	a1,13(a4)
   14178:	00b70623          	sb	a1,12(a4)
   1417c:	00b705a3          	sb	a1,11(a4)
   14180:	00b70523          	sb	a1,10(a4)
   14184:	00b704a3          	sb	a1,9(a4)
   14188:	00b70423          	sb	a1,8(a4)
   1418c:	00b703a3          	sb	a1,7(a4)
   14190:	00b70323          	sb	a1,6(a4)
   14194:	00b702a3          	sb	a1,5(a4)
   14198:	00b70223          	sb	a1,4(a4)
   1419c:	00b701a3          	sb	a1,3(a4)
   141a0:	00b70123          	sb	a1,2(a4)
   141a4:	00b700a3          	sb	a1,1(a4)
   141a8:	00b70023          	sb	a1,0(a4)
   141ac:	00008067          	ret
   141b0:	0ff5f593          	andi	a1,a1,255
   141b4:	00859693          	slli	a3,a1,0x8
   141b8:	00d5e5b3          	or	a1,a1,a3
   141bc:	01059693          	slli	a3,a1,0x10
   141c0:	00d5e5b3          	or	a1,a1,a3
   141c4:	f6dff06f          	j	14130 <memset+0x18>
   141c8:	00279693          	slli	a3,a5,0x2
   141cc:	00000297          	auipc	t0,0x0
   141d0:	005686b3          	add	a3,a3,t0
   141d4:	00008293          	mv	t0,ra
   141d8:	fa0680e7          	jalr	a3,-96
   141dc:	00028093          	mv	ra,t0
   141e0:	ff078793          	addi	a5,a5,-16
   141e4:	40f70733          	sub	a4,a4,a5
   141e8:	00f60633          	add	a2,a2,a5
   141ec:	f6c878e3          	bleu	a2,a6,1415c <memset+0x44>
   141f0:	f3dff06f          	j	1412c <memset+0x14>

000141f4 <__sread>:
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   141f4:	00e59503          	lh	a0,14(a1)
_DEFUN(__sread, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   141f8:	ff010113          	addi	sp,sp,-16
   141fc:	00812423          	sw	s0,8(sp)
   14200:	00058413          	mv	s0,a1
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   14204:	00060593          	mv	a1,a2
   14208:	00068613          	mv	a2,a3
_DEFUN(__sread, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   1420c:	00112623          	sw	ra,12(sp)
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   14210:	904fc0ef          	jal	10314 <read>
    setmode (fp->_file, oldmode);
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
   14214:	02054c63          	bltz	a0,1424c <__sread+0x58>
    fp->_offset += ret;
   14218:	05042783          	lw	a5,80(s0)
   1421c:	05442683          	lw	a3,84(s0)
   14220:	41f55613          	srai	a2,a0,0x1f
   14224:	00a785b3          	add	a1,a5,a0
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
  return ret;
}
   14228:	00c12083          	lw	ra,12(sp)
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
    fp->_offset += ret;
   1422c:	00f5b733          	sltu	a4,a1,a5
   14230:	00c687b3          	add	a5,a3,a2
   14234:	00f707b3          	add	a5,a4,a5
   14238:	04b42823          	sw	a1,80(s0)
   1423c:	04f42a23          	sw	a5,84(s0)
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
  return ret;
}
   14240:	00812403          	lw	s0,8(sp)
   14244:	01010113          	addi	sp,sp,16
   14248:	00008067          	ret
  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
    fp->_offset += ret;
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
   1424c:	00c45703          	lhu	a4,12(s0)
   14250:	fffff7b7          	lui	a5,0xfffff
  return ret;
}
   14254:	00c12083          	lw	ra,12(sp)
  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
    fp->_offset += ret;
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
   14258:	fff78793          	addi	a5,a5,-1 # ffffefff <_gp+0xfffe8f5f>
   1425c:	00f777b3          	and	a5,a4,a5
   14260:	00f41623          	sh	a5,12(s0)
  return ret;
}
   14264:	00812403          	lw	s0,8(sp)
   14268:	01010113          	addi	sp,sp,16
   1426c:	00008067          	ret

00014270 <__seofread>:
       _PTR cookie _AND
       char *buf   _AND
       _READ_WRITE_BUFSIZE_TYPE len)
{
  return 0;
}
   14270:	00000513          	li	a0,0
   14274:	00008067          	ret

00014278 <__swrite>:
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   14278:	00c59703          	lh	a4,12(a1)
_DEFUN(__swrite, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char const *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   1427c:	ff010113          	addi	sp,sp,-16
   14280:	00812423          	sw	s0,8(sp)
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   14284:	10077793          	andi	a5,a4,256
_DEFUN(__swrite, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char const *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
   14288:	00912223          	sw	s1,4(sp)
   1428c:	01212023          	sw	s2,0(sp)
   14290:	00112623          	sw	ra,12(sp)
   14294:	00058413          	mv	s0,a1
   14298:	00060493          	mv	s1,a2
   1429c:	00068913          	mv	s2,a3
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   142a0:	00078e63          	beqz	a5,142bc <__swrite+0x44>
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
   142a4:	00e59503          	lh	a0,14(a1)
   142a8:	00200713          	li	a4,2
   142ac:	00000613          	li	a2,0
   142b0:	00000693          	li	a3,0
   142b4:	808fc0ef          	jal	102bc <lseek>
   142b8:	00c41703          	lh	a4,12(s0)
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
   142bc:	fffff7b7          	lui	a5,0xfffff
   142c0:	fff78793          	addi	a5,a5,-1 # ffffefff <_gp+0xfffe8f5f>
   142c4:	00f777b3          	and	a5,a4,a5
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   142c8:	00e41503          	lh	a0,14(s0)
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
   142cc:	00f41623          	sh	a5,12(s0)
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   142d0:	00090613          	mv	a2,s2
   142d4:	00048593          	mv	a1,s1
  if (oldmode)
    setmode (fp->_file, oldmode);
#endif

  return w;
}
   142d8:	00c12083          	lw	ra,12(sp)
   142dc:	00812403          	lw	s0,8(sp)
   142e0:	00412483          	lw	s1,4(sp)
   142e4:	00012903          	lw	s2,0(sp)
   142e8:	01010113          	addi	sp,sp,16
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   142ec:	a04fc06f          	j	104f0 <write>

000142f0 <__sseek>:
       int whence)
{
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
   142f0:	00e59503          	lh	a0,14(a1)
_DEFUN(__sseek, (ptr, cookie, offset, whence),
       struct _reent *ptr _AND
       void *cookie _AND
       _fpos_t offset _AND
       int whence)
{
   142f4:	ff010113          	addi	sp,sp,-16
   142f8:	00812423          	sw	s0,8(sp)
   142fc:	00112623          	sw	ra,12(sp)
   14300:	00058413          	mv	s0,a1
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
   14304:	fb9fb0ef          	jal	102bc <lseek>
  if (ret == -1L)
   14308:	fff00793          	li	a5,-1
    fp->_flags &= ~__SOFF;
   1430c:	00c45703          	lhu	a4,12(s0)
{
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
   14310:	02f50463          	beq	a0,a5,14338 <__sseek+0x48>
    {
      fp->_flags |= __SOFF;
      fp->_offset = ret;
    }
  return ret;
}
   14314:	00c12083          	lw	ra,12(sp)
  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
    fp->_flags &= ~__SOFF;
  else
    {
      fp->_flags |= __SOFF;
   14318:	000017b7          	lui	a5,0x1
   1431c:	00f767b3          	or	a5,a4,a5
      fp->_offset = ret;
   14320:	04a42823          	sw	a0,80(s0)
  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
    fp->_flags &= ~__SOFF;
  else
    {
      fp->_flags |= __SOFF;
   14324:	00f41623          	sh	a5,12(s0)
      fp->_offset = ret;
   14328:	04b42a23          	sw	a1,84(s0)
    }
  return ret;
}
   1432c:	00812403          	lw	s0,8(sp)
   14330:	01010113          	addi	sp,sp,16
   14334:	00008067          	ret
{
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
   14338:	fca59ee3          	bne	a1,a0,14314 <__sseek+0x24>
    fp->_flags &= ~__SOFF;
   1433c:	fffff7b7          	lui	a5,0xfffff
    {
      fp->_flags |= __SOFF;
      fp->_offset = ret;
    }
  return ret;
}
   14340:	00c12083          	lw	ra,12(sp)
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  if (ret == -1L)
    fp->_flags &= ~__SOFF;
   14344:	fff78793          	addi	a5,a5,-1 # ffffefff <_gp+0xfffe8f5f>
   14348:	00f777b3          	and	a5,a4,a5
   1434c:	00f41623          	sh	a5,12(s0)
    {
      fp->_flags |= __SOFF;
      fp->_offset = ret;
    }
  return ret;
}
   14350:	00812403          	lw	s0,8(sp)
   14354:	01010113          	addi	sp,sp,16
   14358:	00008067          	ret

0001435c <__sclose>:
       struct _reent *ptr _AND
       void *cookie)
{
  FILE *fp = (FILE *) cookie;

  return _close_r (ptr, fp->_file);
   1435c:	00e59503          	lh	a0,14(a1)
   14360:	e05fb06f          	j	10164 <close>

00014364 <_fclose_r>:
      struct _reent *rptr _AND
      register FILE * fp)
{
  int r;

  if (fp == NULL)
   14364:	0e058463          	beqz	a1,1444c <_fclose_r+0xe8>

int
_DEFUN(_fclose_r, (rptr, fp),
      struct _reent *rptr _AND
      register FILE * fp)
{
   14368:	ff010113          	addi	sp,sp,-16
   1436c:	00812423          	sw	s0,8(sp)
   14370:	00912223          	sw	s1,4(sp)
   14374:	00112623          	sw	ra,12(sp)
   14378:	01212023          	sw	s2,0(sp)
   1437c:	00050493          	mv	s1,a0
   14380:	00058413          	mv	s0,a1
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */

  CHECK_INIT (rptr, fp);
   14384:	00050663          	beqz	a0,14390 <_fclose_r+0x2c>
   14388:	03852783          	lw	a5,56(a0)
   1438c:	0a078063          	beqz	a5,1442c <_fclose_r+0xc8>
  int __oldcancel;
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  _flockfile (fp);

  if (fp->_flags == 0)		/* not open! */
   14390:	00c41783          	lh	a5,12(s0)
      register FILE * fp)
{
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */
   14394:	00000513          	li	a0,0
  int __oldcancel;
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  _flockfile (fp);

  if (fp->_flags == 0)		/* not open! */
   14398:	00079e63          	bnez	a5,143b4 <_fclose_r+0x50>
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
}
   1439c:	00c12083          	lw	ra,12(sp)
   143a0:	00812403          	lw	s0,8(sp)
   143a4:	00412483          	lw	s1,4(sp)
   143a8:	00012903          	lw	s2,0(sp)
   143ac:	01010113          	addi	sp,sp,16
   143b0:	00008067          	ret
  r = (fp->_flags & __SWR) ? __sflush_r (rptr, fp) : 0;
#else
  /* Follow POSIX semantics exactly.  Unconditionally flush to allow
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
   143b4:	00040593          	mv	a1,s0
   143b8:	00048513          	mv	a0,s1
   143bc:	800ff0ef          	jal	133bc <__sflush_r>
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
   143c0:	02c42783          	lw	a5,44(s0)
  r = (fp->_flags & __SWR) ? __sflush_r (rptr, fp) : 0;
#else
  /* Follow POSIX semantics exactly.  Unconditionally flush to allow
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
   143c4:	00050913          	mv	s2,a0
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
   143c8:	00078a63          	beqz	a5,143dc <_fclose_r+0x78>
   143cc:	01c42583          	lw	a1,28(s0)
   143d0:	00048513          	mv	a0,s1
   143d4:	000780e7          	jalr	a5
   143d8:	04054e63          	bltz	a0,14434 <_fclose_r+0xd0>
    r = EOF;
  if (fp->_flags & __SMBF)
   143dc:	00c45783          	lhu	a5,12(s0)
   143e0:	0807f793          	andi	a5,a5,128
   143e4:	04079c63          	bnez	a5,1443c <_fclose_r+0xd8>
    _free_r (rptr, (char *) fp->_bf._base);
  if (HASUB (fp))
   143e8:	03042583          	lw	a1,48(s0)
   143ec:	00058c63          	beqz	a1,14404 <_fclose_r+0xa0>
    FREEUB (rptr, fp);
   143f0:	04040793          	addi	a5,s0,64
   143f4:	00f58663          	beq	a1,a5,14400 <_fclose_r+0x9c>
   143f8:	00048513          	mv	a0,s1
   143fc:	f40ff0ef          	jal	13b3c <_free_r>
   14400:	02042823          	sw	zero,48(s0)
  if (HASLB (fp))
   14404:	04442583          	lw	a1,68(s0)
   14408:	00058863          	beqz	a1,14418 <_fclose_r+0xb4>
    FREELB (rptr, fp);
   1440c:	00048513          	mv	a0,s1
   14410:	f2cff0ef          	jal	13b3c <_free_r>
   14414:	04042223          	sw	zero,68(s0)
  __sfp_lock_acquire ();
   14418:	df4ff0ef          	jal	13a0c <__sfp_lock_acquire>
  fp->_flags = 0;		/* release this FILE for reuse */
   1441c:	00041623          	sh	zero,12(s0)
  _funlockfile (fp);
#ifndef __SINGLE_THREAD__
  __lock_close_recursive (fp->_lock);
#endif

  __sfp_lock_release ();
   14420:	df0ff0ef          	jal	13a10 <__sfp_lock_release>
   14424:	00090513          	mv	a0,s2
   14428:	f75ff06f          	j	1439c <_fclose_r+0x38>
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */

  CHECK_INIT (rptr, fp);
   1442c:	dd0ff0ef          	jal	139fc <__sinit>
   14430:	f61ff06f          	j	14390 <_fclose_r+0x2c>
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
    r = EOF;
   14434:	fff00913          	li	s2,-1
   14438:	fa5ff06f          	j	143dc <_fclose_r+0x78>
  if (fp->_flags & __SMBF)
    _free_r (rptr, (char *) fp->_bf._base);
   1443c:	01042583          	lw	a1,16(s0)
   14440:	00048513          	mv	a0,s1
   14444:	ef8ff0ef          	jal	13b3c <_free_r>
   14448:	fa1ff06f          	j	143e8 <_fclose_r+0x84>
      register FILE * fp)
{
  int r;

  if (fp == NULL)
    return (0);			/* on NULL */
   1444c:	00000513          	li	a0,0
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
}
   14450:	00008067          	ret

00014454 <fclose>:

int
_DEFUN(fclose, (fp),
       register FILE * fp)
{
  return _fclose_r(_REENT, fp);
   14454:	00050593          	mv	a1,a0
   14458:	8101a503          	lw	a0,-2032(gp) # 158b0 <_impure_ptr>
   1445c:	f09ff06f          	j	14364 <_fclose_r>

Disassembly of section .startup:

00000000 <_reset-0x200>:
	...

00000200 <_reset>:
 200:	00100137          	lui	sp,0x100
 204:	00016113          	ori	sp,sp,0
 208:	00012023          	sw	zero,0(sp) # 100000 <_gp+0xe9f60>
 20c:	fe012e23          	sw	zero,-4(sp)
 210:	00003437          	lui	s0,0x3
 214:	00640413          	addi	s0,s0,6 # 3006 <_reset+0x2e06>
 218:	30041073          	csrw	mstatus,s0
 21c:	10000413          	li	s0,256
 220:	0c042023          	sw	zero,192(s0)
 224:	30141073          	csrw	mtvec,s0
 228:	5d90f06f          	j	10000 <_ftext>
